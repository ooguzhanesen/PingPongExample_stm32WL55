
SubGHz_Phy_PingPong_DualCore_CM4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000138  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006260  08000138  08000138  00001138  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000608  08006398  08006398  00007398  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080069a0  080069a0  00008018  2**0
                  CONTENTS
  4 .ARM          00000008  080069a0  080069a0  000079a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080069a8  080069a8  00008018  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  080069a8  080069a8  000079a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000008  080069b0  080069b0  000079b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000018  20000000  080069b8  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 MAPPING_TABLE 00000140  20008000  20008000  00009000  2**4
                  ALLOC
 10 MB_MEM1       000000b8  20008140  20008140  00009000  2**2
                  ALLOC
 11 .bss          000007b8  20000018  20000018  00008018  2**2
                  ALLOC
 12 RAM1_region   00000000  200007d0  200007d0  00008018  2**0
                  CONTENTS
 13 ._user_heap_stack 00000a00  200007d0  200007d0  00008018  2**0
                  ALLOC
 14 .ARM.attributes 0000002a  00000000  00000000  00008018  2**0
                  CONTENTS, READONLY
 15 .debug_info   00028115  00000000  00000000  00008042  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 00006f14  00000000  00000000  00030157  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 0000bf9d  00000000  00000000  0003706b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000018e0  00000000  00000000  00043008  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 0000129f  00000000  00000000  000448e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  000233df  00000000  00000000  00045b87  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0002cd96  00000000  00000000  00068f66  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    000c3079  00000000  00000000  00095cfc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  00158d75  2**0
                  CONTENTS, READONLY
 24 .debug_frame  00003d14  00000000  00000000  00158db8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 00000093  00000000  00000000  0015cacc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000138 <__do_global_dtors_aux>:
 8000138:	b510      	push	{r4, lr}
 800013a:	4c05      	ldr	r4, [pc, #20]	@ (8000150 <__do_global_dtors_aux+0x18>)
 800013c:	7823      	ldrb	r3, [r4, #0]
 800013e:	b933      	cbnz	r3, 800014e <__do_global_dtors_aux+0x16>
 8000140:	4b04      	ldr	r3, [pc, #16]	@ (8000154 <__do_global_dtors_aux+0x1c>)
 8000142:	b113      	cbz	r3, 800014a <__do_global_dtors_aux+0x12>
 8000144:	4804      	ldr	r0, [pc, #16]	@ (8000158 <__do_global_dtors_aux+0x20>)
 8000146:	f3af 8000 	nop.w
 800014a:	2301      	movs	r3, #1
 800014c:	7023      	strb	r3, [r4, #0]
 800014e:	bd10      	pop	{r4, pc}
 8000150:	20000018 	.word	0x20000018
 8000154:	00000000 	.word	0x00000000
 8000158:	08006380 	.word	0x08006380

0800015c <frame_dummy>:
 800015c:	b508      	push	{r3, lr}
 800015e:	4b03      	ldr	r3, [pc, #12]	@ (800016c <frame_dummy+0x10>)
 8000160:	b11b      	cbz	r3, 800016a <frame_dummy+0xe>
 8000162:	4903      	ldr	r1, [pc, #12]	@ (8000170 <frame_dummy+0x14>)
 8000164:	4803      	ldr	r0, [pc, #12]	@ (8000174 <frame_dummy+0x18>)
 8000166:	f3af 8000 	nop.w
 800016a:	bd08      	pop	{r3, pc}
 800016c:	00000000 	.word	0x00000000
 8000170:	2000001c 	.word	0x2000001c
 8000174:	08006380 	.word	0x08006380

08000178 <strlen>:
 8000178:	4603      	mov	r3, r0
 800017a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800017e:	2a00      	cmp	r2, #0
 8000180:	d1fb      	bne.n	800017a <strlen+0x2>
 8000182:	1a18      	subs	r0, r3, r0
 8000184:	3801      	subs	r0, #1
 8000186:	4770      	bx	lr

08000188 <__aeabi_uldivmod>:
 8000188:	b953      	cbnz	r3, 80001a0 <__aeabi_uldivmod+0x18>
 800018a:	b94a      	cbnz	r2, 80001a0 <__aeabi_uldivmod+0x18>
 800018c:	2900      	cmp	r1, #0
 800018e:	bf08      	it	eq
 8000190:	2800      	cmpeq	r0, #0
 8000192:	bf1c      	itt	ne
 8000194:	f04f 31ff 	movne.w	r1, #4294967295
 8000198:	f04f 30ff 	movne.w	r0, #4294967295
 800019c:	f000 b96a 	b.w	8000474 <__aeabi_idiv0>
 80001a0:	f1ad 0c08 	sub.w	ip, sp, #8
 80001a4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80001a8:	f000 f806 	bl	80001b8 <__udivmoddi4>
 80001ac:	f8dd e004 	ldr.w	lr, [sp, #4]
 80001b0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80001b4:	b004      	add	sp, #16
 80001b6:	4770      	bx	lr

080001b8 <__udivmoddi4>:
 80001b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80001bc:	9d08      	ldr	r5, [sp, #32]
 80001be:	460c      	mov	r4, r1
 80001c0:	2b00      	cmp	r3, #0
 80001c2:	d14e      	bne.n	8000262 <__udivmoddi4+0xaa>
 80001c4:	4694      	mov	ip, r2
 80001c6:	458c      	cmp	ip, r1
 80001c8:	4686      	mov	lr, r0
 80001ca:	fab2 f282 	clz	r2, r2
 80001ce:	d962      	bls.n	8000296 <__udivmoddi4+0xde>
 80001d0:	b14a      	cbz	r2, 80001e6 <__udivmoddi4+0x2e>
 80001d2:	f1c2 0320 	rsb	r3, r2, #32
 80001d6:	4091      	lsls	r1, r2
 80001d8:	fa20 f303 	lsr.w	r3, r0, r3
 80001dc:	fa0c fc02 	lsl.w	ip, ip, r2
 80001e0:	4319      	orrs	r1, r3
 80001e2:	fa00 fe02 	lsl.w	lr, r0, r2
 80001e6:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80001ea:	fa1f f68c 	uxth.w	r6, ip
 80001ee:	fbb1 f4f7 	udiv	r4, r1, r7
 80001f2:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80001f6:	fb07 1114 	mls	r1, r7, r4, r1
 80001fa:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80001fe:	fb04 f106 	mul.w	r1, r4, r6
 8000202:	4299      	cmp	r1, r3
 8000204:	d90a      	bls.n	800021c <__udivmoddi4+0x64>
 8000206:	eb1c 0303 	adds.w	r3, ip, r3
 800020a:	f104 30ff 	add.w	r0, r4, #4294967295
 800020e:	f080 8112 	bcs.w	8000436 <__udivmoddi4+0x27e>
 8000212:	4299      	cmp	r1, r3
 8000214:	f240 810f 	bls.w	8000436 <__udivmoddi4+0x27e>
 8000218:	3c02      	subs	r4, #2
 800021a:	4463      	add	r3, ip
 800021c:	1a59      	subs	r1, r3, r1
 800021e:	fa1f f38e 	uxth.w	r3, lr
 8000222:	fbb1 f0f7 	udiv	r0, r1, r7
 8000226:	fb07 1110 	mls	r1, r7, r0, r1
 800022a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800022e:	fb00 f606 	mul.w	r6, r0, r6
 8000232:	429e      	cmp	r6, r3
 8000234:	d90a      	bls.n	800024c <__udivmoddi4+0x94>
 8000236:	eb1c 0303 	adds.w	r3, ip, r3
 800023a:	f100 31ff 	add.w	r1, r0, #4294967295
 800023e:	f080 80fc 	bcs.w	800043a <__udivmoddi4+0x282>
 8000242:	429e      	cmp	r6, r3
 8000244:	f240 80f9 	bls.w	800043a <__udivmoddi4+0x282>
 8000248:	4463      	add	r3, ip
 800024a:	3802      	subs	r0, #2
 800024c:	1b9b      	subs	r3, r3, r6
 800024e:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000252:	2100      	movs	r1, #0
 8000254:	b11d      	cbz	r5, 800025e <__udivmoddi4+0xa6>
 8000256:	40d3      	lsrs	r3, r2
 8000258:	2200      	movs	r2, #0
 800025a:	e9c5 3200 	strd	r3, r2, [r5]
 800025e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000262:	428b      	cmp	r3, r1
 8000264:	d905      	bls.n	8000272 <__udivmoddi4+0xba>
 8000266:	b10d      	cbz	r5, 800026c <__udivmoddi4+0xb4>
 8000268:	e9c5 0100 	strd	r0, r1, [r5]
 800026c:	2100      	movs	r1, #0
 800026e:	4608      	mov	r0, r1
 8000270:	e7f5      	b.n	800025e <__udivmoddi4+0xa6>
 8000272:	fab3 f183 	clz	r1, r3
 8000276:	2900      	cmp	r1, #0
 8000278:	d146      	bne.n	8000308 <__udivmoddi4+0x150>
 800027a:	42a3      	cmp	r3, r4
 800027c:	d302      	bcc.n	8000284 <__udivmoddi4+0xcc>
 800027e:	4290      	cmp	r0, r2
 8000280:	f0c0 80f0 	bcc.w	8000464 <__udivmoddi4+0x2ac>
 8000284:	1a86      	subs	r6, r0, r2
 8000286:	eb64 0303 	sbc.w	r3, r4, r3
 800028a:	2001      	movs	r0, #1
 800028c:	2d00      	cmp	r5, #0
 800028e:	d0e6      	beq.n	800025e <__udivmoddi4+0xa6>
 8000290:	e9c5 6300 	strd	r6, r3, [r5]
 8000294:	e7e3      	b.n	800025e <__udivmoddi4+0xa6>
 8000296:	2a00      	cmp	r2, #0
 8000298:	f040 8090 	bne.w	80003bc <__udivmoddi4+0x204>
 800029c:	eba1 040c 	sub.w	r4, r1, ip
 80002a0:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80002a4:	fa1f f78c 	uxth.w	r7, ip
 80002a8:	2101      	movs	r1, #1
 80002aa:	fbb4 f6f8 	udiv	r6, r4, r8
 80002ae:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80002b2:	fb08 4416 	mls	r4, r8, r6, r4
 80002b6:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 80002ba:	fb07 f006 	mul.w	r0, r7, r6
 80002be:	4298      	cmp	r0, r3
 80002c0:	d908      	bls.n	80002d4 <__udivmoddi4+0x11c>
 80002c2:	eb1c 0303 	adds.w	r3, ip, r3
 80002c6:	f106 34ff 	add.w	r4, r6, #4294967295
 80002ca:	d202      	bcs.n	80002d2 <__udivmoddi4+0x11a>
 80002cc:	4298      	cmp	r0, r3
 80002ce:	f200 80cd 	bhi.w	800046c <__udivmoddi4+0x2b4>
 80002d2:	4626      	mov	r6, r4
 80002d4:	1a1c      	subs	r4, r3, r0
 80002d6:	fa1f f38e 	uxth.w	r3, lr
 80002da:	fbb4 f0f8 	udiv	r0, r4, r8
 80002de:	fb08 4410 	mls	r4, r8, r0, r4
 80002e2:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 80002e6:	fb00 f707 	mul.w	r7, r0, r7
 80002ea:	429f      	cmp	r7, r3
 80002ec:	d908      	bls.n	8000300 <__udivmoddi4+0x148>
 80002ee:	eb1c 0303 	adds.w	r3, ip, r3
 80002f2:	f100 34ff 	add.w	r4, r0, #4294967295
 80002f6:	d202      	bcs.n	80002fe <__udivmoddi4+0x146>
 80002f8:	429f      	cmp	r7, r3
 80002fa:	f200 80b0 	bhi.w	800045e <__udivmoddi4+0x2a6>
 80002fe:	4620      	mov	r0, r4
 8000300:	1bdb      	subs	r3, r3, r7
 8000302:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000306:	e7a5      	b.n	8000254 <__udivmoddi4+0x9c>
 8000308:	f1c1 0620 	rsb	r6, r1, #32
 800030c:	408b      	lsls	r3, r1
 800030e:	fa22 f706 	lsr.w	r7, r2, r6
 8000312:	431f      	orrs	r7, r3
 8000314:	fa20 fc06 	lsr.w	ip, r0, r6
 8000318:	fa04 f301 	lsl.w	r3, r4, r1
 800031c:	ea43 030c 	orr.w	r3, r3, ip
 8000320:	40f4      	lsrs	r4, r6
 8000322:	fa00 f801 	lsl.w	r8, r0, r1
 8000326:	0c38      	lsrs	r0, r7, #16
 8000328:	ea4f 4913 	mov.w	r9, r3, lsr #16
 800032c:	fbb4 fef0 	udiv	lr, r4, r0
 8000330:	fa1f fc87 	uxth.w	ip, r7
 8000334:	fb00 441e 	mls	r4, r0, lr, r4
 8000338:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 800033c:	fb0e f90c 	mul.w	r9, lr, ip
 8000340:	45a1      	cmp	r9, r4
 8000342:	fa02 f201 	lsl.w	r2, r2, r1
 8000346:	d90a      	bls.n	800035e <__udivmoddi4+0x1a6>
 8000348:	193c      	adds	r4, r7, r4
 800034a:	f10e 3aff 	add.w	sl, lr, #4294967295
 800034e:	f080 8084 	bcs.w	800045a <__udivmoddi4+0x2a2>
 8000352:	45a1      	cmp	r9, r4
 8000354:	f240 8081 	bls.w	800045a <__udivmoddi4+0x2a2>
 8000358:	f1ae 0e02 	sub.w	lr, lr, #2
 800035c:	443c      	add	r4, r7
 800035e:	eba4 0409 	sub.w	r4, r4, r9
 8000362:	fa1f f983 	uxth.w	r9, r3
 8000366:	fbb4 f3f0 	udiv	r3, r4, r0
 800036a:	fb00 4413 	mls	r4, r0, r3, r4
 800036e:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000372:	fb03 fc0c 	mul.w	ip, r3, ip
 8000376:	45a4      	cmp	ip, r4
 8000378:	d907      	bls.n	800038a <__udivmoddi4+0x1d2>
 800037a:	193c      	adds	r4, r7, r4
 800037c:	f103 30ff 	add.w	r0, r3, #4294967295
 8000380:	d267      	bcs.n	8000452 <__udivmoddi4+0x29a>
 8000382:	45a4      	cmp	ip, r4
 8000384:	d965      	bls.n	8000452 <__udivmoddi4+0x29a>
 8000386:	3b02      	subs	r3, #2
 8000388:	443c      	add	r4, r7
 800038a:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 800038e:	fba0 9302 	umull	r9, r3, r0, r2
 8000392:	eba4 040c 	sub.w	r4, r4, ip
 8000396:	429c      	cmp	r4, r3
 8000398:	46ce      	mov	lr, r9
 800039a:	469c      	mov	ip, r3
 800039c:	d351      	bcc.n	8000442 <__udivmoddi4+0x28a>
 800039e:	d04e      	beq.n	800043e <__udivmoddi4+0x286>
 80003a0:	b155      	cbz	r5, 80003b8 <__udivmoddi4+0x200>
 80003a2:	ebb8 030e 	subs.w	r3, r8, lr
 80003a6:	eb64 040c 	sbc.w	r4, r4, ip
 80003aa:	fa04 f606 	lsl.w	r6, r4, r6
 80003ae:	40cb      	lsrs	r3, r1
 80003b0:	431e      	orrs	r6, r3
 80003b2:	40cc      	lsrs	r4, r1
 80003b4:	e9c5 6400 	strd	r6, r4, [r5]
 80003b8:	2100      	movs	r1, #0
 80003ba:	e750      	b.n	800025e <__udivmoddi4+0xa6>
 80003bc:	f1c2 0320 	rsb	r3, r2, #32
 80003c0:	fa20 f103 	lsr.w	r1, r0, r3
 80003c4:	fa0c fc02 	lsl.w	ip, ip, r2
 80003c8:	fa24 f303 	lsr.w	r3, r4, r3
 80003cc:	4094      	lsls	r4, r2
 80003ce:	430c      	orrs	r4, r1
 80003d0:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80003d4:	fa00 fe02 	lsl.w	lr, r0, r2
 80003d8:	fa1f f78c 	uxth.w	r7, ip
 80003dc:	fbb3 f0f8 	udiv	r0, r3, r8
 80003e0:	fb08 3110 	mls	r1, r8, r0, r3
 80003e4:	0c23      	lsrs	r3, r4, #16
 80003e6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80003ea:	fb00 f107 	mul.w	r1, r0, r7
 80003ee:	4299      	cmp	r1, r3
 80003f0:	d908      	bls.n	8000404 <__udivmoddi4+0x24c>
 80003f2:	eb1c 0303 	adds.w	r3, ip, r3
 80003f6:	f100 36ff 	add.w	r6, r0, #4294967295
 80003fa:	d22c      	bcs.n	8000456 <__udivmoddi4+0x29e>
 80003fc:	4299      	cmp	r1, r3
 80003fe:	d92a      	bls.n	8000456 <__udivmoddi4+0x29e>
 8000400:	3802      	subs	r0, #2
 8000402:	4463      	add	r3, ip
 8000404:	1a5b      	subs	r3, r3, r1
 8000406:	b2a4      	uxth	r4, r4
 8000408:	fbb3 f1f8 	udiv	r1, r3, r8
 800040c:	fb08 3311 	mls	r3, r8, r1, r3
 8000410:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000414:	fb01 f307 	mul.w	r3, r1, r7
 8000418:	42a3      	cmp	r3, r4
 800041a:	d908      	bls.n	800042e <__udivmoddi4+0x276>
 800041c:	eb1c 0404 	adds.w	r4, ip, r4
 8000420:	f101 36ff 	add.w	r6, r1, #4294967295
 8000424:	d213      	bcs.n	800044e <__udivmoddi4+0x296>
 8000426:	42a3      	cmp	r3, r4
 8000428:	d911      	bls.n	800044e <__udivmoddi4+0x296>
 800042a:	3902      	subs	r1, #2
 800042c:	4464      	add	r4, ip
 800042e:	1ae4      	subs	r4, r4, r3
 8000430:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8000434:	e739      	b.n	80002aa <__udivmoddi4+0xf2>
 8000436:	4604      	mov	r4, r0
 8000438:	e6f0      	b.n	800021c <__udivmoddi4+0x64>
 800043a:	4608      	mov	r0, r1
 800043c:	e706      	b.n	800024c <__udivmoddi4+0x94>
 800043e:	45c8      	cmp	r8, r9
 8000440:	d2ae      	bcs.n	80003a0 <__udivmoddi4+0x1e8>
 8000442:	ebb9 0e02 	subs.w	lr, r9, r2
 8000446:	eb63 0c07 	sbc.w	ip, r3, r7
 800044a:	3801      	subs	r0, #1
 800044c:	e7a8      	b.n	80003a0 <__udivmoddi4+0x1e8>
 800044e:	4631      	mov	r1, r6
 8000450:	e7ed      	b.n	800042e <__udivmoddi4+0x276>
 8000452:	4603      	mov	r3, r0
 8000454:	e799      	b.n	800038a <__udivmoddi4+0x1d2>
 8000456:	4630      	mov	r0, r6
 8000458:	e7d4      	b.n	8000404 <__udivmoddi4+0x24c>
 800045a:	46d6      	mov	lr, sl
 800045c:	e77f      	b.n	800035e <__udivmoddi4+0x1a6>
 800045e:	4463      	add	r3, ip
 8000460:	3802      	subs	r0, #2
 8000462:	e74d      	b.n	8000300 <__udivmoddi4+0x148>
 8000464:	4606      	mov	r6, r0
 8000466:	4623      	mov	r3, r4
 8000468:	4608      	mov	r0, r1
 800046a:	e70f      	b.n	800028c <__udivmoddi4+0xd4>
 800046c:	3e02      	subs	r6, #2
 800046e:	4463      	add	r3, ip
 8000470:	e730      	b.n	80002d4 <__udivmoddi4+0x11c>
 8000472:	bf00      	nop

08000474 <__aeabi_idiv0>:
 8000474:	4770      	bx	lr
 8000476:	bf00      	nop

08000478 <DBG_Init>:

/**
  * @brief Initializes the SW probes pins and the monitor RF pins via Alternate Function
  */
void DBG_Init(void)
{
 8000478:	b5f0      	push	{r4, r5, r6, r7, lr}
 800047a:	b089      	sub	sp, #36	@ 0x24
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->IMR2, ExtiLine);
 800047c:	4a22      	ldr	r2, [pc, #136]	@ (8000508 <DBG_Init+0x90>)
 800047e:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8000482:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8000486:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  HAL_DBGMCU_DisableDBGStandbyMode();
#elif defined (DEBUGGER_ENABLED) && ( DEBUGGER_ENABLED == 1 )
  /*Debug power up request wakeup CBDGPWRUPREQ*/
  LL_EXTI_EnableIT_32_63(LL_EXTI_LINE_46);
  /* Disabled HAL_DBGMCU_  */
  HAL_DBGMCU_EnableDBGSleepMode();
 800048a:	f001 fe31 	bl	80020f0 <HAL_DBGMCU_EnableDBGSleepMode>
  HAL_DBGMCU_EnableDBGStopMode();
 800048e:	f001 fe37 	bl	8002100 <HAL_DBGMCU_EnableDBGStopMode>
  HAL_DBGMCU_EnableDBGStandbyMode();
 8000492:	f001 fe3d 	bl	8002110 <HAL_DBGMCU_EnableDBGStandbyMode>
#elif !defined (DEBUGGER_ENABLED)
#error "DEBUGGER_ENABLED not defined or out of range <0,1>"
#endif /* DEBUGGER_OFF */

  GPIO_InitTypeDef  GPIO_InitStruct = {0};
 8000496:	2400      	movs	r4, #0
 8000498:	9403      	str	r4, [sp, #12]
 800049a:	9404      	str	r4, [sp, #16]
 800049c:	9405      	str	r4, [sp, #20]
 800049e:	9406      	str	r4, [sp, #24]
 80004a0:	9407      	str	r4, [sp, #28]

  /* Configure the GPIO pin */
  GPIO_InitStruct.Mode   = GPIO_MODE_OUTPUT_PP;
 80004a2:	2301      	movs	r3, #1
 80004a4:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull   = GPIO_NOPULL;
  GPIO_InitStruct.Speed  = GPIO_SPEED_FREQ_VERY_HIGH;
 80004a6:	2303      	movs	r3, #3
 80004a8:	9306      	str	r3, [sp, #24]
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 80004aa:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80004ae:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80004b0:	f042 0202 	orr.w	r2, r2, #2
 80004b4:	64da      	str	r2, [r3, #76]	@ 0x4c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80004b6:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80004b8:	f002 0202 	and.w	r2, r2, #2
 80004bc:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 80004be:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 80004c0:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80004c2:	f042 0202 	orr.w	r2, r2, #2
 80004c6:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80004c8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80004ca:	f003 0302 	and.w	r3, r3, #2
 80004ce:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80004d0:	9b01      	ldr	r3, [sp, #4]

  /* Enable the GPIO Clock */
  PROBE_LINE1_CLK_ENABLE();
  PROBE_LINE2_CLK_ENABLE();

  GPIO_InitStruct.Pin    = PROBE_LINE1_PIN;
 80004d2:	f44f 5780 	mov.w	r7, #4096	@ 0x1000
 80004d6:	9703      	str	r7, [sp, #12]
  HAL_GPIO_Init(PROBE_LINE1_PORT, &GPIO_InitStruct);
 80004d8:	4d0c      	ldr	r5, [pc, #48]	@ (800050c <DBG_Init+0x94>)
 80004da:	a903      	add	r1, sp, #12
 80004dc:	4628      	mov	r0, r5
 80004de:	f002 fc79 	bl	8002dd4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin    = PROBE_LINE2_PIN;
 80004e2:	f44f 5600 	mov.w	r6, #8192	@ 0x2000
 80004e6:	9603      	str	r6, [sp, #12]
  HAL_GPIO_Init(PROBE_LINE2_PORT, &GPIO_InitStruct);
 80004e8:	a903      	add	r1, sp, #12
 80004ea:	4628      	mov	r0, r5
 80004ec:	f002 fc72 	bl	8002dd4 <HAL_GPIO_Init>

  /* Reset probe Pins */
  HAL_GPIO_WritePin(PROBE_LINE1_PORT, PROBE_LINE1_PIN, GPIO_PIN_RESET);
 80004f0:	4622      	mov	r2, r4
 80004f2:	4639      	mov	r1, r7
 80004f4:	4628      	mov	r0, r5
 80004f6:	f002 fdbd 	bl	8003074 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(PROBE_LINE2_PORT, PROBE_LINE2_PIN, GPIO_PIN_RESET);
 80004fa:	4622      	mov	r2, r4
 80004fc:	4631      	mov	r1, r6
 80004fe:	4628      	mov	r0, r5
 8000500:	f002 fdb8 	bl	8003074 <HAL_GPIO_WritePin>
#endif /* DEBUG_RF_BUSY_ENABLED */

  /* USER CODE BEGIN DBG_Init_3 */

  /* USER CODE END DBG_Init_3 */
}
 8000504:	b009      	add	sp, #36	@ 0x24
 8000506:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000508:	58000800 	.word	0x58000800
 800050c:	48000400 	.word	0x48000400

08000510 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8000510:	b500      	push	{lr}
 8000512:	b083      	sub	sp, #12
  SET_BIT(RCC->AHB1ENR, Periphs);
 8000514:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000518:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 800051a:	f042 0204 	orr.w	r2, r2, #4
 800051e:	649a      	str	r2, [r3, #72]	@ 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8000520:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8000522:	f002 0204 	and.w	r2, r2, #4
 8000526:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8000528:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 800052a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 800052c:	f042 0201 	orr.w	r2, r2, #1
 8000530:	649a      	str	r2, [r3, #72]	@ 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8000532:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8000534:	f003 0301 	and.w	r3, r3, #1
 8000538:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 800053a:	9b00      	ldr	r3, [sp, #0]
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 2, 0);
 800053c:	2200      	movs	r2, #0
 800053e:	2102      	movs	r1, #2
 8000540:	200f      	movs	r0, #15
 8000542:	f001 fe53 	bl	80021ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 8000546:	200f      	movs	r0, #15
 8000548:	f001 fe60 	bl	800220c <HAL_NVIC_EnableIRQ>

}
 800054c:	b003      	add	sp, #12
 800054e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000554 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000554:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000558:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800055a:	2400      	movs	r4, #0
 800055c:	9403      	str	r4, [sp, #12]
 800055e:	9404      	str	r4, [sp, #16]
 8000560:	9405      	str	r4, [sp, #20]
 8000562:	9406      	str	r4, [sp, #24]
 8000564:	9407      	str	r4, [sp, #28]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8000566:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800056a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800056c:	f042 0201 	orr.w	r2, r2, #1
 8000570:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000572:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000574:	f002 0201 	and.w	r2, r2, #1
 8000578:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 800057a:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800057c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800057e:	f042 0202 	orr.w	r2, r2, #2
 8000582:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000584:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000586:	f002 0202 	and.w	r2, r2, #2
 800058a:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 800058c:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800058e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000590:	f042 0204 	orr.w	r2, r2, #4
 8000594:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000596:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8000598:	f003 0304 	and.w	r3, r3, #4
 800059c:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 800059e:	9b00      	ldr	r3, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED1_Pin|LED2_Pin|PROB2_Pin|PROB1_Pin
 80005a0:	4e26      	ldr	r6, [pc, #152]	@ (800063c <MX_GPIO_Init+0xe8>)
 80005a2:	4622      	mov	r2, r4
 80005a4:	f44f 413a 	mov.w	r1, #47616	@ 0xba00
 80005a8:	4630      	mov	r0, r6
 80005aa:	f002 fd63 	bl	8003074 <HAL_GPIO_WritePin>
                          |LED3_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = LED1_Pin|LED2_Pin|LED3_Pin;
 80005ae:	f44f 430a 	mov.w	r3, #35328	@ 0x8a00
 80005b2:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80005b4:	2501      	movs	r5, #1
 80005b6:	9504      	str	r5, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80005b8:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80005ba:	2302      	movs	r3, #2
 80005bc:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80005be:	a903      	add	r1, sp, #12
 80005c0:	4630      	mov	r0, r6
 80005c2:	f002 fc07 	bl	8002dd4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = BUT1_Pin|BUT2_Pin;
 80005c6:	f04f 0803 	mov.w	r8, #3
 80005ca:	f8cd 800c 	str.w	r8, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 80005ce:	f44f 1704 	mov.w	r7, #2162688	@ 0x210000
 80005d2:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80005d4:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80005d6:	a903      	add	r1, sp, #12
 80005d8:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80005dc:	f002 fbfa 	bl	8002dd4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin */
  GPIO_InitStruct.Pin = PROB2_Pin|PROB1_Pin;
 80005e0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
 80005e4:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80005e6:	9504      	str	r5, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80005e8:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80005ea:	f8cd 8018 	str.w	r8, [sp, #24]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80005ee:	a903      	add	r1, sp, #12
 80005f0:	4630      	mov	r0, r6
 80005f2:	f002 fbef 	bl	8002dd4 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = BUT3_Pin;
 80005f6:	2340      	movs	r3, #64	@ 0x40
 80005f8:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 80005fa:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80005fc:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(BUT3_GPIO_Port, &GPIO_InitStruct);
 80005fe:	a903      	add	r1, sp, #12
 8000600:	480f      	ldr	r0, [pc, #60]	@ (8000640 <MX_GPIO_Init+0xec>)
 8000602:	f002 fbe7 	bl	8002dd4 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
 8000606:	4622      	mov	r2, r4
 8000608:	4621      	mov	r1, r4
 800060a:	2006      	movs	r0, #6
 800060c:	f001 fdee 	bl	80021ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 8000610:	2006      	movs	r0, #6
 8000612:	f001 fdfb 	bl	800220c <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
 8000616:	4622      	mov	r2, r4
 8000618:	4621      	mov	r1, r4
 800061a:	2007      	movs	r0, #7
 800061c:	f001 fde6 	bl	80021ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI1_IRQn);
 8000620:	2007      	movs	r0, #7
 8000622:	f001 fdf3 	bl	800220c <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
 8000626:	4622      	mov	r2, r4
 8000628:	4621      	mov	r1, r4
 800062a:	2016      	movs	r0, #22
 800062c:	f001 fdde 	bl	80021ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 8000630:	2016      	movs	r0, #22
 8000632:	f001 fdeb 	bl	800220c <HAL_NVIC_EnableIRQ>

}
 8000636:	b008      	add	sp, #32
 8000638:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800063c:	48000400 	.word	0x48000400
 8000640:	48000800 	.word	0x48000800

08000644 <MX_IPCC_Init>:

IPCC_HandleTypeDef hipcc;

/* IPCC init function */
void MX_IPCC_Init(void)
{
 8000644:	b508      	push	{r3, lr}
  /* USER CODE END IPCC_Init 0 */

  /* USER CODE BEGIN IPCC_Init 1 */

  /* USER CODE END IPCC_Init 1 */
  hipcc.Instance = IPCC;
 8000646:	4805      	ldr	r0, [pc, #20]	@ (800065c <MX_IPCC_Init+0x18>)
 8000648:	4b05      	ldr	r3, [pc, #20]	@ (8000660 <MX_IPCC_Init+0x1c>)
 800064a:	6003      	str	r3, [r0, #0]
  if (HAL_IPCC_Init(&hipcc) != HAL_OK)
 800064c:	f002 fe0c 	bl	8003268 <HAL_IPCC_Init>
 8000650:	b900      	cbnz	r0, 8000654 <MX_IPCC_Init+0x10>
  }
  /* USER CODE BEGIN IPCC_Init 2 */

  /* USER CODE END IPCC_Init 2 */

}
 8000652:	bd08      	pop	{r3, pc}
    Error_Handler();
 8000654:	f000 f88e 	bl	8000774 <Error_Handler>
}
 8000658:	e7fb      	b.n	8000652 <MX_IPCC_Init+0xe>
 800065a:	bf00      	nop
 800065c:	20000034 	.word	0x20000034
 8000660:	58000c00 	.word	0x58000c00

08000664 <HAL_IPCC_MspInit>:

void HAL_IPCC_MspInit(IPCC_HandleTypeDef* ipccHandle)
{

  if(ipccHandle->Instance==IPCC)
 8000664:	6802      	ldr	r2, [r0, #0]
 8000666:	4b12      	ldr	r3, [pc, #72]	@ (80006b0 <HAL_IPCC_MspInit+0x4c>)
 8000668:	429a      	cmp	r2, r3
 800066a:	d000      	beq.n	800066e <HAL_IPCC_MspInit+0xa>
 800066c:	4770      	bx	lr
{
 800066e:	b500      	push	{lr}
 8000670:	b083      	sub	sp, #12
  */
#endif /* DUAL_CORE */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB3ENR, Periphs);
 8000672:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000676:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000678:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 800067c:	651a      	str	r2, [r3, #80]	@ 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 800067e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8000680:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8000684:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000686:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE END IPCC_MspInit 0 */
    /* IPCC clock enable */
    __HAL_RCC_IPCC_CLK_ENABLE();

    /* IPCC interrupt Init */
    HAL_NVIC_SetPriority(IPCC_C1_RX_IRQn, 2, 0);
 8000688:	2200      	movs	r2, #0
 800068a:	2102      	movs	r1, #2
 800068c:	202d      	movs	r0, #45	@ 0x2d
 800068e:	f001 fdad 	bl	80021ec <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 8000692:	202d      	movs	r0, #45	@ 0x2d
 8000694:	f001 fdba 	bl	800220c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(IPCC_C1_TX_IRQn, 2, 0);
 8000698:	2200      	movs	r2, #0
 800069a:	2102      	movs	r1, #2
 800069c:	202e      	movs	r0, #46	@ 0x2e
 800069e:	f001 fda5 	bl	80021ec <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 80006a2:	202e      	movs	r0, #46	@ 0x2e
 80006a4:	f001 fdb2 	bl	800220c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN IPCC_MspInit 1 */

  /* USER CODE END IPCC_MspInit 1 */
  }
}
 80006a8:	b003      	add	sp, #12
 80006aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80006ae:	bf00      	nop
 80006b0:	58000c00 	.word	0x58000c00

080006b4 <IpccIfIsrTxCb>:
/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/

static void IpccIfIsrTxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 80006b4:	b508      	push	{r3, lr}

  /* USER CODE END IpccIfIsrTxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccResponseRcv(ChannelIndex);
 80006b6:	4b02      	ldr	r3, [pc, #8]	@ (80006c0 <IpccIfIsrTxCb+0xc>)
 80006b8:	681b      	ldr	r3, [r3, #0]
 80006ba:	4608      	mov	r0, r1
 80006bc:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrTxCb_2 */

  /* USER CODE END IpccIfIsrTxCb_2 */
}
 80006be:	bd08      	pop	{r3, pc}
 80006c0:	20000074 	.word	0x20000074

080006c4 <IpccIfIsrRxCb>:

static void IpccIfIsrRxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 80006c4:	b508      	push	{r3, lr}

  /* USER CODE END IpccIfIsrRxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccNotificationRcv(ChannelIndex);
 80006c6:	4b02      	ldr	r3, [pc, #8]	@ (80006d0 <IpccIfIsrRxCb+0xc>)
 80006c8:	681b      	ldr	r3, [r3, #0]
 80006ca:	4608      	mov	r0, r1
 80006cc:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrRxCb_2 */

  /* USER CODE END IpccIfIsrRxCb_2 */
}
 80006ce:	bd08      	pop	{r3, pc}
 80006d0:	20000070 	.word	0x20000070

080006d4 <IPCC_IF_Init>:
{
 80006d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80006d6:	4607      	mov	r7, r0
 80006d8:	460e      	mov	r6, r1
  MX_IPCC_Init();
 80006da:	f7ff ffb3 	bl	8000644 <MX_IPCC_Init>
 80006de:	4b11      	ldr	r3, [pc, #68]	@ (8000724 <IPCC_IF_Init+0x50>)
 80006e0:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 80006e4:	f042 0210 	orr.w	r2, r2, #16
 80006e8:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  *         @arg @ref LL_EXTI_LINE_45
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->RTSR2, ExtiLine);
 80006ec:	6a1a      	ldr	r2, [r3, #32]
 80006ee:	f042 0210 	orr.w	r2, r2, #16
 80006f2:	621a      	str	r2, [r3, #32]
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 80006f4:	2400      	movs	r4, #0
 80006f6:	e00d      	b.n	8000714 <IPCC_IF_Init+0x40>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_TX, IpccIfIsrTxCb);
 80006f8:	4d0b      	ldr	r5, [pc, #44]	@ (8000728 <IPCC_IF_Init+0x54>)
 80006fa:	4b0c      	ldr	r3, [pc, #48]	@ (800072c <IPCC_IF_Init+0x58>)
 80006fc:	2200      	movs	r2, #0
 80006fe:	4621      	mov	r1, r4
 8000700:	4628      	mov	r0, r5
 8000702:	f002 fd3d 	bl	8003180 <HAL_IPCC_ActivateNotification>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_RX, IpccIfIsrRxCb);
 8000706:	4b0a      	ldr	r3, [pc, #40]	@ (8000730 <IPCC_IF_Init+0x5c>)
 8000708:	2201      	movs	r2, #1
 800070a:	4621      	mov	r1, r4
 800070c:	4628      	mov	r0, r5
 800070e:	f002 fd37 	bl	8003180 <HAL_IPCC_ActivateNotification>
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8000712:	3401      	adds	r4, #1
 8000714:	2c05      	cmp	r4, #5
 8000716:	d9ef      	bls.n	80006f8 <IPCC_IF_Init+0x24>
  IpccResponseRcv = IPCC_IF_ResponseRcv_cb;
 8000718:	4b06      	ldr	r3, [pc, #24]	@ (8000734 <IPCC_IF_Init+0x60>)
 800071a:	601f      	str	r7, [r3, #0]
  IpccNotificationRcv = IPCC_IF_NotificationRcv_cb;
 800071c:	4b06      	ldr	r3, [pc, #24]	@ (8000738 <IPCC_IF_Init+0x64>)
 800071e:	601e      	str	r6, [r3, #0]
}
 8000720:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000722:	bf00      	nop
 8000724:	58000800 	.word	0x58000800
 8000728:	20000034 	.word	0x20000034
 800072c:	080006b5 	.word	0x080006b5
 8000730:	080006c5 	.word	0x080006c5
 8000734:	20000074 	.word	0x20000074
 8000738:	20000070 	.word	0x20000070

0800073c <IPCC_IF_CommandSnd>:
{
 800073c:	b508      	push	{r3, lr}
 800073e:	4601      	mov	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_TX))
 8000740:	2200      	movs	r2, #0
 8000742:	4804      	ldr	r0, [pc, #16]	@ (8000754 <IPCC_IF_CommandSnd+0x18>)
 8000744:	f002 fd50 	bl	80031e8 <HAL_IPCC_NotifyCPU>
 8000748:	b908      	cbnz	r0, 800074e <IPCC_IF_CommandSnd+0x12>
    return 0;
 800074a:	2000      	movs	r0, #0
}
 800074c:	bd08      	pop	{r3, pc}
    return -1;
 800074e:	f04f 30ff 	mov.w	r0, #4294967295
 8000752:	e7fb      	b.n	800074c <IPCC_IF_CommandSnd+0x10>
 8000754:	20000034 	.word	0x20000034

08000758 <IPCC_IF_AcknowledgeSnd>:
{
 8000758:	b508      	push	{r3, lr}
 800075a:	4601      	mov	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_RX))
 800075c:	2201      	movs	r2, #1
 800075e:	4804      	ldr	r0, [pc, #16]	@ (8000770 <IPCC_IF_AcknowledgeSnd+0x18>)
 8000760:	f002 fd42 	bl	80031e8 <HAL_IPCC_NotifyCPU>
 8000764:	b908      	cbnz	r0, 800076a <IPCC_IF_AcknowledgeSnd+0x12>
    return 0;
 8000766:	2000      	movs	r0, #0
}
 8000768:	bd08      	pop	{r3, pc}
    return -1;
 800076a:	f04f 30ff 	mov.w	r0, #4294967295
 800076e:	e7fb      	b.n	8000768 <IPCC_IF_AcknowledgeSnd+0x10>
 8000770:	20000034 	.word	0x20000034

08000774 <Error_Handler>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000774:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000776:	e7fe      	b.n	8000776 <Error_Handler+0x2>

08000778 <SystemClock_Config>:
{
 8000778:	b510      	push	{r4, lr}
 800077a:	b09a      	sub	sp, #104	@ 0x68
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800077c:	2248      	movs	r2, #72	@ 0x48
 800077e:	2100      	movs	r1, #0
 8000780:	a808      	add	r0, sp, #32
 8000782:	f005 fdd1 	bl	8006328 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000786:	2400      	movs	r4, #0
 8000788:	9401      	str	r4, [sp, #4]
 800078a:	9402      	str	r4, [sp, #8]
 800078c:	9403      	str	r4, [sp, #12]
 800078e:	9404      	str	r4, [sp, #16]
 8000790:	9405      	str	r4, [sp, #20]
 8000792:	9406      	str	r4, [sp, #24]
 8000794:	9407      	str	r4, [sp, #28]
  HAL_PWR_EnableBkUpAccess();
 8000796:	f002 fd85 	bl	80032a4 <HAL_PWR_EnableBkUpAccess>
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 800079a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800079e:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80007a2:	f023 0318 	bic.w	r3, r3, #24
 80007a6:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80007aa:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80007ae:	6813      	ldr	r3, [r2, #0]
 80007b0:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 80007b4:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80007b8:	6013      	str	r3, [r2, #0]
 80007ba:	6813      	ldr	r3, [r2, #0]
 80007bc:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 80007c0:	9300      	str	r3, [sp, #0]
 80007c2:	9b00      	ldr	r3, [sp, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 80007c4:	2324      	movs	r3, #36	@ 0x24
 80007c6:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 80007c8:	2381      	movs	r3, #129	@ 0x81
 80007ca:	930b      	str	r3, [sp, #44]	@ 0x2c
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 80007cc:	2301      	movs	r3, #1
 80007ce:	9310      	str	r3, [sp, #64]	@ 0x40
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 80007d0:	9411      	str	r4, [sp, #68]	@ 0x44
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
 80007d2:	23b0      	movs	r3, #176	@ 0xb0
 80007d4:	9312      	str	r3, [sp, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 80007d6:	9413      	str	r4, [sp, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80007d8:	a808      	add	r0, sp, #32
 80007da:	f002 ff05 	bl	80035e8 <HAL_RCC_OscConfig>
 80007de:	b978      	cbnz	r0, 8000800 <SystemClock_Config+0x88>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK2
 80007e0:	236f      	movs	r3, #111	@ 0x6f
 80007e2:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 80007e4:	2300      	movs	r3, #0
 80007e6:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80007e8:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80007ea:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80007ec:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV1;
 80007ee:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 80007f0:	9307      	str	r3, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 80007f2:	2102      	movs	r1, #2
 80007f4:	a801      	add	r0, sp, #4
 80007f6:	f003 fa29 	bl	8003c4c <HAL_RCC_ClockConfig>
 80007fa:	b918      	cbnz	r0, 8000804 <SystemClock_Config+0x8c>
}
 80007fc:	b01a      	add	sp, #104	@ 0x68
 80007fe:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000800:	f7ff ffb8 	bl	8000774 <Error_Handler>
    Error_Handler();
 8000804:	f7ff ffb6 	bl	8000774 <Error_Handler>

08000808 <main>:
{
 8000808:	b508      	push	{r3, lr}
  HAL_Init();
 800080a:	f001 fc41 	bl	8002090 <HAL_Init>
  SystemClock_Config();
 800080e:	f7ff ffb3 	bl	8000778 <SystemClock_Config>
  MX_GPIO_Init();
 8000812:	f7ff fe9f 	bl	8000554 <MX_GPIO_Init>
  MX_SubGHz_Phy_Init();
 8000816:	f001 fa6a 	bl	8001cee <MX_SubGHz_Phy_Init>
    MX_SubGHz_Phy_Process();
 800081a:	f001 fa6e 	bl	8001cfa <MX_SubGHz_Phy_Process>
  while (1)
 800081e:	e7fc      	b.n	800081a <main+0x12>

08000820 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 8000820:	4770      	bx	lr

08000822 <PWR_ExitOffMode>:
void PWR_ExitOffMode(void)
{
  /* USER CODE BEGIN ExitOffMode_1 */

  /* USER CODE END ExitOffMode_1 */
}
 8000822:	4770      	bx	lr

08000824 <PWR_EnterStopMode>:

void PWR_EnterStopMode(void)
{
 8000824:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 8000826:	f001 fc55 	bl	80020d4 <HAL_SuspendTick>
  * @rmtoll EXTSCR       C1CSSF        LL_PWR_ClearFlag_C1STOP_C1STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C1STOP_C1STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C1CSSF);
 800082a:	2001      	movs	r0, #1
 800082c:	4b02      	ldr	r3, [pc, #8]	@ (8000838 <PWR_EnterStopMode+0x14>)
 800082e:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  LL_PWR_ClearFlag_C1STOP_C1STB();

  /* USER CODE BEGIN EnterStopMode_2 */

  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 8000832:	f002 fda3 	bl	800337c <HAL_PWREx_EnterSTOP2Mode>
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 8000836:	bd08      	pop	{r3, pc}
 8000838:	58000400 	.word	0x58000400

0800083c <PWR_ExitSleepMode>:

  /* USER CODE END EnterSleepMode_3 */
}

void PWR_ExitSleepMode(void)
{
 800083c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Resume sysTick */
  HAL_ResumeTick();
 800083e:	f001 fc50 	bl	80020e2 <HAL_ResumeTick>

  /* USER CODE BEGIN ExitSleepMode_2 */

  /* USER CODE END ExitSleepMode_2 */
}
 8000842:	bd08      	pop	{r3, pc}

08000844 <PWR_ExitStopMode>:
{
 8000844:	b508      	push	{r3, lr}
  HAL_ResumeTick();
 8000846:	f001 fc4c 	bl	80020e2 <HAL_ResumeTick>
  vcom_Resume();
 800084a:	f000 fb87 	bl	8000f5c <vcom_Resume>
}
 800084e:	bd08      	pop	{r3, pc}

08000850 <PWR_EnterSleepMode>:
{
 8000850:	b508      	push	{r3, lr}
  HAL_SuspendTick();
 8000852:	f001 fc3f 	bl	80020d4 <HAL_SuspendTick>
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 8000856:	2101      	movs	r1, #1
 8000858:	2000      	movs	r0, #0
 800085a:	f002 fd2b 	bl	80032b4 <HAL_PWR_EnterSLEEPMode>
}
 800085e:	bd08      	pop	{r3, pc}

08000860 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000860:	b508      	push	{r3, lr}

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 1, 0);
 8000862:	2200      	movs	r2, #0
 8000864:	2101      	movs	r1, #1
 8000866:	f06f 000b 	mvn.w	r0, #11
 800086a:	f001 fcbf 	bl	80021ec <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 1, 0);
 800086e:	2200      	movs	r2, #0
 8000870:	2101      	movs	r1, #1
 8000872:	f06f 000a 	mvn.w	r0, #10
 8000876:	f001 fcb9 	bl	80021ec <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800087a:	bd08      	pop	{r3, pc}

0800087c <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800087c:	e7fe      	b.n	800087c <NMI_Handler>

0800087e <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800087e:	e7fe      	b.n	800087e <HardFault_Handler>

08000880 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000880:	e7fe      	b.n	8000880 <MemManage_Handler>

08000882 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000882:	e7fe      	b.n	8000882 <BusFault_Handler>

08000884 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000884:	e7fe      	b.n	8000884 <UsageFault_Handler>

08000886 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8000886:	4770      	bx	lr

08000888 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8000888:	4770      	bx	lr

0800088a <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800088a:	4770      	bx	lr

0800088c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800088c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800088e:	f001 fc15 	bl	80020bc <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000892:	bd08      	pop	{r3, pc}

08000894 <EXTI0_IRQHandler>:

/**
  * @brief This function handles EXTI Line 0 Interrupt.
  */
void EXTI0_IRQHandler(void)
{
 8000894:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(BUT1_Pin);
 8000896:	2001      	movs	r0, #1
 8000898:	f002 fbfa 	bl	8003090 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI0_IRQn 1 */

  /* USER CODE END EXTI0_IRQn 1 */
}
 800089c:	bd08      	pop	{r3, pc}

0800089e <EXTI1_IRQHandler>:

/**
  * @brief This function handles EXTI Line 1 Interrupt.
  */
void EXTI1_IRQHandler(void)
{
 800089e:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI1_IRQn 0 */

  /* USER CODE END EXTI1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(BUT2_Pin);
 80008a0:	2002      	movs	r0, #2
 80008a2:	f002 fbf5 	bl	8003090 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI1_IRQn 1 */

  /* USER CODE END EXTI1_IRQn 1 */
}
 80008a6:	bd08      	pop	{r3, pc}

080008a8 <DMA1_Channel5_IRQHandler>:

/**
  * @brief This function handles DMA1 Channel 5 Interrupt.
  */
void DMA1_Channel5_IRQHandler(void)
{
 80008a8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 80008aa:	4802      	ldr	r0, [pc, #8]	@ (80008b4 <DMA1_Channel5_IRQHandler+0xc>)
 80008ac:	f001 fec8 	bl	8002640 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel5_IRQn 1 */

  /* USER CODE END DMA1_Channel5_IRQn 1 */
}
 80008b0:	bd08      	pop	{r3, pc}
 80008b2:	bf00      	nop
 80008b4:	200000bc 	.word	0x200000bc

080008b8 <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI Lines [9:5] Interrupt.
  */
void EXTI9_5_IRQHandler(void)
{
 80008b8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(BUT3_Pin);
 80008ba:	2040      	movs	r0, #64	@ 0x40
 80008bc:	f002 fbe8 	bl	8003090 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 80008c0:	bd08      	pop	{r3, pc}
	...

080008c4 <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 Interrupt.
  */
void USART2_IRQHandler(void)
{
 80008c4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 80008c6:	4802      	ldr	r0, [pc, #8]	@ (80008d0 <USART2_IRQHandler+0xc>)
 80008c8:	f003 feaa 	bl	8004620 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 80008cc:	bd08      	pop	{r3, pc}
 80008ce:	bf00      	nop
 80008d0:	2000011c 	.word	0x2000011c

080008d4 <IPCC_C1_RX_IRQHandler>:

/**
  * @brief This function handles IPCC RX Occupied Interrupt.
  */
void IPCC_C1_RX_IRQHandler(void)
{
 80008d4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN IPCC_C1_RX_IRQn 0 */

  /* USER CODE END IPCC_C1_RX_IRQn 0 */
  HAL_IPCC_RX_IRQHandler(&hipcc);
 80008d6:	4802      	ldr	r0, [pc, #8]	@ (80008e0 <IPCC_C1_RX_IRQHandler+0xc>)
 80008d8:	f002 fc14 	bl	8003104 <HAL_IPCC_RX_IRQHandler>
  /* USER CODE BEGIN IPCC_C1_RX_IRQn 1 */

  /* USER CODE END IPCC_C1_RX_IRQn 1 */
}
 80008dc:	bd08      	pop	{r3, pc}
 80008de:	bf00      	nop
 80008e0:	20000034 	.word	0x20000034

080008e4 <IPCC_C1_TX_IRQHandler>:

/**
  * @brief This function handles IPCC TX Free Interrupt.
  */
void IPCC_C1_TX_IRQHandler(void)
{
 80008e4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN IPCC_C1_TX_IRQn 0 */

  /* USER CODE END IPCC_C1_TX_IRQn 0 */
  HAL_IPCC_TX_IRQHandler(&hipcc);
 80008e6:	4802      	ldr	r0, [pc, #8]	@ (80008f0 <IPCC_C1_TX_IRQHandler+0xc>)
 80008e8:	f002 fbe2 	bl	80030b0 <HAL_IPCC_TX_IRQHandler>
  /* USER CODE BEGIN IPCC_C1_TX_IRQn 1 */

  /* USER CODE END IPCC_C1_TX_IRQn 1 */
}
 80008ec:	bd08      	pop	{r3, pc}
 80008ee:	bf00      	nop
 80008f0:	20000034 	.word	0x20000034

080008f4 <tiny_snprintf_like>:

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
{
 80008f4:	b40c      	push	{r2, r3}
 80008f6:	b500      	push	{lr}
 80008f8:	b083      	sub	sp, #12
 80008fa:	ab04      	add	r3, sp, #16
 80008fc:	f853 2b04 	ldr.w	r2, [r3], #4
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
 8000900:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 8000902:	f005 fc4d 	bl	80061a0 <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 8000906:	b003      	add	sp, #12
 8000908:	f85d eb04 	ldr.w	lr, [sp], #4
 800090c:	b002      	add	sp, #8
 800090e:	4770      	bx	lr

08000910 <TimestampNow>:
{
 8000910:	b530      	push	{r4, r5, lr}
 8000912:	b085      	sub	sp, #20
 8000914:	4604      	mov	r4, r0
 8000916:	460d      	mov	r5, r1
  SysTime_t curtime = SysTimeGet();
 8000918:	a802      	add	r0, sp, #8
 800091a:	f005 fa9f 	bl	8005e5c <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 800091e:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 8000922:	9300      	str	r3, [sp, #0]
 8000924:	9b02      	ldr	r3, [sp, #8]
 8000926:	4a05      	ldr	r2, [pc, #20]	@ (800093c <TimestampNow+0x2c>)
 8000928:	2110      	movs	r1, #16
 800092a:	4620      	mov	r0, r4
 800092c:	f7ff ffe2 	bl	80008f4 <tiny_snprintf_like>
  *size = strlen((char *)buff);
 8000930:	4620      	mov	r0, r4
 8000932:	f7ff fc21 	bl	8000178 <strlen>
 8000936:	8028      	strh	r0, [r5, #0]
}
 8000938:	b005      	add	sp, #20
 800093a:	bd30      	pop	{r4, r5, pc}
 800093c:	080063cc 	.word	0x080063cc

08000940 <MBMUXIF_Init>:
{
 8000940:	b508      	push	{r3, lr}
  APP_LOG(TS_ON, VLEVEL_H, "\r\nCM4: System Initialization started \r\n");
 8000942:	4b2c      	ldr	r3, [pc, #176]	@ (80009f4 <MBMUXIF_Init+0xb4>)
 8000944:	2201      	movs	r2, #1
 8000946:	2100      	movs	r1, #0
 8000948:	2003      	movs	r0, #3
 800094a:	f005 f809 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  init_status = MBMUXIF_SystemInit();
 800094e:	f000 fd49 	bl	80013e4 <MBMUXIF_SystemInit>
  if (init_status < 0)
 8000952:	2800      	cmp	r0, #0
 8000954:	db42      	blt.n	80009dc <MBMUXIF_Init+0x9c>
  HAL_PWREx_ReleaseCore(PWR_CORE_CPU2);
 8000956:	2001      	movs	r0, #1
 8000958:	f002 fcda 	bl	8003310 <HAL_PWREx_ReleaseCore>
  MBMUXIF_SetCpusSynchroFlag(CPUS_BOOT_SYNC_ALLOW_CPU2_TO_START);
 800095c:	f245 5055 	movw	r0, #21845	@ 0x5555
 8000960:	f000 fd38 	bl	80013d4 <MBMUXIF_SetCpusSynchroFlag>
  APP_LOG(TS_ON, VLEVEL_H, "CM4: System Initialization done: Wait for CM0PLUS \r\n");
 8000964:	4b24      	ldr	r3, [pc, #144]	@ (80009f8 <MBMUXIF_Init+0xb8>)
 8000966:	2201      	movs	r2, #1
 8000968:	2100      	movs	r1, #0
 800096a:	2003      	movs	r0, #3
 800096c:	f004 fff8 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  MBMUXIF_WaitCm0MbmuxIsInitialized();
 8000970:	f000 fdec 	bl	800154c <MBMUXIF_WaitCm0MbmuxIsInitialized>
  APP_LOG(TS_ON, VLEVEL_H, "CM0PLUS: System Initialization started \r\n");
 8000974:	4b21      	ldr	r3, [pc, #132]	@ (80009fc <MBMUXIF_Init+0xbc>)
 8000976:	2201      	movs	r2, #1
 8000978:	2100      	movs	r1, #0
 800097a:	2003      	movs	r0, #3
 800097c:	f004 fff0 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  p_cm0plus_supported_features_list = MBMUXIF_SystemSendCm0plusInfoListReq();
 8000980:	f000 fe27 	bl	80015d2 <MBMUXIF_SystemSendCm0plusInfoListReq>
  MBMUX_SetCm0plusFeatureListPtr(p_cm0plus_supported_features_list);
 8000984:	f000 fbfc 	bl	8001180 <MBMUX_SetCm0plusFeatureListPtr>
  APP_LOG(TS_ON, VLEVEL_H, "System Initialization CM4-CM0PLUS completed \r\n");
 8000988:	4b1d      	ldr	r3, [pc, #116]	@ (8000a00 <MBMUXIF_Init+0xc0>)
 800098a:	2201      	movs	r2, #1
 800098c:	2100      	movs	r1, #0
 800098e:	2003      	movs	r0, #3
 8000990:	f004 ffe6 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  init_status = MBMUXIF_SystemPrio_Add(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 8000994:	2002      	movs	r0, #2
 8000996:	f000 fe5f 	bl	8001658 <MBMUXIF_SystemPrio_Add>
  if (init_status < 0)
 800099a:	2800      	cmp	r0, #0
 800099c:	db21      	blt.n	80009e2 <MBMUXIF_Init+0xa2>
  MBMUXIF_SetCpusSynchroFlag(CPUS_BOOT_SYNC_RTC_REGISTERED);
 800099e:	f649 1099 	movw	r0, #39321	@ 0x9999
 80009a2:	f000 fd17 	bl	80013d4 <MBMUXIF_SetCpusSynchroFlag>
  APP_LOG(TS_ON, VLEVEL_H, "System_Priority_A Registration for RTC Alarm handling completed \r\n");
 80009a6:	4b17      	ldr	r3, [pc, #92]	@ (8000a04 <MBMUXIF_Init+0xc4>)
 80009a8:	2201      	movs	r2, #1
 80009aa:	2100      	movs	r1, #0
 80009ac:	2003      	movs	r0, #3
 80009ae:	f004 ffd7 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  init_status = MBMUXIF_TraceInit();
 80009b2:	f000 fe97 	bl	80016e4 <MBMUXIF_TraceInit>
  if (init_status < 0)
 80009b6:	2800      	cmp	r0, #0
 80009b8:	db16      	blt.n	80009e8 <MBMUXIF_Init+0xa8>
  APP_LOG(TS_ON, VLEVEL_H, "Trace registration CM4-CM0PLUS completed \r\n");
 80009ba:	4b13      	ldr	r3, [pc, #76]	@ (8000a08 <MBMUXIF_Init+0xc8>)
 80009bc:	2201      	movs	r2, #1
 80009be:	2100      	movs	r1, #0
 80009c0:	2003      	movs	r0, #3
 80009c2:	f004 ffcd 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  init_status = MBMUXIF_RadioInit();
 80009c6:	f000 fc87 	bl	80012d8 <MBMUXIF_RadioInit>
  if (init_status < 0)
 80009ca:	2800      	cmp	r0, #0
 80009cc:	db0f      	blt.n	80009ee <MBMUXIF_Init+0xae>
  APP_LOG(TS_ON, VLEVEL_H, "Radio registration CM4-CM0PLUS completed \r\n");
 80009ce:	4b0f      	ldr	r3, [pc, #60]	@ (8000a0c <MBMUXIF_Init+0xcc>)
 80009d0:	2201      	movs	r2, #1
 80009d2:	2100      	movs	r1, #0
 80009d4:	2003      	movs	r0, #3
 80009d6:	f004 ffc3 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
}
 80009da:	bd08      	pop	{r3, pc}
    Error_Handler();
 80009dc:	f7ff feca 	bl	8000774 <Error_Handler>
 80009e0:	e7b9      	b.n	8000956 <MBMUXIF_Init+0x16>
    Error_Handler();
 80009e2:	f7ff fec7 	bl	8000774 <Error_Handler>
 80009e6:	e7da      	b.n	800099e <MBMUXIF_Init+0x5e>
    Error_Handler();
 80009e8:	f7ff fec4 	bl	8000774 <Error_Handler>
 80009ec:	e7e5      	b.n	80009ba <MBMUXIF_Init+0x7a>
    Error_Handler();
 80009ee:	f7ff fec1 	bl	8000774 <Error_Handler>
 80009f2:	e7ec      	b.n	80009ce <MBMUXIF_Init+0x8e>
 80009f4:	080063d8 	.word	0x080063d8
 80009f8:	08006400 	.word	0x08006400
 80009fc:	08006438 	.word	0x08006438
 8000a00:	08006464 	.word	0x08006464
 8000a04:	08006494 	.word	0x08006494
 8000a08:	080064d8 	.word	0x080064d8
 8000a0c:	08006504 	.word	0x08006504

08000a10 <SystemApp_Init>:
{
 8000a10:	b508      	push	{r3, lr}
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetClkAfterWakeFromStop(uint32_t Clock)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 8000a12:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000a16:	6893      	ldr	r3, [r2, #8]
 8000a18:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8000a1c:	6093      	str	r3, [r2, #8]
  DBG_Init();
 8000a1e:	f7ff fd2b 	bl	8000478 <DBG_Init>
  UTIL_ADV_TRACE_Init();
 8000a22:	f004 ff1d 	bl	8005860 <UTIL_ADV_TRACE_Init>
  UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 8000a26:	480a      	ldr	r0, [pc, #40]	@ (8000a50 <SystemApp_Init+0x40>)
 8000a28:	f004 ff40 	bl	80058ac <UTIL_ADV_TRACE_RegisterTimeStampFunction>
  UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
 8000a2c:	2002      	movs	r0, #2
 8000a2e:	f004 ff43 	bl	80058b8 <UTIL_ADV_TRACE_SetVerboseLevel>
  UTIL_LPM_Init();
 8000a32:	f005 f87d 	bl	8005b30 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 8000a36:	2101      	movs	r1, #1
 8000a38:	4608      	mov	r0, r1
 8000a3a:	f005 f899 	bl	8005b70 <UTIL_LPM_SetOffMode>
  MBMUXIF_Init();
 8000a3e:	f7ff ff7f 	bl	8000940 <MBMUXIF_Init>
  UTIL_TIMER_Init();
 8000a42:	f005 fa2d 	bl	8005ea0 <UTIL_TIMER_Init>
  SYS_TimerInitialisedFlag = 1;
 8000a46:	4b03      	ldr	r3, [pc, #12]	@ (8000a54 <SystemApp_Init+0x44>)
 8000a48:	2201      	movs	r2, #1
 8000a4a:	701a      	strb	r2, [r3, #0]
}
 8000a4c:	bd08      	pop	{r3, pc}
 8000a4e:	bf00      	nop
 8000a50:	08000911 	.word	0x08000911
 8000a54:	20000078 	.word	0x20000078

08000a58 <Process_Sys_Notif>:
{
 8000a58:	b510      	push	{r4, lr}
  notif_ack_id = ComObj->MsgId;
 8000a5a:	6803      	ldr	r3, [r0, #0]
  switch (notif_ack_id)
 8000a5c:	2b03      	cmp	r3, #3
 8000a5e:	d009      	beq.n	8000a74 <Process_Sys_Notif+0x1c>
  APP_LOG(TS_ON, VLEVEL_H, "CM4>(System)\r\n");
 8000a60:	4b0a      	ldr	r3, [pc, #40]	@ (8000a8c <Process_Sys_Notif+0x34>)
 8000a62:	2201      	movs	r2, #1
 8000a64:	2100      	movs	r1, #0
 8000a66:	2003      	movs	r0, #3
 8000a68:	f004 ff7a 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  MBMUXIF_SystemSendAck(FEAT_INFO_SYSTEM_ID);
 8000a6c:	2000      	movs	r0, #0
 8000a6e:	f000 fda1 	bl	80015b4 <MBMUXIF_SystemSendAck>
}
 8000a72:	bd10      	pop	{r4, pc}
 8000a74:	4604      	mov	r4, r0
      APP_LOG(TS_ON, VLEVEL_H, "CM4<(System)\r\n");
 8000a76:	4b06      	ldr	r3, [pc, #24]	@ (8000a90 <Process_Sys_Notif+0x38>)
 8000a78:	2201      	movs	r2, #1
 8000a7a:	2100      	movs	r1, #0
 8000a7c:	2003      	movs	r0, #3
 8000a7e:	f004 ff6f 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
      ComObj->ParamCnt = 0;
 8000a82:	2300      	movs	r3, #0
 8000a84:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* dummy value  */
 8000a86:	6163      	str	r3, [r4, #20]
      break;
 8000a88:	e7ea      	b.n	8000a60 <Process_Sys_Notif+0x8>
 8000a8a:	bf00      	nop
 8000a8c:	08006540 	.word	0x08006540
 8000a90:	08006530 	.word	0x08006530

08000a94 <UTIL_SEQ_EvtIdle>:
{
 8000a94:	b508      	push	{r3, lr}
  UTIL_SEQ_Run(~TaskId_bm);
 8000a96:	43c0      	mvns	r0, r0
 8000a98:	f005 f8ee 	bl	8005c78 <UTIL_SEQ_Run>
}
 8000a9c:	bd08      	pop	{r3, pc}

08000a9e <UTIL_SEQ_Idle>:
{
 8000a9e:	b508      	push	{r3, lr}
  UTIL_LPM_EnterLowPower();
 8000aa0:	f005 f87c 	bl	8005b9c <UTIL_LPM_EnterLowPower>
}
 8000aa4:	bd08      	pop	{r3, pc}

08000aa6 <UTIL_ADV_TRACE_PreSendHook>:
{
 8000aa6:	b508      	push	{r3, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 8000aa8:	2101      	movs	r1, #1
 8000aaa:	2002      	movs	r0, #2
 8000aac:	f005 f84a 	bl	8005b44 <UTIL_LPM_SetStopMode>
}
 8000ab0:	bd08      	pop	{r3, pc}

08000ab2 <UTIL_ADV_TRACE_PostSendHook>:
{
 8000ab2:	b508      	push	{r3, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 8000ab4:	2100      	movs	r1, #0
 8000ab6:	2002      	movs	r0, #2
 8000ab8:	f005 f844 	bl	8005b44 <UTIL_LPM_SetStopMode>
}
 8000abc:	bd08      	pop	{r3, pc}
	...

08000ac0 <HAL_GetTick>:

/**
  * @note This function overwrites the __weak one from HAL
  */
uint32_t HAL_GetTick(void)
{
 8000ac0:	b508      	push	{r3, lr}
  uint32_t ret = 0;
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  if (SYS_TimerInitialisedFlag == 0)
 8000ac2:	4b04      	ldr	r3, [pc, #16]	@ (8000ad4 <HAL_GetTick+0x14>)
 8000ac4:	781b      	ldrb	r3, [r3, #0]
 8000ac6:	b90b      	cbnz	r3, 8000acc <HAL_GetTick+0xc>
  uint32_t ret = 0;
 8000ac8:	2000      	movs	r0, #0
  }
  /* USER CODE BEGIN HAL_GetTick_2 */

  /* USER CODE END HAL_GetTick_2 */
  return ret;
}
 8000aca:	bd08      	pop	{r3, pc}
    ret = TIMER_IF_GetTimerValue();
 8000acc:	f000 f838 	bl	8000b40 <TIMER_IF_GetTimerValue>
 8000ad0:	e7fb      	b.n	8000aca <HAL_GetTick+0xa>
 8000ad2:	bf00      	nop
 8000ad4:	20000078 	.word	0x20000078

08000ad8 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 8000ad8:	b500      	push	{lr}
 8000ada:	b083      	sub	sp, #12
 8000adc:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 8000ade:	9801      	ldr	r0, [sp, #4]
 8000ae0:	f000 f8f8 	bl	8000cd4 <TIMER_IF_DelayMs>
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 8000ae4:	b003      	add	sp, #12
 8000ae6:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000aec <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 8000aec:	4b06      	ldr	r3, [pc, #24]	@ (8000b08 <TIMER_IF_SetTimerContext+0x1c>)
 8000aee:	6898      	ldr	r0, [r3, #8]
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  uint32_t ssr = LL_RTC_TIME_GetSubSecond(RTC);
  /* read twice to make sure value it valid*/
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8000af0:	e001      	b.n	8000af6 <TIMER_IF_SetTimerContext+0xa>
 8000af2:	4b05      	ldr	r3, [pc, #20]	@ (8000b08 <TIMER_IF_SetTimerContext+0x1c>)
 8000af4:	6898      	ldr	r0, [r3, #8]
 8000af6:	4b04      	ldr	r3, [pc, #16]	@ (8000b08 <TIMER_IF_SetTimerContext+0x1c>)
 8000af8:	689b      	ldr	r3, [r3, #8]
 8000afa:	4283      	cmp	r3, r0
 8000afc:	d1f9      	bne.n	8000af2 <TIMER_IF_SetTimerContext+0x6>
  {
    ssr = LL_RTC_TIME_GetSubSecond(RTC);
  }
  return UINT32_MAX - ssr;
 8000afe:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 8000b00:	4b02      	ldr	r3, [pc, #8]	@ (8000b0c <TIMER_IF_SetTimerContext+0x20>)
 8000b02:	6018      	str	r0, [r3, #0]
}
 8000b04:	4770      	bx	lr
 8000b06:	bf00      	nop
 8000b08:	40002800 	.word	0x40002800
 8000b0c:	2000007c 	.word	0x2000007c

08000b10 <TIMER_IF_GetTimerContext>:
}
 8000b10:	4b01      	ldr	r3, [pc, #4]	@ (8000b18 <TIMER_IF_GetTimerContext+0x8>)
 8000b12:	6818      	ldr	r0, [r3, #0]
 8000b14:	4770      	bx	lr
 8000b16:	bf00      	nop
 8000b18:	2000007c 	.word	0x2000007c

08000b1c <TIMER_IF_GetTimerElapsedTime>:
 8000b1c:	4b06      	ldr	r3, [pc, #24]	@ (8000b38 <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8000b1e:	6898      	ldr	r0, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8000b20:	e001      	b.n	8000b26 <TIMER_IF_GetTimerElapsedTime+0xa>
 8000b22:	4b05      	ldr	r3, [pc, #20]	@ (8000b38 <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8000b24:	6898      	ldr	r0, [r3, #8]
 8000b26:	4b04      	ldr	r3, [pc, #16]	@ (8000b38 <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8000b28:	689b      	ldr	r3, [r3, #8]
 8000b2a:	4283      	cmp	r3, r0
 8000b2c:	d1f9      	bne.n	8000b22 <TIMER_IF_GetTimerElapsedTime+0x6>
  return UINT32_MAX - ssr;
 8000b2e:	43c0      	mvns	r0, r0
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 8000b30:	4b02      	ldr	r3, [pc, #8]	@ (8000b3c <TIMER_IF_GetTimerElapsedTime+0x20>)
 8000b32:	681b      	ldr	r3, [r3, #0]
}
 8000b34:	1ac0      	subs	r0, r0, r3
 8000b36:	4770      	bx	lr
 8000b38:	40002800 	.word	0x40002800
 8000b3c:	2000007c 	.word	0x2000007c

08000b40 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 8000b40:	4b07      	ldr	r3, [pc, #28]	@ (8000b60 <TIMER_IF_GetTimerValue+0x20>)
 8000b42:	781b      	ldrb	r3, [r3, #0]
 8000b44:	b153      	cbz	r3, 8000b5c <TIMER_IF_GetTimerValue+0x1c>
 8000b46:	4b07      	ldr	r3, [pc, #28]	@ (8000b64 <TIMER_IF_GetTimerValue+0x24>)
 8000b48:	6898      	ldr	r0, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8000b4a:	e001      	b.n	8000b50 <TIMER_IF_GetTimerValue+0x10>
 8000b4c:	4b05      	ldr	r3, [pc, #20]	@ (8000b64 <TIMER_IF_GetTimerValue+0x24>)
 8000b4e:	6898      	ldr	r0, [r3, #8]
 8000b50:	4b04      	ldr	r3, [pc, #16]	@ (8000b64 <TIMER_IF_GetTimerValue+0x24>)
 8000b52:	689b      	ldr	r3, [r3, #8]
 8000b54:	4283      	cmp	r3, r0
 8000b56:	d1f9      	bne.n	8000b4c <TIMER_IF_GetTimerValue+0xc>
  return UINT32_MAX - ssr;
 8000b58:	43c0      	mvns	r0, r0
 8000b5a:	4770      	bx	lr
  uint32_t ret = 0;
 8000b5c:	2000      	movs	r0, #0
}
 8000b5e:	4770      	bx	lr
 8000b60:	20000080 	.word	0x20000080
 8000b64:	40002800 	.word	0x40002800

08000b68 <TIMER_IF_GetMinimumTimeout>:
}
 8000b68:	2003      	movs	r0, #3
 8000b6a:	4770      	bx	lr

08000b6c <TIMER_IF_Convert_ms2Tick>:
{
 8000b6c:	b508      	push	{r3, lr}
 8000b6e:	4601      	mov	r1, r0
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 8000b70:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8000b74:	2300      	movs	r3, #0
 8000b76:	0280      	lsls	r0, r0, #10
 8000b78:	0d89      	lsrs	r1, r1, #22
 8000b7a:	f7ff fb05 	bl	8000188 <__aeabi_uldivmod>
}
 8000b7e:	bd08      	pop	{r3, pc}

08000b80 <TIMER_IF_Convert_Tick2ms>:
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8000b80:	0ec2      	lsrs	r2, r0, #27
 8000b82:	0143      	lsls	r3, r0, #5
 8000b84:	1a1b      	subs	r3, r3, r0
 8000b86:	f162 0200 	sbc.w	r2, r2, #0
 8000b8a:	0092      	lsls	r2, r2, #2
 8000b8c:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
 8000b90:	009b      	lsls	r3, r3, #2
 8000b92:	181b      	adds	r3, r3, r0
 8000b94:	f142 0000 	adc.w	r0, r2, #0
 8000b98:	00c0      	lsls	r0, r0, #3
 8000b9a:	ea40 7053 	orr.w	r0, r0, r3, lsr #29
 8000b9e:	f3c3 13d5 	ubfx	r3, r3, #7, #22
}
 8000ba2:	ea43 5080 	orr.w	r0, r3, r0, lsl #22
 8000ba6:	4770      	bx	lr

08000ba8 <TIMER_IF_Init>:
{
 8000ba8:	b508      	push	{r3, lr}
  hrtc.Instance = RTC;
 8000baa:	4807      	ldr	r0, [pc, #28]	@ (8000bc8 <TIMER_IF_Init+0x20>)
 8000bac:	4b07      	ldr	r3, [pc, #28]	@ (8000bcc <TIMER_IF_Init+0x24>)
 8000bae:	6003      	str	r3, [r0, #0]
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8000bb0:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8000bb4:	f003 fb16 	bl	80041e4 <HAL_RTC_DeactivateAlarm>
  TIMER_IF_SetTimerContext();
 8000bb8:	f7ff ff98 	bl	8000aec <TIMER_IF_SetTimerContext>
  RTC_Initialized = true;
 8000bbc:	4b04      	ldr	r3, [pc, #16]	@ (8000bd0 <TIMER_IF_Init+0x28>)
 8000bbe:	2201      	movs	r2, #1
 8000bc0:	701a      	strb	r2, [r3, #0]
}
 8000bc2:	2000      	movs	r0, #0
 8000bc4:	bd08      	pop	{r3, pc}
 8000bc6:	bf00      	nop
 8000bc8:	20000084 	.word	0x20000084
 8000bcc:	40002800 	.word	0x40002800
 8000bd0:	20000080 	.word	0x20000080

08000bd4 <TIMER_IF_StopTimer>:
{
 8000bd4:	b508      	push	{r3, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 8000bd6:	4b05      	ldr	r3, [pc, #20]	@ (8000bec <TIMER_IF_StopTimer+0x18>)
 8000bd8:	2201      	movs	r2, #1
 8000bda:	65da      	str	r2, [r3, #92]	@ 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8000bdc:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8000be0:	4803      	ldr	r0, [pc, #12]	@ (8000bf0 <TIMER_IF_StopTimer+0x1c>)
 8000be2:	f003 faff 	bl	80041e4 <HAL_RTC_DeactivateAlarm>
}
 8000be6:	2000      	movs	r0, #0
 8000be8:	bd08      	pop	{r3, pc}
 8000bea:	bf00      	nop
 8000bec:	40002800 	.word	0x40002800
 8000bf0:	20000084 	.word	0x20000084

08000bf4 <TIMER_IF_StartTimer>:
{
 8000bf4:	b510      	push	{r4, lr}
 8000bf6:	b08c      	sub	sp, #48	@ 0x30
 8000bf8:	4604      	mov	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 8000bfa:	222c      	movs	r2, #44	@ 0x2c
 8000bfc:	2100      	movs	r1, #0
 8000bfe:	a801      	add	r0, sp, #4
 8000c00:	f005 fb92 	bl	8006328 <memset>
  TIMER_IF_StopTimer();
 8000c04:	f7ff ffe6 	bl	8000bd4 <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 8000c08:	4b0c      	ldr	r3, [pc, #48]	@ (8000c3c <TIMER_IF_StartTimer+0x48>)
 8000c0a:	681b      	ldr	r3, [r3, #0]
 8000c0c:	441c      	add	r4, r3
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8000c0e:	2300      	movs	r3, #0
 8000c10:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 8000c12:	43e4      	mvns	r4, r4
 8000c14:	9402      	str	r4, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8000c16:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8000c18:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
 8000c1c:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
 8000c1e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000c22:	930b      	str	r3, [sp, #44]	@ 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8000c24:	2201      	movs	r2, #1
 8000c26:	a901      	add	r1, sp, #4
 8000c28:	4805      	ldr	r0, [pc, #20]	@ (8000c40 <TIMER_IF_StartTimer+0x4c>)
 8000c2a:	f003 fb27 	bl	800427c <HAL_RTC_SetAlarm_IT>
 8000c2e:	b910      	cbnz	r0, 8000c36 <TIMER_IF_StartTimer+0x42>
}
 8000c30:	2000      	movs	r0, #0
 8000c32:	b00c      	add	sp, #48	@ 0x30
 8000c34:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000c36:	f7ff fd9d 	bl	8000774 <Error_Handler>
 8000c3a:	e7f9      	b.n	8000c30 <TIMER_IF_StartTimer+0x3c>
 8000c3c:	2000007c 	.word	0x2000007c
 8000c40:	20000084 	.word	0x20000084

08000c44 <TIMER_IF_BkUp_Read_MSBticks>:
{
 8000c44:	b508      	push	{r3, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8000c46:	2102      	movs	r1, #2
 8000c48:	4801      	ldr	r0, [pc, #4]	@ (8000c50 <TIMER_IF_BkUp_Read_MSBticks+0xc>)
 8000c4a:	f003 fbda 	bl	8004402 <HAL_RTCEx_BKUPRead>
}
 8000c4e:	bd08      	pop	{r3, pc}
 8000c50:	20000084 	.word	0x20000084

08000c54 <TIMER_IF_GetTime>:
{
 8000c54:	b538      	push	{r3, r4, r5, lr}
 8000c56:	4605      	mov	r5, r0
 8000c58:	4b0b      	ldr	r3, [pc, #44]	@ (8000c88 <TIMER_IF_GetTime+0x34>)
 8000c5a:	689c      	ldr	r4, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8000c5c:	e001      	b.n	8000c62 <TIMER_IF_GetTime+0xe>
 8000c5e:	4b0a      	ldr	r3, [pc, #40]	@ (8000c88 <TIMER_IF_GetTime+0x34>)
 8000c60:	689c      	ldr	r4, [r3, #8]
 8000c62:	4a09      	ldr	r2, [pc, #36]	@ (8000c88 <TIMER_IF_GetTime+0x34>)
 8000c64:	6892      	ldr	r2, [r2, #8]
 8000c66:	42a2      	cmp	r2, r4
 8000c68:	d1f9      	bne.n	8000c5e <TIMER_IF_GetTime+0xa>
  return UINT32_MAX - ssr;
 8000c6a:	43e4      	mvns	r4, r4
  uint32_t timerValueMSB = TIMER_IF_BkUp_Read_MSBticks();
 8000c6c:	f7ff ffea 	bl	8000c44 <TIMER_IF_BkUp_Read_MSBticks>
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 8000c70:	4623      	mov	r3, r4
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 8000c72:	0aa4      	lsrs	r4, r4, #10
 8000c74:	ea44 5480 	orr.w	r4, r4, r0, lsl #22
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 8000c78:	f3c3 0009 	ubfx	r0, r3, #0, #10
 8000c7c:	f7ff ff80 	bl	8000b80 <TIMER_IF_Convert_Tick2ms>
 8000c80:	8028      	strh	r0, [r5, #0]
}
 8000c82:	4620      	mov	r0, r4
 8000c84:	bd38      	pop	{r3, r4, r5, pc}
 8000c86:	bf00      	nop
 8000c88:	40002800 	.word	0x40002800

08000c8c <TIMER_IF_BkUp_Read_Seconds>:
{
 8000c8c:	b508      	push	{r3, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 8000c8e:	2100      	movs	r1, #0
 8000c90:	4801      	ldr	r0, [pc, #4]	@ (8000c98 <TIMER_IF_BkUp_Read_Seconds+0xc>)
 8000c92:	f003 fbb6 	bl	8004402 <HAL_RTCEx_BKUPRead>
}
 8000c96:	bd08      	pop	{r3, pc}
 8000c98:	20000084 	.word	0x20000084

08000c9c <TIMER_IF_BkUp_Read_SubSeconds>:
{
 8000c9c:	b508      	push	{r3, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 8000c9e:	2101      	movs	r1, #1
 8000ca0:	4801      	ldr	r0, [pc, #4]	@ (8000ca8 <TIMER_IF_BkUp_Read_SubSeconds+0xc>)
 8000ca2:	f003 fbae 	bl	8004402 <HAL_RTCEx_BKUPRead>
}
 8000ca6:	bd08      	pop	{r3, pc}
 8000ca8:	20000084 	.word	0x20000084

08000cac <TIMER_IF_BkUp_Write_Seconds>:
{
 8000cac:	b508      	push	{r3, lr}
 8000cae:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 8000cb0:	2100      	movs	r1, #0
 8000cb2:	4802      	ldr	r0, [pc, #8]	@ (8000cbc <TIMER_IF_BkUp_Write_Seconds+0x10>)
 8000cb4:	f003 fb9e 	bl	80043f4 <HAL_RTCEx_BKUPWrite>
}
 8000cb8:	bd08      	pop	{r3, pc}
 8000cba:	bf00      	nop
 8000cbc:	20000084 	.word	0x20000084

08000cc0 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 8000cc0:	b508      	push	{r3, lr}
 8000cc2:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 8000cc4:	2101      	movs	r1, #1
 8000cc6:	4802      	ldr	r0, [pc, #8]	@ (8000cd0 <TIMER_IF_BkUp_Write_SubSeconds+0x10>)
 8000cc8:	f003 fb94 	bl	80043f4 <HAL_RTCEx_BKUPWrite>
}
 8000ccc:	bd08      	pop	{r3, pc}
 8000cce:	bf00      	nop
 8000cd0:	20000084 	.word	0x20000084

08000cd4 <TIMER_IF_DelayMs>:
{
 8000cd4:	b508      	push	{r3, lr}
  uint32_t delayTicks = TIMER_IF_Convert_ms2Tick(delay);
 8000cd6:	f7ff ff49 	bl	8000b6c <TIMER_IF_Convert_ms2Tick>
 8000cda:	4b0d      	ldr	r3, [pc, #52]	@ (8000d10 <TIMER_IF_DelayMs+0x3c>)
 8000cdc:	6899      	ldr	r1, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8000cde:	e001      	b.n	8000ce4 <TIMER_IF_DelayMs+0x10>
 8000ce0:	4b0b      	ldr	r3, [pc, #44]	@ (8000d10 <TIMER_IF_DelayMs+0x3c>)
 8000ce2:	6899      	ldr	r1, [r3, #8]
 8000ce4:	4a0a      	ldr	r2, [pc, #40]	@ (8000d10 <TIMER_IF_DelayMs+0x3c>)
 8000ce6:	6892      	ldr	r2, [r2, #8]
 8000ce8:	428a      	cmp	r2, r1
 8000cea:	d1f9      	bne.n	8000ce0 <TIMER_IF_DelayMs+0xc>
  return UINT32_MAX - ssr;
 8000cec:	43c9      	mvns	r1, r1
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8000cee:	e00a      	b.n	8000d06 <TIMER_IF_DelayMs+0x32>
 8000cf0:	4b07      	ldr	r3, [pc, #28]	@ (8000d10 <TIMER_IF_DelayMs+0x3c>)
 8000cf2:	689b      	ldr	r3, [r3, #8]
 8000cf4:	4a06      	ldr	r2, [pc, #24]	@ (8000d10 <TIMER_IF_DelayMs+0x3c>)
 8000cf6:	6892      	ldr	r2, [r2, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8000cf8:	429a      	cmp	r2, r3
 8000cfa:	d1f9      	bne.n	8000cf0 <TIMER_IF_DelayMs+0x1c>
  return UINT32_MAX - ssr;
 8000cfc:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8000cfe:	1a5b      	subs	r3, r3, r1
 8000d00:	4283      	cmp	r3, r0
 8000d02:	d203      	bcs.n	8000d0c <TIMER_IF_DelayMs+0x38>
    __NOP();
 8000d04:	bf00      	nop
 8000d06:	4b02      	ldr	r3, [pc, #8]	@ (8000d10 <TIMER_IF_DelayMs+0x3c>)
 8000d08:	689b      	ldr	r3, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8000d0a:	e7f3      	b.n	8000cf4 <TIMER_IF_DelayMs+0x20>
}
 8000d0c:	bd08      	pop	{r3, pc}
 8000d0e:	bf00      	nop
 8000d10:	40002800 	.word	0x40002800

08000d14 <MX_USART2_UART_Init>:
DMA_HandleTypeDef hdma_usart2_tx;

/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 8000d14:	b508      	push	{r3, lr}
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 8000d16:	4817      	ldr	r0, [pc, #92]	@ (8000d74 <MX_USART2_UART_Init+0x60>)
 8000d18:	4b17      	ldr	r3, [pc, #92]	@ (8000d78 <MX_USART2_UART_Init+0x64>)
 8000d1a:	6003      	str	r3, [r0, #0]
  huart2.Init.BaudRate = 115200;
 8000d1c:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
 8000d20:	6043      	str	r3, [r0, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8000d22:	2300      	movs	r3, #0
 8000d24:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8000d26:	60c3      	str	r3, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8000d28:	6103      	str	r3, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000d2a:	220c      	movs	r2, #12
 8000d2c:	6142      	str	r2, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000d2e:	6183      	str	r3, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000d30:	61c3      	str	r3, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000d32:	6203      	str	r3, [r0, #32]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8000d34:	6243      	str	r3, [r0, #36]	@ 0x24
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000d36:	6283      	str	r3, [r0, #40]	@ 0x28
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000d38:	f004 fb2e 	bl	8005398 <HAL_UART_Init>
 8000d3c:	b970      	cbnz	r0, 8000d5c <MX_USART2_UART_Init+0x48>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000d3e:	2100      	movs	r1, #0
 8000d40:	480c      	ldr	r0, [pc, #48]	@ (8000d74 <MX_USART2_UART_Init+0x60>)
 8000d42:	f004 fcde 	bl	8005702 <HAL_UARTEx_SetTxFifoThreshold>
 8000d46:	b960      	cbnz	r0, 8000d62 <MX_USART2_UART_Init+0x4e>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000d48:	2100      	movs	r1, #0
 8000d4a:	480a      	ldr	r0, [pc, #40]	@ (8000d74 <MX_USART2_UART_Init+0x60>)
 8000d4c:	f004 fcfe 	bl	800574c <HAL_UARTEx_SetRxFifoThreshold>
 8000d50:	b950      	cbnz	r0, 8000d68 <MX_USART2_UART_Init+0x54>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_EnableFifoMode(&huart2) != HAL_OK)
 8000d52:	4808      	ldr	r0, [pc, #32]	@ (8000d74 <MX_USART2_UART_Init+0x60>)
 8000d54:	f004 fcb1 	bl	80056ba <HAL_UARTEx_EnableFifoMode>
 8000d58:	b948      	cbnz	r0, 8000d6e <MX_USART2_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 8000d5a:	bd08      	pop	{r3, pc}
    Error_Handler();
 8000d5c:	f7ff fd0a 	bl	8000774 <Error_Handler>
 8000d60:	e7ed      	b.n	8000d3e <MX_USART2_UART_Init+0x2a>
    Error_Handler();
 8000d62:	f7ff fd07 	bl	8000774 <Error_Handler>
 8000d66:	e7ef      	b.n	8000d48 <MX_USART2_UART_Init+0x34>
    Error_Handler();
 8000d68:	f7ff fd04 	bl	8000774 <Error_Handler>
 8000d6c:	e7f1      	b.n	8000d52 <MX_USART2_UART_Init+0x3e>
    Error_Handler();
 8000d6e:	f7ff fd01 	bl	8000774 <Error_Handler>
}
 8000d72:	e7f2      	b.n	8000d5a <MX_USART2_UART_Init+0x46>
 8000d74:	2000011c 	.word	0x2000011c
 8000d78:	40004400 	.word	0x40004400

08000d7c <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8000d7c:	b530      	push	{r4, r5, lr}
 8000d7e:	b097      	sub	sp, #92	@ 0x5c
 8000d80:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000d82:	2100      	movs	r1, #0
 8000d84:	9111      	str	r1, [sp, #68]	@ 0x44
 8000d86:	9112      	str	r1, [sp, #72]	@ 0x48
 8000d88:	9113      	str	r1, [sp, #76]	@ 0x4c
 8000d8a:	9114      	str	r1, [sp, #80]	@ 0x50
 8000d8c:	9115      	str	r1, [sp, #84]	@ 0x54
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8000d8e:	2238      	movs	r2, #56	@ 0x38
 8000d90:	a803      	add	r0, sp, #12
 8000d92:	f005 fac9 	bl	8006328 <memset>
  if(uartHandle->Instance==USART2)
 8000d96:	6822      	ldr	r2, [r4, #0]
 8000d98:	4b2d      	ldr	r3, [pc, #180]	@ (8000e50 <HAL_UART_MspInit+0xd4>)
 8000d9a:	429a      	cmp	r2, r3
 8000d9c:	d001      	beq.n	8000da2 <HAL_UART_MspInit+0x26>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 8000d9e:	b017      	add	sp, #92	@ 0x5c
 8000da0:	bd30      	pop	{r4, r5, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8000da2:	2302      	movs	r3, #2
 8000da4:	9303      	str	r3, [sp, #12]
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
 8000da6:	4b2b      	ldr	r3, [pc, #172]	@ (8000e54 <HAL_UART_MspInit+0xd8>)
 8000da8:	9305      	str	r3, [sp, #20]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8000daa:	a803      	add	r0, sp, #12
 8000dac:	f003 f8f8 	bl	8003fa0 <HAL_RCCEx_PeriphCLKConfig>
 8000db0:	2800      	cmp	r0, #0
 8000db2:	d144      	bne.n	8000e3e <HAL_UART_MspInit+0xc2>
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 8000db4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000db8:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8000dba:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 8000dbe:	659a      	str	r2, [r3, #88]	@ 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8000dc0:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8000dc2:	f402 3200 	and.w	r2, r2, #131072	@ 0x20000
 8000dc6:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 8000dc8:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8000dca:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000dcc:	f042 0201 	orr.w	r2, r2, #1
 8000dd0:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000dd2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8000dd4:	f003 0301 	and.w	r3, r3, #1
 8000dd8:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000dda:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = USARTx_RX_Pin|USARTx_TX_Pin;
 8000ddc:	230c      	movs	r3, #12
 8000dde:	9311      	str	r3, [sp, #68]	@ 0x44
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000de0:	2302      	movs	r3, #2
 8000de2:	9312      	str	r3, [sp, #72]	@ 0x48
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000de4:	2500      	movs	r5, #0
 8000de6:	9513      	str	r5, [sp, #76]	@ 0x4c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000de8:	2303      	movs	r3, #3
 8000dea:	9314      	str	r3, [sp, #80]	@ 0x50
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8000dec:	2307      	movs	r3, #7
 8000dee:	9315      	str	r3, [sp, #84]	@ 0x54
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000df0:	a911      	add	r1, sp, #68	@ 0x44
 8000df2:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8000df6:	f001 ffed 	bl	8002dd4 <HAL_GPIO_Init>
    hdma_usart2_tx.Instance = DMA1_Channel5;
 8000dfa:	4817      	ldr	r0, [pc, #92]	@ (8000e58 <HAL_UART_MspInit+0xdc>)
 8000dfc:	4b17      	ldr	r3, [pc, #92]	@ (8000e5c <HAL_UART_MspInit+0xe0>)
 8000dfe:	6003      	str	r3, [r0, #0]
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8000e00:	2314      	movs	r3, #20
 8000e02:	6043      	str	r3, [r0, #4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8000e04:	2310      	movs	r3, #16
 8000e06:	6083      	str	r3, [r0, #8]
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000e08:	60c5      	str	r5, [r0, #12]
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8000e0a:	2380      	movs	r3, #128	@ 0x80
 8000e0c:	6103      	str	r3, [r0, #16]
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000e0e:	6145      	str	r5, [r0, #20]
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8000e10:	6185      	str	r5, [r0, #24]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 8000e12:	61c5      	str	r5, [r0, #28]
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 8000e14:	6205      	str	r5, [r0, #32]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8000e16:	f001 fa85 	bl	8002324 <HAL_DMA_Init>
 8000e1a:	b998      	cbnz	r0, 8000e44 <HAL_UART_MspInit+0xc8>
    if (HAL_DMA_ConfigChannelAttributes(&hdma_usart2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
 8000e1c:	2110      	movs	r1, #16
 8000e1e:	480e      	ldr	r0, [pc, #56]	@ (8000e58 <HAL_UART_MspInit+0xdc>)
 8000e20:	f001 fc82 	bl	8002728 <HAL_DMA_ConfigChannelAttributes>
 8000e24:	b988      	cbnz	r0, 8000e4a <HAL_UART_MspInit+0xce>
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 8000e26:	4b0c      	ldr	r3, [pc, #48]	@ (8000e58 <HAL_UART_MspInit+0xdc>)
 8000e28:	67e3      	str	r3, [r4, #124]	@ 0x7c
 8000e2a:	629c      	str	r4, [r3, #40]	@ 0x28
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 8000e2c:	2200      	movs	r2, #0
 8000e2e:	2102      	movs	r1, #2
 8000e30:	2025      	movs	r0, #37	@ 0x25
 8000e32:	f001 f9db 	bl	80021ec <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8000e36:	2025      	movs	r0, #37	@ 0x25
 8000e38:	f001 f9e8 	bl	800220c <HAL_NVIC_EnableIRQ>
}
 8000e3c:	e7af      	b.n	8000d9e <HAL_UART_MspInit+0x22>
      Error_Handler();
 8000e3e:	f7ff fc99 	bl	8000774 <Error_Handler>
 8000e42:	e7b7      	b.n	8000db4 <HAL_UART_MspInit+0x38>
      Error_Handler();
 8000e44:	f7ff fc96 	bl	8000774 <Error_Handler>
 8000e48:	e7e8      	b.n	8000e1c <HAL_UART_MspInit+0xa0>
      Error_Handler();
 8000e4a:	f7ff fc93 	bl	8000774 <Error_Handler>
 8000e4e:	e7ea      	b.n	8000e26 <HAL_UART_MspInit+0xaa>
 8000e50:	40004400 	.word	0x40004400
 8000e54:	000c0004 	.word	0x000c0004
 8000e58:	200000bc 	.word	0x200000bc
 8000e5c:	40020058 	.word	0x40020058

08000e60 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==USART2)
 8000e60:	6802      	ldr	r2, [r0, #0]
 8000e62:	4b0c      	ldr	r3, [pc, #48]	@ (8000e94 <HAL_UART_MspDeInit+0x34>)
 8000e64:	429a      	cmp	r2, r3
 8000e66:	d000      	beq.n	8000e6a <HAL_UART_MspDeInit+0xa>
 8000e68:	4770      	bx	lr
{
 8000e6a:	b510      	push	{r4, lr}
 8000e6c:	4604      	mov	r4, r0

  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 8000e6e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000e72:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8000e74:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
 8000e78:	6593      	str	r3, [r2, #88]	@ 0x58

    /**USART2 GPIO Configuration
    PA3     ------> USART2_RX
    PA2     ------> USART2_TX
    */
    HAL_GPIO_DeInit(GPIOA, USARTx_RX_Pin|USARTx_TX_Pin);
 8000e7a:	210c      	movs	r1, #12
 8000e7c:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8000e80:	f002 f87a 	bl	8002f78 <HAL_GPIO_DeInit>

    /* USART2 DMA DeInit */
    HAL_DMA_DeInit(uartHandle->hdmatx);
 8000e84:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 8000e86:	f001 fabf 	bl	8002408 <HAL_DMA_DeInit>

    /* USART2 interrupt Deinit */
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 8000e8a:	2025      	movs	r0, #37	@ 0x25
 8000e8c:	f001 f9c2 	bl	8002214 <HAL_NVIC_DisableIRQ>
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
}
 8000e90:	bd10      	pop	{r4, pc}
 8000e92:	bf00      	nop
 8000e94:	40004400 	.word	0x40004400

08000e98 <vcom_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

UTIL_ADV_TRACE_Status_t vcom_Init(void (*cb)(void *))
{
 8000e98:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Init_1 */

  /* USER CODE END vcom_Init_1 */
  TxCpltCallback = cb;
 8000e9a:	4b07      	ldr	r3, [pc, #28]	@ (8000eb8 <vcom_Init+0x20>)
 8000e9c:	6018      	str	r0, [r3, #0]
  MX_DMA_Init();
 8000e9e:	f7ff fb37 	bl	8000510 <MX_DMA_Init>
  MX_USART2_UART_Init();
 8000ea2:	f7ff ff37 	bl	8000d14 <MX_USART2_UART_Init>
  SET_BIT(EXTI->IMR1, ExtiLine);
 8000ea6:	4a05      	ldr	r2, [pc, #20]	@ (8000ebc <vcom_Init+0x24>)
 8000ea8:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
 8000eac:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8000eb0:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
  LL_EXTI_EnableIT_0_31(LL_EXTI_LINE_27);
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Init_2 */

  /* USER CODE END vcom_Init_2 */
}
 8000eb4:	2000      	movs	r0, #0
 8000eb6:	bd08      	pop	{r3, pc}
 8000eb8:	200001b4 	.word	0x200001b4
 8000ebc:	58000800 	.word	0x58000800

08000ec0 <vcom_DeInit>:

UTIL_ADV_TRACE_Status_t vcom_DeInit(void)
{
 8000ec0:	b508      	push	{r3, lr}

  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->APB1RSTR1, Periphs);
 8000ec2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000ec6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8000ec8:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 8000ecc:	639a      	str	r2, [r3, #56]	@ 0x38

  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 8000ece:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8000ed0:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 8000ed4:	639a      	str	r2, [r3, #56]	@ 0x38
  /* ##-1- Reset peripherals ################################################## */
  __HAL_RCC_USART2_FORCE_RESET();
  __HAL_RCC_USART2_RELEASE_RESET();

  /* ##-2- MspDeInit ################################################## */
  HAL_UART_MspDeInit(&huart2);
 8000ed6:	4804      	ldr	r0, [pc, #16]	@ (8000ee8 <vcom_DeInit+0x28>)
 8000ed8:	f7ff ffc2 	bl	8000e60 <HAL_UART_MspDeInit>

  /* ##-3- Disable the NVIC for DMA ########################################### */
  /* USER CODE BEGIN 1 */
  HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 8000edc:	200f      	movs	r0, #15
 8000ede:	f001 f999 	bl	8002214 <HAL_NVIC_DisableIRQ>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE END 1 */
  /* USER CODE BEGIN vcom_DeInit_2 */

  /* USER CODE END vcom_DeInit_2 */
}
 8000ee2:	2000      	movs	r0, #0
 8000ee4:	bd08      	pop	{r3, pc}
 8000ee6:	bf00      	nop
 8000ee8:	2000011c 	.word	0x2000011c

08000eec <vcom_Trace_DMA>:

  /* USER CODE END vcom_Trace_2 */
}

UTIL_ADV_TRACE_Status_t vcom_Trace_DMA(uint8_t *p_data, uint16_t size)
{
 8000eec:	b508      	push	{r3, lr}
 8000eee:	460a      	mov	r2, r1
  /* USER CODE BEGIN vcom_Trace_DMA_1 */

  /* USER CODE END vcom_Trace_DMA_1 */
  HAL_UART_Transmit_DMA(&huart2, p_data, size);
 8000ef0:	4601      	mov	r1, r0
 8000ef2:	4802      	ldr	r0, [pc, #8]	@ (8000efc <vcom_Trace_DMA+0x10>)
 8000ef4:	f003 fad0 	bl	8004498 <HAL_UART_Transmit_DMA>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Trace_DMA_2 */

  /* USER CODE END vcom_Trace_DMA_2 */
}
 8000ef8:	2000      	movs	r0, #0
 8000efa:	bd08      	pop	{r3, pc}
 8000efc:	2000011c 	.word	0x2000011c

08000f00 <vcom_ReceiveInit>:

UTIL_ADV_TRACE_Status_t vcom_ReceiveInit(void (*RxCb)(uint8_t *rxChar, uint16_t size, uint8_t error))
{
 8000f00:	b510      	push	{r4, lr}
 8000f02:	b082      	sub	sp, #8

  /* USER CODE END vcom_ReceiveInit_1 */
  UART_WakeUpTypeDef WakeUpSelection;

  /*record call back*/
  RxCpltCallback = RxCb;
 8000f04:	4b12      	ldr	r3, [pc, #72]	@ (8000f50 <vcom_ReceiveInit+0x50>)
 8000f06:	6018      	str	r0, [r3, #0]

  /*Set wakeUp event on start bit*/
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;
 8000f08:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8000f0c:	9300      	str	r3, [sp, #0]

  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 8000f0e:	ab02      	add	r3, sp, #8
 8000f10:	e913 0006 	ldmdb	r3, {r1, r2}
 8000f14:	480f      	ldr	r0, [pc, #60]	@ (8000f54 <vcom_ReceiveInit+0x54>)
 8000f16:	f004 fb78 	bl	800560a <HAL_UARTEx_StopModeWakeUpSourceConfig>

  /* Make sure that no UART transfer is on-going */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_BUSY) == SET);
 8000f1a:	4b0e      	ldr	r3, [pc, #56]	@ (8000f54 <vcom_ReceiveInit+0x54>)
 8000f1c:	681b      	ldr	r3, [r3, #0]
 8000f1e:	69da      	ldr	r2, [r3, #28]
 8000f20:	f412 3f80 	tst.w	r2, #65536	@ 0x10000
 8000f24:	d1f9      	bne.n	8000f1a <vcom_ReceiveInit+0x1a>

  /* Make sure that UART is ready to receive)   */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_REACK) == RESET);
 8000f26:	69da      	ldr	r2, [r3, #28]
 8000f28:	f412 0f80 	tst.w	r2, #4194304	@ 0x400000
 8000f2c:	d0fb      	beq.n	8000f26 <vcom_ReceiveInit+0x26>

  /* Enable USART interrupt */
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 8000f2e:	689a      	ldr	r2, [r3, #8]
 8000f30:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8000f34:	609a      	str	r2, [r3, #8]

  /*Enable wakeup from stop mode*/
  HAL_UARTEx_EnableStopMode(&huart2);
 8000f36:	4c07      	ldr	r4, [pc, #28]	@ (8000f54 <vcom_ReceiveInit+0x54>)
 8000f38:	4620      	mov	r0, r4
 8000f3a:	f004 fba7 	bl	800568c <HAL_UARTEx_EnableStopMode>

  /*Start LPUART receive on IT*/
  HAL_UART_Receive_IT(&huart2, &charRx, 1);
 8000f3e:	2201      	movs	r2, #1
 8000f40:	4905      	ldr	r1, [pc, #20]	@ (8000f58 <vcom_ReceiveInit+0x58>)
 8000f42:	4620      	mov	r0, r4
 8000f44:	f004 fafa 	bl	800553c <HAL_UART_Receive_IT>

  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_ReceiveInit_2 */

  /* USER CODE END vcom_ReceiveInit_2 */
}
 8000f48:	2000      	movs	r0, #0
 8000f4a:	b002      	add	sp, #8
 8000f4c:	bd10      	pop	{r4, pc}
 8000f4e:	bf00      	nop
 8000f50:	200001b0 	.word	0x200001b0
 8000f54:	2000011c 	.word	0x2000011c
 8000f58:	200001b8 	.word	0x200001b8

08000f5c <vcom_Resume>:

void vcom_Resume(void)
{
 8000f5c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Resume_1 */

  /* USER CODE END vcom_Resume_1 */
  /*to re-enable lost UART settings*/
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000f5e:	4807      	ldr	r0, [pc, #28]	@ (8000f7c <vcom_Resume+0x20>)
 8000f60:	f004 fa1a 	bl	8005398 <HAL_UART_Init>
 8000f64:	b920      	cbnz	r0, 8000f70 <vcom_Resume+0x14>
  {
    Error_Handler();
  }

  /*to re-enable lost DMA settings*/
  if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8000f66:	4806      	ldr	r0, [pc, #24]	@ (8000f80 <vcom_Resume+0x24>)
 8000f68:	f001 f9dc 	bl	8002324 <HAL_DMA_Init>
 8000f6c:	b918      	cbnz	r0, 8000f76 <vcom_Resume+0x1a>
    Error_Handler();
  }
  /* USER CODE BEGIN vcom_Resume_2 */

  /* USER CODE END vcom_Resume_2 */
}
 8000f6e:	bd08      	pop	{r3, pc}
    Error_Handler();
 8000f70:	f7ff fc00 	bl	8000774 <Error_Handler>
 8000f74:	e7f7      	b.n	8000f66 <vcom_Resume+0xa>
    Error_Handler();
 8000f76:	f7ff fbfd 	bl	8000774 <Error_Handler>
}
 8000f7a:	e7f8      	b.n	8000f6e <vcom_Resume+0x12>
 8000f7c:	2000011c 	.word	0x2000011c
 8000f80:	200000bc 	.word	0x200000bc

08000f84 <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8000f84:	b508      	push	{r3, lr}
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_1 */

  /* USER CODE END HAL_UART_TxCpltCallback_1 */
  /* buffer transmission complete*/
  if (huart->Instance == USART2)
 8000f86:	6802      	ldr	r2, [r0, #0]
 8000f88:	4b04      	ldr	r3, [pc, #16]	@ (8000f9c <HAL_UART_TxCpltCallback+0x18>)
 8000f8a:	429a      	cmp	r2, r3
 8000f8c:	d000      	beq.n	8000f90 <HAL_UART_TxCpltCallback+0xc>
    TxCpltCallback(NULL);
  }
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_2 */

  /* USER CODE END HAL_UART_TxCpltCallback_2 */
}
 8000f8e:	bd08      	pop	{r3, pc}
    TxCpltCallback(NULL);
 8000f90:	4b03      	ldr	r3, [pc, #12]	@ (8000fa0 <HAL_UART_TxCpltCallback+0x1c>)
 8000f92:	681b      	ldr	r3, [r3, #0]
 8000f94:	2000      	movs	r0, #0
 8000f96:	4798      	blx	r3
}
 8000f98:	e7f9      	b.n	8000f8e <HAL_UART_TxCpltCallback+0xa>
 8000f9a:	bf00      	nop
 8000f9c:	40004400 	.word	0x40004400
 8000fa0:	200001b4 	.word	0x200001b4

08000fa4 <HAL_UART_RxCpltCallback>:
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_1 */

  /* USER CODE END HAL_UART_RxCpltCallback_1 */
  if (huart->Instance == USART2)
 8000fa4:	6802      	ldr	r2, [r0, #0]
 8000fa6:	4b0a      	ldr	r3, [pc, #40]	@ (8000fd0 <HAL_UART_RxCpltCallback+0x2c>)
 8000fa8:	429a      	cmp	r2, r3
 8000faa:	d000      	beq.n	8000fae <HAL_UART_RxCpltCallback+0xa>
 8000fac:	4770      	bx	lr
{
 8000fae:	b510      	push	{r4, lr}
 8000fb0:	4604      	mov	r4, r0
  {
    if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart->ErrorCode))
 8000fb2:	4b08      	ldr	r3, [pc, #32]	@ (8000fd4 <HAL_UART_RxCpltCallback+0x30>)
 8000fb4:	681b      	ldr	r3, [r3, #0]
 8000fb6:	b12b      	cbz	r3, 8000fc4 <HAL_UART_RxCpltCallback+0x20>
 8000fb8:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
 8000fbc:	b912      	cbnz	r2, 8000fc4 <HAL_UART_RxCpltCallback+0x20>
    {
      RxCpltCallback(&charRx, 1, 0);
 8000fbe:	2101      	movs	r1, #1
 8000fc0:	4805      	ldr	r0, [pc, #20]	@ (8000fd8 <HAL_UART_RxCpltCallback+0x34>)
 8000fc2:	4798      	blx	r3
    }
    HAL_UART_Receive_IT(huart, &charRx, 1);
 8000fc4:	2201      	movs	r2, #1
 8000fc6:	4904      	ldr	r1, [pc, #16]	@ (8000fd8 <HAL_UART_RxCpltCallback+0x34>)
 8000fc8:	4620      	mov	r0, r4
 8000fca:	f004 fab7 	bl	800553c <HAL_UART_Receive_IT>
  }
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_2 */

  /* USER CODE END HAL_UART_RxCpltCallback_2 */
}
 8000fce:	bd10      	pop	{r4, pc}
 8000fd0:	40004400 	.word	0x40004400
 8000fd4:	200001b0 	.word	0x200001b0
 8000fd8:	200001b8 	.word	0x200001b8

08000fdc <MBMUX_CheckIfFeatureSupportedByCm0plus>:

/* USER CODE END EFD */

/* Private functions ---------------------------------------------------------*/
static uint8_t MBMUX_CheckIfFeatureSupportedByCm0plus(FEAT_INFO_IdTypeDef e_featID)
{
 8000fdc:	b570      	push	{r4, r5, r6, lr}
 8000fde:	b084      	sub	sp, #16
  FEAT_INFO_Param_t  i_feature;
  /* USER CODE BEGIN MBMUX_CheckIfFeatureSupportedByCm0plus_1 */

  /* USER CODE END MBMUX_CheckIfFeatureSupportedByCm0plus_1 */

  if (p_MBMUX_Cm0plusFeatureList != NULL)
 8000fe0:	4b0f      	ldr	r3, [pc, #60]	@ (8001020 <MBMUX_CheckIfFeatureSupportedByCm0plus+0x44>)
 8000fe2:	681c      	ldr	r4, [r3, #0]
 8000fe4:	b1c4      	cbz	r4, 8001018 <MBMUX_CheckIfFeatureSupportedByCm0plus+0x3c>
 8000fe6:	4686      	mov	lr, r0
  {
    cm0plus_nr_of_supported_features = p_MBMUX_Cm0plusFeatureList->Feat_Info_Cnt;
 8000fe8:	7825      	ldrb	r5, [r4, #0]

    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 8000fea:	f04f 0c00 	mov.w	ip, #0
 8000fee:	45ac      	cmp	ip, r5
 8000ff0:	d20f      	bcs.n	8001012 <MBMUX_CheckIfFeatureSupportedByCm0plus+0x36>
    {
      i_feature = *(i + p_MBMUX_Cm0plusFeatureList->Feat_Info_TableAddress);
 8000ff2:	6863      	ldr	r3, [r4, #4]
 8000ff4:	eb03 130c 	add.w	r3, r3, ip, lsl #4
 8000ff8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000ffa:	ae04      	add	r6, sp, #16
 8000ffc:	e906 000f 	stmdb	r6, {r0, r1, r2, r3}
      if (i_feature.Feat_Info_Feature_Id == e_featID)
 8001000:	f89d 3000 	ldrb.w	r3, [sp]
 8001004:	4573      	cmp	r3, lr
 8001006:	d009      	beq.n	800101c <MBMUX_CheckIfFeatureSupportedByCm0plus+0x40>
    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 8001008:	f10c 0c01 	add.w	ip, ip, #1
 800100c:	fa5f fc8c 	uxtb.w	ip, ip
 8001010:	e7ed      	b.n	8000fee <MBMUX_CheckIfFeatureSupportedByCm0plus+0x12>
  int8_t ret = 0;
 8001012:	2000      	movs	r0, #0
  }
  /* USER CODE BEGIN MBMUX_CheckIfFeatureSupportedByCm0plus_Last */

  /* USER CODE END MBMUX_CheckIfFeatureSupportedByCm0plus_Last */
  return ret;
}
 8001014:	b004      	add	sp, #16
 8001016:	bd70      	pop	{r4, r5, r6, pc}
  int8_t ret = 0;
 8001018:	2000      	movs	r0, #0
 800101a:	e7fb      	b.n	8001014 <MBMUX_CheckIfFeatureSupportedByCm0plus+0x38>
        ret = 1;
 800101c:	2001      	movs	r0, #1
 800101e:	e7f9      	b.n	8001014 <MBMUX_CheckIfFeatureSupportedByCm0plus+0x38>
 8001020:	200001bc 	.word	0x200001bc

08001024 <MBMUX_IsrResponseRcvCb>:

static void MBMUX_IsrResponseRcvCb(uint32_t channelIdx)
{
 8001024:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MBMUX_IsrResponseRcvCb_1 */

  /* USER CODE END MBMUX_IsrResponseRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBCmdRespParam[channelIdx];
 8001026:	4b05      	ldr	r3, [pc, #20]	@ (800103c <MBMUX_IsrResponseRcvCb+0x18>)
 8001028:	681a      	ldr	r2, [r3, #0]
 800102a:	eb00 0140 	add.w	r1, r0, r0, lsl #1
  /* call registered callback */
  p_MBMUX_ComTable->MBCmdRespParam[channelIdx].MsgCm4Cb(com_obj);
 800102e:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
 8001032:	685b      	ldr	r3, [r3, #4]
 8001034:	eb02 00c1 	add.w	r0, r2, r1, lsl #3
 8001038:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrResponseRcvCb_Last */

  /* USER CODE END MBMUX_IsrResponseRcvCb_Last */
  return;
}
 800103a:	bd08      	pop	{r3, pc}
 800103c:	200001c0 	.word	0x200001c0

08001040 <MBMUX_IsrNotificationRcvCb>:

static void MBMUX_IsrNotificationRcvCb(uint32_t channelIdx)
{
 8001040:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MBMUX_IsrNotificationRcvCb_1 */

  /* USER CODE END MBMUX_IsrNotificationRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBNotifAckParam[channelIdx];
 8001042:	4b07      	ldr	r3, [pc, #28]	@ (8001060 <MBMUX_IsrNotificationRcvCb+0x20>)
 8001044:	6819      	ldr	r1, [r3, #0]
 8001046:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 800104a:	00d2      	lsls	r2, r2, #3
 800104c:	3290      	adds	r2, #144	@ 0x90
  /* call registered callback */
  p_MBMUX_ComTable->MBNotifAckParam[channelIdx].MsgCm4Cb(com_obj);
 800104e:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 8001052:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8001056:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800105a:	1888      	adds	r0, r1, r2
 800105c:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrNotificationRcvCb_Last */

  /* USER CODE END MBMUX_IsrNotificationRcvCb_Last */
  return;
}
 800105e:	bd08      	pop	{r3, pc}
 8001060:	200001c0 	.word	0x200001c0

08001064 <MBMUX_FindChStillUnregistered>:
  uint8_t feat_id;
  uint8_t ch;
  uint8_t already_used;

  /* First two channels are reserved to SYSTEM, TRACE and SKS */
  if (ComType == MBMUX_CMD_RESP)
 8001064:	b398      	cbz	r0, 80010ce <MBMUX_FindChStillUnregistered+0x6a>
      }
    }
  }
  else  /* RX */
  {
    for (ch = 1; ch < MBMUX_CHANNEL_NUMBER; ch++)
 8001066:	2001      	movs	r0, #1
 8001068:	e026      	b.n	80010b8 <MBMUX_FindChStillUnregistered+0x54>
      for (feat_id = 0; feat_id < FEAT_INFO_CNT; feat_id++)
 800106a:	3301      	adds	r3, #1
 800106c:	b2db      	uxtb	r3, r3
 800106e:	2b0a      	cmp	r3, #10
 8001070:	d809      	bhi.n	8001086 <MBMUX_FindChStillUnregistered+0x22>
        if (p_MBMUX_ComTable->MBMUXMapping[feat_id][MBMUX_CMD_RESP] == ch)
 8001072:	4a1c      	ldr	r2, [pc, #112]	@ (80010e4 <MBMUX_FindChStillUnregistered+0x80>)
 8001074:	6812      	ldr	r2, [r2, #0]
 8001076:	f103 0190 	add.w	r1, r3, #144	@ 0x90
 800107a:	f812 2011 	ldrb.w	r2, [r2, r1, lsl #1]
 800107e:	4282      	cmp	r2, r0
 8001080:	d1f3      	bne.n	800106a <MBMUX_FindChStillUnregistered+0x6>
          already_used = 1;
 8001082:	2401      	movs	r4, #1
 8001084:	e7f1      	b.n	800106a <MBMUX_FindChStillUnregistered+0x6>
      if (already_used == 0)
 8001086:	b1e4      	cbz	r4, 80010c2 <MBMUX_FindChStillUnregistered+0x5e>
    for (ch = 1; ch < MBMUX_CHANNEL_NUMBER; ch++)
 8001088:	3001      	adds	r0, #1
 800108a:	b2c0      	uxtb	r0, r0
 800108c:	2805      	cmp	r0, #5
 800108e:	d818      	bhi.n	80010c2 <MBMUX_FindChStillUnregistered+0x5e>
      already_used = 0;
 8001090:	4664      	mov	r4, ip
      for (feat_id = 0; feat_id < FEAT_INFO_CNT; feat_id++)
 8001092:	4663      	mov	r3, ip
 8001094:	e7eb      	b.n	800106e <MBMUX_FindChStillUnregistered+0xa>
    {
      already_used = 0;
      for (feat_id = 0; feat_id < FEAT_INFO_CNT; feat_id++)
 8001096:	3301      	adds	r3, #1
 8001098:	b2db      	uxtb	r3, r3
 800109a:	2b0a      	cmp	r3, #10
 800109c:	d809      	bhi.n	80010b2 <MBMUX_FindChStillUnregistered+0x4e>
      {
        if (p_MBMUX_ComTable->MBMUXMapping[feat_id][MBMUX_NOTIF_ACK] == ch)
 800109e:	4a11      	ldr	r2, [pc, #68]	@ (80010e4 <MBMUX_FindChStillUnregistered+0x80>)
 80010a0:	6812      	ldr	r2, [r2, #0]
 80010a2:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 80010a6:	f892 2121 	ldrb.w	r2, [r2, #289]	@ 0x121
 80010aa:	4282      	cmp	r2, r0
 80010ac:	d1f3      	bne.n	8001096 <MBMUX_FindChStillUnregistered+0x32>
        {
          already_used = 1;
 80010ae:	2101      	movs	r1, #1
 80010b0:	e7f1      	b.n	8001096 <MBMUX_FindChStillUnregistered+0x32>
        }
      }
      if (already_used == 0)
 80010b2:	b191      	cbz	r1, 80010da <MBMUX_FindChStillUnregistered+0x76>
    for (ch = 1; ch < MBMUX_CHANNEL_NUMBER; ch++)
 80010b4:	3001      	adds	r0, #1
 80010b6:	b2c0      	uxtb	r0, r0
 80010b8:	2805      	cmp	r0, #5
 80010ba:	d80e      	bhi.n	80010da <MBMUX_FindChStillUnregistered+0x76>
      already_used = 0;
 80010bc:	2100      	movs	r1, #0
      for (feat_id = 0; feat_id < FEAT_INFO_CNT; feat_id++)
 80010be:	460b      	mov	r3, r1
 80010c0:	e7eb      	b.n	800109a <MBMUX_FindChStillUnregistered+0x36>
        break;
      }
    }
  }

  if (ch == MBMUX_CHANNEL_NUMBER)
 80010c2:	2806      	cmp	r0, #6
 80010c4:	d001      	beq.n	80010ca <MBMUX_FindChStillUnregistered+0x66>
    return (ch);
  }
  /* USER CODE BEGIN MBMUX_FindChStillUnregistered_Last */

  /* USER CODE END MBMUX_FindChStillUnregistered_Last */
}
 80010c6:	bc10      	pop	{r4}
 80010c8:	4770      	bx	lr
    return MB_CHANNEL_NOT_REGISTERED;
 80010ca:	20ff      	movs	r0, #255	@ 0xff
 80010cc:	e7fb      	b.n	80010c6 <MBMUX_FindChStillUnregistered+0x62>
 80010ce:	4684      	mov	ip, r0
    for (ch = 1; ch < MBMUX_CHANNEL_NUMBER; ch++)
 80010d0:	2001      	movs	r0, #1
 80010d2:	2805      	cmp	r0, #5
 80010d4:	d801      	bhi.n	80010da <MBMUX_FindChStillUnregistered+0x76>
{
 80010d6:	b410      	push	{r4}
 80010d8:	e7da      	b.n	8001090 <MBMUX_FindChStillUnregistered+0x2c>
  if (ch == MBMUX_CHANNEL_NUMBER)
 80010da:	2806      	cmp	r0, #6
 80010dc:	d000      	beq.n	80010e0 <MBMUX_FindChStillUnregistered+0x7c>
}
 80010de:	4770      	bx	lr
    return MB_CHANNEL_NOT_REGISTERED;
 80010e0:	20ff      	movs	r0, #255	@ 0xff
 80010e2:	4770      	bx	lr
 80010e4:	200001c0 	.word	0x200001c0

080010e8 <MBMUX_GetFeatureChIdx>:
static uint8_t MBMUX_GetFeatureChIdx(FEAT_INFO_IdTypeDef e_featID, MBMUX_ComType_t ComType)
{
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_1 */

  /* USER CODE END MBMUX_GetFeatureChIdx_1 */
  return p_MBMUX_ComTable->MBMUXMapping[e_featID][ComType];
 80010e8:	4b03      	ldr	r3, [pc, #12]	@ (80010f8 <MBMUX_GetFeatureChIdx+0x10>)
 80010ea:	681b      	ldr	r3, [r3, #0]
 80010ec:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80010f0:	440b      	add	r3, r1
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_Last */

  /* USER CODE END MBMUX_GetFeatureChIdx_Last */
}
 80010f2:	f893 0120 	ldrb.w	r0, [r3, #288]	@ 0x120
 80010f6:	4770      	bx	lr
 80010f8:	200001c0 	.word	0x200001c0

080010fc <MBMUX_IsrNotRegistered>:

static void MBMUX_IsrNotRegistered(void *ComObj)
{
 80010fc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_1 */

  /* USER CODE END MBMUX_IsrNotRegistered_1 */
  Error_Handler();
 80010fe:	f7ff fb39 	bl	8000774 <Error_Handler>
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_Last */

  /* USER CODE END MBMUX_IsrNotRegistered_Last */
}
 8001102:	bd08      	pop	{r3, pc}

08001104 <MBMUX_Init>:
{
 8001104:	b510      	push	{r4, lr}
 8001106:	4604      	mov	r4, r0
  IPCC_IF_Init(MBMUX_IsrResponseRcvCb, MBMUX_IsrNotificationRcvCb);
 8001108:	4919      	ldr	r1, [pc, #100]	@ (8001170 <MBMUX_Init+0x6c>)
 800110a:	481a      	ldr	r0, [pc, #104]	@ (8001174 <MBMUX_Init+0x70>)
 800110c:	f7ff fae2 	bl	80006d4 <IPCC_IF_Init>
  p_MBMUX_ComTable = pMBMUX_ComTable;
 8001110:	4b19      	ldr	r3, [pc, #100]	@ (8001178 <MBMUX_Init+0x74>)
 8001112:	601c      	str	r4, [r3, #0]
  for (i = 0; i < FEAT_INFO_CNT; i++)
 8001114:	2300      	movs	r3, #0
 8001116:	e00a      	b.n	800112e <MBMUX_Init+0x2a>
    p_MBMUX_ComTable->MBMUXMapping[i][MBMUX_CMD_RESP] = MB_CHANNEL_NOT_REGISTERED;
 8001118:	f103 0190 	add.w	r1, r3, #144	@ 0x90
 800111c:	22ff      	movs	r2, #255	@ 0xff
 800111e:	f804 2011 	strb.w	r2, [r4, r1, lsl #1]
    p_MBMUX_ComTable->MBMUXMapping[i][MBMUX_NOTIF_ACK] = MB_CHANNEL_NOT_REGISTERED;
 8001122:	eb04 0143 	add.w	r1, r4, r3, lsl #1
 8001126:	f881 2121 	strb.w	r2, [r1, #289]	@ 0x121
  for (i = 0; i < FEAT_INFO_CNT; i++)
 800112a:	3301      	adds	r3, #1
 800112c:	b2db      	uxtb	r3, r3
 800112e:	2b0a      	cmp	r3, #10
 8001130:	d9f2      	bls.n	8001118 <MBMUX_Init+0x14>
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 8001132:	2200      	movs	r2, #0
 8001134:	2a05      	cmp	r2, #5
 8001136:	d819      	bhi.n	800116c <MBMUX_Init+0x68>
    p_MBMUX_ComTable->MBCmdRespParam[i].MsgId = 0;
 8001138:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 800113c:	00d8      	lsls	r0, r3, #3
 800113e:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8001142:	2100      	movs	r1, #0
 8001144:	5021      	str	r1, [r4, r0]
    p_MBMUX_ComTable->MBCmdRespParam[i].MsgCm4Cb = MBMUX_IsrNotRegistered;
 8001146:	480d      	ldr	r0, [pc, #52]	@ (800117c <MBMUX_Init+0x78>)
 8001148:	6058      	str	r0, [r3, #4]
    p_MBMUX_ComTable->MBCmdRespParam[i].ParamCnt = 0;
 800114a:	81d9      	strh	r1, [r3, #14]
    p_MBMUX_ComTable->MBCmdRespParam[i].ParamBuf = NULL;
 800114c:	6119      	str	r1, [r3, #16]
    p_MBMUX_ComTable->MBNotifAckParam[i].MsgId = 0;
 800114e:	f8c3 1090 	str.w	r1, [r3, #144]	@ 0x90
    p_MBMUX_ComTable->MBNotifAckParam[i].MsgCm4Cb = MBMUX_IsrNotRegistered;
 8001152:	f8c3 0094 	str.w	r0, [r3, #148]	@ 0x94
    p_MBMUX_ComTable->MBNotifAckParam[i].ParamCnt = 0;
 8001156:	f8a3 109e 	strh.w	r1, [r3, #158]	@ 0x9e
    p_MBMUX_ComTable->MBNotifAckParam[i].ParamBuf = NULL;
 800115a:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 800115e:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8001162:	f8c3 10a0 	str.w	r1, [r3, #160]	@ 0xa0
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 8001166:	3201      	adds	r2, #1
 8001168:	b2d2      	uxtb	r2, r2
 800116a:	e7e3      	b.n	8001134 <MBMUX_Init+0x30>
}
 800116c:	bd10      	pop	{r4, pc}
 800116e:	bf00      	nop
 8001170:	08001041 	.word	0x08001041
 8001174:	08001025 	.word	0x08001025
 8001178:	200001c0 	.word	0x200001c0
 800117c:	080010fd 	.word	0x080010fd

08001180 <MBMUX_SetCm0plusFeatureListPtr>:
  p_MBMUX_Cm0plusFeatureList = pCM0PLUS_FeatureList;
 8001180:	4b01      	ldr	r3, [pc, #4]	@ (8001188 <MBMUX_SetCm0plusFeatureListPtr+0x8>)
 8001182:	6018      	str	r0, [r3, #0]
}
 8001184:	4770      	bx	lr
 8001186:	bf00      	nop
 8001188:	200001bc 	.word	0x200001bc

0800118c <MBMUX_RegisterFeature>:
{
 800118c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001190:	460d      	mov	r5, r1
 8001192:	4617      	mov	r7, r2
 8001194:	461e      	mov	r6, r3
 8001196:	f8bd 8018 	ldrh.w	r8, [sp, #24]
  if (e_featID == FEAT_INFO_SYSTEM_ID)
 800119a:	4604      	mov	r4, r0
 800119c:	b120      	cbz	r0, 80011a8 <MBMUX_RegisterFeature+0x1c>
    check_if_feature_provided_by_cm0plus = MBMUX_CheckIfFeatureSupportedByCm0plus(e_featID);
 800119e:	f7ff ff1d 	bl	8000fdc <MBMUX_CheckIfFeatureSupportedByCm0plus>
 80011a2:	b240      	sxtb	r0, r0
  if (check_if_feature_provided_by_cm0plus == 1)
 80011a4:	2801      	cmp	r0, #1
 80011a6:	d13f      	bne.n	8001228 <MBMUX_RegisterFeature+0x9c>
    check_existing_feature_registration = MBMUX_GetFeatureChIdx(e_featID, ComType);
 80011a8:	4629      	mov	r1, r5
 80011aa:	4620      	mov	r0, r4
 80011ac:	f7ff ff9c 	bl	80010e8 <MBMUX_GetFeatureChIdx>
    if (check_existing_feature_registration == MB_CHANNEL_NOT_REGISTERED)
 80011b0:	28ff      	cmp	r0, #255	@ 0xff
 80011b2:	d016      	beq.n	80011e2 <MBMUX_RegisterFeature+0x56>
    if (ComType == MBMUX_CMD_RESP)
 80011b4:	bb05      	cbnz	r5, 80011f8 <MBMUX_RegisterFeature+0x6c>
      p_MBMUX_ComTable->MBMUXMapping[e_featID][MBMUX_CMD_RESP] = channel_idx;
 80011b6:	4b1e      	ldr	r3, [pc, #120]	@ (8001230 <MBMUX_RegisterFeature+0xa4>)
 80011b8:	681b      	ldr	r3, [r3, #0]
 80011ba:	3490      	adds	r4, #144	@ 0x90
 80011bc:	f803 0014 	strb.w	r0, [r3, r4, lsl #1]
      p_MBMUX_ComTable->MBCmdRespParam[channel_idx].MsgCm4Cb = MsgCb;
 80011c0:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80011c4:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 80011c8:	6057      	str	r7, [r2, #4]
      p_MBMUX_ComTable->MBCmdRespParam[channel_idx].BufSize = ComBufSize;
 80011ca:	f8a2 800c 	strh.w	r8, [r2, #12]
      p_MBMUX_ComTable->MBCmdRespParam[channel_idx].ParamBuf = ComBuffer;
 80011ce:	6116      	str	r6, [r2, #16]
      p_MBMUX_ComTable->MBCmdRespParam[channel_idx].ReturnVal = 0;
 80011d0:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80011d4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80011d8:	2200      	movs	r2, #0
 80011da:	615a      	str	r2, [r3, #20]
    ret = channel_idx;
 80011dc:	b240      	sxtb	r0, r0
}
 80011de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (e_featID == FEAT_INFO_SYSTEM_ID)
 80011e2:	b13c      	cbz	r4, 80011f4 <MBMUX_RegisterFeature+0x68>
        channel_idx = MBMUX_FindChStillUnregistered(ComType);
 80011e4:	4628      	mov	r0, r5
 80011e6:	f7ff ff3d 	bl	8001064 <MBMUX_FindChStillUnregistered>
  if (channel_idx != MB_CHANNEL_NOT_REGISTERED)
 80011ea:	28ff      	cmp	r0, #255	@ 0xff
 80011ec:	d1e2      	bne.n	80011b4 <MBMUX_RegisterFeature+0x28>
  int8_t ret = -1; /* no more ipcc channels available */
 80011ee:	f04f 30ff 	mov.w	r0, #4294967295
 80011f2:	e7f4      	b.n	80011de <MBMUX_RegisterFeature+0x52>
        channel_idx = 0;
 80011f4:	4620      	mov	r0, r4
 80011f6:	e7dd      	b.n	80011b4 <MBMUX_RegisterFeature+0x28>
      p_MBMUX_ComTable->MBMUXMapping[e_featID][MBMUX_NOTIF_ACK] = channel_idx;
 80011f8:	4b0d      	ldr	r3, [pc, #52]	@ (8001230 <MBMUX_RegisterFeature+0xa4>)
 80011fa:	681b      	ldr	r3, [r3, #0]
 80011fc:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 8001200:	f884 0121 	strb.w	r0, [r4, #289]	@ 0x121
      p_MBMUX_ComTable->MBNotifAckParam[channel_idx].MsgCm4Cb = MsgCb;
 8001204:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8001208:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 800120c:	f8c2 7094 	str.w	r7, [r2, #148]	@ 0x94
      p_MBMUX_ComTable->MBNotifAckParam[channel_idx].BufSize = ComBufSize;
 8001210:	f8a2 809c 	strh.w	r8, [r2, #156]	@ 0x9c
      p_MBMUX_ComTable->MBNotifAckParam[channel_idx].ParamBuf = ComBuffer;
 8001214:	f8c2 60a0 	str.w	r6, [r2, #160]	@ 0xa0
      p_MBMUX_ComTable->MBNotifAckParam[channel_idx].ReturnVal = 0;
 8001218:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 800121c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001220:	2200      	movs	r2, #0
 8001222:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
 8001226:	e7d9      	b.n	80011dc <MBMUX_RegisterFeature+0x50>
    ret = -2; /* feature not provided by CM0PLUS */
 8001228:	f06f 0001 	mvn.w	r0, #1
 800122c:	e7d7      	b.n	80011de <MBMUX_RegisterFeature+0x52>
 800122e:	bf00      	nop
 8001230:	200001c0 	.word	0x200001c0

08001234 <MBMUX_GetFeatureComPtr>:
{
 8001234:	b510      	push	{r4, lr}
 8001236:	460c      	mov	r4, r1
  channel_idx = MBMUX_GetFeatureChIdx(e_featID, ComType);
 8001238:	f7ff ff56 	bl	80010e8 <MBMUX_GetFeatureChIdx>
  if (channel_idx < MBMUX_CHANNEL_NUMBER)
 800123c:	2805      	cmp	r0, #5
 800123e:	d80f      	bhi.n	8001260 <MBMUX_GetFeatureComPtr+0x2c>
    if (ComType == MBMUX_CMD_RESP)  /* TX */
 8001240:	b934      	cbnz	r4, 8001250 <MBMUX_GetFeatureComPtr+0x1c>
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBCmdRespParam[channel_idx];
 8001242:	4b08      	ldr	r3, [pc, #32]	@ (8001264 <MBMUX_GetFeatureComPtr+0x30>)
 8001244:	681b      	ldr	r3, [r3, #0]
 8001246:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800124a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
}
 800124e:	bd10      	pop	{r4, pc}
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBNotifAckParam[channel_idx];
 8001250:	4b04      	ldr	r3, [pc, #16]	@ (8001264 <MBMUX_GetFeatureComPtr+0x30>)
 8001252:	681a      	ldr	r2, [r3, #0]
 8001254:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8001258:	00c3      	lsls	r3, r0, #3
 800125a:	3390      	adds	r3, #144	@ 0x90
 800125c:	18d0      	adds	r0, r2, r3
 800125e:	e7f6      	b.n	800124e <MBMUX_GetFeatureComPtr+0x1a>
  MBMUX_ComParam_t *com_param_ptr = NULL;
 8001260:	2000      	movs	r0, #0
  return com_param_ptr;
 8001262:	e7f4      	b.n	800124e <MBMUX_GetFeatureComPtr+0x1a>
 8001264:	200001c0 	.word	0x200001c0

08001268 <MBMUX_CommandSnd>:
{
 8001268:	b510      	push	{r4, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_CMD_RESP);
 800126a:	2100      	movs	r1, #0
 800126c:	f7ff ff3c 	bl	80010e8 <MBMUX_GetFeatureChIdx>
 8001270:	4604      	mov	r4, r0
  if (p_MBMUX_ComTable->MBCmdRespParam[mb_ch].ParamCnt > p_MBMUX_ComTable->MBCmdRespParam[mb_ch].BufSize)
 8001272:	4b08      	ldr	r3, [pc, #32]	@ (8001294 <MBMUX_CommandSnd+0x2c>)
 8001274:	681b      	ldr	r3, [r3, #0]
 8001276:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 800127a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800127e:	89da      	ldrh	r2, [r3, #14]
 8001280:	899b      	ldrh	r3, [r3, #12]
 8001282:	429a      	cmp	r2, r3
 8001284:	d803      	bhi.n	800128e <MBMUX_CommandSnd+0x26>
  return IPCC_IF_CommandSnd(mb_ch);
 8001286:	4620      	mov	r0, r4
 8001288:	f7ff fa58 	bl	800073c <IPCC_IF_CommandSnd>
}
 800128c:	bd10      	pop	{r4, pc}
    Error_Handler();
 800128e:	f7ff fa71 	bl	8000774 <Error_Handler>
 8001292:	e7f8      	b.n	8001286 <MBMUX_CommandSnd+0x1e>
 8001294:	200001c0 	.word	0x200001c0

08001298 <MBMUX_AcknowledgeSnd>:
{
 8001298:	b508      	push	{r3, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_NOTIF_ACK);
 800129a:	2101      	movs	r1, #1
 800129c:	f7ff ff24 	bl	80010e8 <MBMUX_GetFeatureChIdx>
  return IPCC_IF_AcknowledgeSnd(mb_ch);
 80012a0:	f7ff fa5a 	bl	8000758 <IPCC_IF_AcknowledgeSnd>
}
 80012a4:	bd08      	pop	{r3, pc}
	...

080012a8 <MBMUXIF_TaskRadioNotifRcv>:

  /* USER CODE END MBMUXIF_IsrRadioNotifRcvCb_Last */
}

static void MBMUXIF_TaskRadioNotifRcv(void)
{
 80012a8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifRcv_1 */

  /* USER CODE END MBMUXIF_TaskRadioNotifRcv_1 */
  Process_Radio_Notif(RadioComObj);
 80012aa:	4b02      	ldr	r3, [pc, #8]	@ (80012b4 <MBMUXIF_TaskRadioNotifRcv+0xc>)
 80012ac:	6818      	ldr	r0, [r3, #0]
 80012ae:	f000 fc89 	bl	8001bc4 <Process_Radio_Notif>
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifRcv_Last */

  /* USER CODE END MBMUXIF_TaskRadioNotifRcv_Last */
}
 80012b2:	bd08      	pop	{r3, pc}
 80012b4:	200001c4 	.word	0x200001c4

080012b8 <MBMUXIF_IsrRadioNotifRcvCb>:
{
 80012b8:	b508      	push	{r3, lr}
  RadioComObj = (MBMUX_ComParam_t *) ComObj;
 80012ba:	4b03      	ldr	r3, [pc, #12]	@ (80012c8 <MBMUXIF_IsrRadioNotifRcvCb+0x10>)
 80012bc:	6018      	str	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbRadioNotifRcv), CFG_SEQ_Prio_0);
 80012be:	2100      	movs	r1, #0
 80012c0:	2004      	movs	r0, #4
 80012c2:	f004 fc99 	bl	8005bf8 <UTIL_SEQ_SetTask>
}
 80012c6:	bd08      	pop	{r3, pc}
 80012c8:	200001c4 	.word	0x200001c4

080012cc <MBMUXIF_IsrRadioRespRcvCb>:
{
 80012cc:	b508      	push	{r3, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbRadioRespRcv);
 80012ce:	2002      	movs	r0, #2
 80012d0:	f004 fca6 	bl	8005c20 <UTIL_SEQ_SetEvt>
}
 80012d4:	bd08      	pop	{r3, pc}
	...

080012d8 <MBMUXIF_RadioInit>:
{
 80012d8:	b500      	push	{lr}
 80012da:	b083      	sub	sp, #12
  p_cm0plus_system_info = MBMUXIF_SystemGetFeatCapabInfoPtr(FEAT_INFO_SYSTEM_ID);
 80012dc:	2000      	movs	r0, #0
 80012de:	f000 f987 	bl	80015f0 <MBMUXIF_SystemGetFeatCapabInfoPtr>
  cm0_vers = p_cm0plus_system_info->Feat_Info_Feature_Version >> APP_VERSION_SUB2_SHIFT;
 80012e2:	6842      	ldr	r2, [r0, #4]
  if (cm0_vers < (LAST_COMPATIBLE_CM0_RELEASE >> APP_VERSION_SUB2_SHIFT))
 80012e4:	4b16      	ldr	r3, [pc, #88]	@ (8001340 <MBMUXIF_RadioInit+0x68>)
 80012e6:	ebb3 2f12 	cmp.w	r3, r2, lsr #8
 80012ea:	d222      	bcs.n	8001332 <MBMUXIF_RadioInit+0x5a>
    ret = MBMUX_RegisterFeature(FEAT_INFO_RADIO_ID, MBMUX_CMD_RESP,
 80012ec:	233c      	movs	r3, #60	@ 0x3c
 80012ee:	9300      	str	r3, [sp, #0]
 80012f0:	4b14      	ldr	r3, [pc, #80]	@ (8001344 <MBMUXIF_RadioInit+0x6c>)
 80012f2:	4a15      	ldr	r2, [pc, #84]	@ (8001348 <MBMUXIF_RadioInit+0x70>)
 80012f4:	2100      	movs	r1, #0
 80012f6:	2007      	movs	r0, #7
 80012f8:	f7ff ff48 	bl	800118c <MBMUX_RegisterFeature>
  if (ret >= 0)
 80012fc:	2800      	cmp	r0, #0
 80012fe:	da02      	bge.n	8001306 <MBMUXIF_RadioInit+0x2e>
}
 8001300:	b003      	add	sp, #12
 8001302:	f85d fb04 	ldr.w	pc, [sp], #4
    ret = MBMUX_RegisterFeature(FEAT_INFO_RADIO_ID, MBMUX_NOTIF_ACK,
 8001306:	2310      	movs	r3, #16
 8001308:	9300      	str	r3, [sp, #0]
 800130a:	4b10      	ldr	r3, [pc, #64]	@ (800134c <MBMUXIF_RadioInit+0x74>)
 800130c:	4a10      	ldr	r2, [pc, #64]	@ (8001350 <MBMUXIF_RadioInit+0x78>)
 800130e:	2101      	movs	r1, #1
 8001310:	2007      	movs	r0, #7
 8001312:	f7ff ff3b 	bl	800118c <MBMUX_RegisterFeature>
  if (ret >= 0)
 8001316:	2800      	cmp	r0, #0
 8001318:	dbf2      	blt.n	8001300 <MBMUXIF_RadioInit+0x28>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbRadioNotifRcv), UTIL_SEQ_RFU, MBMUXIF_TaskRadioNotifRcv);
 800131a:	4a0e      	ldr	r2, [pc, #56]	@ (8001354 <MBMUXIF_RadioInit+0x7c>)
 800131c:	2100      	movs	r1, #0
 800131e:	2004      	movs	r0, #4
 8001320:	f004 fd6c 	bl	8005dfc <UTIL_SEQ_RegTask>
    ret = MBMUXIF_SystemSendCm0plusRegistrationCmd(FEAT_INFO_RADIO_ID);
 8001324:	2007      	movs	r0, #7
 8001326:	f000 f983 	bl	8001630 <MBMUXIF_SystemSendCm0plusRegistrationCmd>
    if (ret < 0)
 800132a:	2800      	cmp	r0, #0
 800132c:	db04      	blt.n	8001338 <MBMUXIF_RadioInit+0x60>
    ret = 0;
 800132e:	2000      	movs	r0, #0
 8001330:	e7e6      	b.n	8001300 <MBMUXIF_RadioInit+0x28>
    ret = -4; /* version incompatibility */
 8001332:	f06f 0003 	mvn.w	r0, #3
 8001336:	e7e3      	b.n	8001300 <MBMUXIF_RadioInit+0x28>
      ret = -3;
 8001338:	f06f 0002 	mvn.w	r0, #2
 800133c:	e7e0      	b.n	8001300 <MBMUXIF_RadioInit+0x28>
 800133e:	bf00      	nop
 8001340:	000102ff 	.word	0x000102ff
 8001344:	20008150 	.word	0x20008150
 8001348:	080012cd 	.word	0x080012cd
 800134c:	20008140 	.word	0x20008140
 8001350:	080012b9 	.word	0x080012b9
 8001354:	080012a9 	.word	0x080012a9

08001358 <MBMUXIF_GetRadioFeatureCmdComPtr>:
{
 8001358:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_RADIO_ID, MBMUX_CMD_RESP);
 800135a:	2100      	movs	r1, #0
 800135c:	2007      	movs	r0, #7
 800135e:	f7ff ff69 	bl	8001234 <MBMUX_GetFeatureComPtr>
  if (com_param_ptr == NULL)
 8001362:	4604      	mov	r4, r0
 8001364:	b108      	cbz	r0, 800136a <MBMUXIF_GetRadioFeatureCmdComPtr+0x12>
}
 8001366:	4620      	mov	r0, r4
 8001368:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 800136a:	f7ff fa03 	bl	8000774 <Error_Handler>
  return com_param_ptr;
 800136e:	e7fa      	b.n	8001366 <MBMUXIF_GetRadioFeatureCmdComPtr+0xe>

08001370 <MBMUXIF_RadioSendCmd>:
{
 8001370:	b508      	push	{r3, lr}
  if (MBMUX_CommandSnd(FEAT_INFO_RADIO_ID) == 0)
 8001372:	2007      	movs	r0, #7
 8001374:	f7ff ff78 	bl	8001268 <MBMUX_CommandSnd>
 8001378:	b918      	cbnz	r0, 8001382 <MBMUXIF_RadioSendCmd+0x12>
	  HAL_Delay(100);
 800137a:	2064      	movs	r0, #100	@ 0x64
 800137c:	f7ff fbac 	bl	8000ad8 <HAL_Delay>
}
 8001380:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001382:	f7ff f9f7 	bl	8000774 <Error_Handler>
}
 8001386:	e7fb      	b.n	8001380 <MBMUXIF_RadioSendCmd+0x10>

08001388 <MBMUXIF_IsrSystemPrioARespRcvCb>:
static void MBMUXIF_IsrSystemPrioARespRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioARespRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioARespRcvCb */
}
 8001388:	4770      	bx	lr

0800138a <MBMUXIF_IsrSystemPrioBRespRcvCb>:
static void MBMUXIF_IsrSystemPrioBRespRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBRespRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBRespRcvCb */
}
 800138a:	4770      	bx	lr

0800138c <MBMUXIF_IsrSystemPrioBNotifRcvCb>:
static void MBMUXIF_IsrSystemPrioBNotifRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBNotifRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBNotifRcvCb */
}
 800138c:	4770      	bx	lr
	...

08001390 <MBMUXIF_TaskSystemNotifRcv>:
{
 8001390:	b508      	push	{r3, lr}
  Process_Sys_Notif(SystemComObj);
 8001392:	4b02      	ldr	r3, [pc, #8]	@ (800139c <MBMUXIF_TaskSystemNotifRcv+0xc>)
 8001394:	6818      	ldr	r0, [r3, #0]
 8001396:	f7ff fb5f 	bl	8000a58 <Process_Sys_Notif>
}
 800139a:	bd08      	pop	{r3, pc}
 800139c:	200001c8 	.word	0x200001c8

080013a0 <MBMUXIF_IsrSystemNotifRcvCb>:
{
 80013a0:	b508      	push	{r3, lr}
  SystemComObj = (MBMUX_ComParam_t *) ComObj;
 80013a2:	4b03      	ldr	r3, [pc, #12]	@ (80013b0 <MBMUXIF_IsrSystemNotifRcvCb+0x10>)
 80013a4:	6018      	str	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbSystemNotifRcv), CFG_SEQ_Prio_0);
 80013a6:	2100      	movs	r1, #0
 80013a8:	2002      	movs	r0, #2
 80013aa:	f004 fc25 	bl	8005bf8 <UTIL_SEQ_SetTask>
}
 80013ae:	bd08      	pop	{r3, pc}
 80013b0:	200001c8 	.word	0x200001c8

080013b4 <MBMUXIF_IsrSystemRespRcvCb>:
{
 80013b4:	b508      	push	{r3, lr}
  MbSystemRespRcvFlag = 1;
 80013b6:	4b05      	ldr	r3, [pc, #20]	@ (80013cc <MBMUXIF_IsrSystemRespRcvCb+0x18>)
 80013b8:	2201      	movs	r2, #1
 80013ba:	701a      	strb	r2, [r3, #0]
  if (AllowSequencerForSysCmd) /* To avoid using Sequencer during Init sequence */
 80013bc:	4b04      	ldr	r3, [pc, #16]	@ (80013d0 <MBMUXIF_IsrSystemRespRcvCb+0x1c>)
 80013be:	781b      	ldrb	r3, [r3, #0]
 80013c0:	b903      	cbnz	r3, 80013c4 <MBMUXIF_IsrSystemRespRcvCb+0x10>
}
 80013c2:	bd08      	pop	{r3, pc}
    UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbSystemRespRcv);
 80013c4:	4610      	mov	r0, r2
 80013c6:	f004 fc2b 	bl	8005c20 <UTIL_SEQ_SetEvt>
}
 80013ca:	e7fa      	b.n	80013c2 <MBMUXIF_IsrSystemRespRcvCb+0xe>
 80013cc:	200001cc 	.word	0x200001cc
 80013d0:	200001cd 	.word	0x200001cd

080013d4 <MBMUXIF_SetCpusSynchroFlag>:
  pMb_RefTable->SynchronizeCpusAtBoot = flag;
 80013d4:	4b02      	ldr	r3, [pc, #8]	@ (80013e0 <MBMUXIF_SetCpusSynchroFlag+0xc>)
 80013d6:	681b      	ldr	r3, [r3, #0]
 80013d8:	f8a3 0136 	strh.w	r0, [r3, #310]	@ 0x136
}
 80013dc:	4770      	bx	lr
 80013de:	bf00      	nop
 80013e0:	20000000 	.word	0x20000000

080013e4 <MBMUXIF_SystemInit>:
{
 80013e4:	b510      	push	{r4, lr}
 80013e6:	b094      	sub	sp, #80	@ 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80013e8:	2248      	movs	r2, #72	@ 0x48
 80013ea:	2100      	movs	r1, #0
 80013ec:	a802      	add	r0, sp, #8
 80013ee:	f004 ff9b 	bl	8006328 <memset>
  * @rmtoll DBGMCU_IDCODE REV_ID        LL_DBGMCU_GetRevisionID
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF
  */
__STATIC_INLINE uint32_t LL_DBGMCU_GetRevisionID(void)
{
  return (uint32_t)(READ_BIT(DBGMCU->IDCODE, DBGMCU_IDCODE_REV_ID) >> DBGMCU_IDCODE_REV_ID_Pos);
 80013f2:	4b48      	ldr	r3, [pc, #288]	@ (8001514 <MBMUXIF_SystemInit+0x130>)
 80013f4:	681b      	ldr	r3, [r3, #0]
 80013f6:	0c1b      	lsrs	r3, r3, #16
  MBSYS_RefTable.ChipRevId = LL_DBGMCU_GetRevisionID();
 80013f8:	4a47      	ldr	r2, [pc, #284]	@ (8001518 <MBMUXIF_SystemInit+0x134>)
 80013fa:	f8a2 3138 	strh.w	r3, [r2, #312]	@ 0x138
  HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
 80013fe:	4c47      	ldr	r4, [pc, #284]	@ (800151c <MBMUXIF_SystemInit+0x138>)
 8001400:	4620      	mov	r0, r4
 8001402:	f001 fc9d 	bl	8002d40 <HAL_FLASHEx_OBGetConfig>
  if (OptionsBytesStruct.IPCCdataBufAddr != (uint32_t) pMb_RefTable)
 8001406:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8001408:	4b45      	ldr	r3, [pc, #276]	@ (8001520 <MBMUXIF_SystemInit+0x13c>)
 800140a:	681b      	ldr	r3, [r3, #0]
 800140c:	429a      	cmp	r2, r3
 800140e:	d048      	beq.n	80014a2 <MBMUXIF_SystemInit+0xbe>
    APP_PPRINTF("There is a difference between the MAPPING_TABLE placement in memory: 0x%X \r\n",
 8001410:	4b43      	ldr	r3, [pc, #268]	@ (8001520 <MBMUXIF_SystemInit+0x13c>)
 8001412:	681b      	ldr	r3, [r3, #0]
 8001414:	9300      	str	r3, [sp, #0]
 8001416:	4b43      	ldr	r3, [pc, #268]	@ (8001524 <MBMUXIF_SystemInit+0x140>)
 8001418:	2200      	movs	r2, #0
 800141a:	4611      	mov	r1, r2
 800141c:	4610      	mov	r0, r2
 800141e:	f004 fa9f 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
 8001422:	2800      	cmp	r0, #0
 8001424:	d1f4      	bne.n	8001410 <MBMUXIF_SystemInit+0x2c>
    APP_PPRINTF("and the address calculated according to the IPCCDBA option byte: 0x%X \r\n",
 8001426:	4b3d      	ldr	r3, [pc, #244]	@ (800151c <MBMUXIF_SystemInit+0x138>)
 8001428:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800142a:	9300      	str	r3, [sp, #0]
 800142c:	4b3e      	ldr	r3, [pc, #248]	@ (8001528 <MBMUXIF_SystemInit+0x144>)
 800142e:	2200      	movs	r2, #0
 8001430:	4611      	mov	r1, r2
 8001432:	4610      	mov	r0, r2
 8001434:	f004 fa94 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
 8001438:	2800      	cmp	r0, #0
 800143a:	d1f4      	bne.n	8001426 <MBMUXIF_SystemInit+0x42>
    APP_PPRINTF("IPCCDBA is automatically updated\n\rSystem restarting...\r\n\r\n");
 800143c:	4b3b      	ldr	r3, [pc, #236]	@ (800152c <MBMUXIF_SystemInit+0x148>)
 800143e:	2200      	movs	r2, #0
 8001440:	4611      	mov	r1, r2
 8001442:	4610      	mov	r0, r2
 8001444:	f004 fa8c 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
 8001448:	2800      	cmp	r0, #0
 800144a:	d1f7      	bne.n	800143c <MBMUXIF_SystemInit+0x58>
    APP_PPRINTF("Please check the CM4\\MbMux\\mbmuxif_sys.c for more info \r\n\r\n");
 800144c:	4b38      	ldr	r3, [pc, #224]	@ (8001530 <MBMUXIF_SystemInit+0x14c>)
 800144e:	2200      	movs	r2, #0
 8001450:	4611      	mov	r1, r2
 8001452:	4610      	mov	r0, r2
 8001454:	f004 fa84 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
 8001458:	2800      	cmp	r0, #0
 800145a:	d1f7      	bne.n	800144c <MBMUXIF_SystemInit+0x68>
    while (1 != UTIL_ADV_TRACE_IsBufferEmpty())
 800145c:	f004 fa1a 	bl	8005894 <UTIL_ADV_TRACE_IsBufferEmpty>
 8001460:	2801      	cmp	r0, #1
 8001462:	d1fb      	bne.n	800145c <MBMUXIF_SystemInit+0x78>
    if (MBSYS_RefTable.ChipRevId == 0x1001)
 8001464:	4b2c      	ldr	r3, [pc, #176]	@ (8001518 <MBMUXIF_SystemInit+0x134>)
 8001466:	f8b3 2138 	ldrh.w	r2, [r3, #312]	@ 0x138
 800146a:	f241 0301 	movw	r3, #4097	@ 0x1001
 800146e:	429a      	cmp	r2, r3
 8001470:	d02c      	beq.n	80014cc <MBMUXIF_SystemInit+0xe8>
    HAL_FLASH_Unlock();
 8001472:	f001 f96d 	bl	8002750 <HAL_FLASH_Unlock>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8001476:	4b2f      	ldr	r3, [pc, #188]	@ (8001534 <MBMUXIF_SystemInit+0x150>)
 8001478:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 800147c:	611a      	str	r2, [r3, #16]
    HAL_FLASH_OB_Unlock();
 800147e:	f001 f98d 	bl	800279c <HAL_FLASH_OB_Unlock>
    OptionsBytesStruct.OptionType = OPTIONBYTE_IPCC_BUF_ADDR;
 8001482:	4826      	ldr	r0, [pc, #152]	@ (800151c <MBMUXIF_SystemInit+0x138>)
 8001484:	2310      	movs	r3, #16
 8001486:	6003      	str	r3, [r0, #0]
    OptionsBytesStruct.IPCCdataBufAddr = (uint32_t) pMb_RefTable;
 8001488:	4b25      	ldr	r3, [pc, #148]	@ (8001520 <MBMUXIF_SystemInit+0x13c>)
 800148a:	681b      	ldr	r3, [r3, #0]
 800148c:	6543      	str	r3, [r0, #84]	@ 0x54
    if (HAL_FLASHEx_OBProgram(&OptionsBytesStruct) != HAL_OK)
 800148e:	f001 fbed 	bl	8002c6c <HAL_FLASHEx_OBProgram>
 8001492:	bb40      	cbnz	r0, 80014e6 <MBMUXIF_SystemInit+0x102>
    if (HAL_FLASH_OB_Launch() != HAL_OK)
 8001494:	f001 f9ac 	bl	80027f0 <HAL_FLASH_OB_Launch>
 8001498:	bb40      	cbnz	r0, 80014ec <MBMUXIF_SystemInit+0x108>
    (void) HAL_FLASH_OB_Lock();
 800149a:	f001 f999 	bl	80027d0 <HAL_FLASH_OB_Lock>
    (void) HAL_FLASH_Lock();
 800149e:	f001 f96f 	bl	8002780 <HAL_FLASH_Lock>
    MBMUX_Init(pMb_RefTable);
 80014a2:	4b1f      	ldr	r3, [pc, #124]	@ (8001520 <MBMUXIF_SystemInit+0x13c>)
 80014a4:	6818      	ldr	r0, [r3, #0]
 80014a6:	f7ff fe2d 	bl	8001104 <MBMUX_Init>
    ret = MBMUX_RegisterFeature(FEAT_INFO_SYSTEM_ID, MBMUX_CMD_RESP,
 80014aa:	231c      	movs	r3, #28
 80014ac:	9300      	str	r3, [sp, #0]
 80014ae:	4b22      	ldr	r3, [pc, #136]	@ (8001538 <MBMUXIF_SystemInit+0x154>)
 80014b0:	4a22      	ldr	r2, [pc, #136]	@ (800153c <MBMUXIF_SystemInit+0x158>)
 80014b2:	2100      	movs	r1, #0
 80014b4:	4608      	mov	r0, r1
 80014b6:	f7ff fe69 	bl	800118c <MBMUX_RegisterFeature>
  if (ret >= 0)
 80014ba:	1e04      	subs	r4, r0, #0
 80014bc:	da19      	bge.n	80014f2 <MBMUXIF_SystemInit+0x10e>
  MBMUXIF_SetCpusSynchroFlag(CPUS_BOOT_SYNC_PREVENT_CPU2_TO_START);
 80014be:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 80014c2:	f7ff ff87 	bl	80013d4 <MBMUXIF_SetCpusSynchroFlag>
}
 80014c6:	4620      	mov	r0, r4
 80014c8:	b014      	add	sp, #80	@ 0x50
 80014ca:	bd10      	pop	{r4, pc}
      HAL_RCC_GetOscConfig(&RCC_OscInitStruct);
 80014cc:	a802      	add	r0, sp, #8
 80014ce:	f002 fd11 	bl	8003ef4 <HAL_RCC_GetOscConfig>
      RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_8;
 80014d2:	2380      	movs	r3, #128	@ 0x80
 80014d4:	930c      	str	r3, [sp, #48]	@ 0x30
      if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80014d6:	a802      	add	r0, sp, #8
 80014d8:	f002 f886 	bl	80035e8 <HAL_RCC_OscConfig>
 80014dc:	2800      	cmp	r0, #0
 80014de:	d0c8      	beq.n	8001472 <MBMUXIF_SystemInit+0x8e>
        Error_Handler();
 80014e0:	f7ff f948 	bl	8000774 <Error_Handler>
 80014e4:	e7c5      	b.n	8001472 <MBMUXIF_SystemInit+0x8e>
      Error_Handler();
 80014e6:	f7ff f945 	bl	8000774 <Error_Handler>
 80014ea:	e7d3      	b.n	8001494 <MBMUXIF_SystemInit+0xb0>
      Error_Handler();
 80014ec:	f7ff f942 	bl	8000774 <Error_Handler>
 80014f0:	e7d3      	b.n	800149a <MBMUXIF_SystemInit+0xb6>
    ret = MBMUX_RegisterFeature(FEAT_INFO_SYSTEM_ID, MBMUX_NOTIF_ACK,
 80014f2:	2314      	movs	r3, #20
 80014f4:	9300      	str	r3, [sp, #0]
 80014f6:	4b12      	ldr	r3, [pc, #72]	@ (8001540 <MBMUXIF_SystemInit+0x15c>)
 80014f8:	4a12      	ldr	r2, [pc, #72]	@ (8001544 <MBMUXIF_SystemInit+0x160>)
 80014fa:	2101      	movs	r1, #1
 80014fc:	2000      	movs	r0, #0
 80014fe:	f7ff fe45 	bl	800118c <MBMUX_RegisterFeature>
  if (ret >= 0)
 8001502:	1e04      	subs	r4, r0, #0
 8001504:	dbdb      	blt.n	80014be <MBMUXIF_SystemInit+0xda>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbSystemNotifRcv), UTIL_SEQ_RFU, MBMUXIF_TaskSystemNotifRcv);
 8001506:	4a10      	ldr	r2, [pc, #64]	@ (8001548 <MBMUXIF_SystemInit+0x164>)
 8001508:	2100      	movs	r1, #0
 800150a:	2002      	movs	r0, #2
 800150c:	f004 fc76 	bl	8005dfc <UTIL_SEQ_RegTask>
    ret = 0;
 8001510:	2400      	movs	r4, #0
 8001512:	e7d4      	b.n	80014be <MBMUXIF_SystemInit+0xda>
 8001514:	e0042000 	.word	0xe0042000
 8001518:	20008000 	.word	0x20008000
 800151c:	200001d0 	.word	0x200001d0
 8001520:	20000000 	.word	0x20000000
 8001524:	080065a0 	.word	0x080065a0
 8001528:	080065f0 	.word	0x080065f0
 800152c:	0800663c 	.word	0x0800663c
 8001530:	08006678 	.word	0x08006678
 8001534:	58004000 	.word	0x58004000
 8001538:	200081b0 	.word	0x200081b0
 800153c:	080013b5 	.word	0x080013b5
 8001540:	2000819c 	.word	0x2000819c
 8001544:	080013a1 	.word	0x080013a1
 8001548:	08001391 	.word	0x08001391

0800154c <MBMUXIF_WaitCm0MbmuxIsInitialized>:
  while (pMb_RefTable->SynchronizeCpusAtBoot != CPUS_BOOT_SYNC_CPU2_INIT_COMPLETED)
 800154c:	4b04      	ldr	r3, [pc, #16]	@ (8001560 <MBMUXIF_WaitCm0MbmuxIsInitialized+0x14>)
 800154e:	681b      	ldr	r3, [r3, #0]
 8001550:	f8b3 3136 	ldrh.w	r3, [r3, #310]	@ 0x136
 8001554:	b29b      	uxth	r3, r3
 8001556:	f64a 22aa 	movw	r2, #43690	@ 0xaaaa
 800155a:	4293      	cmp	r3, r2
 800155c:	d1f6      	bne.n	800154c <MBMUXIF_WaitCm0MbmuxIsInitialized>
}
 800155e:	4770      	bx	lr
 8001560:	20000000 	.word	0x20000000

08001564 <MBMUXIF_GetSystemFeatureCmdComPtr>:
{
 8001564:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(SystemPrioFeat, MBMUX_CMD_RESP);
 8001566:	2100      	movs	r1, #0
 8001568:	f7ff fe64 	bl	8001234 <MBMUX_GetFeatureComPtr>
  if (com_param_ptr == NULL)
 800156c:	4604      	mov	r4, r0
 800156e:	b108      	cbz	r0, 8001574 <MBMUXIF_GetSystemFeatureCmdComPtr+0x10>
}
 8001570:	4620      	mov	r0, r4
 8001572:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 8001574:	f7ff f8fe 	bl	8000774 <Error_Handler>
  return com_param_ptr;
 8001578:	e7fa      	b.n	8001570 <MBMUXIF_GetSystemFeatureCmdComPtr+0xc>
	...

0800157c <MBMUXIF_SystemSendCmd>:
  if (SystemPrioFeat == FEAT_INFO_SYSTEM_ID)
 800157c:	b100      	cbz	r0, 8001580 <MBMUXIF_SystemSendCmd+0x4>
 800157e:	4770      	bx	lr
{
 8001580:	b508      	push	{r3, lr}
    MbSystemRespRcvFlag = 0;  /* To avoid using Sequencer during Init sequence for SysCmd  */
 8001582:	4b0a      	ldr	r3, [pc, #40]	@ (80015ac <MBMUXIF_SystemSendCmd+0x30>)
 8001584:	7018      	strb	r0, [r3, #0]
    if (MBMUX_CommandSnd(FEAT_INFO_SYSTEM_ID) == 0)
 8001586:	f7ff fe6f 	bl	8001268 <MBMUX_CommandSnd>
 800158a:	b958      	cbnz	r0, 80015a4 <MBMUXIF_SystemSendCmd+0x28>
      if (AllowSequencerForSysCmd)
 800158c:	4b08      	ldr	r3, [pc, #32]	@ (80015b0 <MBMUXIF_SystemSendCmd+0x34>)
 800158e:	781b      	ldrb	r3, [r3, #0]
 8001590:	b923      	cbnz	r3, 800159c <MBMUXIF_SystemSendCmd+0x20>
        while (!MbSystemRespRcvFlag) {}
 8001592:	4b06      	ldr	r3, [pc, #24]	@ (80015ac <MBMUXIF_SystemSendCmd+0x30>)
 8001594:	781b      	ldrb	r3, [r3, #0]
 8001596:	2b00      	cmp	r3, #0
 8001598:	d0fb      	beq.n	8001592 <MBMUXIF_SystemSendCmd+0x16>
}
 800159a:	bd08      	pop	{r3, pc}
        UTIL_SEQ_WaitEvt(1 << CFG_SEQ_Evt_MbSystemRespRcv);
 800159c:	2001      	movs	r0, #1
 800159e:	f004 fc01 	bl	8005da4 <UTIL_SEQ_WaitEvt>
 80015a2:	e7fa      	b.n	800159a <MBMUXIF_SystemSendCmd+0x1e>
      Error_Handler();
 80015a4:	f7ff f8e6 	bl	8000774 <Error_Handler>
}
 80015a8:	e7f7      	b.n	800159a <MBMUXIF_SystemSendCmd+0x1e>
 80015aa:	bf00      	nop
 80015ac:	200001cc 	.word	0x200001cc
 80015b0:	200001cd 	.word	0x200001cd

080015b4 <MBMUXIF_SystemSendAck>:
{
 80015b4:	b508      	push	{r3, lr}
  if (MBMUX_AcknowledgeSnd(SystemPrioFeat) != 0)
 80015b6:	f7ff fe6f 	bl	8001298 <MBMUX_AcknowledgeSnd>
 80015ba:	b900      	cbnz	r0, 80015be <MBMUXIF_SystemSendAck+0xa>
}
 80015bc:	bd08      	pop	{r3, pc}
    Error_Handler();
 80015be:	f7ff f8d9 	bl	8000774 <Error_Handler>
}
 80015c2:	e7fb      	b.n	80015bc <MBMUXIF_SystemSendAck+0x8>

080015c4 <MBMUXIF_IsrSystemPrioANotifRcvCb>:
{
 80015c4:	b508      	push	{r3, lr}
  UTIL_TIMER_IRQ_Handler();
 80015c6:	f004 fd07 	bl	8005fd8 <UTIL_TIMER_IRQ_Handler>
  MBMUXIF_SystemSendAck(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 80015ca:	2002      	movs	r0, #2
 80015cc:	f7ff fff2 	bl	80015b4 <MBMUXIF_SystemSendAck>
}
 80015d0:	bd08      	pop	{r3, pc}

080015d2 <MBMUXIF_SystemSendCm0plusInfoListReq>:
{
 80015d2:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetSystemFeatureCmdComPtr(FEAT_INFO_SYSTEM_ID);
 80015d4:	2000      	movs	r0, #0
 80015d6:	f7ff ffc5 	bl	8001564 <MBMUXIF_GetSystemFeatureCmdComPtr>
  if (com_obj != NULL)
 80015da:	b138      	cbz	r0, 80015ec <MBMUXIF_SystemSendCm0plusInfoListReq+0x1a>
 80015dc:	4604      	mov	r4, r0
    com_obj->MsgId = SYS_GET_INFO_LIST_MSG_ID;
 80015de:	2000      	movs	r0, #0
 80015e0:	6020      	str	r0, [r4, #0]
    com_obj->ParamCnt = 0;
 80015e2:	81e0      	strh	r0, [r4, #14]
    MBMUXIF_SystemSendCmd(FEAT_INFO_SYSTEM_ID);
 80015e4:	f7ff ffca 	bl	800157c <MBMUXIF_SystemSendCmd>
    ret = com_obj->ReturnVal;
 80015e8:	6960      	ldr	r0, [r4, #20]
}
 80015ea:	bd10      	pop	{r4, pc}
  uint32_t ret = 0;
 80015ec:	2000      	movs	r0, #0
 80015ee:	e7fc      	b.n	80015ea <MBMUXIF_SystemSendCm0plusInfoListReq+0x18>

080015f0 <MBMUXIF_SystemGetFeatCapabInfoPtr>:
{
 80015f0:	b538      	push	{r3, r4, r5, lr}
 80015f2:	4604      	mov	r4, r0
  p_cm0plus_supported_features_list = MBMUXIF_SystemSendCm0plusInfoListReq();
 80015f4:	f7ff ffed 	bl	80015d2 <MBMUXIF_SystemSendCm0plusInfoListReq>
  if (p_cm0plus_supported_features_list != NULL)
 80015f8:	4684      	mov	ip, r0
 80015fa:	b1b8      	cbz	r0, 800162c <MBMUXIF_SystemGetFeatCapabInfoPtr+0x3c>
    cm0plus_nr_of_supported_features = p_cm0plus_supported_features_list->Feat_Info_Cnt;
 80015fc:	7800      	ldrb	r0, [r0, #0]
    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 80015fe:	2300      	movs	r3, #0
  FEAT_INFO_Param_t  *p_feature = NULL;
 8001600:	461d      	mov	r5, r3
    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 8001602:	4283      	cmp	r3, r0
 8001604:	d20a      	bcs.n	800161c <MBMUXIF_SystemGetFeatCapabInfoPtr+0x2c>
      p_feature = i + p_cm0plus_supported_features_list->Feat_Info_TableAddress;
 8001606:	f8dc 1004 	ldr.w	r1, [ip, #4]
 800160a:	011a      	lsls	r2, r3, #4
 800160c:	eb01 1503 	add.w	r5, r1, r3, lsl #4
      if (p_feature->Feat_Info_Feature_Id == e_featID)
 8001610:	5c8a      	ldrb	r2, [r1, r2]
 8001612:	42a2      	cmp	r2, r4
 8001614:	d008      	beq.n	8001628 <MBMUXIF_SystemGetFeatCapabInfoPtr+0x38>
    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 8001616:	3301      	adds	r3, #1
 8001618:	b2db      	uxtb	r3, r3
 800161a:	e7f2      	b.n	8001602 <MBMUXIF_SystemGetFeatCapabInfoPtr+0x12>
  uint8_t found = 0;
 800161c:	2300      	movs	r3, #0
  if (!found)
 800161e:	b90b      	cbnz	r3, 8001624 <MBMUXIF_SystemGetFeatCapabInfoPtr+0x34>
    Error_Handler();
 8001620:	f7ff f8a8 	bl	8000774 <Error_Handler>
}
 8001624:	4628      	mov	r0, r5
 8001626:	bd38      	pop	{r3, r4, r5, pc}
        found = 1;
 8001628:	2301      	movs	r3, #1
 800162a:	e7f8      	b.n	800161e <MBMUXIF_SystemGetFeatCapabInfoPtr+0x2e>
  FEAT_INFO_Param_t  *p_feature = NULL;
 800162c:	4605      	mov	r5, r0
 800162e:	e7f7      	b.n	8001620 <MBMUXIF_SystemGetFeatCapabInfoPtr+0x30>

08001630 <MBMUXIF_SystemSendCm0plusRegistrationCmd>:
{
 8001630:	b538      	push	{r3, r4, r5, lr}
 8001632:	4604      	mov	r4, r0
  com_obj = MBMUXIF_GetSystemFeatureCmdComPtr(FEAT_INFO_SYSTEM_ID);
 8001634:	2000      	movs	r0, #0
 8001636:	f7ff ff95 	bl	8001564 <MBMUXIF_GetSystemFeatureCmdComPtr>
  if (com_obj != NULL)
 800163a:	b158      	cbz	r0, 8001654 <MBMUXIF_SystemSendCm0plusRegistrationCmd+0x24>
 800163c:	4605      	mov	r5, r0
    com_obj->MsgId = SYS_REGISTER_FEATURE_MSG_ID;
 800163e:	2301      	movs	r3, #1
 8001640:	6003      	str	r3, [r0, #0]
    com_buffer = com_obj->ParamBuf;
 8001642:	6902      	ldr	r2, [r0, #16]
    com_buffer[i++] = (uint32_t) e_featID;
 8001644:	6014      	str	r4, [r2, #0]
    com_obj->ParamCnt = i;
 8001646:	81c3      	strh	r3, [r0, #14]
    MBMUXIF_SystemSendCmd(FEAT_INFO_SYSTEM_ID);
 8001648:	2000      	movs	r0, #0
 800164a:	f7ff ff97 	bl	800157c <MBMUXIF_SystemSendCmd>
    ret = com_obj->ReturnVal;
 800164e:	6968      	ldr	r0, [r5, #20]
}
 8001650:	b240      	sxtb	r0, r0
 8001652:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t ret = 0;
 8001654:	2000      	movs	r0, #0
 8001656:	e7fb      	b.n	8001650 <MBMUXIF_SystemSendCm0plusRegistrationCmd+0x20>

08001658 <MBMUXIF_SystemPrio_Add>:
{
 8001658:	b510      	push	{r4, lr}
 800165a:	b082      	sub	sp, #8
 800165c:	4604      	mov	r4, r0
  switch (SystemPrioFeat)
 800165e:	1e43      	subs	r3, r0, #1
 8001660:	2b03      	cmp	r3, #3
 8001662:	d80c      	bhi.n	800167e <MBMUXIF_SystemPrio_Add+0x26>
 8001664:	e8df f003 	tbb	[pc, r3]
 8001668:	221a1202 	.word	0x221a1202
      ret = MBMUX_RegisterFeature(SystemPrioFeat, MBMUX_CMD_RESP,
 800166c:	2304      	movs	r3, #4
 800166e:	9300      	str	r3, [sp, #0]
 8001670:	4b14      	ldr	r3, [pc, #80]	@ (80016c4 <MBMUXIF_SystemPrio_Add+0x6c>)
 8001672:	4a15      	ldr	r2, [pc, #84]	@ (80016c8 <MBMUXIF_SystemPrio_Add+0x70>)
 8001674:	2100      	movs	r1, #0
 8001676:	f7ff fd89 	bl	800118c <MBMUX_RegisterFeature>
  if (ret >= 0)
 800167a:	2800      	cmp	r0, #0
 800167c:	db04      	blt.n	8001688 <MBMUXIF_SystemPrio_Add+0x30>
    ret = MBMUXIF_SystemSendCm0plusRegistrationCmd(SystemPrioFeat);
 800167e:	4620      	mov	r0, r4
 8001680:	f7ff ffd6 	bl	8001630 <MBMUXIF_SystemSendCm0plusRegistrationCmd>
    if (ret < 0)
 8001684:	2800      	cmp	r0, #0
 8001686:	db19      	blt.n	80016bc <MBMUXIF_SystemPrio_Add+0x64>
}
 8001688:	b002      	add	sp, #8
 800168a:	bd10      	pop	{r4, pc}
      ret = MBMUX_RegisterFeature(SystemPrioFeat, MBMUX_NOTIF_ACK,
 800168c:	2304      	movs	r3, #4
 800168e:	9300      	str	r3, [sp, #0]
 8001690:	4b0e      	ldr	r3, [pc, #56]	@ (80016cc <MBMUXIF_SystemPrio_Add+0x74>)
 8001692:	4a0f      	ldr	r2, [pc, #60]	@ (80016d0 <MBMUXIF_SystemPrio_Add+0x78>)
 8001694:	2101      	movs	r1, #1
 8001696:	f7ff fd79 	bl	800118c <MBMUX_RegisterFeature>
      break;
 800169a:	e7ee      	b.n	800167a <MBMUXIF_SystemPrio_Add+0x22>
      ret = MBMUX_RegisterFeature(SystemPrioFeat, MBMUX_CMD_RESP,
 800169c:	2304      	movs	r3, #4
 800169e:	9300      	str	r3, [sp, #0]
 80016a0:	4b0c      	ldr	r3, [pc, #48]	@ (80016d4 <MBMUXIF_SystemPrio_Add+0x7c>)
 80016a2:	4a0d      	ldr	r2, [pc, #52]	@ (80016d8 <MBMUXIF_SystemPrio_Add+0x80>)
 80016a4:	2100      	movs	r1, #0
 80016a6:	f7ff fd71 	bl	800118c <MBMUX_RegisterFeature>
      break;
 80016aa:	e7e6      	b.n	800167a <MBMUXIF_SystemPrio_Add+0x22>
      ret = MBMUX_RegisterFeature(SystemPrioFeat, MBMUX_NOTIF_ACK,
 80016ac:	2304      	movs	r3, #4
 80016ae:	9300      	str	r3, [sp, #0]
 80016b0:	4b0a      	ldr	r3, [pc, #40]	@ (80016dc <MBMUXIF_SystemPrio_Add+0x84>)
 80016b2:	4a0b      	ldr	r2, [pc, #44]	@ (80016e0 <MBMUXIF_SystemPrio_Add+0x88>)
 80016b4:	2101      	movs	r1, #1
 80016b6:	f7ff fd69 	bl	800118c <MBMUX_RegisterFeature>
      break;
 80016ba:	e7de      	b.n	800167a <MBMUXIF_SystemPrio_Add+0x22>
      ret = -3;
 80016bc:	f06f 0002 	mvn.w	r0, #2
 80016c0:	e7e2      	b.n	8001688 <MBMUXIF_SystemPrio_Add+0x30>
 80016c2:	bf00      	nop
 80016c4:	20008198 	.word	0x20008198
 80016c8:	08001389 	.word	0x08001389
 80016cc:	20008194 	.word	0x20008194
 80016d0:	080015c5 	.word	0x080015c5
 80016d4:	20008190 	.word	0x20008190
 80016d8:	0800138b 	.word	0x0800138b
 80016dc:	2000818c 	.word	0x2000818c
 80016e0:	0800138d 	.word	0x0800138d

080016e4 <MBMUXIF_TraceInit>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int8_t MBMUXIF_TraceInit(void)
{
 80016e4:	b500      	push	{lr}
 80016e6:	b083      	sub	sp, #12
  int8_t ret;
  /* USER CODE BEGIN MBMUXIF_TraceInit_1 */

  /* USER CODE END MBMUXIF_TraceInit_1 */

  ret = MBMUX_RegisterFeature(FEAT_INFO_TRACE_ID, MBMUX_NOTIF_ACK,
 80016e8:	232c      	movs	r3, #44	@ 0x2c
 80016ea:	9300      	str	r3, [sp, #0]
 80016ec:	4b09      	ldr	r3, [pc, #36]	@ (8001714 <MBMUXIF_TraceInit+0x30>)
 80016ee:	4a0a      	ldr	r2, [pc, #40]	@ (8001718 <MBMUXIF_TraceInit+0x34>)
 80016f0:	2101      	movs	r1, #1
 80016f2:	2006      	movs	r0, #6
 80016f4:	f7ff fd4a 	bl	800118c <MBMUX_RegisterFeature>
                              MBMUXIF_IsrTraceNotifRcvCb,
                              aTraceNotifAckBuff, sizeof(aTraceNotifAckBuff));
  if (ret >= 0)
 80016f8:	2800      	cmp	r0, #0
 80016fa:	da02      	bge.n	8001702 <MBMUXIF_TraceInit+0x1e>

  /* USER CODE BEGIN MBMUXIF_TraceInit_Last */

  /* USER CODE END MBMUXIF_TraceInit_Last */
  return ret;
}
 80016fc:	b003      	add	sp, #12
 80016fe:	f85d fb04 	ldr.w	pc, [sp], #4
    ret = MBMUXIF_SystemSendCm0plusRegistrationCmd(FEAT_INFO_TRACE_ID);
 8001702:	2006      	movs	r0, #6
 8001704:	f7ff ff94 	bl	8001630 <MBMUXIF_SystemSendCm0plusRegistrationCmd>
    if (ret < 0)
 8001708:	2800      	cmp	r0, #0
 800170a:	daf7      	bge.n	80016fc <MBMUXIF_TraceInit+0x18>
      ret = -3;
 800170c:	f06f 0002 	mvn.w	r0, #2
 8001710:	e7f4      	b.n	80016fc <MBMUXIF_TraceInit+0x18>
 8001712:	bf00      	nop
 8001714:	200081cc 	.word	0x200081cc
 8001718:	0800172f 	.word	0x0800172f

0800171c <MBMUXIF_TraceSendAck>:

void MBMUXIF_TraceSendAck(void)
{
 800171c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MBMUXIF_TraceSendAck_1 */

  /* USER CODE END MBMUXIF_TraceSendAck_1 */
  if (MBMUX_AcknowledgeSnd(FEAT_INFO_TRACE_ID) != 0)
 800171e:	2006      	movs	r0, #6
 8001720:	f7ff fdba 	bl	8001298 <MBMUX_AcknowledgeSnd>
 8001724:	b900      	cbnz	r0, 8001728 <MBMUXIF_TraceSendAck+0xc>
    Error_Handler();
  }
  /* USER CODE BEGIN MBMUXIF_TraceSendAck_Last */

  /* USER CODE END MBMUXIF_TraceSendAck_Last */
}
 8001726:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001728:	f7ff f824 	bl	8000774 <Error_Handler>
}
 800172c:	e7fb      	b.n	8001726 <MBMUXIF_TraceSendAck+0xa>

0800172e <MBMUXIF_IsrTraceNotifRcvCb>:

/* USER CODE END EFD */

/* Private functions ---------------------------------------------------------*/
static void MBMUXIF_IsrTraceNotifRcvCb(void *ComObj)
{
 800172e:	b510      	push	{r4, lr}
  uint16_t bufsize;
  UTIL_ADV_TRACE_Status_t ret;

  TraceComObj = (MBMUX_ComParam_t *) ComObj;

  notif_ack_id = TraceComObj->MsgId;
 8001730:	6803      	ldr	r3, [r0, #0]

  switch (notif_ack_id)
 8001732:	b113      	cbz	r3, 800173a <MBMUXIF_IsrTraceNotifRcvCb+0xc>
    default:
      break;
  }

  /* Send ack */
  MBMUXIF_TraceSendAck();
 8001734:	f7ff fff2 	bl	800171c <MBMUXIF_TraceSendAck>
  /* USER CODE BEGIN MBMUXIF_IsrTraceNotifRcvCb_Last */

  /* USER CODE END MBMUXIF_IsrTraceNotifRcvCb_Last */
}
 8001738:	bd10      	pop	{r4, pc}
 800173a:	4604      	mov	r4, r0
      buffer = (uint8_t *) TraceComObj->ParamBuf[0];
 800173c:	6903      	ldr	r3, [r0, #16]
      ret = UTIL_ADV_TRACE_Send(buffer, bufsize);
 800173e:	8899      	ldrh	r1, [r3, #4]
 8001740:	6818      	ldr	r0, [r3, #0]
 8001742:	f004 f971 	bl	8005a28 <UTIL_ADV_TRACE_Send>
      TraceComObj->ParamCnt = 0;
 8001746:	2300      	movs	r3, #0
 8001748:	81e3      	strh	r3, [r4, #14]
      TraceComObj->ReturnVal = (uint32_t)ret;
 800174a:	6160      	str	r0, [r4, #20]
      break;
 800174c:	e7f2      	b.n	8001734 <MBMUXIF_IsrTraceNotifRcvCb+0x6>

0800174e <RadioSetTxGenericConfig>:

  /* USER CODE END RadioSetRxGenericConfig_2 */
}

static int32_t RadioSetTxGenericConfig(GenericModems_t modem, TxConfigGeneric_t *config, int8_t power, uint32_t timeout)
{
 800174e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001752:	4681      	mov	r9, r0
 8001754:	4688      	mov	r8, r1
 8001756:	4617      	mov	r7, r2
 8001758:	461e      	mov	r6, r3
  MBMUX_ComParam_t *com_obj;
  uint32_t *com_buffer;
  uint32_t ret;
  uint16_t i = 0;

  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 800175a:	f7ff fdfd 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 800175e:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_SET_TX_GENERIC_CONFIG_ID;
 8001760:	231e      	movs	r3, #30
 8001762:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001764:	6905      	ldr	r5, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 8001766:	f8c5 9000 	str.w	r9, [r5]
  com_buffer[i++] = (uint32_t) config;
 800176a:	f8c5 8004 	str.w	r8, [r5, #4]
  com_buffer[i++] = (uint32_t) power;
 800176e:	60af      	str	r7, [r5, #8]
  com_buffer[i++] = (uint32_t) timeout;
 8001770:	60ee      	str	r6, [r5, #12]
  com_obj->ParamCnt = i;
 8001772:	2304      	movs	r3, #4
 8001774:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001776:	f7ff fdfb 	bl	8001370 <MBMUXIF_RadioSendCmd>
  ret = com_obj->ReturnVal;
  return (int32_t) ret;
  /* USER CODE BEGIN RadioSetTxGenericConfig_2 */

  /* USER CODE END RadioSetTxGenericConfig_2 */
}
 800177a:	6960      	ldr	r0, [r4, #20]
 800177c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08001780 <RadioSetRxGenericConfig>:
{
 8001780:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001784:	4681      	mov	r9, r0
 8001786:	4688      	mov	r8, r1
 8001788:	4617      	mov	r7, r2
 800178a:	461e      	mov	r6, r3
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 800178c:	f7ff fde4 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 8001790:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_SET_RX_GENERIC_CONFIG_ID;
 8001792:	231d      	movs	r3, #29
 8001794:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001796:	6905      	ldr	r5, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 8001798:	f8c5 9000 	str.w	r9, [r5]
  com_buffer[i++] = (uint32_t) config;
 800179c:	f8c5 8004 	str.w	r8, [r5, #4]
  com_buffer[i++] = (uint32_t) rxContinuous;
 80017a0:	60af      	str	r7, [r5, #8]
  com_buffer[i++] = (uint32_t) symbTimeout;
 80017a2:	60ee      	str	r6, [r5, #12]
  com_obj->ParamCnt = i;
 80017a4:	2304      	movs	r3, #4
 80017a6:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80017a8:	f7ff fde2 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80017ac:	6960      	ldr	r0, [r4, #20]
 80017ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080017b2 <RadioIrqProcess>:
{
 80017b2:	b508      	push	{r3, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80017b4:	f7ff fdd0 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_IRQ_PROCESS_ID;
 80017b8:	2318      	movs	r3, #24
 80017ba:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 80017bc:	2300      	movs	r3, #0
 80017be:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80017c0:	f7ff fdd6 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80017c4:	bd08      	pop	{r3, pc}

080017c6 <RadioGetWakeUpTime>:
{
 80017c6:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80017c8:	f7ff fdc6 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 80017cc:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_GET_WAKEUP_TIME_ID;
 80017ce:	2317      	movs	r3, #23
 80017d0:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 80017d2:	2300      	movs	r3, #0
 80017d4:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80017d6:	f7ff fdcb 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80017da:	6960      	ldr	r0, [r4, #20]
 80017dc:	bd10      	pop	{r4, pc}

080017de <RadioStartCad>:
{
 80017de:	b508      	push	{r3, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80017e0:	f7ff fdba 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_START_CAD_ID;
 80017e4:	230e      	movs	r3, #14
 80017e6:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 80017e8:	2300      	movs	r3, #0
 80017ea:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80017ec:	f7ff fdc0 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80017f0:	bd08      	pop	{r3, pc}

080017f2 <RadioStandby>:
{
 80017f2:	b508      	push	{r3, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80017f4:	f7ff fdb0 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_STANDBY_ID;
 80017f8:	230c      	movs	r3, #12
 80017fa:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 80017fc:	2300      	movs	r3, #0
 80017fe:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001800:	f7ff fdb6 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001804:	bd08      	pop	{r3, pc}

08001806 <RadioSleep>:
{
 8001806:	b508      	push	{r3, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001808:	f7ff fda6 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SLEEP_ID;
 800180c:	230b      	movs	r3, #11
 800180e:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8001810:	2300      	movs	r3, #0
 8001812:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001814:	f7ff fdac 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001818:	bd08      	pop	{r3, pc}

0800181a <RadioRandom>:
{
 800181a:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 800181c:	f7ff fd9c 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 8001820:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_RANDOM_ID;
 8001822:	2305      	movs	r3, #5
 8001824:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8001826:	2300      	movs	r3, #0
 8001828:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 800182a:	f7ff fda1 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 800182e:	6960      	ldr	r0, [r4, #20]
 8001830:	bd10      	pop	{r4, pc}

08001832 <RadioGetStatus>:
{
 8001832:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001834:	f7ff fd90 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 8001838:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_GET_STATUS_ID;
 800183a:	2301      	movs	r3, #1
 800183c:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 800183e:	2300      	movs	r3, #0
 8001840:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001842:	f7ff fd95 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001846:	7d20      	ldrb	r0, [r4, #20]
 8001848:	bd10      	pop	{r4, pc}

0800184a <RadioTxCw>:
{
 800184a:	b510      	push	{r4, lr}
 800184c:	4604      	mov	r4, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 800184e:	f7ff fd83 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_TX_CW_ID;
 8001852:	231c      	movs	r3, #28
 8001854:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001856:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) power;
 8001858:	601c      	str	r4, [r3, #0]
  com_obj->ParamCnt = i;
 800185a:	2301      	movs	r3, #1
 800185c:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 800185e:	f7ff fd87 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001862:	bd10      	pop	{r4, pc}

08001864 <RadioTxPrbs>:
{
 8001864:	b508      	push	{r3, lr}
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001866:	f7ff fd77 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_TX_PRBS_ID;
 800186a:	231b      	movs	r3, #27
 800186c:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = i;
 800186e:	2300      	movs	r3, #0
 8001870:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001872:	f7ff fd7d 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001876:	bd08      	pop	{r3, pc}

08001878 <RadioSetRxDutyCycle>:
{
 8001878:	b538      	push	{r3, r4, r5, lr}
 800187a:	4605      	mov	r5, r0
 800187c:	460c      	mov	r4, r1
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 800187e:	f7ff fd6b 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_RX_DUTY_CYCLE_ID;
 8001882:	231a      	movs	r3, #26
 8001884:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001886:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) rxTime;
 8001888:	601d      	str	r5, [r3, #0]
  com_buffer[i++] = (uint32_t) sleepTime;
 800188a:	605c      	str	r4, [r3, #4]
  com_obj->ParamCnt = i;
 800188c:	2302      	movs	r3, #2
 800188e:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001890:	f7ff fd6e 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001894:	bd38      	pop	{r3, r4, r5, pc}

08001896 <RadioRxBoosted>:
{
 8001896:	b510      	push	{r4, lr}
 8001898:	4604      	mov	r4, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 800189a:	f7ff fd5d 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_RX_BOOSTED_ID;
 800189e:	2319      	movs	r3, #25
 80018a0:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 80018a2:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) timeout;
 80018a4:	601c      	str	r4, [r3, #0]
  com_obj->ParamCnt = i;
 80018a6:	2301      	movs	r3, #1
 80018a8:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80018aa:	f7ff fd61 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80018ae:	bd10      	pop	{r4, pc}

080018b0 <RadioSetPublicNetwork>:
{
 80018b0:	b510      	push	{r4, lr}
 80018b2:	4604      	mov	r4, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80018b4:	f7ff fd50 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_PUBLIC_NETWORK_ID;
 80018b8:	2316      	movs	r3, #22
 80018ba:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 80018bc:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) enable;
 80018be:	601c      	str	r4, [r3, #0]
  com_obj->ParamCnt = i;
 80018c0:	2301      	movs	r3, #1
 80018c2:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80018c4:	f7ff fd54 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80018c8:	bd10      	pop	{r4, pc}

080018ca <RadioSetMaxPayloadLength>:
{
 80018ca:	b538      	push	{r3, r4, r5, lr}
 80018cc:	4605      	mov	r5, r0
 80018ce:	460c      	mov	r4, r1
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80018d0:	f7ff fd42 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_MAX_PAYLOAD_LENGTH_ID;
 80018d4:	2315      	movs	r3, #21
 80018d6:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 80018d8:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 80018da:	601d      	str	r5, [r3, #0]
  com_buffer[i++] = (uint32_t) max;
 80018dc:	605c      	str	r4, [r3, #4]
  com_obj->ParamCnt = i;
 80018de:	2302      	movs	r3, #2
 80018e0:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80018e2:	f7ff fd45 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80018e6:	bd38      	pop	{r3, r4, r5, pc}

080018e8 <RadioReadRegisters>:
{
 80018e8:	b570      	push	{r4, r5, r6, lr}
 80018ea:	4606      	mov	r6, r0
 80018ec:	460d      	mov	r5, r1
 80018ee:	4614      	mov	r4, r2
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80018f0:	f7ff fd32 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_READ_BUFFER_ID;
 80018f4:	2314      	movs	r3, #20
 80018f6:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 80018f8:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) addr;
 80018fa:	601e      	str	r6, [r3, #0]
  com_buffer[i++] = (uint32_t) buffer;
 80018fc:	605d      	str	r5, [r3, #4]
  com_buffer[i++] = (uint32_t) size;
 80018fe:	609c      	str	r4, [r3, #8]
  com_obj->ParamCnt = i;
 8001900:	2303      	movs	r3, #3
 8001902:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001904:	f7ff fd34 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001908:	bd70      	pop	{r4, r5, r6, pc}

0800190a <RadioWriteRegisters>:
{
 800190a:	b570      	push	{r4, r5, r6, lr}
 800190c:	4606      	mov	r6, r0
 800190e:	460d      	mov	r5, r1
 8001910:	4614      	mov	r4, r2
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001912:	f7ff fd21 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_WRITE_BUFFER_ID;
 8001916:	2313      	movs	r3, #19
 8001918:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 800191a:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) addr;
 800191c:	601e      	str	r6, [r3, #0]
  com_buffer[i++] = (uint32_t) buffer;
 800191e:	605d      	str	r5, [r3, #4]
  com_buffer[i++] = (uint32_t) size;
 8001920:	609c      	str	r4, [r3, #8]
  com_obj->ParamCnt = i;
 8001922:	2303      	movs	r3, #3
 8001924:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001926:	f7ff fd23 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 800192a:	bd70      	pop	{r4, r5, r6, pc}

0800192c <RadioRead>:
{
 800192c:	b538      	push	{r3, r4, r5, lr}
 800192e:	4605      	mov	r5, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001930:	f7ff fd12 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 8001934:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_READ_ID;
 8001936:	2312      	movs	r3, #18
 8001938:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 800193a:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) addr;
 800193c:	601d      	str	r5, [r3, #0]
  com_obj->ParamCnt = i;
 800193e:	2301      	movs	r3, #1
 8001940:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001942:	f7ff fd15 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001946:	7d20      	ldrb	r0, [r4, #20]
 8001948:	bd38      	pop	{r3, r4, r5, pc}

0800194a <RadioWrite>:
{
 800194a:	b538      	push	{r3, r4, r5, lr}
 800194c:	4605      	mov	r5, r0
 800194e:	460c      	mov	r4, r1
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001950:	f7ff fd02 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_WRITE_ID;
 8001954:	2311      	movs	r3, #17
 8001956:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001958:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) addr;
 800195a:	601d      	str	r5, [r3, #0]
  com_buffer[i++] = (uint32_t) data;
 800195c:	605c      	str	r4, [r3, #4]
  com_obj->ParamCnt = i;
 800195e:	2302      	movs	r3, #2
 8001960:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001962:	f7ff fd05 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001966:	bd38      	pop	{r3, r4, r5, pc}

08001968 <RadioRssi>:
{
 8001968:	b538      	push	{r3, r4, r5, lr}
 800196a:	4605      	mov	r5, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 800196c:	f7ff fcf4 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 8001970:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_RSSI_ID;
 8001972:	2310      	movs	r3, #16
 8001974:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001976:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 8001978:	601d      	str	r5, [r3, #0]
  com_obj->ParamCnt = i;
 800197a:	2301      	movs	r3, #1
 800197c:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 800197e:	f7ff fcf7 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001982:	f9b4 0014 	ldrsh.w	r0, [r4, #20]
 8001986:	bd38      	pop	{r3, r4, r5, pc}

08001988 <RadioSetTxContinuousWave>:
{
 8001988:	b570      	push	{r4, r5, r6, lr}
 800198a:	4606      	mov	r6, r0
 800198c:	460d      	mov	r5, r1
 800198e:	4614      	mov	r4, r2
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001990:	f7ff fce2 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_TX_CONTINUOUS_WAVE_ID;
 8001994:	230f      	movs	r3, #15
 8001996:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001998:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) freq;
 800199a:	601e      	str	r6, [r3, #0]
  com_buffer[i++] = (uint32_t) power;
 800199c:	605d      	str	r5, [r3, #4]
  com_buffer[i++] = (uint32_t) time;
 800199e:	609c      	str	r4, [r3, #8]
  com_obj->ParamCnt = i;
 80019a0:	2303      	movs	r3, #3
 80019a2:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80019a4:	f7ff fce4 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80019a8:	bd70      	pop	{r4, r5, r6, pc}

080019aa <RadioRx>:
{
 80019aa:	b510      	push	{r4, lr}
 80019ac:	4604      	mov	r4, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80019ae:	f7ff fcd3 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_RX_ID;
 80019b2:	230d      	movs	r3, #13
 80019b4:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 80019b6:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) timeout;
 80019b8:	601c      	str	r4, [r3, #0]
  com_obj->ParamCnt = i;
 80019ba:	2301      	movs	r3, #1
 80019bc:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80019be:	f7ff fcd7 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80019c2:	bd10      	pop	{r4, pc}

080019c4 <RadioSend>:
{
 80019c4:	b570      	push	{r4, r5, r6, lr}
 80019c6:	4606      	mov	r6, r0
 80019c8:	460d      	mov	r5, r1
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80019ca:	f7ff fcc5 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 80019ce:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_SEND_ID;
 80019d0:	230a      	movs	r3, #10
 80019d2:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 80019d4:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) buffer;
 80019d6:	601e      	str	r6, [r3, #0]
  com_buffer[i++] = (uint32_t) size;
 80019d8:	605d      	str	r5, [r3, #4]
  com_obj->ParamCnt = i;
 80019da:	2302      	movs	r3, #2
 80019dc:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 80019de:	f7ff fcc7 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 80019e2:	7d20      	ldrb	r0, [r4, #20]
 80019e4:	bd70      	pop	{r4, r5, r6, pc}

080019e6 <RadioGetTimeOnAir>:
{
 80019e6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80019ea:	4681      	mov	r9, r0
 80019ec:	4688      	mov	r8, r1
 80019ee:	4617      	mov	r7, r2
 80019f0:	461e      	mov	r6, r3
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 80019f2:	f7ff fcb1 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 80019f6:	4605      	mov	r5, r0
  com_obj->MsgId = RADIO_GET_TIME_ON_AIR_ID;
 80019f8:	2309      	movs	r3, #9
 80019fa:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 80019fc:	6904      	ldr	r4, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 80019fe:	f8c4 9000 	str.w	r9, [r4]
  com_buffer[i++] = (uint32_t) bandwidth;
 8001a02:	f8c4 8004 	str.w	r8, [r4, #4]
  com_buffer[i++] = (uint32_t) spreadingFactor;
 8001a06:	60a7      	str	r7, [r4, #8]
  com_buffer[i++] = (uint32_t) coderate;
 8001a08:	60e6      	str	r6, [r4, #12]
  com_buffer[i++] = (uint32_t) preambleLen;
 8001a0a:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8001a0e:	6123      	str	r3, [r4, #16]
  com_buffer[i++] = (uint32_t) fixLen;
 8001a10:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 8001a14:	6163      	str	r3, [r4, #20]
  com_buffer[i++] = (uint32_t) payloadLen;
 8001a16:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 8001a1a:	61a3      	str	r3, [r4, #24]
  com_buffer[i++] = (uint32_t) crcOn;
 8001a1c:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 8001a20:	61e3      	str	r3, [r4, #28]
  com_obj->ParamCnt = i;
 8001a22:	2308      	movs	r3, #8
 8001a24:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001a26:	f7ff fca3 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001a2a:	6968      	ldr	r0, [r5, #20]
 8001a2c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08001a30 <RadioCheckRfFrequency>:
{
 8001a30:	b538      	push	{r3, r4, r5, lr}
 8001a32:	4605      	mov	r5, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001a34:	f7ff fc90 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 8001a38:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_CHECK_RF_FREQUENCY_ID;
 8001a3a:	2308      	movs	r3, #8
 8001a3c:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001a3e:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) frequency;
 8001a40:	601d      	str	r5, [r3, #0]
  com_obj->ParamCnt = i;
 8001a42:	2301      	movs	r3, #1
 8001a44:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001a46:	f7ff fc93 	bl	8001370 <MBMUXIF_RadioSendCmd>
  ret = com_obj->ReturnVal;
 8001a4a:	6960      	ldr	r0, [r4, #20]
}
 8001a4c:	3800      	subs	r0, #0
 8001a4e:	bf18      	it	ne
 8001a50:	2001      	movne	r0, #1
 8001a52:	bd38      	pop	{r3, r4, r5, pc}

08001a54 <RadioSetTxConfig>:
{
 8001a54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001a58:	4680      	mov	r8, r0
 8001a5a:	460f      	mov	r7, r1
 8001a5c:	4616      	mov	r6, r2
 8001a5e:	461d      	mov	r5, r3
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001a60:	f7ff fc7a 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_TX_CONFIG_ID;
 8001a64:	2307      	movs	r3, #7
 8001a66:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001a68:	6904      	ldr	r4, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 8001a6a:	f8c4 8000 	str.w	r8, [r4]
  com_buffer[i++] = (uint32_t) power;
 8001a6e:	6067      	str	r7, [r4, #4]
  com_buffer[i++] = (uint32_t) fdev;
 8001a70:	60a6      	str	r6, [r4, #8]
  com_buffer[i++] = (uint32_t) bandwidth;
 8001a72:	60e5      	str	r5, [r4, #12]
  com_buffer[i++] = (uint32_t) datarate;
 8001a74:	9b06      	ldr	r3, [sp, #24]
 8001a76:	6123      	str	r3, [r4, #16]
  com_buffer[i++] = (uint32_t) coderate;
 8001a78:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8001a7c:	6163      	str	r3, [r4, #20]
  com_buffer[i++] = (uint32_t) preambleLen;
 8001a7e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8001a82:	61a3      	str	r3, [r4, #24]
  com_buffer[i++] = (uint32_t) fixLen;
 8001a84:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 8001a88:	61e3      	str	r3, [r4, #28]
  com_buffer[i++] = (uint32_t) crcOn;
 8001a8a:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 8001a8e:	6223      	str	r3, [r4, #32]
  com_buffer[i++] = (uint32_t) freqHopOn;
 8001a90:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 8001a94:	6263      	str	r3, [r4, #36]	@ 0x24
  com_buffer[i++] = (uint32_t) hopPeriod;
 8001a96:	f89d 3030 	ldrb.w	r3, [sp, #48]	@ 0x30
 8001a9a:	62a3      	str	r3, [r4, #40]	@ 0x28
  com_buffer[i++] = (uint32_t) iqInverted;
 8001a9c:	f89d 3034 	ldrb.w	r3, [sp, #52]	@ 0x34
 8001aa0:	62e3      	str	r3, [r4, #44]	@ 0x2c
  com_buffer[i++] = (uint32_t) timeout;
 8001aa2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8001aa4:	6323      	str	r3, [r4, #48]	@ 0x30
  com_obj->ParamCnt = i;
 8001aa6:	230d      	movs	r3, #13
 8001aa8:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001aaa:	f7ff fc61 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001aae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001ab2 <RadioSetRxConfig>:
{
 8001ab2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001ab6:	4680      	mov	r8, r0
 8001ab8:	460f      	mov	r7, r1
 8001aba:	4616      	mov	r6, r2
 8001abc:	461d      	mov	r5, r3
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001abe:	f7ff fc4b 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_RX_CONFIG_ID;
 8001ac2:	2306      	movs	r3, #6
 8001ac4:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001ac6:	6904      	ldr	r4, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 8001ac8:	f8c4 8000 	str.w	r8, [r4]
  com_buffer[i++] = (uint32_t) bandwidth;
 8001acc:	6067      	str	r7, [r4, #4]
  com_buffer[i++] = (uint32_t) datarate;
 8001ace:	60a6      	str	r6, [r4, #8]
  com_buffer[i++] = (uint32_t) coderate;
 8001ad0:	60e5      	str	r5, [r4, #12]
  com_buffer[i++] = (uint32_t) bandwidthAfc;
 8001ad2:	9b06      	ldr	r3, [sp, #24]
 8001ad4:	6123      	str	r3, [r4, #16]
  com_buffer[i++] = (uint32_t) preambleLen;
 8001ad6:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8001ada:	6163      	str	r3, [r4, #20]
  com_buffer[i++] = (uint32_t) symbTimeout;
 8001adc:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8001ae0:	61a3      	str	r3, [r4, #24]
  com_buffer[i++] = (uint32_t) fixLen;
 8001ae2:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 8001ae6:	61e3      	str	r3, [r4, #28]
  com_buffer[i++] = (uint32_t) payloadLen;
 8001ae8:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 8001aec:	6223      	str	r3, [r4, #32]
  com_buffer[i++] = (uint32_t) crcOn;
 8001aee:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 8001af2:	6263      	str	r3, [r4, #36]	@ 0x24
  com_buffer[i++] = (uint32_t) freqHopOn;
 8001af4:	f89d 3030 	ldrb.w	r3, [sp, #48]	@ 0x30
 8001af8:	62a3      	str	r3, [r4, #40]	@ 0x28
  com_buffer[i++] = (uint32_t) hopPeriod;
 8001afa:	f89d 3034 	ldrb.w	r3, [sp, #52]	@ 0x34
 8001afe:	62e3      	str	r3, [r4, #44]	@ 0x2c
  com_buffer[i++] = (uint32_t) iqInverted;
 8001b00:	f89d 3038 	ldrb.w	r3, [sp, #56]	@ 0x38
 8001b04:	6323      	str	r3, [r4, #48]	@ 0x30
  com_buffer[i++] = (uint32_t) rxContinuous;
 8001b06:	f89d 303c 	ldrb.w	r3, [sp, #60]	@ 0x3c
 8001b0a:	6363      	str	r3, [r4, #52]	@ 0x34
  com_obj->ParamCnt = i;
 8001b0c:	230e      	movs	r3, #14
 8001b0e:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001b10:	f7ff fc2e 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001b14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001b18 <RadioIsChannelFree>:
{
 8001b18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001b1c:	4681      	mov	r9, r0
 8001b1e:	4688      	mov	r8, r1
 8001b20:	4617      	mov	r7, r2
 8001b22:	461e      	mov	r6, r3
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001b24:	f7ff fc18 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
 8001b28:	4604      	mov	r4, r0
  com_obj->MsgId = RADIO_IS_CHANNEL_FREE_ID;
 8001b2a:	2304      	movs	r3, #4
 8001b2c:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001b2e:	6905      	ldr	r5, [r0, #16]
  com_buffer[i++] = (uint32_t) freq;
 8001b30:	f8c5 9000 	str.w	r9, [r5]
  com_buffer[i++] = (uint32_t) rxBandwidth;
 8001b34:	f8c5 8004 	str.w	r8, [r5, #4]
  com_buffer[i++] = (uint32_t) rssiThresh;
 8001b38:	60af      	str	r7, [r5, #8]
  com_buffer[i++] = (uint32_t) maxCarrierSenseTime;
 8001b3a:	60ee      	str	r6, [r5, #12]
  com_obj->ParamCnt = i;
 8001b3c:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001b3e:	f7ff fc17 	bl	8001370 <MBMUXIF_RadioSendCmd>
  ret = com_obj->ReturnVal;
 8001b42:	6960      	ldr	r0, [r4, #20]
}
 8001b44:	3800      	subs	r0, #0
 8001b46:	bf18      	it	ne
 8001b48:	2001      	movne	r0, #1
 8001b4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08001b4e <RadioSetChannel>:
{
 8001b4e:	b510      	push	{r4, lr}
 8001b50:	4604      	mov	r4, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001b52:	f7ff fc01 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_CHANNEL_ID;
 8001b56:	2303      	movs	r3, #3
 8001b58:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001b5a:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) freq;
 8001b5c:	601c      	str	r4, [r3, #0]
  com_obj->ParamCnt = i;
 8001b5e:	2301      	movs	r3, #1
 8001b60:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001b62:	f7ff fc05 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001b66:	bd10      	pop	{r4, pc}

08001b68 <RadioSetModem>:
{
 8001b68:	b510      	push	{r4, lr}
 8001b6a:	4604      	mov	r4, r0
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001b6c:	f7ff fbf4 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_SET_MODEM_ID;
 8001b70:	2302      	movs	r3, #2
 8001b72:	6003      	str	r3, [r0, #0]
  com_buffer = com_obj->ParamBuf;
 8001b74:	6903      	ldr	r3, [r0, #16]
  com_buffer[i++] = (uint32_t) modem;
 8001b76:	601c      	str	r4, [r3, #0]
  com_obj->ParamCnt = i;
 8001b78:	2301      	movs	r3, #1
 8001b7a:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001b7c:	f7ff fbf8 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001b80:	bd10      	pop	{r4, pc}
	...

08001b84 <RadioInit>:
{
 8001b84:	b510      	push	{r4, lr}
  if (events == NULL)
 8001b86:	4604      	mov	r4, r0
 8001b88:	b1b0      	cbz	r0, 8001bb8 <RadioInit+0x34>
  radioevents_wrap.TxDone = events->TxDone;
 8001b8a:	6822      	ldr	r2, [r4, #0]
 8001b8c:	4b0c      	ldr	r3, [pc, #48]	@ (8001bc0 <RadioInit+0x3c>)
 8001b8e:	601a      	str	r2, [r3, #0]
  radioevents_wrap.TxTimeout = events->TxTimeout;
 8001b90:	6862      	ldr	r2, [r4, #4]
 8001b92:	605a      	str	r2, [r3, #4]
  radioevents_wrap.RxDone = events->RxDone;
 8001b94:	68a2      	ldr	r2, [r4, #8]
 8001b96:	609a      	str	r2, [r3, #8]
  radioevents_wrap.RxTimeout = events->RxTimeout;
 8001b98:	68e2      	ldr	r2, [r4, #12]
 8001b9a:	60da      	str	r2, [r3, #12]
  radioevents_wrap.RxError = events->RxError;
 8001b9c:	6922      	ldr	r2, [r4, #16]
 8001b9e:	611a      	str	r2, [r3, #16]
  radioevents_wrap.FhssChangeChannel = events->FhssChangeChannel;
 8001ba0:	6962      	ldr	r2, [r4, #20]
 8001ba2:	615a      	str	r2, [r3, #20]
  radioevents_wrap.CadDone = events->CadDone;
 8001ba4:	69a2      	ldr	r2, [r4, #24]
 8001ba6:	619a      	str	r2, [r3, #24]
  com_obj = MBMUXIF_GetRadioFeatureCmdComPtr();
 8001ba8:	f7ff fbd6 	bl	8001358 <MBMUXIF_GetRadioFeatureCmdComPtr>
  com_obj->MsgId = RADIO_INIT_ID;
 8001bac:	2300      	movs	r3, #0
 8001bae:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8001bb0:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendCmd();
 8001bb2:	f7ff fbdd 	bl	8001370 <MBMUXIF_RadioSendCmd>
}
 8001bb6:	bd10      	pop	{r4, pc}
    Error_Handler();
 8001bb8:	f7fe fddc 	bl	8000774 <Error_Handler>
 8001bbc:	e7e5      	b.n	8001b8a <RadioInit+0x6>
 8001bbe:	bf00      	nop
 8001bc0:	20000228 	.word	0x20000228

08001bc4 <Process_Radio_Notif>:
{
 8001bc4:	b570      	push	{r4, r5, r6, lr}
 8001bc6:	4604      	mov	r4, r0
  uint32_t *com_buffer = ComObj->ParamBuf;
 8001bc8:	6905      	ldr	r5, [r0, #16]
  APP_LOG(TS_ON, VLEVEL_H, "CM4<(Radio)\r\n");
 8001bca:	4b26      	ldr	r3, [pc, #152]	@ (8001c64 <Process_Radio_Notif+0xa0>)
 8001bcc:	2201      	movs	r2, #1
 8001bce:	2100      	movs	r1, #0
 8001bd0:	2003      	movs	r0, #3
 8001bd2:	f003 fec5 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  switch (ComObj->MsgId)
 8001bd6:	6823      	ldr	r3, [r4, #0]
 8001bd8:	3b1f      	subs	r3, #31
 8001bda:	2b04      	cmp	r3, #4
 8001bdc:	d80b      	bhi.n	8001bf6 <Process_Radio_Notif+0x32>
 8001bde:	e8df f003 	tbb	[pc, r3]
 8001be2:	1703      	.short	0x1703
 8001be4:	3022      	.short	0x3022
 8001be6:	38          	.byte	0x38
 8001be7:	00          	.byte	0x00
      if (radioevents_wrap.TxDone != NULL)
 8001be8:	4b1f      	ldr	r3, [pc, #124]	@ (8001c68 <Process_Radio_Notif+0xa4>)
 8001bea:	681b      	ldr	r3, [r3, #0]
 8001bec:	b16b      	cbz	r3, 8001c0a <Process_Radio_Notif+0x46>
        radioevents_wrap.TxDone();
 8001bee:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8001bf0:	2300      	movs	r3, #0
 8001bf2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal =  0; /* */
 8001bf4:	6163      	str	r3, [r4, #20]
  APP_LOG(TS_ON, VLEVEL_H, "CM4>(Radio)\r\n");
 8001bf6:	4b1d      	ldr	r3, [pc, #116]	@ (8001c6c <Process_Radio_Notif+0xa8>)
 8001bf8:	2201      	movs	r2, #1
 8001bfa:	2100      	movs	r1, #0
 8001bfc:	2003      	movs	r0, #3
 8001bfe:	f003 feaf 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_AcknowledgeSnd(FEAT_INFO_RADIO_ID);
 8001c02:	2007      	movs	r0, #7
 8001c04:	f7ff fb48 	bl	8001298 <MBMUX_AcknowledgeSnd>
}
 8001c08:	bd70      	pop	{r4, r5, r6, pc}
        Error_Handler();
 8001c0a:	f7fe fdb3 	bl	8000774 <Error_Handler>
 8001c0e:	e7ef      	b.n	8001bf0 <Process_Radio_Notif+0x2c>
      if (radioevents_wrap.TxTimeout != NULL)
 8001c10:	4b15      	ldr	r3, [pc, #84]	@ (8001c68 <Process_Radio_Notif+0xa4>)
 8001c12:	685b      	ldr	r3, [r3, #4]
 8001c14:	b123      	cbz	r3, 8001c20 <Process_Radio_Notif+0x5c>
        radioevents_wrap.TxTimeout();
 8001c16:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8001c18:	2300      	movs	r3, #0
 8001c1a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal =  0; /* */
 8001c1c:	6163      	str	r3, [r4, #20]
      break;
 8001c1e:	e7ea      	b.n	8001bf6 <Process_Radio_Notif+0x32>
        Error_Handler();
 8001c20:	f7fe fda8 	bl	8000774 <Error_Handler>
 8001c24:	e7f8      	b.n	8001c18 <Process_Radio_Notif+0x54>
      if (radioevents_wrap.RxDone != NULL)
 8001c26:	4b10      	ldr	r3, [pc, #64]	@ (8001c68 <Process_Radio_Notif+0xa4>)
 8001c28:	689e      	ldr	r6, [r3, #8]
 8001c2a:	b136      	cbz	r6, 8001c3a <Process_Radio_Notif+0x76>
        radioevents_wrap.RxDone((uint8_t *) com_buffer[0], (uint16_t) com_buffer[1], (int16_t) com_buffer[2],
 8001c2c:	f995 300c 	ldrsb.w	r3, [r5, #12]
 8001c30:	f9b5 2008 	ldrsh.w	r2, [r5, #8]
 8001c34:	88a9      	ldrh	r1, [r5, #4]
 8001c36:	6828      	ldr	r0, [r5, #0]
 8001c38:	47b0      	blx	r6
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8001c3a:	2300      	movs	r3, #0
 8001c3c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal =  0; /* */
 8001c3e:	6163      	str	r3, [r4, #20]
      break;
 8001c40:	e7d9      	b.n	8001bf6 <Process_Radio_Notif+0x32>
      if (radioevents_wrap.RxTimeout != NULL)
 8001c42:	4b09      	ldr	r3, [pc, #36]	@ (8001c68 <Process_Radio_Notif+0xa4>)
 8001c44:	68db      	ldr	r3, [r3, #12]
 8001c46:	b103      	cbz	r3, 8001c4a <Process_Radio_Notif+0x86>
        radioevents_wrap.RxTimeout();
 8001c48:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8001c4a:	2300      	movs	r3, #0
 8001c4c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal =  0; /* */
 8001c4e:	6163      	str	r3, [r4, #20]
      break;
 8001c50:	e7d1      	b.n	8001bf6 <Process_Radio_Notif+0x32>
      if (radioevents_wrap.RxError != NULL)
 8001c52:	4b05      	ldr	r3, [pc, #20]	@ (8001c68 <Process_Radio_Notif+0xa4>)
 8001c54:	691b      	ldr	r3, [r3, #16]
 8001c56:	b103      	cbz	r3, 8001c5a <Process_Radio_Notif+0x96>
        radioevents_wrap.RxError();
 8001c58:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8001c5a:	2300      	movs	r3, #0
 8001c5c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal =  0; /* */
 8001c5e:	6163      	str	r3, [r4, #20]
      break;
 8001c60:	e7c9      	b.n	8001bf6 <Process_Radio_Notif+0x32>
 8001c62:	bf00      	nop
 8001c64:	080066b4 	.word	0x080066b4
 8001c68:	20000228 	.word	0x20000228
 8001c6c:	080066c4 	.word	0x080066c4

08001c70 <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 8001c70:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001c72:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001c74:	3304      	adds	r3, #4

08001c76 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001c76:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001c78:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 8001c7a:	d3f9      	bcc.n	8001c70 <CopyDataInit>
  bx lr
 8001c7c:	4770      	bx	lr

08001c7e <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 8001c7e:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 8001c80:	3004      	adds	r0, #4

08001c82 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 8001c82:	4288      	cmp	r0, r1
  bcc FillZerobss
 8001c84:	d3fb      	bcc.n	8001c7e <FillZerobss>
  bx lr
 8001c86:	4770      	bx	lr

08001c88 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8001c88:	480e      	ldr	r0, [pc, #56]	@ (8001cc4 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8001c8a:	4685      	mov	sp, r0

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 8001c8c:	480e      	ldr	r0, [pc, #56]	@ (8001cc8 <LoopForever+0x6>)
 8001c8e:	490f      	ldr	r1, [pc, #60]	@ (8001ccc <LoopForever+0xa>)
 8001c90:	2300      	movs	r3, #0
 8001c92:	f7ff fff6 	bl	8001c82 <LoopFillZerobss>

/* Zero fill the MB_MEM1 segments. */
  INIT_BSS _sMB_MEM1, _eMB_MEM1
 8001c96:	480e      	ldr	r0, [pc, #56]	@ (8001cd0 <LoopForever+0xe>)
 8001c98:	490e      	ldr	r1, [pc, #56]	@ (8001cd4 <LoopForever+0x12>)
 8001c9a:	2300      	movs	r3, #0
 8001c9c:	f7ff fff1 	bl	8001c82 <LoopFillZerobss>

/* Zero fill the MAPPING_TABLE segments. */
  INIT_BSS _sMAPPING_TABLE, _eMAPPING_TABLE
 8001ca0:	480d      	ldr	r0, [pc, #52]	@ (8001cd8 <LoopForever+0x16>)
 8001ca2:	490e      	ldr	r1, [pc, #56]	@ (8001cdc <LoopForever+0x1a>)
 8001ca4:	2300      	movs	r3, #0
 8001ca6:	f7ff ffec 	bl	8001c82 <LoopFillZerobss>

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 8001caa:	480d      	ldr	r0, [pc, #52]	@ (8001ce0 <LoopForever+0x1e>)
 8001cac:	490d      	ldr	r1, [pc, #52]	@ (8001ce4 <LoopForever+0x22>)
 8001cae:	4a0e      	ldr	r2, [pc, #56]	@ (8001ce8 <LoopForever+0x26>)
 8001cb0:	2300      	movs	r3, #0
 8001cb2:	f7ff ffe0 	bl	8001c76 <LoopCopyDataInit>

/* Call the clock system initialization function.*/
  bl  SystemInit
 8001cb6:	f000 f9c1 	bl	800203c <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8001cba:	f004 fb3d 	bl	8006338 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8001cbe:	f7fe fda3 	bl	8000808 <main>

08001cc2 <LoopForever>:

LoopForever:
    b LoopForever
 8001cc2:	e7fe      	b.n	8001cc2 <LoopForever>
  ldr   r0, =_estack
 8001cc4:	20008000 	.word	0x20008000
  INIT_BSS _sbss, _ebss
 8001cc8:	20000018 	.word	0x20000018
 8001ccc:	200007d0 	.word	0x200007d0
  INIT_BSS _sMB_MEM1, _eMB_MEM1
 8001cd0:	20008140 	.word	0x20008140
 8001cd4:	200081f8 	.word	0x200081f8
  INIT_BSS _sMAPPING_TABLE, _eMAPPING_TABLE
 8001cd8:	20008000 	.word	0x20008000
 8001cdc:	20008140 	.word	0x20008140
  INIT_DATA _sdata, _edata, _sidata
 8001ce0:	20000000 	.word	0x20000000
 8001ce4:	20000018 	.word	0x20000018
 8001ce8:	080069b8 	.word	0x080069b8

08001cec <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001cec:	e7fe      	b.n	8001cec <ADC_IRQHandler>

08001cee <MX_SubGHz_Phy_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_SubGHz_Phy_Init(void)
{
 8001cee:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_SubGHz_Phy_Init_1 */

  /* USER CODE END MX_SubGHz_Phy_Init_1 */
  SystemApp_Init();
 8001cf0:	f7fe fe8e 	bl	8000a10 <SystemApp_Init>
  /* USER CODE BEGIN MX_SubGHz_Phy_Init_1_1 */

  /* USER CODE END MX_SubGHz_Phy_Init_1_1 */
  SubghzApp_Init();
 8001cf4:	f000 f8a0 	bl	8001e38 <SubghzApp_Init>
  /* USER CODE BEGIN MX_SubGHz_Phy_Init_2 */

  /* USER CODE END MX_SubGHz_Phy_Init_2 */
}
 8001cf8:	bd08      	pop	{r3, pc}

08001cfa <MX_SubGHz_Phy_Process>:

void MX_SubGHz_Phy_Process(void)
{
 8001cfa:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_SubGHz_Phy_Process_1 */

  /* USER CODE END MX_SubGHz_Phy_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 8001cfc:	f04f 30ff 	mov.w	r0, #4294967295
 8001d00:	f003 ffba 	bl	8005c78 <UTIL_SEQ_Run>
  /* USER CODE BEGIN MX_SubGHz_Phy_Process_2 */

  /* USER CODE END MX_SubGHz_Phy_Process_2 */
}
 8001d04:	bd08      	pop	{r3, pc}
	...

08001d08 <PingPong_Process>:
  /* USER CODE END OnRxError */
}

/* USER CODE BEGIN PrFD */
static void PingPong_Process(void)
{
 8001d08:	b508      	push	{r3, lr}
  Radio.Sleep();
 8001d0a:	4b16      	ldr	r3, [pc, #88]	@ (8001d64 <PingPong_Process+0x5c>)
 8001d0c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d0e:	4798      	blx	r3


  switch (BufferRx[0])
 8001d10:	4b15      	ldr	r3, [pc, #84]	@ (8001d68 <PingPong_Process+0x60>)
 8001d12:	781b      	ldrb	r3, [r3, #0]
 8001d14:	2b02      	cmp	r3, #2
 8001d16:	d012      	beq.n	8001d3e <PingPong_Process+0x36>
 8001d18:	2b03      	cmp	r3, #3
 8001d1a:	d019      	beq.n	8001d50 <PingPong_Process+0x48>
 8001d1c:	2b01      	cmp	r3, #1
 8001d1e:	d005      	beq.n	8001d2c <PingPong_Process+0x24>
     default:
       break;
   }

   // Mesajdan sonra tekrar dinlemeye ge
   Radio.Rx(RX_TIMEOUT_VALUE);
 8001d20:	4b10      	ldr	r3, [pc, #64]	@ (8001d64 <PingPong_Process+0x5c>)
 8001d22:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001d24:	f640 30b8 	movw	r0, #3000	@ 0xbb8
 8001d28:	4798      	blx	r3
//      Radio.Rx(RX_TIMEOUT_VALUE);
//      break;
//    default:
//      break;
//  }
}
 8001d2a:	bd08      	pop	{r3, pc}
       HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
 8001d2c:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8001d30:	480e      	ldr	r0, [pc, #56]	@ (8001d6c <PingPong_Process+0x64>)
 8001d32:	f001 f9a4 	bl	800307e <HAL_GPIO_TogglePin>
       BufferRx[0]=0;
 8001d36:	4b0c      	ldr	r3, [pc, #48]	@ (8001d68 <PingPong_Process+0x60>)
 8001d38:	2200      	movs	r2, #0
 8001d3a:	701a      	strb	r2, [r3, #0]
       break;
 8001d3c:	e7f0      	b.n	8001d20 <PingPong_Process+0x18>
         HAL_GPIO_TogglePin(LED1_GPIO_Port, LED2_Pin);
 8001d3e:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8001d42:	480a      	ldr	r0, [pc, #40]	@ (8001d6c <PingPong_Process+0x64>)
 8001d44:	f001 f99b 	bl	800307e <HAL_GPIO_TogglePin>
         BufferRx[0]=0;
 8001d48:	4b07      	ldr	r3, [pc, #28]	@ (8001d68 <PingPong_Process+0x60>)
 8001d4a:	2200      	movs	r2, #0
 8001d4c:	701a      	strb	r2, [r3, #0]
       break;
 8001d4e:	e7e7      	b.n	8001d20 <PingPong_Process+0x18>
         HAL_GPIO_TogglePin(LED1_GPIO_Port, LED3_Pin);
 8001d50:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8001d54:	4805      	ldr	r0, [pc, #20]	@ (8001d6c <PingPong_Process+0x64>)
 8001d56:	f001 f992 	bl	800307e <HAL_GPIO_TogglePin>
         BufferRx[0]=0;
 8001d5a:	4b03      	ldr	r3, [pc, #12]	@ (8001d68 <PingPong_Process+0x60>)
 8001d5c:	2200      	movs	r2, #0
 8001d5e:	701a      	strb	r2, [r3, #0]
       break;
 8001d60:	e7de      	b.n	8001d20 <PingPong_Process+0x18>
 8001d62:	bf00      	nop
 8001d64:	080066d4 	.word	0x080066d4
 8001d68:	20000350 	.word	0x20000350
 8001d6c:	48000400 	.word	0x48000400

08001d70 <OnRxError>:
{
 8001d70:	b508      	push	{r3, lr}
  APP_LOG(TS_ON, VLEVEL_L, "OnRxError\n\r");
 8001d72:	4b07      	ldr	r3, [pc, #28]	@ (8001d90 <OnRxError+0x20>)
 8001d74:	2201      	movs	r2, #1
 8001d76:	2100      	movs	r1, #0
 8001d78:	4610      	mov	r0, r2
 8001d7a:	f003 fdf1 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  State = RX_ERROR;
 8001d7e:	4b05      	ldr	r3, [pc, #20]	@ (8001d94 <OnRxError+0x24>)
 8001d80:	2202      	movs	r2, #2
 8001d82:	701a      	strb	r2, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_SubGHz_Phy_App_Process), CFG_SEQ_Prio_0);
 8001d84:	2100      	movs	r1, #0
 8001d86:	2001      	movs	r0, #1
 8001d88:	f003 ff36 	bl	8005bf8 <UTIL_SEQ_SetTask>
}
 8001d8c:	bd08      	pop	{r3, pc}
 8001d8e:	bf00      	nop
 8001d90:	08006760 	.word	0x08006760
 8001d94:	2000044f 	.word	0x2000044f

08001d98 <OnRxTimeout>:
{
 8001d98:	b508      	push	{r3, lr}
  APP_LOG(TS_ON, VLEVEL_L, "OnRxTimeout\n\r");
 8001d9a:	4b06      	ldr	r3, [pc, #24]	@ (8001db4 <OnRxTimeout+0x1c>)
 8001d9c:	2201      	movs	r2, #1
 8001d9e:	2100      	movs	r1, #0
 8001da0:	4610      	mov	r0, r2
 8001da2:	f003 fddd 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  State = RX_TIMEOUT;
 8001da6:	2001      	movs	r0, #1
 8001da8:	4b03      	ldr	r3, [pc, #12]	@ (8001db8 <OnRxTimeout+0x20>)
 8001daa:	7018      	strb	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_SubGHz_Phy_App_Process), CFG_SEQ_Prio_0);
 8001dac:	2100      	movs	r1, #0
 8001dae:	f003 ff23 	bl	8005bf8 <UTIL_SEQ_SetTask>
}
 8001db2:	bd08      	pop	{r3, pc}
 8001db4:	0800676c 	.word	0x0800676c
 8001db8:	2000044f 	.word	0x2000044f

08001dbc <OnTxTimeout>:
{
 8001dbc:	b508      	push	{r3, lr}
  APP_LOG(TS_ON, VLEVEL_L, "OnTxTimeout\n\r");
 8001dbe:	4b07      	ldr	r3, [pc, #28]	@ (8001ddc <OnTxTimeout+0x20>)
 8001dc0:	2201      	movs	r2, #1
 8001dc2:	2100      	movs	r1, #0
 8001dc4:	4610      	mov	r0, r2
 8001dc6:	f003 fdcb 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  State = TX_TIMEOUT;
 8001dca:	4b05      	ldr	r3, [pc, #20]	@ (8001de0 <OnTxTimeout+0x24>)
 8001dcc:	2204      	movs	r2, #4
 8001dce:	701a      	strb	r2, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_SubGHz_Phy_App_Process), CFG_SEQ_Prio_0);
 8001dd0:	2100      	movs	r1, #0
 8001dd2:	2001      	movs	r0, #1
 8001dd4:	f003 ff10 	bl	8005bf8 <UTIL_SEQ_SetTask>
}
 8001dd8:	bd08      	pop	{r3, pc}
 8001dda:	bf00      	nop
 8001ddc:	0800677c 	.word	0x0800677c
 8001de0:	2000044f 	.word	0x2000044f

08001de4 <OnRxDone>:
{
 8001de4:	b508      	push	{r3, lr}
	State = RX;
 8001de6:	4b07      	ldr	r3, [pc, #28]	@ (8001e04 <OnRxDone+0x20>)
 8001de8:	2200      	movs	r2, #0
 8001dea:	701a      	strb	r2, [r3, #0]
	RxBufferSize = size;
 8001dec:	4b06      	ldr	r3, [pc, #24]	@ (8001e08 <OnRxDone+0x24>)
 8001dee:	8019      	strh	r1, [r3, #0]
	  if (size >= 1)
 8001df0:	b111      	cbz	r1, 8001df8 <OnRxDone+0x14>
	    BufferRx[0] = payload[0];
 8001df2:	7802      	ldrb	r2, [r0, #0]
 8001df4:	4b05      	ldr	r3, [pc, #20]	@ (8001e0c <OnRxDone+0x28>)
 8001df6:	701a      	strb	r2, [r3, #0]
	  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_SubGHz_Phy_App_Process), CFG_SEQ_Prio_0);
 8001df8:	2100      	movs	r1, #0
 8001dfa:	2001      	movs	r0, #1
 8001dfc:	f003 fefc 	bl	8005bf8 <UTIL_SEQ_SetTask>
}
 8001e00:	bd08      	pop	{r3, pc}
 8001e02:	bf00      	nop
 8001e04:	2000044f 	.word	0x2000044f
 8001e08:	2000024c 	.word	0x2000024c
 8001e0c:	20000350 	.word	0x20000350

08001e10 <OnTxDone>:
{
 8001e10:	b508      	push	{r3, lr}
  APP_LOG(TS_ON, VLEVEL_L, "OnTxDone\n\r");
 8001e12:	4b07      	ldr	r3, [pc, #28]	@ (8001e30 <OnTxDone+0x20>)
 8001e14:	2201      	movs	r2, #1
 8001e16:	2100      	movs	r1, #0
 8001e18:	4610      	mov	r0, r2
 8001e1a:	f003 fda1 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  State = TX;
 8001e1e:	4b05      	ldr	r3, [pc, #20]	@ (8001e34 <OnTxDone+0x24>)
 8001e20:	2203      	movs	r2, #3
 8001e22:	701a      	strb	r2, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_SubGHz_Phy_App_Process), CFG_SEQ_Prio_0);
 8001e24:	2100      	movs	r1, #0
 8001e26:	2001      	movs	r0, #1
 8001e28:	f003 fee6 	bl	8005bf8 <UTIL_SEQ_SetTask>
}
 8001e2c:	bd08      	pop	{r3, pc}
 8001e2e:	bf00      	nop
 8001e30:	0800678c 	.word	0x0800678c
 8001e34:	2000044f 	.word	0x2000044f

08001e38 <SubghzApp_Init>:
{
 8001e38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001e3c:	b08b      	sub	sp, #44	@ 0x2c
  APP_LOG(TS_OFF, VLEVEL_M, "\n\rPING PONG\n\r");
 8001e3e:	4b58      	ldr	r3, [pc, #352]	@ (8001fa0 <SubghzApp_Init+0x168>)
 8001e40:	2200      	movs	r2, #0
 8001e42:	4611      	mov	r1, r2
 8001e44:	2002      	movs	r0, #2
 8001e46:	f003 fd8b 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "M4 APP_VERSION:      V%X.%X.%X\r\n",
 8001e4a:	2400      	movs	r4, #0
 8001e4c:	9402      	str	r4, [sp, #8]
 8001e4e:	2303      	movs	r3, #3
 8001e50:	9301      	str	r3, [sp, #4]
 8001e52:	2501      	movs	r5, #1
 8001e54:	9500      	str	r5, [sp, #0]
 8001e56:	4b53      	ldr	r3, [pc, #332]	@ (8001fa4 <SubghzApp_Init+0x16c>)
 8001e58:	4622      	mov	r2, r4
 8001e5a:	4621      	mov	r1, r4
 8001e5c:	2002      	movs	r0, #2
 8001e5e:	f003 fd7f 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  p_cm0plus_specific_features_info = MBMUXIF_SystemGetFeatCapabInfoPtr(FEAT_INFO_SYSTEM_ID);
 8001e62:	4620      	mov	r0, r4
 8001e64:	f7ff fbc4 	bl	80015f0 <MBMUXIF_SystemGetFeatCapabInfoPtr>
  feature_version = p_cm0plus_specific_features_info->Feat_Info_Feature_Version;
 8001e68:	6843      	ldr	r3, [r0, #4]
  APP_LOG(TS_OFF, VLEVEL_M, "M0PLUS_APP_VERSION:  V%X.%X.%X\r\n",
 8001e6a:	0e1a      	lsrs	r2, r3, #24
 8001e6c:	f3c3 2107 	ubfx	r1, r3, #8, #8
 8001e70:	9102      	str	r1, [sp, #8]
 8001e72:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8001e76:	9301      	str	r3, [sp, #4]
 8001e78:	9200      	str	r2, [sp, #0]
 8001e7a:	4b4b      	ldr	r3, [pc, #300]	@ (8001fa8 <SubghzApp_Init+0x170>)
 8001e7c:	4622      	mov	r2, r4
 8001e7e:	4621      	mov	r1, r4
 8001e80:	2002      	movs	r0, #2
 8001e82:	f003 fd6d 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  p_cm0plus_specific_features_info = MBMUXIF_SystemGetFeatCapabInfoPtr(FEAT_INFO_RADIO_ID);
 8001e86:	2007      	movs	r0, #7
 8001e88:	f7ff fbb2 	bl	80015f0 <MBMUXIF_SystemGetFeatCapabInfoPtr>
  feature_version = p_cm0plus_specific_features_info->Feat_Info_Feature_Version;
 8001e8c:	6843      	ldr	r3, [r0, #4]
  APP_LOG(TS_OFF, VLEVEL_M, "MW_RADIO_VERSION:    V%X.%X.%X\r\n",
 8001e8e:	0e1a      	lsrs	r2, r3, #24
 8001e90:	f3c3 2107 	ubfx	r1, r3, #8, #8
 8001e94:	9102      	str	r1, [sp, #8]
 8001e96:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8001e9a:	9301      	str	r3, [sp, #4]
 8001e9c:	9200      	str	r2, [sp, #0]
 8001e9e:	4b43      	ldr	r3, [pc, #268]	@ (8001fac <SubghzApp_Init+0x174>)
 8001ea0:	4622      	mov	r2, r4
 8001ea2:	4621      	mov	r1, r4
 8001ea4:	2002      	movs	r0, #2
 8001ea6:	f003 fd5b 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  RadioEvents.TxDone = OnTxDone;
 8001eaa:	4841      	ldr	r0, [pc, #260]	@ (8001fb0 <SubghzApp_Init+0x178>)
 8001eac:	4b41      	ldr	r3, [pc, #260]	@ (8001fb4 <SubghzApp_Init+0x17c>)
 8001eae:	6003      	str	r3, [r0, #0]
  RadioEvents.RxDone = OnRxDone;
 8001eb0:	4b41      	ldr	r3, [pc, #260]	@ (8001fb8 <SubghzApp_Init+0x180>)
 8001eb2:	6083      	str	r3, [r0, #8]
  RadioEvents.TxTimeout = OnTxTimeout;
 8001eb4:	4b41      	ldr	r3, [pc, #260]	@ (8001fbc <SubghzApp_Init+0x184>)
 8001eb6:	6043      	str	r3, [r0, #4]
  RadioEvents.RxTimeout = OnRxTimeout;
 8001eb8:	4b41      	ldr	r3, [pc, #260]	@ (8001fc0 <SubghzApp_Init+0x188>)
 8001eba:	60c3      	str	r3, [r0, #12]
  RadioEvents.RxError = OnRxError;
 8001ebc:	4b41      	ldr	r3, [pc, #260]	@ (8001fc4 <SubghzApp_Init+0x18c>)
 8001ebe:	6103      	str	r3, [r0, #16]
  Radio.Init(&RadioEvents);
 8001ec0:	4e41      	ldr	r6, [pc, #260]	@ (8001fc8 <SubghzApp_Init+0x190>)
 8001ec2:	6833      	ldr	r3, [r6, #0]
 8001ec4:	4798      	blx	r3
  random_delay = (Radio.Random()) >> 22; /*10bits random e.g. from 0 to 1023 ms*/
 8001ec6:	6973      	ldr	r3, [r6, #20]
 8001ec8:	4798      	blx	r3
 8001eca:	0d80      	lsrs	r0, r0, #22
 8001ecc:	4f3f      	ldr	r7, [pc, #252]	@ (8001fcc <SubghzApp_Init+0x194>)
 8001ece:	6038      	str	r0, [r7, #0]
  Radio.SetChannel(RF_FREQUENCY);
 8001ed0:	68f3      	ldr	r3, [r6, #12]
 8001ed2:	483f      	ldr	r0, [pc, #252]	@ (8001fd0 <SubghzApp_Init+0x198>)
 8001ed4:	4798      	blx	r3
  APP_LOG(TS_OFF, VLEVEL_M, "---------------\n\r");
 8001ed6:	4b3f      	ldr	r3, [pc, #252]	@ (8001fd4 <SubghzApp_Init+0x19c>)
 8001ed8:	4622      	mov	r2, r4
 8001eda:	4621      	mov	r1, r4
 8001edc:	2002      	movs	r0, #2
 8001ede:	f003 fd3f 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "LORA_MODULATION\n\r");
 8001ee2:	4b3d      	ldr	r3, [pc, #244]	@ (8001fd8 <SubghzApp_Init+0x1a0>)
 8001ee4:	4622      	mov	r2, r4
 8001ee6:	4621      	mov	r1, r4
 8001ee8:	2002      	movs	r0, #2
 8001eea:	f003 fd39 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "LORA_BW=%d kHz\n\r", (1 << LORA_BANDWIDTH) * 125);
 8001eee:	237d      	movs	r3, #125	@ 0x7d
 8001ef0:	9300      	str	r3, [sp, #0]
 8001ef2:	4b3a      	ldr	r3, [pc, #232]	@ (8001fdc <SubghzApp_Init+0x1a4>)
 8001ef4:	4622      	mov	r2, r4
 8001ef6:	4621      	mov	r1, r4
 8001ef8:	2002      	movs	r0, #2
 8001efa:	f003 fd31 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "LORA_SF=%d\n\r", LORA_SPREADING_FACTOR);
 8001efe:	f04f 0807 	mov.w	r8, #7
 8001f02:	f8cd 8000 	str.w	r8, [sp]
 8001f06:	4b36      	ldr	r3, [pc, #216]	@ (8001fe0 <SubghzApp_Init+0x1a8>)
 8001f08:	4622      	mov	r2, r4
 8001f0a:	4621      	mov	r1, r4
 8001f0c:	2002      	movs	r0, #2
 8001f0e:	f003 fd27 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  Radio.SetTxConfig(MODEM_LORA, TX_OUTPUT_POWER, 0, LORA_BANDWIDTH,
 8001f12:	f640 33b8 	movw	r3, #3000	@ 0xbb8
 8001f16:	9308      	str	r3, [sp, #32]
 8001f18:	9407      	str	r4, [sp, #28]
 8001f1a:	9406      	str	r4, [sp, #24]
 8001f1c:	9405      	str	r4, [sp, #20]
 8001f1e:	9504      	str	r5, [sp, #16]
 8001f20:	9403      	str	r4, [sp, #12]
 8001f22:	f04f 0908 	mov.w	r9, #8
 8001f26:	f8cd 9008 	str.w	r9, [sp, #8]
 8001f2a:	9501      	str	r5, [sp, #4]
 8001f2c:	f8cd 8000 	str.w	r8, [sp]
 8001f30:	4623      	mov	r3, r4
 8001f32:	4622      	mov	r2, r4
 8001f34:	210e      	movs	r1, #14
 8001f36:	4628      	mov	r0, r5
 8001f38:	f8d6 c01c 	ldr.w	ip, [r6, #28]
 8001f3c:	47e0      	blx	ip
  Radio.SetRxConfig(MODEM_LORA, LORA_BANDWIDTH, LORA_SPREADING_FACTOR,
 8001f3e:	9509      	str	r5, [sp, #36]	@ 0x24
 8001f40:	9408      	str	r4, [sp, #32]
 8001f42:	9407      	str	r4, [sp, #28]
 8001f44:	9406      	str	r4, [sp, #24]
 8001f46:	9505      	str	r5, [sp, #20]
 8001f48:	9404      	str	r4, [sp, #16]
 8001f4a:	9403      	str	r4, [sp, #12]
 8001f4c:	2305      	movs	r3, #5
 8001f4e:	9302      	str	r3, [sp, #8]
 8001f50:	f8cd 9004 	str.w	r9, [sp, #4]
 8001f54:	9400      	str	r4, [sp, #0]
 8001f56:	462b      	mov	r3, r5
 8001f58:	4642      	mov	r2, r8
 8001f5a:	4621      	mov	r1, r4
 8001f5c:	4628      	mov	r0, r5
 8001f5e:	f8d6 c018 	ldr.w	ip, [r6, #24]
 8001f62:	47e0      	blx	ip
  Radio.SetMaxPayloadLength(MODEM_LORA, MAX_APP_BUFFER_SIZE);
 8001f64:	6d73      	ldr	r3, [r6, #84]	@ 0x54
 8001f66:	21ff      	movs	r1, #255	@ 0xff
 8001f68:	4628      	mov	r0, r5
 8001f6a:	4798      	blx	r3
  memset(BufferTx, 0x0, MAX_APP_BUFFER_SIZE);
 8001f6c:	22ff      	movs	r2, #255	@ 0xff
 8001f6e:	4621      	mov	r1, r4
 8001f70:	481c      	ldr	r0, [pc, #112]	@ (8001fe4 <SubghzApp_Init+0x1ac>)
 8001f72:	f004 f9d9 	bl	8006328 <memset>
  APP_LOG(TS_ON, VLEVEL_L, "rand=%d\n\r", random_delay);
 8001f76:	683b      	ldr	r3, [r7, #0]
 8001f78:	9300      	str	r3, [sp, #0]
 8001f7a:	4b1b      	ldr	r3, [pc, #108]	@ (8001fe8 <SubghzApp_Init+0x1b0>)
 8001f7c:	462a      	mov	r2, r5
 8001f7e:	4621      	mov	r1, r4
 8001f80:	4628      	mov	r0, r5
 8001f82:	f003 fced 	bl	8005960 <UTIL_ADV_TRACE_COND_FSend>
  Radio.Rx(RX_TIMEOUT_VALUE + random_delay);
 8001f86:	6b73      	ldr	r3, [r6, #52]	@ 0x34
 8001f88:	6838      	ldr	r0, [r7, #0]
 8001f8a:	f600 30b8 	addw	r0, r0, #3000	@ 0xbb8
 8001f8e:	4798      	blx	r3
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_SubGHz_Phy_App_Process), UTIL_SEQ_RFU, PingPong_Process);
 8001f90:	4a16      	ldr	r2, [pc, #88]	@ (8001fec <SubghzApp_Init+0x1b4>)
 8001f92:	4621      	mov	r1, r4
 8001f94:	4628      	mov	r0, r5
 8001f96:	f003 ff31 	bl	8005dfc <UTIL_SEQ_RegTask>
}
 8001f9a:	b00b      	add	sp, #44	@ 0x2c
 8001f9c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001fa0:	08006798 	.word	0x08006798
 8001fa4:	080067a8 	.word	0x080067a8
 8001fa8:	080067cc 	.word	0x080067cc
 8001fac:	080067f0 	.word	0x080067f0
 8001fb0:	20000450 	.word	0x20000450
 8001fb4:	08001e11 	.word	0x08001e11
 8001fb8:	08001de5 	.word	0x08001de5
 8001fbc:	08001dbd 	.word	0x08001dbd
 8001fc0:	08001d99 	.word	0x08001d99
 8001fc4:	08001d71 	.word	0x08001d71
 8001fc8:	080066d4 	.word	0x080066d4
 8001fcc:	20000248 	.word	0x20000248
 8001fd0:	33bca100 	.word	0x33bca100
 8001fd4:	08006814 	.word	0x08006814
 8001fd8:	08006828 	.word	0x08006828
 8001fdc:	0800683c 	.word	0x0800683c
 8001fe0:	08006850 	.word	0x08006850
 8001fe4:	20000250 	.word	0x20000250
 8001fe8:	08006860 	.word	0x08006860
 8001fec:	08001d09 	.word	0x08001d09

08001ff0 <HAL_GPIO_EXTI_Callback>:
{
 8001ff0:	b508      	push	{r3, lr}
  if (GPIO_Pin == BUT1_Pin)
 8001ff2:	2801      	cmp	r0, #1
 8001ff4:	d007      	beq.n	8002006 <HAL_GPIO_EXTI_Callback+0x16>
  else if (GPIO_Pin == BUT2_Pin)
 8001ff6:	2802      	cmp	r0, #2
 8001ff8:	d016      	beq.n	8002028 <HAL_GPIO_EXTI_Callback+0x38>
  else if (GPIO_Pin == BUT3_Pin)
 8001ffa:	2840      	cmp	r0, #64	@ 0x40
 8001ffc:	d10a      	bne.n	8002014 <HAL_GPIO_EXTI_Callback+0x24>
	  BufferButtonTx[0] = 0x03;
 8001ffe:	4b0c      	ldr	r3, [pc, #48]	@ (8002030 <HAL_GPIO_EXTI_Callback+0x40>)
 8002000:	2203      	movs	r2, #3
 8002002:	701a      	strb	r2, [r3, #0]
 8002004:	e006      	b.n	8002014 <HAL_GPIO_EXTI_Callback+0x24>
	  BufferButtonTx[0] = 0x01;
 8002006:	4b0a      	ldr	r3, [pc, #40]	@ (8002030 <HAL_GPIO_EXTI_Callback+0x40>)
 8002008:	2201      	movs	r2, #1
 800200a:	701a      	strb	r2, [r3, #0]
	  buttonCounter++;
 800200c:	4a09      	ldr	r2, [pc, #36]	@ (8002034 <HAL_GPIO_EXTI_Callback+0x44>)
 800200e:	8813      	ldrh	r3, [r2, #0]
 8002010:	3301      	adds	r3, #1
 8002012:	8013      	strh	r3, [r2, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_SubGHz_Phy_App_Process), CFG_SEQ_Prio_0);
 8002014:	2100      	movs	r1, #0
 8002016:	2001      	movs	r0, #1
 8002018:	f003 fdee 	bl	8005bf8 <UTIL_SEQ_SetTask>
  Radio.Send(BufferButtonTx, 1); // 1 byte gnder
 800201c:	4b06      	ldr	r3, [pc, #24]	@ (8002038 <HAL_GPIO_EXTI_Callback+0x48>)
 800201e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002020:	2101      	movs	r1, #1
 8002022:	4803      	ldr	r0, [pc, #12]	@ (8002030 <HAL_GPIO_EXTI_Callback+0x40>)
 8002024:	4798      	blx	r3
}
 8002026:	bd08      	pop	{r3, pc}
	  BufferButtonTx[0] = 0x02;
 8002028:	4b01      	ldr	r3, [pc, #4]	@ (8002030 <HAL_GPIO_EXTI_Callback+0x40>)
 800202a:	2202      	movs	r2, #2
 800202c:	701a      	strb	r2, [r3, #0]
 800202e:	e7f1      	b.n	8002014 <HAL_GPIO_EXTI_Callback+0x24>
 8002030:	20000248 	.word	0x20000248
 8002034:	20000244 	.word	0x20000244
 8002038:	080066d4 	.word	0x080066d4

0800203c <SystemInit>:

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 800203c:	4770      	bx	lr
	...

08002040 <HAL_InitTick>:
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  HAL_StatusTypeDef  status = HAL_OK;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 8002040:	4b11      	ldr	r3, [pc, #68]	@ (8002088 <HAL_InitTick+0x48>)
 8002042:	781b      	ldrb	r3, [r3, #0]
 8002044:	b90b      	cbnz	r3, 800204a <HAL_InitTick+0xa>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 8002046:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8002048:	4770      	bx	lr
{
 800204a:	b510      	push	{r4, lr}
 800204c:	4604      	mov	r4, r0
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 800204e:	f001 fabb 	bl	80035c8 <HAL_RCC_GetHCLKFreq>
 8002052:	4b0d      	ldr	r3, [pc, #52]	@ (8002088 <HAL_InitTick+0x48>)
 8002054:	781a      	ldrb	r2, [r3, #0]
 8002056:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800205a:	fbb3 f3f2 	udiv	r3, r3, r2
 800205e:	fbb0 f0f3 	udiv	r0, r0, r3
 8002062:	f000 f8db 	bl	800221c <HAL_SYSTICK_Config>
 8002066:	b968      	cbnz	r0, 8002084 <HAL_InitTick+0x44>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8002068:	2c0f      	cmp	r4, #15
 800206a:	d901      	bls.n	8002070 <HAL_InitTick+0x30>
        status = HAL_ERROR;
 800206c:	2001      	movs	r0, #1
 800206e:	e00a      	b.n	8002086 <HAL_InitTick+0x46>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8002070:	2200      	movs	r2, #0
 8002072:	4621      	mov	r1, r4
 8002074:	f04f 30ff 	mov.w	r0, #4294967295
 8002078:	f000 f8b8 	bl	80021ec <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800207c:	4b03      	ldr	r3, [pc, #12]	@ (800208c <HAL_InitTick+0x4c>)
 800207e:	601c      	str	r4, [r3, #0]
  HAL_StatusTypeDef  status = HAL_OK;
 8002080:	2000      	movs	r0, #0
 8002082:	e000      	b.n	8002086 <HAL_InitTick+0x46>
      status = HAL_ERROR;
 8002084:	2001      	movs	r0, #1
}
 8002086:	bd10      	pop	{r4, pc}
 8002088:	20000008 	.word	0x20000008
 800208c:	2000000c 	.word	0x2000000c

08002090 <HAL_Init>:
{
 8002090:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002092:	2003      	movs	r0, #3
 8002094:	f000 f898 	bl	80021c8 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8002098:	f001 fa96 	bl	80035c8 <HAL_RCC_GetHCLKFreq>
 800209c:	4b06      	ldr	r3, [pc, #24]	@ (80020b8 <HAL_Init+0x28>)
 800209e:	6018      	str	r0, [r3, #0]
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80020a0:	200f      	movs	r0, #15
 80020a2:	f7ff ffcd 	bl	8002040 <HAL_InitTick>
 80020a6:	b110      	cbz	r0, 80020ae <HAL_Init+0x1e>
    status = HAL_ERROR;
 80020a8:	2401      	movs	r4, #1
}
 80020aa:	4620      	mov	r0, r4
 80020ac:	bd10      	pop	{r4, pc}
 80020ae:	4604      	mov	r4, r0
    HAL_MspInit();
 80020b0:	f7fe fbd6 	bl	8000860 <HAL_MspInit>
 80020b4:	e7f9      	b.n	80020aa <HAL_Init+0x1a>
 80020b6:	bf00      	nop
 80020b8:	20000004 	.word	0x20000004

080020bc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 80020bc:	4b03      	ldr	r3, [pc, #12]	@ (80020cc <HAL_IncTick+0x10>)
 80020be:	781b      	ldrb	r3, [r3, #0]
 80020c0:	4a03      	ldr	r2, [pc, #12]	@ (80020d0 <HAL_IncTick+0x14>)
 80020c2:	6811      	ldr	r1, [r2, #0]
 80020c4:	440b      	add	r3, r1
 80020c6:	6013      	str	r3, [r2, #0]
}
 80020c8:	4770      	bx	lr
 80020ca:	bf00      	nop
 80020cc:	20000008 	.word	0x20000008
 80020d0:	2000046c 	.word	0x2000046c

080020d4 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 80020d4:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 80020d8:	6913      	ldr	r3, [r2, #16]
 80020da:	f023 0302 	bic.w	r3, r3, #2
 80020de:	6113      	str	r3, [r2, #16]
}
 80020e0:	4770      	bx	lr

080020e2 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 80020e2:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 80020e6:	6913      	ldr	r3, [r2, #16]
 80020e8:	f043 0302 	orr.w	r3, r3, #2
 80020ec:	6113      	str	r3, [r2, #16]
}
 80020ee:	4770      	bx	lr

080020f0 <HAL_DBGMCU_EnableDBGSleepMode>:
  * @rmtoll DBGMCU_CR    DBG_SLEEP     LL_DBGMCU_EnableDBGSleepMode
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 80020f0:	4a02      	ldr	r2, [pc, #8]	@ (80020fc <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 80020f2:	6853      	ldr	r3, [r2, #4]
 80020f4:	f043 0301 	orr.w	r3, r3, #1
 80020f8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  LL_DBGMCU_EnableDBGSleepMode();
}
 80020fa:	4770      	bx	lr
 80020fc:	e0042000 	.word	0xe0042000

08002100 <HAL_DBGMCU_EnableDBGStopMode>:
  * @rmtoll DBGMCU_CR    DBG_STOP      LL_DBGMCU_EnableDBGStopMode
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8002100:	4a02      	ldr	r2, [pc, #8]	@ (800210c <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 8002102:	6853      	ldr	r3, [r2, #4]
 8002104:	f043 0302 	orr.w	r3, r3, #2
 8002108:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  LL_DBGMCU_EnableDBGStopMode();
}
 800210a:	4770      	bx	lr
 800210c:	e0042000 	.word	0xe0042000

08002110 <HAL_DBGMCU_EnableDBGStandbyMode>:
  * @rmtoll DBGMCU_CR    DBG_STANDBY   LL_DBGMCU_EnableDBGStandbyMode
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8002110:	4a02      	ldr	r2, [pc, #8]	@ (800211c <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 8002112:	6853      	ldr	r3, [r2, #4]
 8002114:	f043 0304 	orr.w	r3, r3, #4
 8002118:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  LL_DBGMCU_EnableDBGStandbyMode();
}
 800211a:	4770      	bx	lr
 800211c:	e0042000 	.word	0xe0042000

08002120 <__NVIC_EnableIRQ>:
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8002120:	2800      	cmp	r0, #0
 8002122:	db07      	blt.n	8002134 <__NVIC_EnableIRQ+0x14>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002124:	f000 021f 	and.w	r2, r0, #31
 8002128:	0940      	lsrs	r0, r0, #5
 800212a:	2301      	movs	r3, #1
 800212c:	4093      	lsls	r3, r2
 800212e:	4a02      	ldr	r2, [pc, #8]	@ (8002138 <__NVIC_EnableIRQ+0x18>)
 8002130:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8002134:	4770      	bx	lr
 8002136:	bf00      	nop
 8002138:	e000e100 	.word	0xe000e100

0800213c <__NVIC_DisableIRQ>:
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 800213c:	2800      	cmp	r0, #0
 800213e:	db0c      	blt.n	800215a <__NVIC_DisableIRQ+0x1e>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002140:	f000 021f 	and.w	r2, r0, #31
 8002144:	0940      	lsrs	r0, r0, #5
 8002146:	2301      	movs	r3, #1
 8002148:	4093      	lsls	r3, r2
 800214a:	3020      	adds	r0, #32
 800214c:	4a03      	ldr	r2, [pc, #12]	@ (800215c <__NVIC_DisableIRQ+0x20>)
 800214e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8002152:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002156:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
 800215a:	4770      	bx	lr
 800215c:	e000e100 	.word	0xe000e100

08002160 <__NVIC_SetPriority>:
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8002160:	2800      	cmp	r0, #0
 8002162:	db08      	blt.n	8002176 <__NVIC_SetPriority+0x16>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002164:	0109      	lsls	r1, r1, #4
 8002166:	b2c9      	uxtb	r1, r1
 8002168:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 800216c:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 8002170:	f880 1300 	strb.w	r1, [r0, #768]	@ 0x300
 8002174:	4770      	bx	lr
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002176:	f000 000f 	and.w	r0, r0, #15
 800217a:	0109      	lsls	r1, r1, #4
 800217c:	b2c9      	uxtb	r1, r1
 800217e:	4b01      	ldr	r3, [pc, #4]	@ (8002184 <__NVIC_SetPriority+0x24>)
 8002180:	5419      	strb	r1, [r3, r0]
  }
}
 8002182:	4770      	bx	lr
 8002184:	e000ed14 	.word	0xe000ed14

08002188 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8002188:	b500      	push	{lr}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800218a:	f000 0007 	and.w	r0, r0, #7
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800218e:	f1c0 0c07 	rsb	ip, r0, #7
 8002192:	f1bc 0f04 	cmp.w	ip, #4
 8002196:	bf28      	it	cs
 8002198:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800219c:	1d03      	adds	r3, r0, #4
 800219e:	2b06      	cmp	r3, #6
 80021a0:	d90f      	bls.n	80021c2 <NVIC_EncodePriority+0x3a>
 80021a2:	1ec3      	subs	r3, r0, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80021a4:	f04f 3eff 	mov.w	lr, #4294967295
 80021a8:	fa0e f00c 	lsl.w	r0, lr, ip
 80021ac:	ea21 0100 	bic.w	r1, r1, r0
 80021b0:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80021b2:	fa0e fe03 	lsl.w	lr, lr, r3
 80021b6:	ea22 020e 	bic.w	r2, r2, lr
         );
}
 80021ba:	ea41 0002 	orr.w	r0, r1, r2
 80021be:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80021c2:	2300      	movs	r3, #0
 80021c4:	e7ee      	b.n	80021a4 <NVIC_EncodePriority+0x1c>
	...

080021c8 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80021c8:	4a07      	ldr	r2, [pc, #28]	@ (80021e8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80021ca:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80021cc:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 80021d0:	041b      	lsls	r3, r3, #16
 80021d2:	0c1b      	lsrs	r3, r3, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80021d4:	0200      	lsls	r0, r0, #8
 80021d6:	f400 60e0 	and.w	r0, r0, #1792	@ 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80021da:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 80021dc:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 80021e0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 80021e4:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80021e6:	4770      	bx	lr
 80021e8:	e000ed00 	.word	0xe000ed00

080021ec <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80021ec:	b510      	push	{r4, lr}
 80021ee:	4604      	mov	r4, r0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80021f0:	4b05      	ldr	r3, [pc, #20]	@ (8002208 <HAL_NVIC_SetPriority+0x1c>)
 80021f2:	68d8      	ldr	r0, [r3, #12]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80021f4:	f3c0 2002 	ubfx	r0, r0, #8, #3
 80021f8:	f7ff ffc6 	bl	8002188 <NVIC_EncodePriority>
 80021fc:	4601      	mov	r1, r0
 80021fe:	4620      	mov	r0, r4
 8002200:	f7ff ffae 	bl	8002160 <__NVIC_SetPriority>
}
 8002204:	bd10      	pop	{r4, pc}
 8002206:	bf00      	nop
 8002208:	e000ed00 	.word	0xe000ed00

0800220c <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *          to the appropriate CMSIS device file (stm32wlxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800220c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800220e:	f7ff ff87 	bl	8002120 <__NVIC_EnableIRQ>
}
 8002212:	bd08      	pop	{r3, pc}

08002214 <HAL_NVIC_DisableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *          to the appropriate CMSIS device file (stm32wlxxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8002214:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 8002216:	f7ff ff91 	bl	800213c <__NVIC_DisableIRQ>
}
 800221a:	bd08      	pop	{r3, pc}

0800221c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800221c:	3801      	subs	r0, #1
 800221e:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 8002222:	d20b      	bcs.n	800223c <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002224:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8002228:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800222a:	4a05      	ldr	r2, [pc, #20]	@ (8002240 <HAL_SYSTICK_Config+0x24>)
 800222c:	21f0      	movs	r1, #240	@ 0xf0
 800222e:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002232:	2000      	movs	r0, #0
 8002234:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002236:	2207      	movs	r2, #7
 8002238:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800223a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800223c:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
 800223e:	4770      	bx	lr
 8002240:	e000ed00 	.word	0xe000ed00

08002244 <DMA_SetConfig>:
  * @param DstAddress The destination memory Buffer address
  * @param DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8002244:	b410      	push	{r4}
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8002246:	6cc4      	ldr	r4, [r0, #76]	@ 0x4c
 8002248:	f8d0 c050 	ldr.w	ip, [r0, #80]	@ 0x50
 800224c:	f8c4 c004 	str.w	ip, [r4, #4]

  if (hdma->DMAmuxRequestGen != NULL)
 8002250:	6d44      	ldr	r4, [r0, #84]	@ 0x54
 8002252:	b124      	cbz	r4, 800225e <DMA_SetConfig+0x1a>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8002254:	6d84      	ldr	r4, [r0, #88]	@ 0x58
 8002256:	f8d0 c05c 	ldr.w	ip, [r0, #92]	@ 0x5c
 800225a:	f8c4 c004 	str.w	ip, [r4, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800225e:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 8002260:	f004 0c1c 	and.w	ip, r4, #28
 8002264:	2401      	movs	r4, #1
 8002266:	fa04 f40c 	lsl.w	r4, r4, ip
 800226a:	f8d0 c040 	ldr.w	ip, [r0, #64]	@ 0x40
 800226e:	f8cc 4004 	str.w	r4, [ip, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 8002272:	6804      	ldr	r4, [r0, #0]
 8002274:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8002276:	6883      	ldr	r3, [r0, #8]
 8002278:	2b10      	cmp	r3, #16
 800227a:	d005      	beq.n	8002288 <DMA_SetConfig+0x44>
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 800227c:	6803      	ldr	r3, [r0, #0]
 800227e:	6099      	str	r1, [r3, #8]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 8002280:	6803      	ldr	r3, [r0, #0]
 8002282:	60da      	str	r2, [r3, #12]
  }
}
 8002284:	bc10      	pop	{r4}
 8002286:	4770      	bx	lr
    hdma->Instance->CPAR = DstAddress;
 8002288:	6803      	ldr	r3, [r0, #0]
 800228a:	609a      	str	r2, [r3, #8]
    hdma->Instance->CMAR = SrcAddress;
 800228c:	6803      	ldr	r3, [r0, #0]
 800228e:	60d9      	str	r1, [r3, #12]
 8002290:	e7f8      	b.n	8002284 <DMA_SetConfig+0x40>
	...

08002294 <DMA_CalcDMAMUXChannelBaseAndMask>:
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8002294:	6803      	ldr	r3, [r0, #0]
 8002296:	4a14      	ldr	r2, [pc, #80]	@ (80022e8 <DMA_CalcDMAMUXChannelBaseAndMask+0x54>)
 8002298:	4293      	cmp	r3, r2
 800229a:	d816      	bhi.n	80022ca <DMA_CalcDMAMUXChannelBaseAndMask+0x36>
  {
    /* DMA1 */
    /* Associate a DMA Channel to a DMAMUX channel */
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 800229c:	6c42      	ldr	r2, [r0, #68]	@ 0x44
 800229e:	f022 0203 	bic.w	r2, r2, #3
 80022a2:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 80022a6:	f502 3202 	add.w	r2, r2, #133120	@ 0x20800
 80022aa:	6482      	str	r2, [r0, #72]	@ 0x48

    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 80022ac:	b2db      	uxtb	r3, r3
 80022ae:	3b08      	subs	r3, #8
 80022b0:	4a0e      	ldr	r2, [pc, #56]	@ (80022ec <DMA_CalcDMAMUXChannelBaseAndMask+0x58>)
 80022b2:	fba2 2303 	umull	r2, r3, r2, r3
 80022b6:	091b      	lsrs	r3, r3, #4
    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
  }

  /* Initialize the field DMAmuxChannelStatus to DMAMUX1_ChannelStatus base */
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80022b8:	4a0d      	ldr	r2, [pc, #52]	@ (80022f0 <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>)
 80022ba:	64c2      	str	r2, [r0, #76]	@ 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80022bc:	f003 031f 	and.w	r3, r3, #31
 80022c0:	2201      	movs	r2, #1
 80022c2:	fa02 f303 	lsl.w	r3, r2, r3
 80022c6:	6503      	str	r3, [r0, #80]	@ 0x50
}
 80022c8:	4770      	bx	lr
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 80022ca:	6c42      	ldr	r2, [r0, #68]	@ 0x44
 80022cc:	f022 0103 	bic.w	r1, r2, #3
 80022d0:	4a08      	ldr	r2, [pc, #32]	@ (80022f4 <DMA_CalcDMAMUXChannelBaseAndMask+0x60>)
 80022d2:	440a      	add	r2, r1
 80022d4:	6482      	str	r2, [r0, #72]	@ 0x48
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 80022d6:	b2db      	uxtb	r3, r3
 80022d8:	3b08      	subs	r3, #8
 80022da:	4a04      	ldr	r2, [pc, #16]	@ (80022ec <DMA_CalcDMAMUXChannelBaseAndMask+0x58>)
 80022dc:	fba2 2303 	umull	r2, r3, r2, r3
 80022e0:	091b      	lsrs	r3, r3, #4
 80022e2:	3307      	adds	r3, #7
 80022e4:	e7e8      	b.n	80022b8 <DMA_CalcDMAMUXChannelBaseAndMask+0x24>
 80022e6:	bf00      	nop
 80022e8:	40020407 	.word	0x40020407
 80022ec:	cccccccd 	.word	0xcccccccd
 80022f0:	40020880 	.word	0x40020880
 80022f4:	4002081c 	.word	0x4002081c

080022f8 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @retval None
  */

static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 80022f8:	6843      	ldr	r3, [r0, #4]
 80022fa:	f003 037f 	and.w	r3, r3, #127	@ 0x7f

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80022fe:	4a07      	ldr	r2, [pc, #28]	@ (800231c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x24>)
 8002300:	441a      	add	r2, r3
 8002302:	0092      	lsls	r2, r2, #2
 8002304:	6542      	str	r2, [r0, #84]	@ 0x54

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8002306:	4a06      	ldr	r2, [pc, #24]	@ (8002320 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x28>)
 8002308:	6582      	str	r2, [r0, #88]	@ 0x58

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 800230a:	3b01      	subs	r3, #1
 800230c:	f003 0303 	and.w	r3, r3, #3
 8002310:	2201      	movs	r2, #1
 8002312:	fa02 f303 	lsl.w	r3, r2, r3
 8002316:	65c3      	str	r3, [r0, #92]	@ 0x5c
}
 8002318:	4770      	bx	lr
 800231a:	bf00      	nop
 800231c:	1000823f 	.word	0x1000823f
 8002320:	40020940 	.word	0x40020940

08002324 <HAL_DMA_Init>:
  if (hdma == NULL)
 8002324:	2800      	cmp	r0, #0
 8002326:	d060      	beq.n	80023ea <HAL_DMA_Init+0xc6>
{
 8002328:	b510      	push	{r4, lr}
 800232a:	4604      	mov	r4, r0
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800232c:	6802      	ldr	r2, [r0, #0]
 800232e:	4b30      	ldr	r3, [pc, #192]	@ (80023f0 <HAL_DMA_Init+0xcc>)
 8002330:	429a      	cmp	r2, r3
 8002332:	d842      	bhi.n	80023ba <HAL_DMA_Init+0x96>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8002334:	4b2f      	ldr	r3, [pc, #188]	@ (80023f4 <HAL_DMA_Init+0xd0>)
 8002336:	4413      	add	r3, r2
 8002338:	492f      	ldr	r1, [pc, #188]	@ (80023f8 <HAL_DMA_Init+0xd4>)
 800233a:	fba1 1303 	umull	r1, r3, r1, r3
 800233e:	091b      	lsrs	r3, r3, #4
 8002340:	009b      	lsls	r3, r3, #2
 8002342:	6443      	str	r3, [r0, #68]	@ 0x44
    hdma->DmaBaseAddress = DMA1;
 8002344:	4b2d      	ldr	r3, [pc, #180]	@ (80023fc <HAL_DMA_Init+0xd8>)
 8002346:	6403      	str	r3, [r0, #64]	@ 0x40
  hdma->State = HAL_DMA_STATE_BUSY;
 8002348:	2302      	movs	r3, #2
 800234a:	f884 3025 	strb.w	r3, [r4, #37]	@ 0x25
  CLEAR_BIT(hdma->Instance->CCR, (DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 800234e:	6813      	ldr	r3, [r2, #0]
 8002350:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
 8002354:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8002358:	6013      	str	r3, [r2, #0]
  SET_BIT(hdma->Instance->CCR, (hdma->Init.Direction           |                               \
 800235a:	6821      	ldr	r1, [r4, #0]
 800235c:	680a      	ldr	r2, [r1, #0]
 800235e:	68a3      	ldr	r3, [r4, #8]
 8002360:	68e0      	ldr	r0, [r4, #12]
 8002362:	4303      	orrs	r3, r0
 8002364:	6920      	ldr	r0, [r4, #16]
 8002366:	4303      	orrs	r3, r0
 8002368:	6960      	ldr	r0, [r4, #20]
 800236a:	4303      	orrs	r3, r0
 800236c:	69a0      	ldr	r0, [r4, #24]
 800236e:	4303      	orrs	r3, r0
 8002370:	69e0      	ldr	r0, [r4, #28]
 8002372:	4303      	orrs	r3, r0
 8002374:	6a20      	ldr	r0, [r4, #32]
 8002376:	4303      	orrs	r3, r0
 8002378:	4313      	orrs	r3, r2
 800237a:	600b      	str	r3, [r1, #0]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 800237c:	4620      	mov	r0, r4
 800237e:	f7ff ff89 	bl	8002294 <DMA_CalcDMAMUXChannelBaseAndMask>
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8002382:	68a3      	ldr	r3, [r4, #8]
 8002384:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8002388:	d022      	beq.n	80023d0 <HAL_DMA_Init+0xac>
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800238a:	6863      	ldr	r3, [r4, #4]
 800238c:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800238e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8002392:	6013      	str	r3, [r2, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8002394:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8002396:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 8002398:	605a      	str	r2, [r3, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 800239a:	6863      	ldr	r3, [r4, #4]
 800239c:	3b01      	subs	r3, #1
 800239e:	2b03      	cmp	r3, #3
 80023a0:	d919      	bls.n	80023d6 <HAL_DMA_Init+0xb2>
    hdma->DMAmuxRequestGen = NULL;
 80023a2:	2300      	movs	r3, #0
 80023a4:	6563      	str	r3, [r4, #84]	@ 0x54
    hdma->DMAmuxRequestGenStatus = NULL;
 80023a6:	65a3      	str	r3, [r4, #88]	@ 0x58
    hdma->DMAmuxRequestGenStatusMask = 0U;
 80023a8:	65e3      	str	r3, [r4, #92]	@ 0x5c
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80023aa:	2000      	movs	r0, #0
 80023ac:	63e0      	str	r0, [r4, #60]	@ 0x3c
  hdma->State = HAL_DMA_STATE_READY;
 80023ae:	2301      	movs	r3, #1
 80023b0:	f884 3025 	strb.w	r3, [r4, #37]	@ 0x25
  __HAL_UNLOCK(hdma);
 80023b4:	f884 0024 	strb.w	r0, [r4, #36]	@ 0x24
}
 80023b8:	bd10      	pop	{r4, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 80023ba:	4b11      	ldr	r3, [pc, #68]	@ (8002400 <HAL_DMA_Init+0xdc>)
 80023bc:	4413      	add	r3, r2
 80023be:	490e      	ldr	r1, [pc, #56]	@ (80023f8 <HAL_DMA_Init+0xd4>)
 80023c0:	fba1 1303 	umull	r1, r3, r1, r3
 80023c4:	091b      	lsrs	r3, r3, #4
 80023c6:	009b      	lsls	r3, r3, #2
 80023c8:	6443      	str	r3, [r0, #68]	@ 0x44
    hdma->DmaBaseAddress = DMA2;
 80023ca:	4b0e      	ldr	r3, [pc, #56]	@ (8002404 <HAL_DMA_Init+0xe0>)
 80023cc:	6403      	str	r3, [r0, #64]	@ 0x40
 80023ce:	e7bb      	b.n	8002348 <HAL_DMA_Init+0x24>
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 80023d0:	2300      	movs	r3, #0
 80023d2:	6063      	str	r3, [r4, #4]
 80023d4:	e7d9      	b.n	800238a <HAL_DMA_Init+0x66>
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 80023d6:	4620      	mov	r0, r4
 80023d8:	f7ff ff8e 	bl	80022f8 <DMA_CalcDMAMUXRequestGenBaseAndMask>
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80023dc:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 80023de:	2200      	movs	r2, #0
 80023e0:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80023e2:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80023e4:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
 80023e6:	605a      	str	r2, [r3, #4]
 80023e8:	e7df      	b.n	80023aa <HAL_DMA_Init+0x86>
    return HAL_ERROR;
 80023ea:	2001      	movs	r0, #1
}
 80023ec:	4770      	bx	lr
 80023ee:	bf00      	nop
 80023f0:	40020407 	.word	0x40020407
 80023f4:	bffdfff8 	.word	0xbffdfff8
 80023f8:	cccccccd 	.word	0xcccccccd
 80023fc:	40020000 	.word	0x40020000
 8002400:	bffdfbf8 	.word	0xbffdfbf8
 8002404:	40020400 	.word	0x40020400

08002408 <HAL_DMA_DeInit>:
  if (NULL == hdma)
 8002408:	2800      	cmp	r0, #0
 800240a:	d04b      	beq.n	80024a4 <HAL_DMA_DeInit+0x9c>
{
 800240c:	b538      	push	{r3, r4, r5, lr}
 800240e:	4604      	mov	r4, r0
  __HAL_DMA_DISABLE(hdma);
 8002410:	6802      	ldr	r2, [r0, #0]
 8002412:	6813      	ldr	r3, [r2, #0]
 8002414:	f023 0301 	bic.w	r3, r3, #1
 8002418:	6013      	str	r3, [r2, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800241a:	6802      	ldr	r2, [r0, #0]
 800241c:	4b22      	ldr	r3, [pc, #136]	@ (80024a8 <HAL_DMA_DeInit+0xa0>)
 800241e:	429a      	cmp	r2, r3
 8002420:	d82c      	bhi.n	800247c <HAL_DMA_DeInit+0x74>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8002422:	4b22      	ldr	r3, [pc, #136]	@ (80024ac <HAL_DMA_DeInit+0xa4>)
 8002424:	4413      	add	r3, r2
 8002426:	4922      	ldr	r1, [pc, #136]	@ (80024b0 <HAL_DMA_DeInit+0xa8>)
 8002428:	fba1 1303 	umull	r1, r3, r1, r3
 800242c:	091b      	lsrs	r3, r3, #4
 800242e:	009b      	lsls	r3, r3, #2
 8002430:	6443      	str	r3, [r0, #68]	@ 0x44
    hdma->DmaBaseAddress = DMA1;
 8002432:	4b20      	ldr	r3, [pc, #128]	@ (80024b4 <HAL_DMA_DeInit+0xac>)
 8002434:	6403      	str	r3, [r0, #64]	@ 0x40
  hdma->Instance->CCR = 0U;
 8002436:	2500      	movs	r5, #0
 8002438:	6015      	str	r5, [r2, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800243a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800243c:	f003 021c 	and.w	r2, r3, #28
 8002440:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8002442:	2301      	movs	r3, #1
 8002444:	4093      	lsls	r3, r2
 8002446:	604b      	str	r3, [r1, #4]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 8002448:	4620      	mov	r0, r4
 800244a:	f7ff ff23 	bl	8002294 <DMA_CalcDMAMUXChannelBaseAndMask>
  hdma->DMAmuxChannel->CCR = 0U;
 800244e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002450:	601d      	str	r5, [r3, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8002452:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8002454:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 8002456:	605a      	str	r2, [r3, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8002458:	6863      	ldr	r3, [r4, #4]
 800245a:	3b01      	subs	r3, #1
 800245c:	2b03      	cmp	r3, #3
 800245e:	d918      	bls.n	8002492 <HAL_DMA_DeInit+0x8a>
  hdma->DMAmuxRequestGen = NULL;
 8002460:	2000      	movs	r0, #0
 8002462:	6560      	str	r0, [r4, #84]	@ 0x54
  hdma->DMAmuxRequestGenStatus = NULL;
 8002464:	65a0      	str	r0, [r4, #88]	@ 0x58
  hdma->DMAmuxRequestGenStatusMask = 0U;
 8002466:	65e0      	str	r0, [r4, #92]	@ 0x5c
  hdma->XferCpltCallback = NULL;
 8002468:	62e0      	str	r0, [r4, #44]	@ 0x2c
  hdma->XferHalfCpltCallback = NULL;
 800246a:	6320      	str	r0, [r4, #48]	@ 0x30
  hdma->XferErrorCallback = NULL;
 800246c:	6360      	str	r0, [r4, #52]	@ 0x34
  hdma->XferAbortCallback = NULL;
 800246e:	63a0      	str	r0, [r4, #56]	@ 0x38
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002470:	63e0      	str	r0, [r4, #60]	@ 0x3c
  hdma->State = HAL_DMA_STATE_RESET;
 8002472:	f884 0025 	strb.w	r0, [r4, #37]	@ 0x25
  __HAL_UNLOCK(hdma);
 8002476:	f884 0024 	strb.w	r0, [r4, #36]	@ 0x24
}
 800247a:	bd38      	pop	{r3, r4, r5, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 800247c:	4b0e      	ldr	r3, [pc, #56]	@ (80024b8 <HAL_DMA_DeInit+0xb0>)
 800247e:	4413      	add	r3, r2
 8002480:	490b      	ldr	r1, [pc, #44]	@ (80024b0 <HAL_DMA_DeInit+0xa8>)
 8002482:	fba1 1303 	umull	r1, r3, r1, r3
 8002486:	091b      	lsrs	r3, r3, #4
 8002488:	009b      	lsls	r3, r3, #2
 800248a:	6443      	str	r3, [r0, #68]	@ 0x44
    hdma->DmaBaseAddress = DMA2;
 800248c:	4b0b      	ldr	r3, [pc, #44]	@ (80024bc <HAL_DMA_DeInit+0xb4>)
 800248e:	6403      	str	r3, [r0, #64]	@ 0x40
 8002490:	e7d1      	b.n	8002436 <HAL_DMA_DeInit+0x2e>
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 8002492:	4620      	mov	r0, r4
 8002494:	f7ff ff30 	bl	80022f8 <DMA_CalcDMAMUXRequestGenBaseAndMask>
    hdma->DMAmuxRequestGen->RGCR = 0U;
 8002498:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 800249a:	601d      	str	r5, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800249c:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 800249e:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
 80024a0:	605a      	str	r2, [r3, #4]
 80024a2:	e7dd      	b.n	8002460 <HAL_DMA_DeInit+0x58>
    return HAL_ERROR;
 80024a4:	2001      	movs	r0, #1
}
 80024a6:	4770      	bx	lr
 80024a8:	40020407 	.word	0x40020407
 80024ac:	bffdfff8 	.word	0xbffdfff8
 80024b0:	cccccccd 	.word	0xcccccccd
 80024b4:	40020000 	.word	0x40020000
 80024b8:	bffdfbf8 	.word	0xbffdfbf8
 80024bc:	40020400 	.word	0x40020400

080024c0 <HAL_DMA_Start_IT>:
{
 80024c0:	b538      	push	{r3, r4, r5, lr}
 80024c2:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 80024c4:	f890 0024 	ldrb.w	r0, [r0, #36]	@ 0x24
 80024c8:	2801      	cmp	r0, #1
 80024ca:	d043      	beq.n	8002554 <HAL_DMA_Start_IT+0x94>
 80024cc:	2001      	movs	r0, #1
 80024ce:	f884 0024 	strb.w	r0, [r4, #36]	@ 0x24
  if (hdma->State == HAL_DMA_STATE_READY)
 80024d2:	f894 0025 	ldrb.w	r0, [r4, #37]	@ 0x25
 80024d6:	b2c0      	uxtb	r0, r0
 80024d8:	2801      	cmp	r0, #1
 80024da:	d006      	beq.n	80024ea <HAL_DMA_Start_IT+0x2a>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 80024dc:	2380      	movs	r3, #128	@ 0x80
 80024de:	63e3      	str	r3, [r4, #60]	@ 0x3c
    __HAL_UNLOCK(hdma);
 80024e0:	2300      	movs	r3, #0
 80024e2:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
    status = HAL_ERROR;
 80024e6:	2001      	movs	r0, #1
}
 80024e8:	bd38      	pop	{r3, r4, r5, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 80024ea:	2002      	movs	r0, #2
 80024ec:	f884 0025 	strb.w	r0, [r4, #37]	@ 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80024f0:	2000      	movs	r0, #0
 80024f2:	63e0      	str	r0, [r4, #60]	@ 0x3c
    __HAL_DMA_DISABLE(hdma);
 80024f4:	6825      	ldr	r5, [r4, #0]
 80024f6:	6828      	ldr	r0, [r5, #0]
 80024f8:	f020 0001 	bic.w	r0, r0, #1
 80024fc:	6028      	str	r0, [r5, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 80024fe:	4620      	mov	r0, r4
 8002500:	f7ff fea0 	bl	8002244 <DMA_SetConfig>
    if (NULL != hdma->XferHalfCpltCallback)
 8002504:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8002506:	b1d3      	cbz	r3, 800253e <HAL_DMA_Start_IT+0x7e>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8002508:	6822      	ldr	r2, [r4, #0]
 800250a:	6813      	ldr	r3, [r2, #0]
 800250c:	f043 030e 	orr.w	r3, r3, #14
 8002510:	6013      	str	r3, [r2, #0]
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 8002512:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002514:	681a      	ldr	r2, [r3, #0]
 8002516:	f412 3f80 	tst.w	r2, #65536	@ 0x10000
 800251a:	d003      	beq.n	8002524 <HAL_DMA_Start_IT+0x64>
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 800251c:	681a      	ldr	r2, [r3, #0]
 800251e:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8002522:	601a      	str	r2, [r3, #0]
    if (hdma->DMAmuxRequestGen != NULL)
 8002524:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8002526:	b11b      	cbz	r3, 8002530 <HAL_DMA_Start_IT+0x70>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 8002528:	681a      	ldr	r2, [r3, #0]
 800252a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800252e:	601a      	str	r2, [r3, #0]
    __HAL_DMA_ENABLE(hdma);
 8002530:	6822      	ldr	r2, [r4, #0]
 8002532:	6813      	ldr	r3, [r2, #0]
 8002534:	f043 0301 	orr.w	r3, r3, #1
 8002538:	6013      	str	r3, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800253a:	2000      	movs	r0, #0
 800253c:	e7d4      	b.n	80024e8 <HAL_DMA_Start_IT+0x28>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800253e:	6822      	ldr	r2, [r4, #0]
 8002540:	6813      	ldr	r3, [r2, #0]
 8002542:	f023 0304 	bic.w	r3, r3, #4
 8002546:	6013      	str	r3, [r2, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8002548:	6822      	ldr	r2, [r4, #0]
 800254a:	6813      	ldr	r3, [r2, #0]
 800254c:	f043 030a 	orr.w	r3, r3, #10
 8002550:	6013      	str	r3, [r2, #0]
 8002552:	e7de      	b.n	8002512 <HAL_DMA_Start_IT+0x52>
  __HAL_LOCK(hdma);
 8002554:	2002      	movs	r0, #2
 8002556:	e7c7      	b.n	80024e8 <HAL_DMA_Start_IT+0x28>

08002558 <HAL_DMA_Abort>:
  if (NULL == hdma)
 8002558:	4603      	mov	r3, r0
 800255a:	2800      	cmp	r0, #0
 800255c:	d034      	beq.n	80025c8 <HAL_DMA_Abort+0x70>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 800255e:	f890 2025 	ldrb.w	r2, [r0, #37]	@ 0x25
 8002562:	b2d2      	uxtb	r2, r2
 8002564:	2a02      	cmp	r2, #2
 8002566:	d006      	beq.n	8002576 <HAL_DMA_Abort+0x1e>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8002568:	2204      	movs	r2, #4
 800256a:	63c2      	str	r2, [r0, #60]	@ 0x3c
    __HAL_UNLOCK(hdma);
 800256c:	2200      	movs	r2, #0
 800256e:	f880 2024 	strb.w	r2, [r0, #36]	@ 0x24
    return HAL_ERROR;
 8002572:	2001      	movs	r0, #1
 8002574:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8002576:	6801      	ldr	r1, [r0, #0]
 8002578:	680a      	ldr	r2, [r1, #0]
 800257a:	f022 020e 	bic.w	r2, r2, #14
 800257e:	600a      	str	r2, [r1, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8002580:	6c81      	ldr	r1, [r0, #72]	@ 0x48
 8002582:	680a      	ldr	r2, [r1, #0]
 8002584:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8002588:	600a      	str	r2, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 800258a:	6801      	ldr	r1, [r0, #0]
 800258c:	680a      	ldr	r2, [r1, #0]
 800258e:	f022 0201 	bic.w	r2, r2, #1
 8002592:	600a      	str	r2, [r1, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8002594:	6c42      	ldr	r2, [r0, #68]	@ 0x44
 8002596:	f002 011c 	and.w	r1, r2, #28
 800259a:	6c00      	ldr	r0, [r0, #64]	@ 0x40
 800259c:	2201      	movs	r2, #1
 800259e:	408a      	lsls	r2, r1
 80025a0:	6042      	str	r2, [r0, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80025a2:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80025a4:	6d19      	ldr	r1, [r3, #80]	@ 0x50
 80025a6:	6051      	str	r1, [r2, #4]
    if (hdma->DMAmuxRequestGen != NULL)
 80025a8:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 80025aa:	b132      	cbz	r2, 80025ba <HAL_DMA_Abort+0x62>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 80025ac:	6811      	ldr	r1, [r2, #0]
 80025ae:	f421 7180 	bic.w	r1, r1, #256	@ 0x100
 80025b2:	6011      	str	r1, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80025b4:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80025b6:	6dd9      	ldr	r1, [r3, #92]	@ 0x5c
 80025b8:	6051      	str	r1, [r2, #4]
    hdma->State = HAL_DMA_STATE_READY;
 80025ba:	2201      	movs	r2, #1
 80025bc:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
    __HAL_UNLOCK(hdma);
 80025c0:	2000      	movs	r0, #0
 80025c2:	f883 0024 	strb.w	r0, [r3, #36]	@ 0x24
  return HAL_OK;
 80025c6:	4770      	bx	lr
    return HAL_ERROR;
 80025c8:	2001      	movs	r0, #1
}
 80025ca:	4770      	bx	lr

080025cc <HAL_DMA_Abort_IT>:
{
 80025cc:	b508      	push	{r3, lr}
  if (hdma->State != HAL_DMA_STATE_BUSY)
 80025ce:	f890 3025 	ldrb.w	r3, [r0, #37]	@ 0x25
 80025d2:	b2db      	uxtb	r3, r3
 80025d4:	2b02      	cmp	r3, #2
 80025d6:	d003      	beq.n	80025e0 <HAL_DMA_Abort_IT+0x14>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80025d8:	2304      	movs	r3, #4
 80025da:	63c3      	str	r3, [r0, #60]	@ 0x3c
    status = HAL_ERROR;
 80025dc:	2001      	movs	r0, #1
}
 80025de:	bd08      	pop	{r3, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80025e0:	6802      	ldr	r2, [r0, #0]
 80025e2:	6813      	ldr	r3, [r2, #0]
 80025e4:	f023 030e 	bic.w	r3, r3, #14
 80025e8:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 80025ea:	6802      	ldr	r2, [r0, #0]
 80025ec:	6813      	ldr	r3, [r2, #0]
 80025ee:	f023 0301 	bic.w	r3, r3, #1
 80025f2:	6013      	str	r3, [r2, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80025f4:	6c82      	ldr	r2, [r0, #72]	@ 0x48
 80025f6:	6813      	ldr	r3, [r2, #0]
 80025f8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80025fc:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80025fe:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 8002600:	f003 021c 	and.w	r2, r3, #28
 8002604:	6c01      	ldr	r1, [r0, #64]	@ 0x40
 8002606:	2301      	movs	r3, #1
 8002608:	4093      	lsls	r3, r2
 800260a:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800260c:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 800260e:	6d02      	ldr	r2, [r0, #80]	@ 0x50
 8002610:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != NULL)
 8002612:	6d43      	ldr	r3, [r0, #84]	@ 0x54
 8002614:	b133      	cbz	r3, 8002624 <HAL_DMA_Abort_IT+0x58>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8002616:	681a      	ldr	r2, [r3, #0]
 8002618:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 800261c:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800261e:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 8002620:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
 8002622:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8002624:	2301      	movs	r3, #1
 8002626:	f880 3025 	strb.w	r3, [r0, #37]	@ 0x25
    __HAL_UNLOCK(hdma);
 800262a:	2300      	movs	r3, #0
 800262c:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
    if (hdma->XferAbortCallback != NULL)
 8002630:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8002632:	b113      	cbz	r3, 800263a <HAL_DMA_Abort_IT+0x6e>
      hdma->XferAbortCallback(hdma);
 8002634:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 8002636:	2000      	movs	r0, #0
 8002638:	e7d1      	b.n	80025de <HAL_DMA_Abort_IT+0x12>
 800263a:	2000      	movs	r0, #0
 800263c:	e7cf      	b.n	80025de <HAL_DMA_Abort_IT+0x12>
	...

08002640 <HAL_DMA_IRQHandler>:
{
 8002640:	b538      	push	{r3, r4, r5, lr}
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8002642:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8002644:	6819      	ldr	r1, [r3, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8002646:	6804      	ldr	r4, [r0, #0]
 8002648:	6825      	ldr	r5, [r4, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 800264a:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 800264c:	f003 031c 	and.w	r3, r3, #28
 8002650:	2204      	movs	r2, #4
 8002652:	409a      	lsls	r2, r3
 8002654:	420a      	tst	r2, r1
 8002656:	d015      	beq.n	8002684 <HAL_DMA_IRQHandler+0x44>
 8002658:	f015 0f04 	tst.w	r5, #4
 800265c:	d012      	beq.n	8002684 <HAL_DMA_IRQHandler+0x44>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800265e:	6823      	ldr	r3, [r4, #0]
 8002660:	f013 0f20 	tst.w	r3, #32
 8002664:	d103      	bne.n	800266e <HAL_DMA_IRQHandler+0x2e>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8002666:	6823      	ldr	r3, [r4, #0]
 8002668:	f023 0304 	bic.w	r3, r3, #4
 800266c:	6023      	str	r3, [r4, #0]
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 800266e:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 8002670:	f003 021c 	and.w	r2, r3, #28
 8002674:	6c01      	ldr	r1, [r0, #64]	@ 0x40
 8002676:	2304      	movs	r3, #4
 8002678:	4093      	lsls	r3, r2
 800267a:	604b      	str	r3, [r1, #4]
      if (hdma->XferHalfCpltCallback != NULL)
 800267c:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 800267e:	b103      	cbz	r3, 8002682 <HAL_DMA_IRQHandler+0x42>
        hdma->XferHalfCpltCallback(hdma);
 8002680:	4798      	blx	r3
}
 8002682:	bd38      	pop	{r3, r4, r5, pc}
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)))) && (0U != (source_it & DMA_IT_TC)))
 8002684:	2202      	movs	r2, #2
 8002686:	409a      	lsls	r2, r3
 8002688:	420a      	tst	r2, r1
 800268a:	d028      	beq.n	80026de <HAL_DMA_IRQHandler+0x9e>
 800268c:	f015 0f02 	tst.w	r5, #2
 8002690:	d025      	beq.n	80026de <HAL_DMA_IRQHandler+0x9e>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8002692:	6823      	ldr	r3, [r4, #0]
 8002694:	f013 0f20 	tst.w	r3, #32
 8002698:	d106      	bne.n	80026a8 <HAL_DMA_IRQHandler+0x68>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800269a:	6823      	ldr	r3, [r4, #0]
 800269c:	f023 030a 	bic.w	r3, r3, #10
 80026a0:	6023      	str	r3, [r4, #0]
        hdma->State = HAL_DMA_STATE_READY;
 80026a2:	2301      	movs	r3, #1
 80026a4:	f880 3025 	strb.w	r3, [r0, #37]	@ 0x25
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 80026a8:	6802      	ldr	r2, [r0, #0]
 80026aa:	4b1c      	ldr	r3, [pc, #112]	@ (800271c <HAL_DMA_IRQHandler+0xdc>)
 80026ac:	429a      	cmp	r2, r3
 80026ae:	d90e      	bls.n	80026ce <HAL_DMA_IRQHandler+0x8e>
 80026b0:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 80026b2:	f003 021c 	and.w	r2, r3, #28
 80026b6:	2302      	movs	r3, #2
 80026b8:	4093      	lsls	r3, r2
 80026ba:	4a19      	ldr	r2, [pc, #100]	@ (8002720 <HAL_DMA_IRQHandler+0xe0>)
 80026bc:	6053      	str	r3, [r2, #4]
      __HAL_UNLOCK(hdma);
 80026be:	2300      	movs	r3, #0
 80026c0:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
      if (hdma->XferCpltCallback != NULL)
 80026c4:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 80026c6:	2b00      	cmp	r3, #0
 80026c8:	d0db      	beq.n	8002682 <HAL_DMA_IRQHandler+0x42>
        hdma->XferCpltCallback(hdma);
 80026ca:	4798      	blx	r3
 80026cc:	e7d9      	b.n	8002682 <HAL_DMA_IRQHandler+0x42>
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 80026ce:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 80026d0:	f003 021c 	and.w	r2, r3, #28
 80026d4:	2302      	movs	r3, #2
 80026d6:	4093      	lsls	r3, r2
 80026d8:	4a12      	ldr	r2, [pc, #72]	@ (8002724 <HAL_DMA_IRQHandler+0xe4>)
 80026da:	6053      	str	r3, [r2, #4]
 80026dc:	e7ef      	b.n	80026be <HAL_DMA_IRQHandler+0x7e>
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 80026de:	2208      	movs	r2, #8
 80026e0:	fa02 f303 	lsl.w	r3, r2, r3
 80026e4:	420b      	tst	r3, r1
 80026e6:	d0cc      	beq.n	8002682 <HAL_DMA_IRQHandler+0x42>
 80026e8:	f015 0f08 	tst.w	r5, #8
 80026ec:	d0c9      	beq.n	8002682 <HAL_DMA_IRQHandler+0x42>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80026ee:	6823      	ldr	r3, [r4, #0]
 80026f0:	f023 030e 	bic.w	r3, r3, #14
 80026f4:	6023      	str	r3, [r4, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80026f6:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 80026f8:	f003 031c 	and.w	r3, r3, #28
 80026fc:	6c01      	ldr	r1, [r0, #64]	@ 0x40
 80026fe:	2201      	movs	r2, #1
 8002700:	fa02 f303 	lsl.w	r3, r2, r3
 8002704:	604b      	str	r3, [r1, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8002706:	63c2      	str	r2, [r0, #60]	@ 0x3c
    hdma->State = HAL_DMA_STATE_READY;
 8002708:	f880 2025 	strb.w	r2, [r0, #37]	@ 0x25
    __HAL_UNLOCK(hdma);
 800270c:	2300      	movs	r3, #0
 800270e:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
    if (hdma->XferErrorCallback != NULL)
 8002712:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8002714:	2b00      	cmp	r3, #0
 8002716:	d0b4      	beq.n	8002682 <HAL_DMA_IRQHandler+0x42>
      hdma->XferErrorCallback(hdma);
 8002718:	4798      	blx	r3
  return;
 800271a:	e7b2      	b.n	8002682 <HAL_DMA_IRQHandler+0x42>
 800271c:	40020080 	.word	0x40020080
 8002720:	40020400 	.word	0x40020400
 8002724:	40020000 	.word	0x40020000

08002728 <HAL_DMA_ConfigChannelAttributes>:
  if (hdma == NULL)
 8002728:	b178      	cbz	r0, 800274a <HAL_DMA_ConfigChannelAttributes+0x22>
  ccr = READ_REG(hdma->Instance->CCR);
 800272a:	6803      	ldr	r3, [r0, #0]
 800272c:	681a      	ldr	r2, [r3, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 800272e:	f011 0f10 	tst.w	r1, #16
 8002732:	d004      	beq.n	800273e <HAL_DMA_ConfigChannelAttributes+0x16>
    if ((ChannelAttributes & DMA_CCR_PRIV) != 0U)
 8002734:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8002738:	d004      	beq.n	8002744 <HAL_DMA_ConfigChannelAttributes+0x1c>
      SET_BIT(ccr, DMA_CCR_PRIV);
 800273a:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
  WRITE_REG(hdma->Instance->CCR, ccr);
 800273e:	601a      	str	r2, [r3, #0]
  return status;
 8002740:	2000      	movs	r0, #0
 8002742:	4770      	bx	lr
      CLEAR_BIT(ccr, DMA_CCR_PRIV);
 8002744:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 8002748:	e7f9      	b.n	800273e <HAL_DMA_ConfigChannelAttributes+0x16>
    return status;
 800274a:	2001      	movs	r0, #1
}
 800274c:	4770      	bx	lr
	...

08002750 <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8002750:	4b09      	ldr	r3, [pc, #36]	@ (8002778 <HAL_FLASH_Unlock+0x28>)
 8002752:	695b      	ldr	r3, [r3, #20]
 8002754:	2b00      	cmp	r3, #0
 8002756:	db01      	blt.n	800275c <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 8002758:	2000      	movs	r0, #0
 800275a:	4770      	bx	lr
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 800275c:	4b06      	ldr	r3, [pc, #24]	@ (8002778 <HAL_FLASH_Unlock+0x28>)
 800275e:	4a07      	ldr	r2, [pc, #28]	@ (800277c <HAL_FLASH_Unlock+0x2c>)
 8002760:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8002762:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 8002766:	609a      	str	r2, [r3, #8]

    /* verify Flash is unlock */
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8002768:	695b      	ldr	r3, [r3, #20]
 800276a:	2b00      	cmp	r3, #0
 800276c:	db01      	blt.n	8002772 <HAL_FLASH_Unlock+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 800276e:	2000      	movs	r0, #0
 8002770:	4770      	bx	lr
    {
      status = HAL_ERROR;
 8002772:	2001      	movs	r0, #1
    }
  }

  return status;
}
 8002774:	4770      	bx	lr
 8002776:	bf00      	nop
 8002778:	58004000 	.word	0x58004000
 800277c:	45670123 	.word	0x45670123

08002780 <HAL_FLASH_Lock>:
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Set the LOCK Bit to lock the FLASH Registers access */
  /* @Note  The lock and unlock procedure is done only using CR registers even from CPU2 */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8002780:	4b05      	ldr	r3, [pc, #20]	@ (8002798 <HAL_FLASH_Lock+0x18>)
 8002782:	695a      	ldr	r2, [r3, #20]
 8002784:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 8002788:	615a      	str	r2, [r3, #20]

  /* verify Flash is locked */
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 800278a:	695b      	ldr	r3, [r3, #20]
 800278c:	2b00      	cmp	r3, #0
 800278e:	db01      	blt.n	8002794 <HAL_FLASH_Lock+0x14>
  {
    status = HAL_ERROR;
 8002790:	2001      	movs	r0, #1
  }

  return status;
}
 8002792:	4770      	bx	lr
  HAL_StatusTypeDef status = HAL_OK;
 8002794:	2000      	movs	r0, #0
 8002796:	4770      	bx	lr
 8002798:	58004000 	.word	0x58004000

0800279c <HAL_FLASH_OB_Unlock>:
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_ERROR;

  /* @Note The lock and unlock procedure is done only using CR registers even from CPU2 */
  if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0U)
 800279c:	4b0a      	ldr	r3, [pc, #40]	@ (80027c8 <HAL_FLASH_OB_Unlock+0x2c>)
 800279e:	695b      	ldr	r3, [r3, #20]
 80027a0:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 80027a4:	d00b      	beq.n	80027be <HAL_FLASH_OB_Unlock+0x22>
  {
    /* Authorizes the Option Byte register programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 80027a6:	4b08      	ldr	r3, [pc, #32]	@ (80027c8 <HAL_FLASH_OB_Unlock+0x2c>)
 80027a8:	4a08      	ldr	r2, [pc, #32]	@ (80027cc <HAL_FLASH_OB_Unlock+0x30>)
 80027aa:	60da      	str	r2, [r3, #12]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 80027ac:	f102 3244 	add.w	r2, r2, #1145324612	@ 0x44444444
 80027b0:	60da      	str	r2, [r3, #12]

    /* verify option bytes are unlocked */
    if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) == 0U)
 80027b2:	695b      	ldr	r3, [r3, #20]
 80027b4:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 80027b8:	d003      	beq.n	80027c2 <HAL_FLASH_OB_Unlock+0x26>
  HAL_StatusTypeDef status = HAL_ERROR;
 80027ba:	2001      	movs	r0, #1
 80027bc:	4770      	bx	lr
 80027be:	2001      	movs	r0, #1
 80027c0:	4770      	bx	lr
    {
      status = HAL_OK;
 80027c2:	2000      	movs	r0, #0
    }
  }

  return status;
}
 80027c4:	4770      	bx	lr
 80027c6:	bf00      	nop
 80027c8:	58004000 	.word	0x58004000
 80027cc:	08192a3b 	.word	0x08192a3b

080027d0 <HAL_FLASH_OB_Lock>:
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  /* @Note The lock and unlock procedure is done only using CR registers even from CPU2 */
  SET_BIT(FLASH->CR, FLASH_CR_OPTLOCK);
 80027d0:	4b06      	ldr	r3, [pc, #24]	@ (80027ec <HAL_FLASH_OB_Lock+0x1c>)
 80027d2:	695a      	ldr	r2, [r3, #20]
 80027d4:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
 80027d8:	615a      	str	r2, [r3, #20]

  /* verify option bytes are lock */
  if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) == 0U)
 80027da:	695b      	ldr	r3, [r3, #20]
 80027dc:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 80027e0:	d001      	beq.n	80027e6 <HAL_FLASH_OB_Lock+0x16>
  HAL_StatusTypeDef status = HAL_OK;
 80027e2:	2000      	movs	r0, #0
 80027e4:	4770      	bx	lr
  {
    status = HAL_ERROR;
 80027e6:	2001      	movs	r0, #1
  }

  return status;
}
 80027e8:	4770      	bx	lr
 80027ea:	bf00      	nop
 80027ec:	58004000 	.word	0x58004000

080027f0 <HAL_FLASH_OB_Launch>:
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
  /* Set the bit to force the option byte reloading */
  /* The OB launch is done from the same register either from CPU1 or CPU2 */
  SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);
 80027f0:	4a03      	ldr	r2, [pc, #12]	@ (8002800 <HAL_FLASH_OB_Launch+0x10>)
 80027f2:	6953      	ldr	r3, [r2, #20]
 80027f4:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 80027f8:	6153      	str	r3, [r2, #20]

  /* We should not reach here : Option byte launch generates Option byte reset
     so return error */
  return HAL_ERROR;
}
 80027fa:	2001      	movs	r0, #1
 80027fc:	4770      	bx	lr
 80027fe:	bf00      	nop
 8002800:	58004000 	.word	0x58004000

08002804 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout Maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 8002804:	b538      	push	{r3, r4, r5, lr}
 8002806:	4605      	mov	r5, r0
  uint32_t error;
  uint32_t tickstart = HAL_GetTick();
 8002808:	f7fe f95a 	bl	8000ac0 <HAL_GetTick>
 800280c:	4604      	mov	r4, r0

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 800280e:	4b1b      	ldr	r3, [pc, #108]	@ (800287c <FLASH_WaitForLastOperation+0x78>)
 8002810:	691b      	ldr	r3, [r3, #16]
 8002812:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 8002816:	d006      	beq.n	8002826 <FLASH_WaitForLastOperation+0x22>
  {
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8002818:	f7fe f952 	bl	8000ac0 <HAL_GetTick>
 800281c:	1b00      	subs	r0, r0, r4
 800281e:	42a8      	cmp	r0, r5
 8002820:	d3f5      	bcc.n	800280e <FLASH_WaitForLastOperation+0xa>
    {
      return HAL_TIMEOUT;
 8002822:	2003      	movs	r0, #3
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
}
 8002824:	bd38      	pop	{r3, r4, r5, pc}
  error = FLASH->SR;
 8002826:	4b15      	ldr	r3, [pc, #84]	@ (800287c <FLASH_WaitForLastOperation+0x78>)
 8002828:	691b      	ldr	r3, [r3, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 800282a:	f013 0f01 	tst.w	r3, #1
 800282e:	d115      	bne.n	800285c <FLASH_WaitForLastOperation+0x58>
  error &= FLASH_FLAG_SR_ERRORS;
 8002830:	f423 5370 	bic.w	r3, r3, #15360	@ 0x3c00
 8002834:	f023 0305 	bic.w	r3, r3, #5
 8002838:	041b      	lsls	r3, r3, #16
 800283a:	0c1b      	lsrs	r3, r3, #16
  __HAL_FLASH_CLEAR_FLAG(error);
 800283c:	b10b      	cbz	r3, 8002842 <FLASH_WaitForLastOperation+0x3e>
 800283e:	4a0f      	ldr	r2, [pc, #60]	@ (800287c <FLASH_WaitForLastOperation+0x78>)
 8002840:	6113      	str	r3, [r2, #16]
  if (error != 0U)
 8002842:	b9ab      	cbnz	r3, 8002870 <FLASH_WaitForLastOperation+0x6c>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8002844:	4b0d      	ldr	r3, [pc, #52]	@ (800287c <FLASH_WaitForLastOperation+0x78>)
 8002846:	691b      	ldr	r3, [r3, #16]
 8002848:	f413 2f80 	tst.w	r3, #262144	@ 0x40000
 800284c:	d014      	beq.n	8002878 <FLASH_WaitForLastOperation+0x74>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 800284e:	f7fe f937 	bl	8000ac0 <HAL_GetTick>
 8002852:	1b00      	subs	r0, r0, r4
 8002854:	42a8      	cmp	r0, r5
 8002856:	d3f5      	bcc.n	8002844 <FLASH_WaitForLastOperation+0x40>
      return HAL_TIMEOUT;
 8002858:	2003      	movs	r0, #3
 800285a:	e7e3      	b.n	8002824 <FLASH_WaitForLastOperation+0x20>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 800285c:	4a07      	ldr	r2, [pc, #28]	@ (800287c <FLASH_WaitForLastOperation+0x78>)
 800285e:	2101      	movs	r1, #1
 8002860:	6111      	str	r1, [r2, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 8002862:	f423 5370 	bic.w	r3, r3, #15360	@ 0x3c00
 8002866:	f023 0305 	bic.w	r3, r3, #5
 800286a:	041b      	lsls	r3, r3, #16
 800286c:	0c1b      	lsrs	r3, r3, #16
  __HAL_FLASH_CLEAR_FLAG(error);
 800286e:	e7e5      	b.n	800283c <FLASH_WaitForLastOperation+0x38>
    pFlash.ErrorCode = error;
 8002870:	4a03      	ldr	r2, [pc, #12]	@ (8002880 <FLASH_WaitForLastOperation+0x7c>)
 8002872:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 8002874:	2001      	movs	r0, #1
 8002876:	e7d5      	b.n	8002824 <FLASH_WaitForLastOperation+0x20>
  return HAL_OK;
 8002878:	2000      	movs	r0, #0
 800287a:	e7d3      	b.n	8002824 <FLASH_WaitForLastOperation+0x20>
 800287c:	58004000 	.word	0x58004000
 8002880:	20000470 	.word	0x20000470

08002884 <FLASH_OB_WRPConfig>:
  assert_param(IS_OB_WRPAREA(WRPArea));
  assert_param(IS_FLASH_PAGE(WRPStartOffset));
  assert_param(IS_FLASH_PAGE(WRDPEndOffset));

  /* Configure the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 8002884:	b940      	cbnz	r0, 8002898 <FLASH_OB_WRPConfig+0x14>
  {
    MODIFY_REG(FLASH->WRP1AR, (FLASH_WRP1AR_WRP1A_STRT | FLASH_WRP1AR_WRP1A_END),
 8002886:	4809      	ldr	r0, [pc, #36]	@ (80028ac <FLASH_OB_WRPConfig+0x28>)
 8002888:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 800288a:	f023 137f 	bic.w	r3, r3, #8323199	@ 0x7f007f
 800288e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8002892:	430b      	orrs	r3, r1
 8002894:	62c3      	str	r3, [r0, #44]	@ 0x2c
 8002896:	4770      	bx	lr
               (WRPStartOffset | (WRDPEndOffset << FLASH_WRP1AR_WRP1A_END_Pos)));
  }
  else /* OB_WRPAREA_BANK1_AREAB */
  {
    MODIFY_REG(FLASH->WRP1BR, (FLASH_WRP1BR_WRP1B_STRT | FLASH_WRP1BR_WRP1B_END),
 8002898:	4804      	ldr	r0, [pc, #16]	@ (80028ac <FLASH_OB_WRPConfig+0x28>)
 800289a:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 800289c:	f023 137f 	bic.w	r3, r3, #8323199	@ 0x7f007f
 80028a0:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 80028a4:	430b      	orrs	r3, r1
 80028a6:	6303      	str	r3, [r0, #48]	@ 0x30
               (WRPStartOffset | (WRDPEndOffset << FLASH_WRP1AR_WRP1A_END_Pos)));
  }
}
 80028a8:	4770      	bx	lr
 80028aa:	bf00      	nop
 80028ac:	58004000 	.word	0x58004000

080028b0 <FLASH_OB_OptrConfig>:
  *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
  * @retval None
  */
#endif
static void FLASH_OB_OptrConfig(uint32_t UserType, uint32_t UserConfig, uint32_t RDPLevel)
{
 80028b0:	b410      	push	{r4}
  assert_param(IS_OB_USER_TYPE(UserType));
  assert_param(IS_OB_USER_CONFIG(UserType, UserConfig));
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  optr = FLASH->OPTR;
 80028b2:	4c05      	ldr	r4, [pc, #20]	@ (80028c8 <FLASH_OB_OptrConfig+0x18>)
 80028b4:	6a23      	ldr	r3, [r4, #32]
  optr &= ~(UserType | FLASH_OPTR_RDP);
 80028b6:	f040 00ff 	orr.w	r0, r0, #255	@ 0xff
 80028ba:	ea23 0300 	bic.w	r3, r3, r0
  FLASH->OPTR = (optr | UserConfig | RDPLevel);
 80028be:	430b      	orrs	r3, r1
 80028c0:	4313      	orrs	r3, r2
 80028c2:	6223      	str	r3, [r4, #32]
}
 80028c4:	bc10      	pop	{r4}
 80028c6:	4770      	bx	lr
 80028c8:	58004000 	.word	0x58004000

080028cc <FLASH_OB_PCROP1AConfig>:
  assert_param(IS_OB_PCROP_CONFIG(PCROPConfig));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1AStartAddr));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1AEndAddr));

  /* get pcrop 1A end register */
  pcrop1aend = FLASH->PCROP1AER;
 80028cc:	4b10      	ldr	r3, [pc, #64]	@ (8002910 <FLASH_OB_PCROP1AConfig+0x44>)
 80028ce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28

  /* Configure the Proprietary code readout protection offset */
  if ((PCROPConfig & OB_PCROP_ZONE_A) != 0U)
 80028d0:	f010 0f01 	tst.w	r0, #1
 80028d4:	d014      	beq.n	8002900 <FLASH_OB_PCROP1AConfig+0x34>
{
 80028d6:	b410      	push	{r4}
  {
    /* Compute offset depending on pcrop granularity */
    startoffset = ((PCROP1AStartAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 80028d8:	f101 4178 	add.w	r1, r1, #4160749568	@ 0xf8000000
 80028dc:	0a89      	lsrs	r1, r1, #10
    endoffset = ((PCROP1AEndAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 80028de:	f102 4278 	add.w	r2, r2, #4160749568	@ 0xf8000000

    /* Set Zone A start offset */
    WRITE_REG(FLASH->PCROP1ASR, startoffset);
 80028e2:	4c0b      	ldr	r4, [pc, #44]	@ (8002910 <FLASH_OB_PCROP1AConfig+0x44>)
 80028e4:	6261      	str	r1, [r4, #36]	@ 0x24

    /* Set Zone A end offset */
    pcrop1aend &= ~FLASH_PCROP1AER_PCROP1A_END;
 80028e6:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
    pcrop1aend |= endoffset;
 80028ea:	ea43 2392 	orr.w	r3, r3, r2, lsr #10
  }

  /* Set RDP erase protection if needed. This bit is only set & will be reset by mass erase */
  if ((PCROPConfig & OB_PCROP_RDP_ERASE) != 0U)
 80028ee:	2800      	cmp	r0, #0
 80028f0:	db03      	blt.n	80028fa <FLASH_OB_PCROP1AConfig+0x2e>
  {
    pcrop1aend |= FLASH_PCROP1AER_PCROP_RDP;
  }

  /* set 1A End register */
  WRITE_REG(FLASH->PCROP1AER, pcrop1aend);
 80028f2:	4a07      	ldr	r2, [pc, #28]	@ (8002910 <FLASH_OB_PCROP1AConfig+0x44>)
 80028f4:	6293      	str	r3, [r2, #40]	@ 0x28
}
 80028f6:	bc10      	pop	{r4}
 80028f8:	4770      	bx	lr
    pcrop1aend |= FLASH_PCROP1AER_PCROP_RDP;
 80028fa:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80028fe:	e7f8      	b.n	80028f2 <FLASH_OB_PCROP1AConfig+0x26>
  if ((PCROPConfig & OB_PCROP_RDP_ERASE) != 0U)
 8002900:	2800      	cmp	r0, #0
 8002902:	db02      	blt.n	800290a <FLASH_OB_PCROP1AConfig+0x3e>
  WRITE_REG(FLASH->PCROP1AER, pcrop1aend);
 8002904:	4a02      	ldr	r2, [pc, #8]	@ (8002910 <FLASH_OB_PCROP1AConfig+0x44>)
 8002906:	6293      	str	r3, [r2, #40]	@ 0x28
 8002908:	4770      	bx	lr
    pcrop1aend |= FLASH_PCROP1AER_PCROP_RDP;
 800290a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800290e:	e7f9      	b.n	8002904 <FLASH_OB_PCROP1AConfig+0x38>
 8002910:	58004000 	.word	0x58004000

08002914 <FLASH_OB_PCROP1BConfig>:
  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1BStartAddr));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1BEndAddr));

  /* Compute offset depending on pcrop granularity */
  startoffset = ((PCROP1BStartAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 8002914:	f100 4078 	add.w	r0, r0, #4160749568	@ 0xf8000000
 8002918:	0a80      	lsrs	r0, r0, #10
  endoffset = ((PCROP1BEndAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800291a:	f101 4178 	add.w	r1, r1, #4160749568	@ 0xf8000000
 800291e:	0a89      	lsrs	r1, r1, #10

  /* Configure the Proprietary code readout protection start address */
  WRITE_REG(FLASH->PCROP1BSR, startoffset);
 8002920:	4b01      	ldr	r3, [pc, #4]	@ (8002928 <FLASH_OB_PCROP1BConfig+0x14>)
 8002922:	6358      	str	r0, [r3, #52]	@ 0x34

  /* Configure the Proprietary code readout protection end address */
  WRITE_REG(FLASH->PCROP1BER, endoffset);
 8002924:	6399      	str	r1, [r3, #56]	@ 0x38
}
 8002926:	4770      	bx	lr
 8002928:	58004000 	.word	0x58004000

0800292c <FLASH_OB_IPCCBufferAddrConfig>:
static void FLASH_OB_IPCCBufferAddrConfig(uint32_t IPCCDataBufAddr)
{
  assert_param(IS_OB_IPCC_BUF_ADDR(IPCCDataBufAddr));

  /* Configure the option bytes register */
  WRITE_REG(FLASH->IPCCBR, (uint32_t)((IPCCDataBufAddr - SRAM1_BASE) >> 4));
 800292c:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 8002930:	0900      	lsrs	r0, r0, #4
 8002932:	4b01      	ldr	r3, [pc, #4]	@ (8002938 <FLASH_OB_IPCCBufferAddrConfig+0xc>)
 8002934:	63d8      	str	r0, [r3, #60]	@ 0x3c
}
 8002936:	4770      	bx	lr
 8002938:	58004000 	.word	0x58004000

0800293c <FLASH_OB_GetWRP>:
{
  /* Check the parameters */
  assert_param(IS_OB_WRPAREA(WRPArea));

  /* Get the configuration of the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 800293c:	b948      	cbnz	r0, 8002952 <FLASH_OB_GetWRP+0x16>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_STRT);
 800293e:	480a      	ldr	r0, [pc, #40]	@ (8002968 <FLASH_OB_GetWRP+0x2c>)
 8002940:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 8002942:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8002946:	600b      	str	r3, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_END) >> FLASH_WRP1AR_WRP1A_END_Pos);
 8002948:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 800294a:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800294e:	6013      	str	r3, [r2, #0]
 8002950:	4770      	bx	lr
  }
  else /* OB_WRPAREA_BANK1_AREAB */
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
 8002952:	4805      	ldr	r0, [pc, #20]	@ (8002968 <FLASH_OB_GetWRP+0x2c>)
 8002954:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 8002956:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800295a:	600b      	str	r3, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
 800295c:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 800295e:	f3c3 4306 	ubfx	r3, r3, #16, #7
 8002962:	6013      	str	r3, [r2, #0]
  }
}
 8002964:	4770      	bx	lr
 8002966:	bf00      	nop
 8002968:	58004000 	.word	0x58004000

0800296c <FLASH_OB_GetRDP>:
  *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
  *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
  uint32_t rdplvl = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 800296c:	4b04      	ldr	r3, [pc, #16]	@ (8002980 <FLASH_OB_GetRDP+0x14>)
 800296e:	6a18      	ldr	r0, [r3, #32]
 8002970:	b2c0      	uxtb	r0, r0

  if ((rdplvl != OB_RDP_LEVEL_0) && (rdplvl != OB_RDP_LEVEL_2))
 8002972:	28aa      	cmp	r0, #170	@ 0xaa
 8002974:	d002      	beq.n	800297c <FLASH_OB_GetRDP+0x10>
 8002976:	28cc      	cmp	r0, #204	@ 0xcc
 8002978:	d000      	beq.n	800297c <FLASH_OB_GetRDP+0x10>
  {
    return (OB_RDP_LEVEL_1);
 800297a:	20bb      	movs	r0, #187	@ 0xbb
  }
  else
  {
    return rdplvl;
  }
}
 800297c:	4770      	bx	lr
 800297e:	bf00      	nop
 8002980:	58004000 	.word	0x58004000

08002984 <FLASH_OB_GetUser>:
  *         @arg @ref OB_BOOT_LOCK_DISABLE or @ref OB_BOOT_LOCK_ENABLE
  */
#endif
static uint32_t FLASH_OB_GetUser(void)
{
  uint32_t user_config = (READ_REG(FLASH->OPTR) & OB_USER_ALL);
 8002984:	4b02      	ldr	r3, [pc, #8]	@ (8002990 <FLASH_OB_GetUser+0xc>)
 8002986:	6a1b      	ldr	r3, [r3, #32]
  CLEAR_BIT(user_config, (FLASH_OPTR_RDP | FLASH_OPTR_ESE));

  return user_config;
}
 8002988:	4802      	ldr	r0, [pc, #8]	@ (8002994 <FLASH_OB_GetUser+0x10>)
 800298a:	4018      	ands	r0, r3
 800298c:	4770      	bx	lr
 800298e:	bf00      	nop
 8002990:	58004000 	.word	0x58004000
 8002994:	cf8f7e00 	.word	0xcf8f7e00

08002998 <FLASH_OB_GetPCROP>:
  * @param PCROP1BEndAddr [out] Specifies the address where to copied the end address of
  *                       the Zone 1B Proprietary code readout protection
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROP1AStartAddr, uint32_t *PCROP1AEndAddr, uint32_t *PCROP1BStartAddr, uint32_t *PCROP1BEndAddr)
{
 8002998:	b430      	push	{r4, r5}
  uint32_t pcrop;

  pcrop             = (READ_BIT(FLASH->PCROP1BSR, FLASH_PCROP1BSR_PCROP1B_STRT));
 800299a:	4c12      	ldr	r4, [pc, #72]	@ (80029e4 <FLASH_OB_GetPCROP+0x4c>)
 800299c:	6b65      	ldr	r5, [r4, #52]	@ 0x34
  *PCROP1BStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 800299e:	02ad      	lsls	r5, r5, #10
 80029a0:	f405 357f 	and.w	r5, r5, #261120	@ 0x3fc00
 80029a4:	f105 6500 	add.w	r5, r5, #134217728	@ 0x8000000
 80029a8:	601d      	str	r5, [r3, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1BER, FLASH_PCROP1BER_PCROP1B_END));
 80029aa:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
  *PCROP1BEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80029ac:	029b      	lsls	r3, r3, #10
 80029ae:	f403 337f 	and.w	r3, r3, #261120	@ 0x3fc00
 80029b2:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 80029b6:	9d02      	ldr	r5, [sp, #8]
 80029b8:	602b      	str	r3, [r5, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1ASR, FLASH_PCROP1ASR_PCROP1A_STRT));
 80029ba:	6a63      	ldr	r3, [r4, #36]	@ 0x24
  *PCROP1AStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80029bc:	029b      	lsls	r3, r3, #10
 80029be:	f403 337f 	and.w	r3, r3, #261120	@ 0x3fc00
 80029c2:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 80029c6:	600b      	str	r3, [r1, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1AER, FLASH_PCROP1AER_PCROP1A_END));
 80029c8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
  *PCROP1AEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80029ca:	029b      	lsls	r3, r3, #10
 80029cc:	f403 337f 	and.w	r3, r3, #261120	@ 0x3fc00
 80029d0:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 80029d4:	6013      	str	r3, [r2, #0]

  *PCROPConfig      = (READ_REG(FLASH->PCROP1AER) & FLASH_PCROP1AER_PCROP_RDP);
 80029d6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80029d8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80029dc:	6003      	str	r3, [r0, #0]
}
 80029de:	bc30      	pop	{r4, r5}
 80029e0:	4770      	bx	lr
 80029e2:	bf00      	nop
 80029e4:	58004000 	.word	0x58004000

080029e8 <FLASH_OB_GetIPCCBufferAddr>:
  *           This value correspond to the first double-word of the IPCC mailbox data buffer area
  *           in SRAM starting from 0x20000000 (SRAM1 start address to SRAM2 end address).
  */
static uint32_t FLASH_OB_GetIPCCBufferAddr(void)
{
  return (uint32_t)((READ_BIT(FLASH->IPCCBR, FLASH_IPCCBR_IPCCDBA) << 4) + SRAM1_BASE);
 80029e8:	4b03      	ldr	r3, [pc, #12]	@ (80029f8 <FLASH_OB_GetIPCCBufferAddr+0x10>)
 80029ea:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80029ec:	4803      	ldr	r0, [pc, #12]	@ (80029fc <FLASH_OB_GetIPCCBufferAddr+0x14>)
 80029ee:	ea00 1003 	and.w	r0, r0, r3, lsl #4
}
 80029f2:	f100 5000 	add.w	r0, r0, #536870912	@ 0x20000000
 80029f6:	4770      	bx	lr
 80029f8:	58004000 	.word	0x58004000
 80029fc:	0003fff0 	.word	0x0003fff0

08002a00 <FLASH_OB_GetC2BootResetConfig>:
  * @param  C2BootResetRegion   Specifies the Secure Boot reset memory region
  * @retval None
  */
static void FLASH_OB_GetC2BootResetConfig(uint32_t *C2BootResetVectAddr, uint32_t *C2BootResetRegion)
{
  *C2BootResetRegion = (READ_BIT(FLASH->SRRVR, FLASH_SRRVR_C2OPT));
 8002a00:	4b0d      	ldr	r3, [pc, #52]	@ (8002a38 <FLASH_OB_GetC2BootResetConfig+0x38>)
 8002a02:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8002a06:	f003 4200 	and.w	r2, r3, #2147483648	@ 0x80000000
 8002a0a:	600a      	str	r2, [r1, #0]

  if (*C2BootResetRegion == OB_C2_BOOT_FROM_FLASH)
 8002a0c:	2b00      	cmp	r3, #0
 8002a0e:	db09      	blt.n	8002a24 <FLASH_OB_GetC2BootResetConfig+0x24>
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
  }
  else
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + SRAM1_BASE);
 8002a10:	4b09      	ldr	r3, [pc, #36]	@ (8002a38 <FLASH_OB_GetC2BootResetConfig+0x38>)
 8002a12:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 8002a16:	4b09      	ldr	r3, [pc, #36]	@ (8002a3c <FLASH_OB_GetC2BootResetConfig+0x3c>)
 8002a18:	ea03 0382 	and.w	r3, r3, r2, lsl #2
 8002a1c:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 8002a20:	6003      	str	r3, [r0, #0]
  }
}
 8002a22:	4770      	bx	lr
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
 8002a24:	4b04      	ldr	r3, [pc, #16]	@ (8002a38 <FLASH_OB_GetC2BootResetConfig+0x38>)
 8002a26:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 8002a2a:	4b04      	ldr	r3, [pc, #16]	@ (8002a3c <FLASH_OB_GetC2BootResetConfig+0x3c>)
 8002a2c:	ea03 0382 	and.w	r3, r3, r2, lsl #2
 8002a30:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 8002a34:	6003      	str	r3, [r0, #0]
 8002a36:	4770      	bx	lr
 8002a38:	58004000 	.word	0x58004000
 8002a3c:	0003fffc 	.word	0x0003fffc

08002a40 <FLASH_OB_GetSUBGHZSPISecureAccess>:
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_DISABLE : Sub-GHz radio SPI Secure access disabled
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_ENABLE : Sub-GHz radio SPI Secure access enabled
  */
static uint32_t FLASH_OB_GetSUBGHZSPISecureAccess(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_SUBGHZSPISD));
 8002a40:	4b02      	ldr	r3, [pc, #8]	@ (8002a4c <FLASH_OB_GetSUBGHZSPISecureAccess+0xc>)
 8002a42:	f8d3 0080 	ldr.w	r0, [r3, #128]	@ 0x80
}
 8002a46:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
 8002a4a:	4770      	bx	lr
 8002a4c:	58004000 	.word	0x58004000

08002a50 <FLASH_OB_GetC2DebugAccessMode>:
  *           @arg @ref OB_C2_DEBUG_ACCESS_DISABLE : CPU2 debug access disabled
  *           @arg @ref OB_C2_DEBUG_ACCESS_ENABLE : CPU2 debug access enabled
  */
static uint32_t FLASH_OB_GetC2DebugAccessMode(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_DDS));
 8002a50:	4b02      	ldr	r3, [pc, #8]	@ (8002a5c <FLASH_OB_GetC2DebugAccessMode+0xc>)
 8002a52:	f8d3 0080 	ldr.w	r0, [r3, #128]	@ 0x80
}
 8002a56:	f400 5080 	and.w	r0, r0, #4096	@ 0x1000
 8002a5a:	4770      	bx	lr
 8002a5c:	58004000 	.word	0x58004000

08002a60 <FLASH_OB_ConfigSecureMode>:
  * @retval None
  */
static void FLASH_OB_ConfigSecureMode(uint32_t SecureMode, uint32_t *Reg, uint32_t Bit, uint32_t ValueEnable)
{
  /* Check if SecureMode is requested */
  if ((SecureMode & ValueEnable) == ValueEnable)
 8002a60:	4383      	bics	r3, r0
 8002a62:	d003      	beq.n	8002a6c <FLASH_OB_ConfigSecureMode+0xc>
  {
    CLEAR_BIT(*Reg, Bit);
  }
  else
  {
    SET_BIT(*Reg, Bit);
 8002a64:	680b      	ldr	r3, [r1, #0]
 8002a66:	4313      	orrs	r3, r2
 8002a68:	600b      	str	r3, [r1, #0]
  }
}
 8002a6a:	4770      	bx	lr
    CLEAR_BIT(*Reg, Bit);
 8002a6c:	680b      	ldr	r3, [r1, #0]
 8002a6e:	ea23 0302 	bic.w	r3, r3, r2
 8002a72:	600b      	str	r3, [r1, #0]
 8002a74:	4770      	bx	lr
	...

08002a78 <FLASH_OB_SecureConfig>:
{
 8002a78:	b510      	push	{r4, lr}
 8002a7a:	b082      	sub	sp, #8
 8002a7c:	4604      	mov	r4, r0
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 8002a7e:	4b49      	ldr	r3, [pc, #292]	@ (8002ba4 <FLASH_OB_SecureConfig+0x12c>)
 8002a80:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 8002a84:	9201      	str	r2, [sp, #4]
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);
 8002a86:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8002a8a:	9300      	str	r3, [sp, #0]
  if ((pOBParam->OptionType & OPTIONBYTE_SECURE_MODE) != 0U)
 8002a8c:	6801      	ldr	r1, [r0, #0]
 8002a8e:	f411 7f00 	tst.w	r1, #512	@ 0x200
 8002a92:	d032      	beq.n	8002afa <FLASH_OB_SecureConfig+0x82>
    MODIFY_REG(sfr_reg_val, (FLASH_SFR_SFSA | FLASH_SFR_HDPSA), \
 8002a94:	f022 127f 	bic.w	r2, r2, #8323199	@ 0x7f007f
 8002a98:	6b01      	ldr	r1, [r0, #48]	@ 0x30
 8002a9a:	f101 4078 	add.w	r0, r1, #4160749568	@ 0xf8000000
 8002a9e:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8002aa0:	f101 4178 	add.w	r1, r1, #4160749568	@ 0xf8000000
 8002aa4:	0ac9      	lsrs	r1, r1, #11
 8002aa6:	0409      	lsls	r1, r1, #16
 8002aa8:	ea41 21d0 	orr.w	r1, r1, r0, lsr #11
 8002aac:	430a      	orrs	r2, r1
 8002aae:	9201      	str	r2, [sp, #4]
    MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRSA | FLASH_SRRVR_SNBRSA), \
 8002ab0:	f023 5379 	bic.w	r3, r3, #1044381696	@ 0x3e400000
 8002ab4:	f423 1370 	bic.w	r3, r3, #3932160	@ 0x3c0000
 8002ab8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8002aba:	f101 4160 	add.w	r1, r1, #3758096384	@ 0xe0000000
 8002abe:	f5a1 4100 	sub.w	r1, r1, #32768	@ 0x8000
 8002ac2:	0a88      	lsrs	r0, r1, #10
 8002ac4:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8002ac6:	f101 4160 	add.w	r1, r1, #3758096384	@ 0xe0000000
 8002aca:	0a89      	lsrs	r1, r1, #10
 8002acc:	0649      	lsls	r1, r1, #25
 8002ace:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
 8002ad2:	430b      	orrs	r3, r1
 8002ad4:	9300      	str	r3, [sp, #0]
    if (pOBParam->SecureMode == OB_SECURE_SYSTEM_AND_ALL_AREAS_ENABLE)
 8002ad6:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8002ad8:	280f      	cmp	r0, #15
 8002ada:	d008      	beq.n	8002aee <FLASH_OB_SecureConfig+0x76>
    else if (pOBParam->SecureMode == OB_SECURE_SYSTEM_AND_ALL_AREAS_DISABLE)
 8002adc:	28f0      	cmp	r0, #240	@ 0xf0
 8002ade:	d13b      	bne.n	8002b58 <FLASH_OB_SecureConfig+0xe0>
      SET_BIT(sfr_reg_val, (FLASH_SFR_FSD | FLASH_SFR_HDPAD));
 8002ae0:	f042 1280 	orr.w	r2, r2, #8388736	@ 0x800080
 8002ae4:	9201      	str	r2, [sp, #4]
      SET_BIT(srrvr_reg_val, (FLASH_SRRVR_BRSD | FLASH_SRRVR_NBRSD));
 8002ae6:	f043 4381 	orr.w	r3, r3, #1082130432	@ 0x40800000
 8002aea:	9300      	str	r3, [sp, #0]
 8002aec:	e005      	b.n	8002afa <FLASH_OB_SecureConfig+0x82>
      CLEAR_BIT(sfr_reg_val, (FLASH_SFR_FSD | FLASH_SFR_HDPAD));
 8002aee:	f022 1280 	bic.w	r2, r2, #8388736	@ 0x800080
 8002af2:	9201      	str	r2, [sp, #4]
      CLEAR_BIT(srrvr_reg_val, (FLASH_SRRVR_BRSD | FLASH_SRRVR_NBRSD));
 8002af4:	f023 4381 	bic.w	r3, r3, #1082130432	@ 0x40800000
 8002af8:	9300      	str	r3, [sp, #0]
  if ((pOBParam->OptionType & OPTIONBYTE_C2_BOOT_VECT) != 0U)
 8002afa:	6823      	ldr	r3, [r4, #0]
 8002afc:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8002b00:	d00d      	beq.n	8002b1e <FLASH_OB_SecureConfig+0xa6>
    if (pOBParam->C2BootRegion == OB_C2_BOOT_FROM_FLASH)
 8002b02:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8002b04:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8002b08:	d041      	beq.n	8002b8e <FLASH_OB_SecureConfig+0x116>
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - SRAM1_BASE) >> 2) | pOBParam->C2BootRegion));
 8002b0a:	4a27      	ldr	r2, [pc, #156]	@ (8002ba8 <FLASH_OB_SecureConfig+0x130>)
 8002b0c:	9900      	ldr	r1, [sp, #0]
 8002b0e:	400a      	ands	r2, r1
 8002b10:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 8002b12:	f101 4160 	add.w	r1, r1, #3758096384	@ 0xe0000000
 8002b16:	ea43 0391 	orr.w	r3, r3, r1, lsr #2
 8002b1a:	431a      	orrs	r2, r3
 8002b1c:	9200      	str	r2, [sp, #0]
  if ((pOBParam->OptionType & OPTIONBYTE_C2_DEBUG_ACCESS) != 0U)
 8002b1e:	6823      	ldr	r3, [r4, #0]
 8002b20:	f413 6f80 	tst.w	r3, #1024	@ 0x400
 8002b24:	d005      	beq.n	8002b32 <FLASH_OB_SecureConfig+0xba>
    MODIFY_REG(sfr_reg_val, FLASH_SFR_DDS, (uint32_t)pOBParam->C2DebugAccessMode);
 8002b26:	9b01      	ldr	r3, [sp, #4]
 8002b28:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8002b2c:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8002b2e:	4313      	orrs	r3, r2
 8002b30:	9301      	str	r3, [sp, #4]
  if ((pOBParam->OptionType & OPTIONBYTE_SUBGHZSPI_SECURE_ACCESS) != 0U)
 8002b32:	6823      	ldr	r3, [r4, #0]
 8002b34:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 8002b38:	d005      	beq.n	8002b46 <FLASH_OB_SecureConfig+0xce>
    MODIFY_REG(sfr_reg_val, FLASH_SFR_SUBGHZSPISD, (uint32_t)pOBParam->SUBGHZSPISecureAccess);
 8002b3a:	9b01      	ldr	r3, [sp, #4]
 8002b3c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8002b40:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8002b42:	4313      	orrs	r3, r2
 8002b44:	9301      	str	r3, [sp, #4]
  WRITE_REG(FLASH->SFR, sfr_reg_val);
 8002b46:	4b17      	ldr	r3, [pc, #92]	@ (8002ba4 <FLASH_OB_SecureConfig+0x12c>)
 8002b48:	9a01      	ldr	r2, [sp, #4]
 8002b4a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  WRITE_REG(FLASH->SRRVR, srrvr_reg_val);
 8002b4e:	9a00      	ldr	r2, [sp, #0]
 8002b50:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
}
 8002b54:	b002      	add	sp, #8
 8002b56:	bd10      	pop	{r4, pc}
      FLASH_OB_ConfigSecureMode(pOBParam->SecureMode, &sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE);
 8002b58:	2301      	movs	r3, #1
 8002b5a:	2280      	movs	r2, #128	@ 0x80
 8002b5c:	a901      	add	r1, sp, #4
 8002b5e:	f7ff ff7f 	bl	8002a60 <FLASH_OB_ConfigSecureMode>
      FLASH_OB_ConfigSecureMode(pOBParam->SecureMode, &sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE);
 8002b62:	2302      	movs	r3, #2
 8002b64:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 8002b68:	a901      	add	r1, sp, #4
 8002b6a:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8002b6c:	f7ff ff78 	bl	8002a60 <FLASH_OB_ConfigSecureMode>
      FLASH_OB_ConfigSecureMode(pOBParam->SecureMode, &srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE);
 8002b70:	2304      	movs	r3, #4
 8002b72:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8002b76:	4669      	mov	r1, sp
 8002b78:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8002b7a:	f7ff ff71 	bl	8002a60 <FLASH_OB_ConfigSecureMode>
      FLASH_OB_ConfigSecureMode(pOBParam->SecureMode, &srrvr_reg_val, FLASH_SRRVR_BRSD, OB_SECURE_SRAM2_ENABLE);
 8002b7e:	2308      	movs	r3, #8
 8002b80:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 8002b84:	4669      	mov	r1, sp
 8002b86:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8002b88:	f7ff ff6a 	bl	8002a60 <FLASH_OB_ConfigSecureMode>
 8002b8c:	e7b5      	b.n	8002afa <FLASH_OB_SecureConfig+0x82>
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - FLASH_BASE) >> 2) | pOBParam->C2BootRegion));
 8002b8e:	4a06      	ldr	r2, [pc, #24]	@ (8002ba8 <FLASH_OB_SecureConfig+0x130>)
 8002b90:	9900      	ldr	r1, [sp, #0]
 8002b92:	400a      	ands	r2, r1
 8002b94:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 8002b96:	f101 4178 	add.w	r1, r1, #4160749568	@ 0xf8000000
 8002b9a:	ea43 0391 	orr.w	r3, r3, r1, lsr #2
 8002b9e:	431a      	orrs	r2, r3
 8002ba0:	9200      	str	r2, [sp, #0]
 8002ba2:	e7bc      	b.n	8002b1e <FLASH_OB_SecureConfig+0xa6>
 8002ba4:	58004000 	.word	0x58004000
 8002ba8:	7fff0000 	.word	0x7fff0000

08002bac <FLASH_OB_GetSecureMode>:
  *                               Null
  */
static uint32_t FLASH_OB_GetSecureMode(uint32_t Reg, uint32_t Bit, uint32_t ValueEnable, uint32_t ValueDisable)
{
  /* Return status of bit (set as enable, set as disable) */
  if (READ_BIT(Reg, Bit) == 0U)
 8002bac:	4208      	tst	r0, r1
 8002bae:	d100      	bne.n	8002bb2 <FLASH_OB_GetSecureMode+0x6>
  {
    return ValueEnable;
 8002bb0:	4613      	mov	r3, r2
  }
  else
  {
    return ValueDisable;
  }
}
 8002bb2:	4618      	mov	r0, r3
 8002bb4:	4770      	bx	lr
	...

08002bb8 <FLASH_OB_GetSecureMemoryConfig>:
{
 8002bb8:	b570      	push	{r4, r5, r6, lr}
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 8002bba:	4c21      	ldr	r4, [pc, #132]	@ (8002c40 <FLASH_OB_GetSecureMemoryConfig+0x88>)
 8002bbc:	f8d4 6080 	ldr.w	r6, [r4, #128]	@ 0x80
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);
 8002bc0:	f8d4 5084 	ldr.w	r5, [r4, #132]	@ 0x84
  uint32_t user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_SFSA) >> FLASH_SFR_SFSA_Pos);
 8002bc4:	f006 047f 	and.w	r4, r6, #127	@ 0x7f
  *SecureFlashStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 8002bc8:	f504 3480 	add.w	r4, r4, #65536	@ 0x10000
 8002bcc:	02e4      	lsls	r4, r4, #11
 8002bce:	6004      	str	r4, [r0, #0]
  user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_HDPSA) >> FLASH_SFR_HDPSA_Pos);
 8002bd0:	f3c6 4006 	ubfx	r0, r6, #16, #7
  *HideProtectionStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 8002bd4:	f500 3080 	add.w	r0, r0, #65536	@ 0x10000
 8002bd8:	02c0      	lsls	r0, r0, #11
 8002bda:	6008      	str	r0, [r1, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SBRSA) >> FLASH_SRRVR_SBRSA_Pos);
 8002bdc:	0ca9      	lsrs	r1, r5, #18
  *SecureSRAM2StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM2_BASE);
 8002bde:	0289      	lsls	r1, r1, #10
 8002be0:	f401 41f8 	and.w	r1, r1, #31744	@ 0x7c00
 8002be4:	f101 5100 	add.w	r1, r1, #536870912	@ 0x20000000
 8002be8:	f501 4100 	add.w	r1, r1, #32768	@ 0x8000
 8002bec:	6011      	str	r1, [r2, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SNBRSA) >> FLASH_SRRVR_SNBRSA_Pos);
 8002bee:	0e6a      	lsrs	r2, r5, #25
  *SecureSRAM1StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM1_BASE);
 8002bf0:	0292      	lsls	r2, r2, #10
 8002bf2:	f402 42f8 	and.w	r2, r2, #31744	@ 0x7c00
 8002bf6:	f102 5200 	add.w	r2, r2, #536870912	@ 0x20000000
 8002bfa:	601a      	str	r2, [r3, #0]
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8002bfc:	2310      	movs	r3, #16
 8002bfe:	2201      	movs	r2, #1
 8002c00:	2180      	movs	r1, #128	@ 0x80
 8002c02:	4630      	mov	r0, r6
 8002c04:	f7ff ffd2 	bl	8002bac <FLASH_OB_GetSecureMode>
 8002c08:	4604      	mov	r4, r0
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 8002c0a:	2320      	movs	r3, #32
 8002c0c:	2202      	movs	r2, #2
 8002c0e:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
 8002c12:	4630      	mov	r0, r6
 8002c14:	f7ff ffca 	bl	8002bac <FLASH_OB_GetSecureMode>
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8002c18:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 8002c1a:	2340      	movs	r3, #64	@ 0x40
 8002c1c:	2204      	movs	r2, #4
 8002c1e:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8002c22:	4628      	mov	r0, r5
 8002c24:	f7ff ffc2 	bl	8002bac <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 8002c28:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_BRSD, OB_SECURE_SRAM2_ENABLE, OB_SECURE_SRAM2_DISABLE));
 8002c2a:	2380      	movs	r3, #128	@ 0x80
 8002c2c:	2208      	movs	r2, #8
 8002c2e:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
 8002c32:	4628      	mov	r0, r5
 8002c34:	f7ff ffba 	bl	8002bac <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 8002c38:	4304      	orrs	r4, r0
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8002c3a:	9b04      	ldr	r3, [sp, #16]
 8002c3c:	601c      	str	r4, [r3, #0]
}
 8002c3e:	bd70      	pop	{r4, r5, r6, pc}
 8002c40:	58004000 	.word	0x58004000

08002c44 <FLASH_OB_ProceedWriteOperation>:
{
 8002c44:	b508      	push	{r3, lr}
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8002c46:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8002c4a:	f7ff fddb 	bl	8002804 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 8002c4e:	b100      	cbz	r0, 8002c52 <FLASH_OB_ProceedWriteOperation+0xe>
}
 8002c50:	bd08      	pop	{r3, pc}
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8002c52:	4a05      	ldr	r2, [pc, #20]	@ (8002c68 <FLASH_OB_ProceedWriteOperation+0x24>)
 8002c54:	6953      	ldr	r3, [r2, #20]
 8002c56:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8002c5a:	6153      	str	r3, [r2, #20]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8002c5c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8002c60:	f7ff fdd0 	bl	8002804 <FLASH_WaitForLastOperation>
 8002c64:	e7f4      	b.n	8002c50 <FLASH_OB_ProceedWriteOperation+0xc>
 8002c66:	bf00      	nop
 8002c68:	58004000 	.word	0x58004000

08002c6c <HAL_FLASHEx_OBProgram>:
  __HAL_LOCK(&pFlash);
 8002c6c:	4b32      	ldr	r3, [pc, #200]	@ (8002d38 <HAL_FLASHEx_OBProgram+0xcc>)
 8002c6e:	781b      	ldrb	r3, [r3, #0]
 8002c70:	2b01      	cmp	r3, #1
 8002c72:	d05e      	beq.n	8002d32 <HAL_FLASHEx_OBProgram+0xc6>
{
 8002c74:	b510      	push	{r4, lr}
 8002c76:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
 8002c78:	4b2f      	ldr	r3, [pc, #188]	@ (8002d38 <HAL_FLASHEx_OBProgram+0xcc>)
 8002c7a:	2201      	movs	r2, #1
 8002c7c:	701a      	strb	r2, [r3, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8002c7e:	2200      	movs	r2, #0
 8002c80:	605a      	str	r2, [r3, #4]
  if ((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
 8002c82:	6803      	ldr	r3, [r0, #0]
 8002c84:	f013 0f01 	tst.w	r3, #1
 8002c88:	d124      	bne.n	8002cd4 <HAL_FLASHEx_OBProgram+0x68>
  if ((pOBInit->OptionType & (OPTIONBYTE_RDP | OPTIONBYTE_USER)) == (OPTIONBYTE_RDP | OPTIONBYTE_USER))
 8002c8a:	6823      	ldr	r3, [r4, #0]
 8002c8c:	f003 0206 	and.w	r2, r3, #6
 8002c90:	2a06      	cmp	r2, #6
 8002c92:	d025      	beq.n	8002ce0 <HAL_FLASHEx_OBProgram+0x74>
  else if ((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 8002c94:	f013 0f02 	tst.w	r3, #2
 8002c98:	d128      	bne.n	8002cec <HAL_FLASHEx_OBProgram+0x80>
  else if ((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 8002c9a:	f013 0f04 	tst.w	r3, #4
 8002c9e:	d12e      	bne.n	8002cfe <HAL_FLASHEx_OBProgram+0x92>
  if ((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
 8002ca0:	6823      	ldr	r3, [r4, #0]
 8002ca2:	f013 0f08 	tst.w	r3, #8
 8002ca6:	d007      	beq.n	8002cb8 <HAL_FLASHEx_OBProgram+0x4c>
    if ((pOBInit->PCROPConfig & (OB_PCROP_ZONE_A | OB_PCROP_RDP_ERASE)) != 0U)
 8002ca8:	69e0      	ldr	r0, [r4, #28]
 8002caa:	4b24      	ldr	r3, [pc, #144]	@ (8002d3c <HAL_FLASHEx_OBProgram+0xd0>)
 8002cac:	4218      	tst	r0, r3
 8002cae:	d12e      	bne.n	8002d0e <HAL_FLASHEx_OBProgram+0xa2>
    if ((pOBInit->PCROPConfig & OB_PCROP_ZONE_B) != 0U)
 8002cb0:	69e3      	ldr	r3, [r4, #28]
 8002cb2:	f013 0f02 	tst.w	r3, #2
 8002cb6:	d12f      	bne.n	8002d18 <HAL_FLASHEx_OBProgram+0xac>
  if ((pOBInit->OptionType & (OPTIONBYTE_SECURE_MODE | OPTIONBYTE_C2_BOOT_VECT | OPTIONBYTE_C2_DEBUG_ACCESS | OPTIONBYTE_SUBGHZSPI_SECURE_ACCESS)) != 0U)
 8002cb8:	6823      	ldr	r3, [r4, #0]
 8002cba:	f413 6f70 	tst.w	r3, #3840	@ 0xf00
 8002cbe:	d130      	bne.n	8002d22 <HAL_FLASHEx_OBProgram+0xb6>
  if ((pOBInit->OptionType & OPTIONBYTE_IPCC_BUF_ADDR) != 0U)
 8002cc0:	6823      	ldr	r3, [r4, #0]
 8002cc2:	f013 0f10 	tst.w	r3, #16
 8002cc6:	d130      	bne.n	8002d2a <HAL_FLASHEx_OBProgram+0xbe>
  status = FLASH_OB_ProceedWriteOperation();
 8002cc8:	f7ff ffbc 	bl	8002c44 <FLASH_OB_ProceedWriteOperation>
  __HAL_UNLOCK(&pFlash);
 8002ccc:	4b1a      	ldr	r3, [pc, #104]	@ (8002d38 <HAL_FLASHEx_OBProgram+0xcc>)
 8002cce:	2200      	movs	r2, #0
 8002cd0:	701a      	strb	r2, [r3, #0]
}
 8002cd2:	bd10      	pop	{r4, pc}
    FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 8002cd4:	68c2      	ldr	r2, [r0, #12]
 8002cd6:	6881      	ldr	r1, [r0, #8]
 8002cd8:	6840      	ldr	r0, [r0, #4]
 8002cda:	f7ff fdd3 	bl	8002884 <FLASH_OB_WRPConfig>
 8002cde:	e7d4      	b.n	8002c8a <HAL_FLASHEx_OBProgram+0x1e>
    FLASH_OB_OptrConfig(pOBInit->UserType, pOBInit->UserConfig, pOBInit->RDPLevel);
 8002ce0:	6922      	ldr	r2, [r4, #16]
 8002ce2:	69a1      	ldr	r1, [r4, #24]
 8002ce4:	6960      	ldr	r0, [r4, #20]
 8002ce6:	f7ff fde3 	bl	80028b0 <FLASH_OB_OptrConfig>
 8002cea:	e7d9      	b.n	8002ca0 <HAL_FLASHEx_OBProgram+0x34>
    optr = FLASH_OB_GetUser();
 8002cec:	f7ff fe4a 	bl	8002984 <FLASH_OB_GetUser>
    optr &= ~OB_USER_BOR_LEV;
 8002cf0:	f420 6060 	bic.w	r0, r0, #3584	@ 0xe00
    FLASH_OB_OptrConfig(optr, optr, pOBInit->RDPLevel);
 8002cf4:	6922      	ldr	r2, [r4, #16]
 8002cf6:	4601      	mov	r1, r0
 8002cf8:	f7ff fdda 	bl	80028b0 <FLASH_OB_OptrConfig>
 8002cfc:	e7d0      	b.n	8002ca0 <HAL_FLASHEx_OBProgram+0x34>
    optr = FLASH_OB_GetRDP();
 8002cfe:	f7ff fe35 	bl	800296c <FLASH_OB_GetRDP>
 8002d02:	4602      	mov	r2, r0
    FLASH_OB_OptrConfig(pOBInit->UserType, pOBInit->UserConfig, optr);
 8002d04:	69a1      	ldr	r1, [r4, #24]
 8002d06:	6960      	ldr	r0, [r4, #20]
 8002d08:	f7ff fdd2 	bl	80028b0 <FLASH_OB_OptrConfig>
 8002d0c:	e7c8      	b.n	8002ca0 <HAL_FLASHEx_OBProgram+0x34>
      FLASH_OB_PCROP1AConfig(pOBInit->PCROPConfig, pOBInit->PCROP1AStartAddr, pOBInit->PCROP1AEndAddr);
 8002d0e:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8002d10:	6a21      	ldr	r1, [r4, #32]
 8002d12:	f7ff fddb 	bl	80028cc <FLASH_OB_PCROP1AConfig>
 8002d16:	e7cb      	b.n	8002cb0 <HAL_FLASHEx_OBProgram+0x44>
      FLASH_OB_PCROP1BConfig(pOBInit->PCROP1BStartAddr, pOBInit->PCROP1BEndAddr);
 8002d18:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8002d1a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8002d1c:	f7ff fdfa 	bl	8002914 <FLASH_OB_PCROP1BConfig>
 8002d20:	e7ca      	b.n	8002cb8 <HAL_FLASHEx_OBProgram+0x4c>
    FLASH_OB_SecureConfig(pOBInit);
 8002d22:	4620      	mov	r0, r4
 8002d24:	f7ff fea8 	bl	8002a78 <FLASH_OB_SecureConfig>
 8002d28:	e7ca      	b.n	8002cc0 <HAL_FLASHEx_OBProgram+0x54>
    FLASH_OB_IPCCBufferAddrConfig(pOBInit->IPCCdataBufAddr);
 8002d2a:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 8002d2c:	f7ff fdfe 	bl	800292c <FLASH_OB_IPCCBufferAddrConfig>
 8002d30:	e7ca      	b.n	8002cc8 <HAL_FLASHEx_OBProgram+0x5c>
  __HAL_LOCK(&pFlash);
 8002d32:	2002      	movs	r0, #2
}
 8002d34:	4770      	bx	lr
 8002d36:	bf00      	nop
 8002d38:	20000470 	.word	0x20000470
 8002d3c:	80000001 	.word	0x80000001

08002d40 <HAL_FLASHEx_OBGetConfig>:
{
 8002d40:	b510      	push	{r4, lr}
 8002d42:	b082      	sub	sp, #8
 8002d44:	4604      	mov	r4, r0
  pOBInit->OptionType = OPTIONBYTE_ALL;
 8002d46:	f640 731f 	movw	r3, #3871	@ 0xf1f
 8002d4a:	6003      	str	r3, [r0, #0]
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
 8002d4c:	6840      	ldr	r0, [r0, #4]
 8002d4e:	2801      	cmp	r0, #1
 8002d50:	d936      	bls.n	8002dc0 <HAL_FLASHEx_OBGetConfig+0x80>
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 8002d52:	f7ff fe0b 	bl	800296c <FLASH_OB_GetRDP>
 8002d56:	6120      	str	r0, [r4, #16]
  pOBInit->UserConfig = FLASH_OB_GetUser();
 8002d58:	f7ff fe14 	bl	8002984 <FLASH_OB_GetUser>
 8002d5c:	61a0      	str	r0, [r4, #24]
  pOBInit->UserType = OB_USER_ALL;
 8002d5e:	4b1c      	ldr	r3, [pc, #112]	@ (8002dd0 <HAL_FLASHEx_OBGetConfig+0x90>)
 8002d60:	6163      	str	r3, [r4, #20]
  FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROP1AStartAddr), &(pOBInit->PCROP1AEndAddr), &(pOBInit->PCROP1BStartAddr), &(pOBInit->PCROP1BEndAddr));
 8002d62:	f104 032c 	add.w	r3, r4, #44	@ 0x2c
 8002d66:	9300      	str	r3, [sp, #0]
 8002d68:	f104 0328 	add.w	r3, r4, #40	@ 0x28
 8002d6c:	f104 0224 	add.w	r2, r4, #36	@ 0x24
 8002d70:	f104 0120 	add.w	r1, r4, #32
 8002d74:	f104 001c 	add.w	r0, r4, #28
 8002d78:	f7ff fe0e 	bl	8002998 <FLASH_OB_GetPCROP>
  pOBInit->PCROPConfig |= (OB_PCROP_ZONE_A | OB_PCROP_ZONE_B);
 8002d7c:	69e3      	ldr	r3, [r4, #28]
 8002d7e:	f043 0303 	orr.w	r3, r3, #3
 8002d82:	61e3      	str	r3, [r4, #28]
  pOBInit->IPCCdataBufAddr = FLASH_OB_GetIPCCBufferAddr();
 8002d84:	f7ff fe30 	bl	80029e8 <FLASH_OB_GetIPCCBufferAddr>
 8002d88:	6560      	str	r0, [r4, #84]	@ 0x54
  FLASH_OB_GetSecureMemoryConfig(&(pOBInit->SecureFlashStartAddr), &(pOBInit->HideProtectionStartAddr), &(pOBInit->SecureSRAM2StartAddr), &(pOBInit->SecureSRAM1StartAddr), &(pOBInit->SecureMode));
 8002d8a:	f104 0340 	add.w	r3, r4, #64	@ 0x40
 8002d8e:	9300      	str	r3, [sp, #0]
 8002d90:	f104 0338 	add.w	r3, r4, #56	@ 0x38
 8002d94:	f104 0234 	add.w	r2, r4, #52	@ 0x34
 8002d98:	f104 013c 	add.w	r1, r4, #60	@ 0x3c
 8002d9c:	f104 0030 	add.w	r0, r4, #48	@ 0x30
 8002da0:	f7ff ff0a 	bl	8002bb8 <FLASH_OB_GetSecureMemoryConfig>
  FLASH_OB_GetC2BootResetConfig(&(pOBInit->C2SecureBootVectAddr), &(pOBInit->C2BootRegion));
 8002da4:	f104 014c 	add.w	r1, r4, #76	@ 0x4c
 8002da8:	f104 0050 	add.w	r0, r4, #80	@ 0x50
 8002dac:	f7ff fe28 	bl	8002a00 <FLASH_OB_GetC2BootResetConfig>
  pOBInit->SUBGHZSPISecureAccess = FLASH_OB_GetSUBGHZSPISecureAccess();
 8002db0:	f7ff fe46 	bl	8002a40 <FLASH_OB_GetSUBGHZSPISecureAccess>
 8002db4:	6460      	str	r0, [r4, #68]	@ 0x44
  pOBInit->C2DebugAccessMode = FLASH_OB_GetC2DebugAccessMode();
 8002db6:	f7ff fe4b 	bl	8002a50 <FLASH_OB_GetC2DebugAccessMode>
 8002dba:	64a0      	str	r0, [r4, #72]	@ 0x48
}
 8002dbc:	b002      	add	sp, #8
 8002dbe:	bd10      	pop	{r4, pc}
    FLASH_OB_GetWRP(pOBInit->WRPArea, &(pOBInit->WRPStartOffset), &(pOBInit->WRPEndOffset));
 8002dc0:	f104 020c 	add.w	r2, r4, #12
 8002dc4:	f104 0108 	add.w	r1, r4, #8
 8002dc8:	f7ff fdb8 	bl	800293c <FLASH_OB_GetWRP>
 8002dcc:	e7c1      	b.n	8002d52 <HAL_FLASHEx_OBGetConfig+0x12>
 8002dce:	bf00      	nop
 8002dd0:	cf8f7e00 	.word	0xcf8f7e00

08002dd4 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002dd4:	b570      	push	{r4, r5, r6, lr}
  uint32_t position = 0x00u;
 8002dd6:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8002dd8:	e069      	b.n	8002eae <HAL_GPIO_Init+0xda>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8002dda:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8002ddc:	005e      	lsls	r6, r3, #1
 8002dde:	2403      	movs	r4, #3
 8002de0:	40b4      	lsls	r4, r6
 8002de2:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002de6:	68cc      	ldr	r4, [r1, #12]
 8002de8:	40b4      	lsls	r4, r6
 8002dea:	432c      	orrs	r4, r5
        GPIOx->OSPEEDR = temp;
 8002dec:	6084      	str	r4, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8002dee:	6845      	ldr	r5, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8002df0:	ea25 050c 	bic.w	r5, r5, ip
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002df4:	684c      	ldr	r4, [r1, #4]
 8002df6:	f3c4 1400 	ubfx	r4, r4, #4, #1
 8002dfa:	409c      	lsls	r4, r3
 8002dfc:	432c      	orrs	r4, r5
        GPIOx->OTYPER = temp;
 8002dfe:	6044      	str	r4, [r0, #4]
 8002e00:	e066      	b.n	8002ed0 <HAL_GPIO_Init+0xfc>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8002e02:	08dd      	lsrs	r5, r3, #3
 8002e04:	3508      	adds	r5, #8
 8002e06:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8002e0a:	f003 0c07 	and.w	ip, r3, #7
 8002e0e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8002e12:	f04f 0e0f 	mov.w	lr, #15
 8002e16:	fa0e fe0c 	lsl.w	lr, lr, ip
 8002e1a:	ea24 0e0e 	bic.w	lr, r4, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8002e1e:	690c      	ldr	r4, [r1, #16]
 8002e20:	fa04 f40c 	lsl.w	r4, r4, ip
 8002e24:	ea44 040e 	orr.w	r4, r4, lr
        GPIOx->AFR[position >> 3u] = temp;
 8002e28:	f840 4025 	str.w	r4, [r0, r5, lsl #2]
 8002e2c:	e067      	b.n	8002efe <HAL_GPIO_Init+0x12a>
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = SYSCFG->EXTICR[position >> 2u];
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8002e2e:	2402      	movs	r4, #2
 8002e30:	e000      	b.n	8002e34 <HAL_GPIO_Init+0x60>
 8002e32:	2400      	movs	r4, #0
 8002e34:	fa04 f40e 	lsl.w	r4, r4, lr
 8002e38:	432c      	orrs	r4, r5
        SYSCFG->EXTICR[position >> 2u] = temp;
 8002e3a:	f10c 0c02 	add.w	ip, ip, #2
 8002e3e:	4d4b      	ldr	r5, [pc, #300]	@ (8002f6c <HAL_GPIO_Init+0x198>)
 8002e40:	f845 402c 	str.w	r4, [r5, ip, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8002e44:	4c4a      	ldr	r4, [pc, #296]	@ (8002f70 <HAL_GPIO_Init+0x19c>)
 8002e46:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
 8002e48:	43d4      	mvns	r4, r2
 8002e4a:	ea25 0602 	bic.w	r6, r5, r2
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8002e4e:	f8d1 c004 	ldr.w	ip, [r1, #4]
 8002e52:	f41c 1f80 	tst.w	ip, #1048576	@ 0x100000
 8002e56:	d001      	beq.n	8002e5c <HAL_GPIO_Init+0x88>
        {
          temp |= iocurrent;
 8002e58:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->RTSR1 = temp;
 8002e5c:	4d44      	ldr	r5, [pc, #272]	@ (8002f70 <HAL_GPIO_Init+0x19c>)
 8002e5e:	602e      	str	r6, [r5, #0]

        temp = EXTI->FTSR1;
 8002e60:	686d      	ldr	r5, [r5, #4]
        temp &= ~(iocurrent);
 8002e62:	ea04 0605 	and.w	r6, r4, r5
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8002e66:	f8d1 c004 	ldr.w	ip, [r1, #4]
 8002e6a:	f41c 1f00 	tst.w	ip, #2097152	@ 0x200000
 8002e6e:	d001      	beq.n	8002e74 <HAL_GPIO_Init+0xa0>
        {
          temp |= iocurrent;
 8002e70:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->FTSR1 = temp;
 8002e74:	4d3e      	ldr	r5, [pc, #248]	@ (8002f70 <HAL_GPIO_Init+0x19c>)
 8002e76:	606e      	str	r6, [r5, #4]

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 8002e78:	f8d5 5080 	ldr.w	r5, [r5, #128]	@ 0x80
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8002e7c:	ea04 0605 	and.w	r6, r4, r5
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8002e80:	f8d1 c004 	ldr.w	ip, [r1, #4]
 8002e84:	f41c 3f80 	tst.w	ip, #65536	@ 0x10000
 8002e88:	d001      	beq.n	8002e8e <HAL_GPIO_Init+0xba>
        {
          temp |= iocurrent;
 8002e8a:	ea42 0605 	orr.w	r6, r2, r5
        }
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 = temp;
#else
        EXTI->IMR1 = temp;
 8002e8e:	4d38      	ldr	r5, [pc, #224]	@ (8002f70 <HAL_GPIO_Init+0x19c>)
 8002e90:	f8c5 6080 	str.w	r6, [r5, #128]	@ 0x80
#endif /* CORE_CM0PLUS */

#ifdef CORE_CM0PLUS
        temp = EXTI->C2EMR1;
#else
        temp = EXTI->EMR1;
 8002e94:	f8d5 5084 	ldr.w	r5, [r5, #132]	@ 0x84
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8002e98:	402c      	ands	r4, r5
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8002e9a:	684e      	ldr	r6, [r1, #4]
 8002e9c:	f416 3f00 	tst.w	r6, #131072	@ 0x20000
 8002ea0:	d001      	beq.n	8002ea6 <HAL_GPIO_Init+0xd2>
        {
          temp |= iocurrent;
 8002ea2:	ea42 0405 	orr.w	r4, r2, r5
        }
#ifdef CORE_CM0PLUS
        EXTI->C2EMR1 = temp;
#else
        EXTI->EMR1 = temp;
 8002ea6:	4a32      	ldr	r2, [pc, #200]	@ (8002f70 <HAL_GPIO_Init+0x19c>)
 8002ea8:	f8c2 4084 	str.w	r4, [r2, #132]	@ 0x84
#endif /* CORE_CM0PLUS */
      }
    }

    position++;
 8002eac:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8002eae:	680a      	ldr	r2, [r1, #0]
 8002eb0:	fa32 f403 	lsrs.w	r4, r2, r3
 8002eb4:	d058      	beq.n	8002f68 <HAL_GPIO_Init+0x194>
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8002eb6:	f04f 0c01 	mov.w	ip, #1
 8002eba:	fa0c fc03 	lsl.w	ip, ip, r3
    if (iocurrent != 0x00u)
 8002ebe:	ea1c 0202 	ands.w	r2, ip, r2
 8002ec2:	d0f3      	beq.n	8002eac <HAL_GPIO_Init+0xd8>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8002ec4:	684c      	ldr	r4, [r1, #4]
 8002ec6:	f004 0403 	and.w	r4, r4, #3
 8002eca:	3c01      	subs	r4, #1
 8002ecc:	2c01      	cmp	r4, #1
 8002ece:	d984      	bls.n	8002dda <HAL_GPIO_Init+0x6>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002ed0:	684c      	ldr	r4, [r1, #4]
 8002ed2:	f004 0403 	and.w	r4, r4, #3
 8002ed6:	2c03      	cmp	r4, #3
 8002ed8:	d00c      	beq.n	8002ef4 <HAL_GPIO_Init+0x120>
        temp = GPIOx->PUPDR;
 8002eda:	68c4      	ldr	r4, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8002edc:	005d      	lsls	r5, r3, #1
 8002ede:	f04f 0c03 	mov.w	ip, #3
 8002ee2:	fa0c fc05 	lsl.w	ip, ip, r5
 8002ee6:	ea24 0c0c 	bic.w	ip, r4, ip
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002eea:	688c      	ldr	r4, [r1, #8]
 8002eec:	40ac      	lsls	r4, r5
 8002eee:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->PUPDR = temp;
 8002ef2:	60c4      	str	r4, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002ef4:	684c      	ldr	r4, [r1, #4]
 8002ef6:	f004 0403 	and.w	r4, r4, #3
 8002efa:	2c02      	cmp	r4, #2
 8002efc:	d081      	beq.n	8002e02 <HAL_GPIO_Init+0x2e>
      temp = GPIOx->MODER;
 8002efe:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8002f00:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8002f04:	f04f 0c03 	mov.w	ip, #3
 8002f08:	fa0c fc0e 	lsl.w	ip, ip, lr
 8002f0c:	ea24 0c0c 	bic.w	ip, r4, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002f10:	684c      	ldr	r4, [r1, #4]
 8002f12:	f004 0403 	and.w	r4, r4, #3
 8002f16:	fa04 f40e 	lsl.w	r4, r4, lr
 8002f1a:	ea44 040c 	orr.w	r4, r4, ip
      GPIOx->MODER = temp;
 8002f1e:	6004      	str	r4, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8002f20:	684c      	ldr	r4, [r1, #4]
 8002f22:	f414 3f40 	tst.w	r4, #196608	@ 0x30000
 8002f26:	d0c1      	beq.n	8002eac <HAL_GPIO_Init+0xd8>
        temp = SYSCFG->EXTICR[position >> 2u];
 8002f28:	ea4f 0c93 	mov.w	ip, r3, lsr #2
 8002f2c:	f10c 0502 	add.w	r5, ip, #2
 8002f30:	4c0e      	ldr	r4, [pc, #56]	@ (8002f6c <HAL_GPIO_Init+0x198>)
 8002f32:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 8002f36:	f003 0e03 	and.w	lr, r3, #3
 8002f3a:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8002f3e:	2407      	movs	r4, #7
 8002f40:	fa04 f40e 	lsl.w	r4, r4, lr
 8002f44:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8002f48:	f1b0 4f90 	cmp.w	r0, #1207959552	@ 0x48000000
 8002f4c:	f43f af71 	beq.w	8002e32 <HAL_GPIO_Init+0x5e>
 8002f50:	4c08      	ldr	r4, [pc, #32]	@ (8002f74 <HAL_GPIO_Init+0x1a0>)
 8002f52:	42a0      	cmp	r0, r4
 8002f54:	d006      	beq.n	8002f64 <HAL_GPIO_Init+0x190>
 8002f56:	f504 6480 	add.w	r4, r4, #1024	@ 0x400
 8002f5a:	42a0      	cmp	r0, r4
 8002f5c:	f43f af67 	beq.w	8002e2e <HAL_GPIO_Init+0x5a>
 8002f60:	2407      	movs	r4, #7
 8002f62:	e767      	b.n	8002e34 <HAL_GPIO_Init+0x60>
 8002f64:	2401      	movs	r4, #1
 8002f66:	e765      	b.n	8002e34 <HAL_GPIO_Init+0x60>
  }
}
 8002f68:	bd70      	pop	{r4, r5, r6, pc}
 8002f6a:	bf00      	nop
 8002f6c:	40010000 	.word	0x40010000
 8002f70:	58000800 	.word	0x58000800
 8002f74:	48000400 	.word	0x48000400

08002f78 <HAL_GPIO_DeInit>:
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00u;
 8002f78:	2300      	movs	r3, #0
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
 8002f7a:	fa31 f203 	lsrs.w	r2, r1, r3
 8002f7e:	d071      	beq.n	8003064 <HAL_GPIO_DeInit+0xec>
{
 8002f80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002f82:	e02e      	b.n	8002fe2 <HAL_GPIO_DeInit+0x6a>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2u];
      tmp &= (0x07uL << (4U * (position & 0x03U)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8002f84:	2502      	movs	r5, #2
 8002f86:	e000      	b.n	8002f8a <HAL_GPIO_DeInit+0x12>
 8002f88:	2500      	movs	r5, #0
 8002f8a:	fa05 f50c 	lsl.w	r5, r5, ip
 8002f8e:	42a5      	cmp	r5, r4
 8002f90:	d049      	beq.n	8003026 <HAL_GPIO_DeInit+0xae>
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 8002f92:	6804      	ldr	r4, [r0, #0]
 8002f94:	005d      	lsls	r5, r3, #1
 8002f96:	f04f 0c03 	mov.w	ip, #3
 8002f9a:	fa0c fc05 	lsl.w	ip, ip, r5
 8002f9e:	ea44 040c 	orr.w	r4, r4, ip
 8002fa2:	6004      	str	r4, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8002fa4:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 8002fa8:	f10e 0e08 	add.w	lr, lr, #8
 8002fac:	f850 402e 	ldr.w	r4, [r0, lr, lsl #2]
 8002fb0:	f003 0607 	and.w	r6, r3, #7
 8002fb4:	00b6      	lsls	r6, r6, #2
 8002fb6:	250f      	movs	r5, #15
 8002fb8:	40b5      	lsls	r5, r6
 8002fba:	ea24 0405 	bic.w	r4, r4, r5
 8002fbe:	f840 402e 	str.w	r4, [r0, lr, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8002fc2:	6884      	ldr	r4, [r0, #8]
 8002fc4:	ea24 040c 	bic.w	r4, r4, ip
 8002fc8:	6084      	str	r4, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 8002fca:	6844      	ldr	r4, [r0, #4]
 8002fcc:	ea24 0202 	bic.w	r2, r4, r2
 8002fd0:	6042      	str	r2, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8002fd2:	68c2      	ldr	r2, [r0, #12]
 8002fd4:	ea22 020c 	bic.w	r2, r2, ip
 8002fd8:	60c2      	str	r2, [r0, #12]
    }

    position++;
 8002fda:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00u)
 8002fdc:	fa31 f203 	lsrs.w	r2, r1, r3
 8002fe0:	d03f      	beq.n	8003062 <HAL_GPIO_DeInit+0xea>
    iocurrent = (GPIO_Pin) & (1uL << position);
 8002fe2:	2201      	movs	r2, #1
 8002fe4:	409a      	lsls	r2, r3
    if (iocurrent != 0x00u)
 8002fe6:	ea12 0701 	ands.w	r7, r2, r1
 8002fea:	d0f6      	beq.n	8002fda <HAL_GPIO_DeInit+0x62>
      tmp = SYSCFG->EXTICR[position >> 2u];
 8002fec:	089e      	lsrs	r6, r3, #2
 8002fee:	1cb5      	adds	r5, r6, #2
 8002ff0:	4c1d      	ldr	r4, [pc, #116]	@ (8003068 <HAL_GPIO_DeInit+0xf0>)
 8002ff2:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 8002ff6:	f003 0c03 	and.w	ip, r3, #3
 8002ffa:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8002ffe:	f04f 0e07 	mov.w	lr, #7
 8003002:	fa0e fe0c 	lsl.w	lr, lr, ip
 8003006:	ea0e 0404 	and.w	r4, lr, r4
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800300a:	f1b0 4f90 	cmp.w	r0, #1207959552	@ 0x48000000
 800300e:	d0bb      	beq.n	8002f88 <HAL_GPIO_DeInit+0x10>
 8003010:	4d16      	ldr	r5, [pc, #88]	@ (800306c <HAL_GPIO_DeInit+0xf4>)
 8003012:	42a8      	cmp	r0, r5
 8003014:	d005      	beq.n	8003022 <HAL_GPIO_DeInit+0xaa>
 8003016:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800301a:	42a8      	cmp	r0, r5
 800301c:	d0b2      	beq.n	8002f84 <HAL_GPIO_DeInit+0xc>
 800301e:	2507      	movs	r5, #7
 8003020:	e7b3      	b.n	8002f8a <HAL_GPIO_DeInit+0x12>
 8003022:	2501      	movs	r5, #1
 8003024:	e7b1      	b.n	8002f8a <HAL_GPIO_DeInit+0x12>
        EXTI->IMR1 &= ~(iocurrent);
 8003026:	4c12      	ldr	r4, [pc, #72]	@ (8003070 <HAL_GPIO_DeInit+0xf8>)
 8003028:	f8d4 5080 	ldr.w	r5, [r4, #128]	@ 0x80
 800302c:	ea25 0507 	bic.w	r5, r5, r7
 8003030:	f8c4 5080 	str.w	r5, [r4, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
 8003034:	f8d4 5084 	ldr.w	r5, [r4, #132]	@ 0x84
 8003038:	ea25 0507 	bic.w	r5, r5, r7
 800303c:	f8c4 5084 	str.w	r5, [r4, #132]	@ 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 8003040:	6825      	ldr	r5, [r4, #0]
 8003042:	ea25 0507 	bic.w	r5, r5, r7
 8003046:	6025      	str	r5, [r4, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 8003048:	6865      	ldr	r5, [r4, #4]
 800304a:	ea25 0507 	bic.w	r5, r5, r7
 800304e:	6065      	str	r5, [r4, #4]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 8003050:	4d05      	ldr	r5, [pc, #20]	@ (8003068 <HAL_GPIO_DeInit+0xf0>)
 8003052:	3602      	adds	r6, #2
 8003054:	f855 4026 	ldr.w	r4, [r5, r6, lsl #2]
 8003058:	ea24 040e 	bic.w	r4, r4, lr
 800305c:	f845 4026 	str.w	r4, [r5, r6, lsl #2]
 8003060:	e797      	b.n	8002f92 <HAL_GPIO_DeInit+0x1a>
  }
}
 8003062:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003064:	4770      	bx	lr
 8003066:	bf00      	nop
 8003068:	40010000 	.word	0x40010000
 800306c:	48000400 	.word	0x48000400
 8003070:	58000800 	.word	0x58000800

08003074 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8003074:	b10a      	cbz	r2, 800307a <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8003076:	6181      	str	r1, [r0, #24]
 8003078:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800307a:	6281      	str	r1, [r0, #40]	@ 0x28
  }
}
 800307c:	4770      	bx	lr

0800307e <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800307e:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8003080:	ea01 0203 	and.w	r2, r1, r3
 8003084:	ea21 0103 	bic.w	r1, r1, r3
 8003088:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 800308c:	6181      	str	r1, [r0, #24]
}
 800308e:	4770      	bx	lr

08003090 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8003090:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8003092:	4b05      	ldr	r3, [pc, #20]	@ (80030a8 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 8003094:	68db      	ldr	r3, [r3, #12]
 8003096:	4203      	tst	r3, r0
 8003098:	d100      	bne.n	800309c <HAL_GPIO_EXTI_IRQHandler+0xc>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}
 800309a:	bd08      	pop	{r3, pc}
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800309c:	4b02      	ldr	r3, [pc, #8]	@ (80030a8 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 800309e:	60d8      	str	r0, [r3, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80030a0:	f7fe ffa6 	bl	8001ff0 <HAL_GPIO_EXTI_Callback>
}
 80030a4:	e7f9      	b.n	800309a <HAL_GPIO_EXTI_IRQHandler+0xa>
 80030a6:	bf00      	nop
 80030a8:	58000800 	.word	0x58000800

080030ac <HAL_IPCC_RxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_RxCallback can be implemented in the user file
   */
}
 80030ac:	4770      	bx	lr

080030ae <HAL_IPCC_TxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_TxCallback can be implemented in the user file
   */
}
 80030ae:	4770      	bx	lr

080030b0 <HAL_IPCC_TX_IRQHandler>:
{
 80030b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80030b2:	4607      	mov	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_TX_BUF;
 80030b4:	4b12      	ldr	r3, [pc, #72]	@ (8003100 <HAL_IPCC_TX_IRQHandler+0x50>)
 80030b6:	685d      	ldr	r5, [r3, #4]
 80030b8:	43ed      	mvns	r5, r5
 80030ba:	f405 157c 	and.w	r5, r5, #4128768	@ 0x3f0000
  irqmask = irqmask & ~(currentInstance->SR << IPCC_MR_CH1FM_Pos);
 80030be:	68db      	ldr	r3, [r3, #12]
 80030c0:	ea25 4503 	bic.w	r5, r5, r3, lsl #16
  uint32_t ch_count = 0U;
 80030c4:	2600      	movs	r6, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 80030c6:	e006      	b.n	80030d6 <HAL_IPCC_TX_IRQHandler+0x26>
        hipcc->ChannelCallbackTx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_TX);
 80030c8:	2200      	movs	r2, #0
 80030ca:	4631      	mov	r1, r6
 80030cc:	4638      	mov	r0, r7
 80030ce:	4798      	blx	r3
      irqmask =  irqmask & ~(bit_pos);
 80030d0:	ea25 0504 	bic.w	r5, r5, r4
    ch_count++;
 80030d4:	3601      	adds	r6, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 80030d6:	b18d      	cbz	r5, 80030fc <HAL_IPCC_TX_IRQHandler+0x4c>
    bit_pos = 1UL << (IPCC_MR_CH1FM_Pos + (ch_count & CHANNEL_INDEX_Msk));
 80030d8:	f006 030f 	and.w	r3, r6, #15
 80030dc:	3310      	adds	r3, #16
 80030de:	2401      	movs	r4, #1
 80030e0:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 80030e2:	4225      	tst	r5, r4
 80030e4:	d0f6      	beq.n	80030d4 <HAL_IPCC_TX_IRQHandler+0x24>
      currentInstance->MR |= bit_pos;
 80030e6:	4a06      	ldr	r2, [pc, #24]	@ (8003100 <HAL_IPCC_TX_IRQHandler+0x50>)
 80030e8:	6853      	ldr	r3, [r2, #4]
 80030ea:	4323      	orrs	r3, r4
 80030ec:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackTx[ch_count] != NULL)
 80030ee:	1db3      	adds	r3, r6, #6
 80030f0:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80030f4:	685b      	ldr	r3, [r3, #4]
 80030f6:	2b00      	cmp	r3, #0
 80030f8:	d1e6      	bne.n	80030c8 <HAL_IPCC_TX_IRQHandler+0x18>
 80030fa:	e7e9      	b.n	80030d0 <HAL_IPCC_TX_IRQHandler+0x20>
}
 80030fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80030fe:	bf00      	nop
 8003100:	58000c00 	.word	0x58000c00

08003104 <HAL_IPCC_RX_IRQHandler>:
{
 8003104:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003106:	4607      	mov	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_RX_BUF;
 8003108:	4a10      	ldr	r2, [pc, #64]	@ (800314c <HAL_IPCC_RX_IRQHandler+0x48>)
 800310a:	6853      	ldr	r3, [r2, #4]
 800310c:	43db      	mvns	r3, r3
 800310e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
  irqmask = irqmask & otherInstance->SR;
 8003112:	69d6      	ldr	r6, [r2, #28]
 8003114:	401e      	ands	r6, r3
  uint32_t ch_count = 0U;
 8003116:	2500      	movs	r5, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8003118:	e006      	b.n	8003128 <HAL_IPCC_RX_IRQHandler+0x24>
        hipcc->ChannelCallbackRx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_RX);
 800311a:	2201      	movs	r2, #1
 800311c:	4629      	mov	r1, r5
 800311e:	4638      	mov	r0, r7
 8003120:	4798      	blx	r3
      irqmask = irqmask & ~(bit_pos);
 8003122:	ea26 0604 	bic.w	r6, r6, r4
    ch_count++;
 8003126:	3501      	adds	r5, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8003128:	b17e      	cbz	r6, 800314a <HAL_IPCC_RX_IRQHandler+0x46>
    bit_pos = 1UL << (ch_count & CHANNEL_INDEX_Msk);
 800312a:	f005 030f 	and.w	r3, r5, #15
 800312e:	2401      	movs	r4, #1
 8003130:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 8003132:	4226      	tst	r6, r4
 8003134:	d0f7      	beq.n	8003126 <HAL_IPCC_RX_IRQHandler+0x22>
      currentInstance->MR |= bit_pos;
 8003136:	4a05      	ldr	r2, [pc, #20]	@ (800314c <HAL_IPCC_RX_IRQHandler+0x48>)
 8003138:	6853      	ldr	r3, [r2, #4]
 800313a:	4323      	orrs	r3, r4
 800313c:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackRx[ch_count] != NULL)
 800313e:	eb07 0385 	add.w	r3, r7, r5, lsl #2
 8003142:	685b      	ldr	r3, [r3, #4]
 8003144:	2b00      	cmp	r3, #0
 8003146:	d1e8      	bne.n	800311a <HAL_IPCC_RX_IRQHandler+0x16>
 8003148:	e7eb      	b.n	8003122 <HAL_IPCC_RX_IRQHandler+0x1e>
}
 800314a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800314c:	58000c00 	.word	0x58000c00

08003150 <IPCC_UnmaskInterrupt>:
#if defined(CORE_CM0PLUS)
  IPCC_CommonTypeDef *currentInstance = IPCC_C2;
#else
  IPCC_CommonTypeDef *currentInstance = IPCC_C1;
#endif
  if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 8003150:	b951      	cbnz	r1, 8003168 <IPCC_UnmaskInterrupt+0x18>
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 8003152:	490a      	ldr	r1, [pc, #40]	@ (800317c <IPCC_UnmaskInterrupt+0x2c>)
 8003154:	684b      	ldr	r3, [r1, #4]
 8003156:	f000 000f 	and.w	r0, r0, #15
 800315a:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800315e:	4082      	lsls	r2, r0
 8003160:	ea23 0302 	bic.w	r3, r3, r2
 8003164:	604b      	str	r3, [r1, #4]
 8003166:	4770      	bx	lr
  }
  else
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 8003168:	4904      	ldr	r1, [pc, #16]	@ (800317c <IPCC_UnmaskInterrupt+0x2c>)
 800316a:	684b      	ldr	r3, [r1, #4]
 800316c:	f000 000f 	and.w	r0, r0, #15
 8003170:	2201      	movs	r2, #1
 8003172:	4082      	lsls	r2, r0
 8003174:	ea23 0302 	bic.w	r3, r3, r2
 8003178:	604b      	str	r3, [r1, #4]
  }
}
 800317a:	4770      	bx	lr
 800317c:	58000c00 	.word	0x58000c00

08003180 <HAL_IPCC_ActivateNotification>:
  if (hipcc != NULL)
 8003180:	b378      	cbz	r0, 80031e2 <HAL_IPCC_ActivateNotification+0x62>
{
 8003182:	b510      	push	{r4, lr}
 8003184:	460c      	mov	r4, r1
 8003186:	4686      	mov	lr, r0
    if (hipcc->State == HAL_IPCC_STATE_READY)
 8003188:	f890 c038 	ldrb.w	ip, [r0, #56]	@ 0x38
 800318c:	fa5f fc8c 	uxtb.w	ip, ip
 8003190:	f1bc 0f01 	cmp.w	ip, #1
 8003194:	d001      	beq.n	800319a <HAL_IPCC_ActivateNotification+0x1a>
      err = HAL_ERROR;
 8003196:	2001      	movs	r0, #1
}
 8003198:	bd10      	pop	{r4, pc}
      if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 800319a:	b982      	cbnz	r2, 80031be <HAL_IPCC_ActivateNotification+0x3e>
        hipcc->ChannelCallbackTx[ChannelIndex] = cb;
 800319c:	3106      	adds	r1, #6
 800319e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80031a2:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80031a4:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80031a6:	f004 000f 	and.w	r0, r4, #15
 80031aa:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 80031ae:	4081      	lsls	r1, r0
 80031b0:	430b      	orrs	r3, r1
 80031b2:	f8ce 3034 	str.w	r3, [lr, #52]	@ 0x34
      if (ChannelDir == IPCC_CHANNEL_DIR_RX)
 80031b6:	2a01      	cmp	r2, #1
 80031b8:	d00d      	beq.n	80031d6 <HAL_IPCC_ActivateNotification+0x56>
  HAL_StatusTypeDef err = HAL_OK;
 80031ba:	2000      	movs	r0, #0
 80031bc:	e7ec      	b.n	8003198 <HAL_IPCC_ActivateNotification+0x18>
        hipcc->ChannelCallbackRx[ChannelIndex] = cb;
 80031be:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80031c2:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80031c4:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80031c6:	f004 000f 	and.w	r0, r4, #15
 80031ca:	2101      	movs	r1, #1
 80031cc:	4081      	lsls	r1, r0
 80031ce:	430b      	orrs	r3, r1
 80031d0:	f8ce 3034 	str.w	r3, [lr, #52]	@ 0x34
 80031d4:	e7ef      	b.n	80031b6 <HAL_IPCC_ActivateNotification+0x36>
        IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 80031d6:	4611      	mov	r1, r2
 80031d8:	4620      	mov	r0, r4
 80031da:	f7ff ffb9 	bl	8003150 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 80031de:	2000      	movs	r0, #0
 80031e0:	e7da      	b.n	8003198 <HAL_IPCC_ActivateNotification+0x18>
    err = HAL_ERROR;
 80031e2:	2001      	movs	r0, #1
}
 80031e4:	4770      	bx	lr
	...

080031e8 <HAL_IPCC_NotifyCPU>:
  if (hipcc->State == HAL_IPCC_STATE_READY)
 80031e8:	f890 3038 	ldrb.w	r3, [r0, #56]	@ 0x38
 80031ec:	b2db      	uxtb	r3, r3
 80031ee:	2b01      	cmp	r3, #1
 80031f0:	d001      	beq.n	80031f6 <HAL_IPCC_NotifyCPU+0xe>
    err = HAL_ERROR;
 80031f2:	2001      	movs	r0, #1
}
 80031f4:	4770      	bx	lr
{
 80031f6:	b510      	push	{r4, lr}
 80031f8:	468c      	mov	ip, r1
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 80031fa:	4b0c      	ldr	r3, [pc, #48]	@ (800322c <HAL_IPCC_NotifyCPU+0x44>)
 80031fc:	6899      	ldr	r1, [r3, #8]
 80031fe:	b962      	cbnz	r2, 800321a <HAL_IPCC_NotifyCPU+0x32>
 8003200:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003204:	f00c 040f 	and.w	r4, ip, #15
 8003208:	40a3      	lsls	r3, r4
 800320a:	4319      	orrs	r1, r3
 800320c:	4c07      	ldr	r4, [pc, #28]	@ (800322c <HAL_IPCC_NotifyCPU+0x44>)
 800320e:	60a1      	str	r1, [r4, #8]
    if ((hipcc->callbackRequest & mask) == mask)
 8003210:	6b41      	ldr	r1, [r0, #52]	@ 0x34
 8003212:	438b      	bics	r3, r1
 8003214:	d003      	beq.n	800321e <HAL_IPCC_NotifyCPU+0x36>
  HAL_StatusTypeDef err = HAL_OK;
 8003216:	2000      	movs	r0, #0
}
 8003218:	bd10      	pop	{r4, pc}
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 800321a:	2301      	movs	r3, #1
 800321c:	e7f2      	b.n	8003204 <HAL_IPCC_NotifyCPU+0x1c>
      IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 800321e:	4611      	mov	r1, r2
 8003220:	4660      	mov	r0, ip
 8003222:	f7ff ff95 	bl	8003150 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 8003226:	2000      	movs	r0, #0
 8003228:	e7f6      	b.n	8003218 <HAL_IPCC_NotifyCPU+0x30>
 800322a:	bf00      	nop
 800322c:	58000c00 	.word	0x58000c00

08003230 <IPCC_SetDefaultCallbacks>:
  */
void IPCC_SetDefaultCallbacks(IPCC_HandleTypeDef *hipcc)
{
  uint32_t i;
  /* Set all callbacks to default */
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8003230:	2300      	movs	r3, #0
 8003232:	e009      	b.n	8003248 <IPCC_SetDefaultCallbacks+0x18>
  {
    hipcc->ChannelCallbackRx[i] = HAL_IPCC_RxCallback;
 8003234:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8003238:	4905      	ldr	r1, [pc, #20]	@ (8003250 <IPCC_SetDefaultCallbacks+0x20>)
 800323a:	6051      	str	r1, [r2, #4]
    hipcc->ChannelCallbackTx[i] = HAL_IPCC_TxCallback;
 800323c:	1d9a      	adds	r2, r3, #6
 800323e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8003242:	4904      	ldr	r1, [pc, #16]	@ (8003254 <IPCC_SetDefaultCallbacks+0x24>)
 8003244:	6051      	str	r1, [r2, #4]
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8003246:	3301      	adds	r3, #1
 8003248:	2b05      	cmp	r3, #5
 800324a:	d9f3      	bls.n	8003234 <IPCC_SetDefaultCallbacks+0x4>
  }
}
 800324c:	4770      	bx	lr
 800324e:	bf00      	nop
 8003250:	080030ad 	.word	0x080030ad
 8003254:	080030af 	.word	0x080030af

08003258 <IPCC_Reset_Register>:
  * @param  Instance pointer to register
  */
void IPCC_Reset_Register(IPCC_CommonTypeDef *Instance)
{
  /* Disable RX and TX interrupts */
  Instance->CR  = 0x00000000U;
 8003258:	2300      	movs	r3, #0
 800325a:	6003      	str	r3, [r0, #0]

  /* Mask RX and TX interrupts */
  Instance->MR  = (IPCC_ALL_TX_BUF | IPCC_ALL_RX_BUF);
 800325c:	f04f 133f 	mov.w	r3, #4128831	@ 0x3f003f
 8003260:	6043      	str	r3, [r0, #4]

  /* Clear RX status */
  Instance->SCR = IPCC_ALL_RX_BUF;
 8003262:	233f      	movs	r3, #63	@ 0x3f
 8003264:	6083      	str	r3, [r0, #8]
}
 8003266:	4770      	bx	lr

08003268 <HAL_IPCC_Init>:
  if (hipcc != NULL)
 8003268:	b1c0      	cbz	r0, 800329c <HAL_IPCC_Init+0x34>
{
 800326a:	b538      	push	{r3, r4, r5, lr}
 800326c:	4604      	mov	r4, r0
    if (hipcc->State == HAL_IPCC_STATE_RESET)
 800326e:	f890 3038 	ldrb.w	r3, [r0, #56]	@ 0x38
 8003272:	b183      	cbz	r3, 8003296 <HAL_IPCC_Init+0x2e>
    IPCC_Reset_Register(currentInstance);
 8003274:	4d0a      	ldr	r5, [pc, #40]	@ (80032a0 <HAL_IPCC_Init+0x38>)
 8003276:	4628      	mov	r0, r5
 8003278:	f7ff ffee 	bl	8003258 <IPCC_Reset_Register>
    currentInstance->CR |= (IPCC_CR_RXOIE | IPCC_CR_TXFIE);
 800327c:	682b      	ldr	r3, [r5, #0]
 800327e:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 8003282:	602b      	str	r3, [r5, #0]
    IPCC_SetDefaultCallbacks(hipcc);
 8003284:	4620      	mov	r0, r4
 8003286:	f7ff ffd3 	bl	8003230 <IPCC_SetDefaultCallbacks>
    hipcc->callbackRequest = 0;
 800328a:	2000      	movs	r0, #0
 800328c:	6360      	str	r0, [r4, #52]	@ 0x34
    hipcc->State = HAL_IPCC_STATE_READY;
 800328e:	2301      	movs	r3, #1
 8003290:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
}
 8003294:	bd38      	pop	{r3, r4, r5, pc}
      HAL_IPCC_MspInit(hipcc);
 8003296:	f7fd f9e5 	bl	8000664 <HAL_IPCC_MspInit>
 800329a:	e7eb      	b.n	8003274 <HAL_IPCC_Init+0xc>
    err = HAL_ERROR;
 800329c:	2001      	movs	r0, #1
}
 800329e:	4770      	bx	lr
 80032a0:	58000c00 	.word	0x58000c00

080032a4 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80032a4:	4a02      	ldr	r2, [pc, #8]	@ (80032b0 <HAL_PWR_EnableBkUpAccess+0xc>)
 80032a6:	6813      	ldr	r3, [r2, #0]
 80032a8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80032ac:	6013      	str	r3, [r2, #0]
}
 80032ae:	4770      	bx	lr
 80032b0:	58000400 	.word	0x58000400

080032b4 <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as
  *        the interrupt wake up source.
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 80032b4:	b510      	push	{r4, lr}
 80032b6:	460c      	mov	r4, r1
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 80032b8:	b9a0      	cbnz	r0, 80032e4 <HAL_PWR_EnterSLEEPMode+0x30>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 80032ba:	4b0f      	ldr	r3, [pc, #60]	@ (80032f8 <HAL_PWR_EnterSLEEPMode+0x44>)
 80032bc:	695b      	ldr	r3, [r3, #20]
 80032be:	f413 7f00 	tst.w	r3, #512	@ 0x200
 80032c2:	d10a      	bne.n	80032da <HAL_PWR_EnterSLEEPMode+0x26>
      HAL_PWREx_EnableLowPowerRunMode();
    }
  }

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80032c4:	4a0d      	ldr	r2, [pc, #52]	@ (80032fc <HAL_PWR_EnterSLEEPMode+0x48>)
 80032c6:	6913      	ldr	r3, [r2, #16]
 80032c8:	f023 0304 	bic.w	r3, r3, #4
 80032cc:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry -------------------------------------------------*/
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 80032ce:	2c01      	cmp	r4, #1
 80032d0:	d010      	beq.n	80032f4 <HAL_PWR_EnterSLEEPMode+0x40>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 80032d2:	bf40      	sev
    __WFE();
 80032d4:	bf20      	wfe
    __WFE();
 80032d6:	bf20      	wfe
  }
}
 80032d8:	bd10      	pop	{r4, pc}
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 80032da:	f000 f829 	bl	8003330 <HAL_PWREx_DisableLowPowerRunMode>
 80032de:	2800      	cmp	r0, #0
 80032e0:	d0f0      	beq.n	80032c4 <HAL_PWR_EnterSLEEPMode+0x10>
 80032e2:	e7f9      	b.n	80032d8 <HAL_PWR_EnterSLEEPMode+0x24>
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 80032e4:	4b04      	ldr	r3, [pc, #16]	@ (80032f8 <HAL_PWR_EnterSLEEPMode+0x44>)
 80032e6:	695b      	ldr	r3, [r3, #20]
 80032e8:	f413 7f00 	tst.w	r3, #512	@ 0x200
 80032ec:	d1ea      	bne.n	80032c4 <HAL_PWR_EnterSLEEPMode+0x10>
      HAL_PWREx_EnableLowPowerRunMode();
 80032ee:	f000 f817 	bl	8003320 <HAL_PWREx_EnableLowPowerRunMode>
 80032f2:	e7e7      	b.n	80032c4 <HAL_PWR_EnterSLEEPMode+0x10>
    __WFI();
 80032f4:	bf30      	wfi
 80032f6:	e7ef      	b.n	80032d8 <HAL_PWR_EnterSLEEPMode+0x24>
 80032f8:	58000400 	.word	0x58000400
 80032fc:	e000ed00 	.word	0xe000ed00

08003300 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 8003300:	4b02      	ldr	r3, [pc, #8]	@ (800330c <HAL_PWREx_GetVoltageRange+0xc>)
 8003302:	6818      	ldr	r0, [r3, #0]
}
 8003304:	f400 60c0 	and.w	r0, r0, #1536	@ 0x600
 8003308:	4770      	bx	lr
 800330a:	bf00      	nop
 800330c:	58000400 	.word	0x58000400

08003310 <HAL_PWREx_ReleaseCore>:
  SET_BIT(PWR->CR4, PWR_CR4_C2BOOT);
 8003310:	4a02      	ldr	r2, [pc, #8]	@ (800331c <HAL_PWREx_ReleaseCore+0xc>)
 8003312:	68d3      	ldr	r3, [r2, #12]
 8003314:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8003318:	60d3      	str	r3, [r2, #12]
{
  /* Check the parameters */
  assert_param(IS_PWR_CORE_HOLD_RELEASE(CPU));

  LL_PWR_EnableBootC2();
}
 800331a:	4770      	bx	lr
 800331c:	58000400 	.word	0x58000400

08003320 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 8003320:	4a02      	ldr	r2, [pc, #8]	@ (800332c <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 8003322:	6813      	ldr	r3, [r2, #0]
 8003324:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8003328:	6013      	str	r3, [r2, #0]
}
 800332a:	4770      	bx	lr
 800332c:	58000400 	.word	0x58000400

08003330 <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 8003330:	4a0f      	ldr	r2, [pc, #60]	@ (8003370 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 8003332:	6813      	ldr	r3, [r2, #0]
 8003334:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8003338:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 800333a:	4b0e      	ldr	r3, [pc, #56]	@ (8003374 <HAL_PWREx_DisableLowPowerRunMode+0x44>)
 800333c:	681b      	ldr	r3, [r3, #0]
 800333e:	2232      	movs	r2, #50	@ 0x32
 8003340:	fb02 f303 	mul.w	r3, r2, r3
 8003344:	4a0c      	ldr	r2, [pc, #48]	@ (8003378 <HAL_PWREx_DisableLowPowerRunMode+0x48>)
 8003346:	fba2 2303 	umull	r2, r3, r2, r3
 800334a:	0c9b      	lsrs	r3, r3, #18
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 800334c:	e000      	b.n	8003350 <HAL_PWREx_DisableLowPowerRunMode+0x20>
  {
    wait_loop_index--;
 800334e:	3b01      	subs	r3, #1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8003350:	4a07      	ldr	r2, [pc, #28]	@ (8003370 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 8003352:	6952      	ldr	r2, [r2, #20]
 8003354:	f412 7f00 	tst.w	r2, #512	@ 0x200
 8003358:	d001      	beq.n	800335e <HAL_PWREx_DisableLowPowerRunMode+0x2e>
 800335a:	2b00      	cmp	r3, #0
 800335c:	d1f7      	bne.n	800334e <HAL_PWREx_DisableLowPowerRunMode+0x1e>
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 800335e:	4b04      	ldr	r3, [pc, #16]	@ (8003370 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 8003360:	695b      	ldr	r3, [r3, #20]
 8003362:	f413 7f00 	tst.w	r3, #512	@ 0x200
 8003366:	d101      	bne.n	800336c <HAL_PWREx_DisableLowPowerRunMode+0x3c>
  {
    return HAL_TIMEOUT;
  }

  return HAL_OK;
 8003368:	2000      	movs	r0, #0
 800336a:	4770      	bx	lr
    return HAL_TIMEOUT;
 800336c:	2003      	movs	r0, #3
}
 800336e:	4770      	bx	lr
 8003370:	58000400 	.word	0x58000400
 8003374:	20000004 	.word	0x20000004
 8003378:	431bde83 	.word	0x431bde83

0800337c <HAL_PWREx_EnterSTOP2Mode>:
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 800337c:	4a0c      	ldr	r2, [pc, #48]	@ (80033b0 <HAL_PWREx_EnterSTOP2Mode+0x34>)
 800337e:	6813      	ldr	r3, [r2, #0]
 8003380:	f023 0307 	bic.w	r3, r3, #7
 8003384:	f043 0302 	orr.w	r3, r3, #2
 8003388:	6013      	str	r3, [r2, #0]
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800338a:	4a0a      	ldr	r2, [pc, #40]	@ (80033b4 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 800338c:	6913      	ldr	r3, [r2, #16]
 800338e:	f043 0304 	orr.w	r3, r3, #4
 8003392:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 8003394:	2801      	cmp	r0, #1
 8003396:	d008      	beq.n	80033aa <HAL_PWREx_EnterSTOP2Mode+0x2e>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 8003398:	bf40      	sev
    __WFE();
 800339a:	bf20      	wfe
    __WFE();
 800339c:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800339e:	4a05      	ldr	r2, [pc, #20]	@ (80033b4 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 80033a0:	6913      	ldr	r3, [r2, #16]
 80033a2:	f023 0304 	bic.w	r3, r3, #4
 80033a6:	6113      	str	r3, [r2, #16]
}
 80033a8:	4770      	bx	lr
    __WFI();
 80033aa:	bf30      	wfi
 80033ac:	e7f7      	b.n	800339e <HAL_PWREx_EnterSTOP2Mode+0x22>
 80033ae:	bf00      	nop
 80033b0:	58000400 	.word	0x58000400
 80033b4:	e000ed00 	.word	0xe000ed00

080033b8 <RCC_SetFlashLatency>:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1   Regulator voltage output range 1 mode
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2   Regulator voltage output range 2 mode
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatency(uint32_t Flash_ClkSrcFreq, uint32_t VCORE_Voltage)
{
 80033b8:	b530      	push	{r4, r5, lr}
 80033ba:	b089      	sub	sp, #36	@ 0x24
 80033bc:	4604      	mov	r4, r0
 80033be:	468c      	mov	ip, r1
  /* Flash Clock source (HCLK3) range in MHz for VCORE range1 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS1[] = {18, 36, 48};
 80033c0:	4b2a      	ldr	r3, [pc, #168]	@ (800346c <RCC_SetFlashLatency+0xb4>)
 80033c2:	e893 0003 	ldmia.w	r3, {r0, r1}
 80033c6:	9006      	str	r0, [sp, #24]
 80033c8:	f8ad 101c 	strh.w	r1, [sp, #28]

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};
 80033cc:	f103 0208 	add.w	r2, r3, #8
 80033d0:	e892 0003 	ldmia.w	r2, {r0, r1}
 80033d4:	9004      	str	r0, [sp, #16]
 80033d6:	f8ad 1014 	strh.w	r1, [sp, #20]

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 80033da:	ad01      	add	r5, sp, #4
 80033dc:	3310      	adds	r3, #16
 80033de:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80033e2:	e885 0007 	stmia.w	r5, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 80033e6:	f5bc 7f00 	cmp.w	ip, #512	@ 0x200
 80033ea:	d007      	beq.n	80033fc <RCC_SetFlashLatency+0x44>
      }
    }
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 80033ec:	2300      	movs	r3, #0
 80033ee:	e014      	b.n	800341a <RCC_SetFlashLatency+0x62>
        latency = FLASH_LATENCY_RANGE[index];
 80033f0:	aa08      	add	r2, sp, #32
 80033f2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80033f6:	f853 5c1c 	ldr.w	r5, [r3, #-28]
        break;
 80033fa:	e01e      	b.n	800343a <RCC_SetFlashLatency+0x82>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 80033fc:	2300      	movs	r3, #0
 80033fe:	2b02      	cmp	r3, #2
 8003400:	d808      	bhi.n	8003414 <RCC_SetFlashLatency+0x5c>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 8003402:	aa08      	add	r2, sp, #32
 8003404:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 8003408:	f832 2c08 	ldrh.w	r2, [r2, #-8]
 800340c:	42a2      	cmp	r2, r4
 800340e:	d2ef      	bcs.n	80033f0 <RCC_SetFlashLatency+0x38>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 8003410:	3301      	adds	r3, #1
 8003412:	e7f4      	b.n	80033fe <RCC_SetFlashLatency+0x46>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8003414:	2500      	movs	r5, #0
 8003416:	e010      	b.n	800343a <RCC_SetFlashLatency+0x82>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8003418:	3301      	adds	r3, #1
 800341a:	2b02      	cmp	r3, #2
 800341c:	d80c      	bhi.n	8003438 <RCC_SetFlashLatency+0x80>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 800341e:	aa08      	add	r2, sp, #32
 8003420:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 8003424:	f832 2c10 	ldrh.w	r2, [r2, #-16]
 8003428:	42a2      	cmp	r2, r4
 800342a:	d3f5      	bcc.n	8003418 <RCC_SetFlashLatency+0x60>
      {
        latency = FLASH_LATENCY_RANGE[index];
 800342c:	aa08      	add	r2, sp, #32
 800342e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003432:	f853 5c1c 	ldr.w	r5, [r3, #-28]
        break;
 8003436:	e000      	b.n	800343a <RCC_SetFlashLatency+0x82>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8003438:	2500      	movs	r5, #0
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 800343a:	4a0d      	ldr	r2, [pc, #52]	@ (8003470 <RCC_SetFlashLatency+0xb8>)
 800343c:	6813      	ldr	r3, [r2, #0]
 800343e:	f023 0307 	bic.w	r3, r3, #7
 8003442:	432b      	orrs	r3, r5
 8003444:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8003446:	f7fd fb3b 	bl	8000ac0 <HAL_GetTick>
 800344a:	4604      	mov	r4, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 800344c:	4b08      	ldr	r3, [pc, #32]	@ (8003470 <RCC_SetFlashLatency+0xb8>)
 800344e:	681b      	ldr	r3, [r3, #0]
 8003450:	f003 0307 	and.w	r3, r3, #7
 8003454:	42ab      	cmp	r3, r5
 8003456:	d006      	beq.n	8003466 <RCC_SetFlashLatency+0xae>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8003458:	f7fd fb32 	bl	8000ac0 <HAL_GetTick>
 800345c:	1b00      	subs	r0, r0, r4
 800345e:	2802      	cmp	r0, #2
 8003460:	d9f4      	bls.n	800344c <RCC_SetFlashLatency+0x94>
    {
      return HAL_TIMEOUT;
 8003462:	2003      	movs	r0, #3
 8003464:	e000      	b.n	8003468 <RCC_SetFlashLatency+0xb0>
    }
  }
  return HAL_OK;
 8003466:	2000      	movs	r0, #0
}
 8003468:	b009      	add	sp, #36	@ 0x24
 800346a:	bd30      	pop	{r4, r5, pc}
 800346c:	08006398 	.word	0x08006398
 8003470:	58004000 	.word	0x58004000

08003474 <RCC_SetFlashLatencyFromMSIRange>:
{
 8003474:	b510      	push	{r4, lr}
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 8003476:	f3c0 1003 	ubfx	r0, r0, #4, #4
 800347a:	4b0c      	ldr	r3, [pc, #48]	@ (80034ac <RCC_SetFlashLatencyFromMSIRange+0x38>)
 800347c:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 8003480:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003484:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 8003488:	f003 030f 	and.w	r3, r3, #15
 800348c:	4a08      	ldr	r2, [pc, #32]	@ (80034b0 <RCC_SetFlashLatencyFromMSIRange+0x3c>)
 800348e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003492:	fbb4 f4f3 	udiv	r4, r4, r3
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 8003496:	f7ff ff33 	bl	8003300 <HAL_PWREx_GetVoltageRange>
 800349a:	4601      	mov	r1, r0
 800349c:	4b05      	ldr	r3, [pc, #20]	@ (80034b4 <RCC_SetFlashLatencyFromMSIRange+0x40>)
 800349e:	fba3 3404 	umull	r3, r4, r3, r4
 80034a2:	0ca0      	lsrs	r0, r4, #18
 80034a4:	f7ff ff88 	bl	80033b8 <RCC_SetFlashLatency>
}
 80034a8:	bd10      	pop	{r4, pc}
 80034aa:	bf00      	nop
 80034ac:	0800686c 	.word	0x0800686c
 80034b0:	080068cc 	.word	0x080068cc
 80034b4:	431bde83 	.word	0x431bde83

080034b8 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80034b8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80034bc:	6899      	ldr	r1, [r3, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80034be:	68db      	ldr	r3, [r3, #12]
 80034c0:	f003 0303 	and.w	r3, r3, #3
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80034c4:	f011 010c 	ands.w	r1, r1, #12
 80034c8:	d00a      	beq.n	80034e0 <HAL_RCC_GetSysClockFreq+0x28>
 80034ca:	290c      	cmp	r1, #12
 80034cc:	d006      	beq.n	80034dc <HAL_RCC_GetSysClockFreq+0x24>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80034ce:	2904      	cmp	r1, #4
 80034d0:	d047      	beq.n	8003562 <HAL_RCC_GetSysClockFreq+0xaa>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 80034d2:	2908      	cmp	r1, #8
 80034d4:	d03b      	beq.n	800354e <HAL_RCC_GetSysClockFreq+0x96>
  uint32_t msifreq = 0U;
 80034d6:	2200      	movs	r2, #0
  uint32_t sysclockfreq = 0U;
 80034d8:	4610      	mov	r0, r2
 80034da:	e026      	b.n	800352a <HAL_RCC_GetSysClockFreq+0x72>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 80034dc:	2b01      	cmp	r3, #1
 80034de:	d1f6      	bne.n	80034ce <HAL_RCC_GetSysClockFreq+0x16>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 80034e0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80034e4:	681b      	ldr	r3, [r3, #0]
 80034e6:	f013 0308 	ands.w	r3, r3, #8
 80034ea:	d00d      	beq.n	8003508 <HAL_RCC_GetSysClockFreq+0x50>
 80034ec:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80034f0:	681b      	ldr	r3, [r3, #0]
 80034f2:	f013 0308 	ands.w	r3, r3, #8
 80034f6:	d124      	bne.n	8003542 <HAL_RCC_GetSysClockFreq+0x8a>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80034f8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80034fc:	f8d2 2094 	ldr.w	r2, [r2, #148]	@ 0x94
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8003500:	4a2e      	ldr	r2, [pc, #184]	@ (80035bc <HAL_RCC_GetSysClockFreq+0x104>)
 8003502:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8003506:	e00e      	b.n	8003526 <HAL_RCC_GetSysClockFreq+0x6e>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8003508:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800350c:	6812      	ldr	r2, [r2, #0]
 800350e:	f012 0f08 	tst.w	r2, #8
 8003512:	d112      	bne.n	800353a <HAL_RCC_GetSysClockFreq+0x82>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8003514:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003518:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800351c:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8003520:	4a26      	ldr	r2, [pc, #152]	@ (80035bc <HAL_RCC_GetSysClockFreq+0x104>)
 8003522:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8003526:	b1d1      	cbz	r1, 800355e <HAL_RCC_GetSysClockFreq+0xa6>
  uint32_t sysclockfreq = 0U;
 8003528:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800352a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800352e:	689b      	ldr	r3, [r3, #8]
 8003530:	f003 030c 	and.w	r3, r3, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003534:	2b0c      	cmp	r3, #12
 8003536:	d01a      	beq.n	800356e <HAL_RCC_GetSysClockFreq+0xb6>
}
 8003538:	4770      	bx	lr
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 800353a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800353e:	6812      	ldr	r2, [r2, #0]
 8003540:	e7ee      	b.n	8003520 <HAL_RCC_GetSysClockFreq+0x68>
 8003542:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003546:	681b      	ldr	r3, [r3, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8003548:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800354c:	e7d8      	b.n	8003500 <HAL_RCC_GetSysClockFreq+0x48>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 800354e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003552:	681a      	ldr	r2, [r3, #0]
 8003554:	f412 1280 	ands.w	r2, r2, #1048576	@ 0x100000
 8003558:	d106      	bne.n	8003568 <HAL_RCC_GetSysClockFreq+0xb0>
      sysclockfreq = HSE_VALUE;
 800355a:	4819      	ldr	r0, [pc, #100]	@ (80035c0 <HAL_RCC_GetSysClockFreq+0x108>)
 800355c:	e7e5      	b.n	800352a <HAL_RCC_GetSysClockFreq+0x72>
      sysclockfreq = msifreq;
 800355e:	4610      	mov	r0, r2
 8003560:	e7e3      	b.n	800352a <HAL_RCC_GetSysClockFreq+0x72>
  uint32_t msifreq = 0U;
 8003562:	2200      	movs	r2, #0
    sysclockfreq = HSI_VALUE;
 8003564:	4817      	ldr	r0, [pc, #92]	@ (80035c4 <HAL_RCC_GetSysClockFreq+0x10c>)
 8003566:	e7e0      	b.n	800352a <HAL_RCC_GetSysClockFreq+0x72>
  uint32_t msifreq = 0U;
 8003568:	2200      	movs	r2, #0
      sysclockfreq = HSE_VALUE / 2U;
 800356a:	4816      	ldr	r0, [pc, #88]	@ (80035c4 <HAL_RCC_GetSysClockFreq+0x10c>)
 800356c:	e7dd      	b.n	800352a <HAL_RCC_GetSysClockFreq+0x72>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800356e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003572:	68db      	ldr	r3, [r3, #12]
 8003574:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 8003578:	2b02      	cmp	r3, #2
 800357a:	d009      	beq.n	8003590 <HAL_RCC_GetSysClockFreq+0xd8>
 800357c:	2b03      	cmp	r3, #3
 800357e:	d108      	bne.n	8003592 <HAL_RCC_GetSysClockFreq+0xda>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8003580:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003584:	681b      	ldr	r3, [r3, #0]
 8003586:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 800358a:	d115      	bne.n	80035b8 <HAL_RCC_GetSysClockFreq+0x100>
          pllinputfreq = HSE_VALUE;
 800358c:	4a0c      	ldr	r2, [pc, #48]	@ (80035c0 <HAL_RCC_GetSysClockFreq+0x108>)
 800358e:	e000      	b.n	8003592 <HAL_RCC_GetSysClockFreq+0xda>
    switch (pllsource)
 8003590:	4a0c      	ldr	r2, [pc, #48]	@ (80035c4 <HAL_RCC_GetSysClockFreq+0x10c>)
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8003592:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003596:	68cb      	ldr	r3, [r1, #12]
 8003598:	f3c3 2306 	ubfx	r3, r3, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 800359c:	fb03 f202 	mul.w	r2, r3, r2
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80035a0:	68cb      	ldr	r3, [r1, #12]
 80035a2:	f3c3 1302 	ubfx	r3, r3, #4, #3
 80035a6:	3301      	adds	r3, #1
 80035a8:	fbb2 f2f3 	udiv	r2, r2, r3
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80035ac:	68c8      	ldr	r0, [r1, #12]
 80035ae:	0f40      	lsrs	r0, r0, #29
 80035b0:	3001      	adds	r0, #1
 80035b2:	fbb2 f0f0 	udiv	r0, r2, r0
  return sysclockfreq;
 80035b6:	e7bf      	b.n	8003538 <HAL_RCC_GetSysClockFreq+0x80>
          pllinputfreq = HSE_VALUE / 2U;
 80035b8:	4a02      	ldr	r2, [pc, #8]	@ (80035c4 <HAL_RCC_GetSysClockFreq+0x10c>)
 80035ba:	e7ea      	b.n	8003592 <HAL_RCC_GetSysClockFreq+0xda>
 80035bc:	0800686c 	.word	0x0800686c
 80035c0:	01e84800 	.word	0x01e84800
 80035c4:	00f42400 	.word	0x00f42400

080035c8 <HAL_RCC_GetHCLKFreq>:
{
 80035c8:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 80035ca:	f7ff ff75 	bl	80034b8 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80035ce:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80035d2:	689b      	ldr	r3, [r3, #8]
 80035d4:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80035d8:	4a02      	ldr	r2, [pc, #8]	@ (80035e4 <HAL_RCC_GetHCLKFreq+0x1c>)
 80035da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 80035de:	fbb0 f0f3 	udiv	r0, r0, r3
 80035e2:	bd08      	pop	{r3, pc}
 80035e4:	080068cc 	.word	0x080068cc

080035e8 <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
 80035e8:	2800      	cmp	r0, #0
 80035ea:	f000 8311 	beq.w	8003c10 <HAL_RCC_OscConfig+0x628>
{
 80035ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80035f0:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80035f2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80035f6:	689d      	ldr	r5, [r3, #8]
 80035f8:	f005 050c 	and.w	r5, r5, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80035fc:	68de      	ldr	r6, [r3, #12]
 80035fe:	f006 0603 	and.w	r6, r6, #3
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8003602:	6803      	ldr	r3, [r0, #0]
 8003604:	f013 0f20 	tst.w	r3, #32
 8003608:	d02a      	beq.n	8003660 <HAL_RCC_OscConfig+0x78>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800360a:	2d00      	cmp	r5, #0
 800360c:	d065      	beq.n	80036da <HAL_RCC_OscConfig+0xf2>
 800360e:	2d0c      	cmp	r5, #12
 8003610:	d061      	beq.n	80036d6 <HAL_RCC_OscConfig+0xee>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8003612:	6a23      	ldr	r3, [r4, #32]
 8003614:	2b00      	cmp	r3, #0
 8003616:	f000 80bf 	beq.w	8003798 <HAL_RCC_OscConfig+0x1b0>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 800361a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800361e:	6813      	ldr	r3, [r2, #0]
 8003620:	f043 0301 	orr.w	r3, r3, #1
 8003624:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8003626:	f7fd fa4b 	bl	8000ac0 <HAL_GetTick>
 800362a:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 800362c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003630:	681b      	ldr	r3, [r3, #0]
 8003632:	f013 0f02 	tst.w	r3, #2
 8003636:	f000 80a7 	beq.w	8003788 <HAL_RCC_OscConfig+0x1a0>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800363a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800363e:	681a      	ldr	r2, [r3, #0]
 8003640:	f042 0208 	orr.w	r2, r2, #8
 8003644:	601a      	str	r2, [r3, #0]
 8003646:	681a      	ldr	r2, [r3, #0]
 8003648:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 800364c:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800364e:	430a      	orrs	r2, r1
 8003650:	601a      	str	r2, [r3, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8003652:	6a61      	ldr	r1, [r4, #36]	@ 0x24
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 8003654:	685a      	ldr	r2, [r3, #4]
 8003656:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
 800365a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800365e:	605a      	str	r2, [r3, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003660:	6823      	ldr	r3, [r4, #0]
 8003662:	f013 0f01 	tst.w	r3, #1
 8003666:	f000 80b5 	beq.w	80037d4 <HAL_RCC_OscConfig+0x1ec>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 800366a:	2d08      	cmp	r5, #8
 800366c:	f000 80ae 	beq.w	80037cc <HAL_RCC_OscConfig+0x1e4>
 8003670:	2d0c      	cmp	r5, #12
 8003672:	f000 80a8 	beq.w	80037c6 <HAL_RCC_OscConfig+0x1de>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 8003676:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800367a:	6813      	ldr	r3, [r2, #0]
 800367c:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8003680:	68a1      	ldr	r1, [r4, #8]
 8003682:	430b      	orrs	r3, r1
 8003684:	6013      	str	r3, [r2, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003686:	6863      	ldr	r3, [r4, #4]
 8003688:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800368c:	f000 80c4 	beq.w	8003818 <HAL_RCC_OscConfig+0x230>
 8003690:	f5b3 1f04 	cmp.w	r3, #2162688	@ 0x210000
 8003694:	f000 80c5 	beq.w	8003822 <HAL_RCC_OscConfig+0x23a>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 8003698:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800369c:	681a      	ldr	r2, [r3, #0]
 800369e:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 80036a2:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 80036a4:	681a      	ldr	r2, [r3, #0]
 80036a6:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 80036aa:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80036ac:	6863      	ldr	r3, [r4, #4]
 80036ae:	2b00      	cmp	r3, #0
 80036b0:	f000 80c2 	beq.w	8003838 <HAL_RCC_OscConfig+0x250>
        tickstart = HAL_GetTick();
 80036b4:	f7fd fa04 	bl	8000ac0 <HAL_GetTick>
 80036b8:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 80036ba:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80036be:	681b      	ldr	r3, [r3, #0]
 80036c0:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 80036c4:	f040 8086 	bne.w	80037d4 <HAL_RCC_OscConfig+0x1ec>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80036c8:	f7fd f9fa 	bl	8000ac0 <HAL_GetTick>
 80036cc:	1bc0      	subs	r0, r0, r7
 80036ce:	2864      	cmp	r0, #100	@ 0x64
 80036d0:	d9f3      	bls.n	80036ba <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
 80036d2:	2003      	movs	r0, #3
 80036d4:	e2a9      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 80036d6:	2e01      	cmp	r6, #1
 80036d8:	d19b      	bne.n	8003612 <HAL_RCC_OscConfig+0x2a>
      if (RCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 80036da:	6a23      	ldr	r3, [r4, #32]
 80036dc:	2b00      	cmp	r3, #0
 80036de:	f000 8299 	beq.w	8003c14 <HAL_RCC_OscConfig+0x62c>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80036e2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 80036e4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80036e8:	681b      	ldr	r3, [r3, #0]
 80036ea:	f013 0f08 	tst.w	r3, #8
 80036ee:	d029      	beq.n	8003744 <HAL_RCC_OscConfig+0x15c>
 80036f0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80036f4:	681b      	ldr	r3, [r3, #0]
 80036f6:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 80036fa:	4298      	cmp	r0, r3
 80036fc:	d92a      	bls.n	8003754 <HAL_RCC_OscConfig+0x16c>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80036fe:	f7ff feb9 	bl	8003474 <RCC_SetFlashLatencyFromMSIRange>
 8003702:	2800      	cmp	r0, #0
 8003704:	f040 8288 	bne.w	8003c18 <HAL_RCC_OscConfig+0x630>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8003708:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800370c:	681a      	ldr	r2, [r3, #0]
 800370e:	f042 0208 	orr.w	r2, r2, #8
 8003712:	601a      	str	r2, [r3, #0]
 8003714:	681a      	ldr	r2, [r3, #0]
 8003716:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 800371a:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800371c:	430a      	orrs	r2, r1
 800371e:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8003720:	6a61      	ldr	r1, [r4, #36]	@ 0x24
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 8003722:	685a      	ldr	r2, [r3, #4]
 8003724:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
 8003728:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800372c:	605a      	str	r2, [r3, #4]
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800372e:	f7ff ff4b 	bl	80035c8 <HAL_RCC_GetHCLKFreq>
 8003732:	4bba      	ldr	r3, [pc, #744]	@ (8003a1c <HAL_RCC_OscConfig+0x434>)
 8003734:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 8003736:	4bba      	ldr	r3, [pc, #744]	@ (8003a20 <HAL_RCC_OscConfig+0x438>)
 8003738:	6818      	ldr	r0, [r3, #0]
 800373a:	f7fe fc81 	bl	8002040 <HAL_InitTick>
        if (status != HAL_OK)
 800373e:	2800      	cmp	r0, #0
 8003740:	d08e      	beq.n	8003660 <HAL_RCC_OscConfig+0x78>
 8003742:	e272      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8003744:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003748:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800374c:	091b      	lsrs	r3, r3, #4
 800374e:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8003752:	e7d2      	b.n	80036fa <HAL_RCC_OscConfig+0x112>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8003754:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003758:	681a      	ldr	r2, [r3, #0]
 800375a:	f042 0208 	orr.w	r2, r2, #8
 800375e:	601a      	str	r2, [r3, #0]
 8003760:	681a      	ldr	r2, [r3, #0]
 8003762:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8003766:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8003768:	430a      	orrs	r2, r1
 800376a:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800376c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800376e:	685a      	ldr	r2, [r3, #4]
 8003770:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
 8003774:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8003778:	605a      	str	r2, [r3, #4]
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800377a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 800377c:	f7ff fe7a 	bl	8003474 <RCC_SetFlashLatencyFromMSIRange>
 8003780:	2800      	cmp	r0, #0
 8003782:	d0d4      	beq.n	800372e <HAL_RCC_OscConfig+0x146>
            return HAL_ERROR;
 8003784:	2001      	movs	r0, #1
 8003786:	e250      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8003788:	f7fd f99a 	bl	8000ac0 <HAL_GetTick>
 800378c:	1bc0      	subs	r0, r0, r7
 800378e:	2802      	cmp	r0, #2
 8003790:	f67f af4c 	bls.w	800362c <HAL_RCC_OscConfig+0x44>
            return HAL_TIMEOUT;
 8003794:	2003      	movs	r0, #3
 8003796:	e248      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 8003798:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800379c:	6813      	ldr	r3, [r2, #0]
 800379e:	f023 0301 	bic.w	r3, r3, #1
 80037a2:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80037a4:	f7fd f98c 	bl	8000ac0 <HAL_GetTick>
 80037a8:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 80037aa:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80037ae:	681b      	ldr	r3, [r3, #0]
 80037b0:	f013 0f02 	tst.w	r3, #2
 80037b4:	f43f af54 	beq.w	8003660 <HAL_RCC_OscConfig+0x78>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80037b8:	f7fd f982 	bl	8000ac0 <HAL_GetTick>
 80037bc:	1bc0      	subs	r0, r0, r7
 80037be:	2802      	cmp	r0, #2
 80037c0:	d9f3      	bls.n	80037aa <HAL_RCC_OscConfig+0x1c2>
            return HAL_TIMEOUT;
 80037c2:	2003      	movs	r0, #3
 80037c4:	e231      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 80037c6:	2e03      	cmp	r6, #3
 80037c8:	f47f af55 	bne.w	8003676 <HAL_RCC_OscConfig+0x8e>
      if (RCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 80037cc:	6863      	ldr	r3, [r4, #4]
 80037ce:	2b00      	cmp	r3, #0
 80037d0:	f000 8224 	beq.w	8003c1c <HAL_RCC_OscConfig+0x634>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80037d4:	6823      	ldr	r3, [r4, #0]
 80037d6:	f013 0f02 	tst.w	r3, #2
 80037da:	d056      	beq.n	800388a <HAL_RCC_OscConfig+0x2a2>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 80037dc:	2d04      	cmp	r5, #4
 80037de:	d03d      	beq.n	800385c <HAL_RCC_OscConfig+0x274>
 80037e0:	2d0c      	cmp	r5, #12
 80037e2:	d039      	beq.n	8003858 <HAL_RCC_OscConfig+0x270>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80037e4:	6923      	ldr	r3, [r4, #16]
 80037e6:	2b00      	cmp	r3, #0
 80037e8:	f000 808a 	beq.w	8003900 <HAL_RCC_OscConfig+0x318>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 80037ec:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80037f0:	6813      	ldr	r3, [r2, #0]
 80037f2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80037f6:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80037f8:	f7fd f962 	bl	8000ac0 <HAL_GetTick>
 80037fc:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 80037fe:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003802:	681b      	ldr	r3, [r3, #0]
 8003804:	f413 6f80 	tst.w	r3, #1024	@ 0x400
 8003808:	d136      	bne.n	8003878 <HAL_RCC_OscConfig+0x290>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800380a:	f7fd f959 	bl	8000ac0 <HAL_GetTick>
 800380e:	1b80      	subs	r0, r0, r6
 8003810:	2802      	cmp	r0, #2
 8003812:	d9f4      	bls.n	80037fe <HAL_RCC_OscConfig+0x216>
            return HAL_TIMEOUT;
 8003814:	2003      	movs	r0, #3
 8003816:	e208      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8003818:	6813      	ldr	r3, [r2, #0]
 800381a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800381e:	6013      	str	r3, [r2, #0]
}
 8003820:	e744      	b.n	80036ac <HAL_RCC_OscConfig+0xc4>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 8003822:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003826:	681a      	ldr	r2, [r3, #0]
 8003828:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
 800382c:	601a      	str	r2, [r3, #0]
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 800382e:	681a      	ldr	r2, [r3, #0]
 8003830:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8003834:	601a      	str	r2, [r3, #0]
}
 8003836:	e739      	b.n	80036ac <HAL_RCC_OscConfig+0xc4>
        tickstart = HAL_GetTick();
 8003838:	f7fd f942 	bl	8000ac0 <HAL_GetTick>
 800383c:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800383e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003842:	681b      	ldr	r3, [r3, #0]
 8003844:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8003848:	d0c4      	beq.n	80037d4 <HAL_RCC_OscConfig+0x1ec>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800384a:	f7fd f939 	bl	8000ac0 <HAL_GetTick>
 800384e:	1bc0      	subs	r0, r0, r7
 8003850:	2864      	cmp	r0, #100	@ 0x64
 8003852:	d9f4      	bls.n	800383e <HAL_RCC_OscConfig+0x256>
            return HAL_TIMEOUT;
 8003854:	2003      	movs	r0, #3
 8003856:	e1e8      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8003858:	2e02      	cmp	r6, #2
 800385a:	d1c3      	bne.n	80037e4 <HAL_RCC_OscConfig+0x1fc>
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 800385c:	6923      	ldr	r3, [r4, #16]
 800385e:	2b00      	cmp	r3, #0
 8003860:	f000 81de 	beq.w	8003c20 <HAL_RCC_OscConfig+0x638>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003864:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8003866:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800386a:	6853      	ldr	r3, [r2, #4]
 800386c:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8003870:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8003874:	6053      	str	r3, [r2, #4]
}
 8003876:	e008      	b.n	800388a <HAL_RCC_OscConfig+0x2a2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003878:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 800387a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800387e:	6853      	ldr	r3, [r2, #4]
 8003880:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8003884:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8003888:	6053      	str	r3, [r2, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800388a:	6823      	ldr	r3, [r4, #0]
 800388c:	f013 0f08 	tst.w	r3, #8
 8003890:	d07e      	beq.n	8003990 <HAL_RCC_OscConfig+0x3a8>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8003892:	69a3      	ldr	r3, [r4, #24]
 8003894:	2b00      	cmp	r3, #0
 8003896:	d062      	beq.n	800395e <HAL_RCC_OscConfig+0x376>
      uint32_t csr_temp = RCC->CSR;
 8003898:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800389c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 80038a0:	69e1      	ldr	r1, [r4, #28]
 80038a2:	f003 0210 	and.w	r2, r3, #16
 80038a6:	4291      	cmp	r1, r2
 80038a8:	d011      	beq.n	80038ce <HAL_RCC_OscConfig+0x2e6>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 80038aa:	f003 0203 	and.w	r2, r3, #3
 80038ae:	2a02      	cmp	r2, #2
 80038b0:	f000 81b8 	beq.w	8003c24 <HAL_RCC_OscConfig+0x63c>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 80038b4:	f013 0f01 	tst.w	r3, #1
 80038b8:	d138      	bne.n	800392c <HAL_RCC_OscConfig+0x344>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 80038ba:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80038be:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
 80038c2:	f023 0310 	bic.w	r3, r3, #16
 80038c6:	69e1      	ldr	r1, [r4, #28]
 80038c8:	430b      	orrs	r3, r1
 80038ca:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 80038ce:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80038d2:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
 80038d6:	f043 0301 	orr.w	r3, r3, #1
 80038da:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
      tickstart = HAL_GetTick();
 80038de:	f7fd f8ef 	bl	8000ac0 <HAL_GetTick>
 80038e2:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 80038e4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80038e8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80038ec:	f013 0f02 	tst.w	r3, #2
 80038f0:	d14e      	bne.n	8003990 <HAL_RCC_OscConfig+0x3a8>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80038f2:	f7fd f8e5 	bl	8000ac0 <HAL_GetTick>
 80038f6:	1b80      	subs	r0, r0, r6
 80038f8:	2811      	cmp	r0, #17
 80038fa:	d9f3      	bls.n	80038e4 <HAL_RCC_OscConfig+0x2fc>
          return HAL_TIMEOUT;
 80038fc:	2003      	movs	r0, #3
 80038fe:	e194      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 8003900:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003904:	6813      	ldr	r3, [r2, #0]
 8003906:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800390a:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800390c:	f7fd f8d8 	bl	8000ac0 <HAL_GetTick>
 8003910:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8003912:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003916:	681b      	ldr	r3, [r3, #0]
 8003918:	f413 6f80 	tst.w	r3, #1024	@ 0x400
 800391c:	d0b5      	beq.n	800388a <HAL_RCC_OscConfig+0x2a2>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800391e:	f7fd f8cf 	bl	8000ac0 <HAL_GetTick>
 8003922:	1b80      	subs	r0, r0, r6
 8003924:	2802      	cmp	r0, #2
 8003926:	d9f4      	bls.n	8003912 <HAL_RCC_OscConfig+0x32a>
            return HAL_TIMEOUT;
 8003928:	2003      	movs	r0, #3
 800392a:	e17e      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 800392c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003930:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
 8003934:	f023 0301 	bic.w	r3, r3, #1
 8003938:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
          tickstart = HAL_GetTick();
 800393c:	f7fd f8c0 	bl	8000ac0 <HAL_GetTick>
 8003940:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 8003942:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003946:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800394a:	f013 0f02 	tst.w	r3, #2
 800394e:	d0b4      	beq.n	80038ba <HAL_RCC_OscConfig+0x2d2>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003950:	f7fd f8b6 	bl	8000ac0 <HAL_GetTick>
 8003954:	1b80      	subs	r0, r0, r6
 8003956:	2811      	cmp	r0, #17
 8003958:	d9f3      	bls.n	8003942 <HAL_RCC_OscConfig+0x35a>
              return HAL_TIMEOUT;
 800395a:	2003      	movs	r0, #3
 800395c:	e165      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 800395e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003962:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
 8003966:	f023 0301 	bic.w	r3, r3, #1
 800396a:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
      tickstart = HAL_GetTick();
 800396e:	f7fd f8a7 	bl	8000ac0 <HAL_GetTick>
 8003972:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 8003974:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003978:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800397c:	f013 0f02 	tst.w	r3, #2
 8003980:	d006      	beq.n	8003990 <HAL_RCC_OscConfig+0x3a8>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003982:	f7fd f89d 	bl	8000ac0 <HAL_GetTick>
 8003986:	1b80      	subs	r0, r0, r6
 8003988:	2811      	cmp	r0, #17
 800398a:	d9f3      	bls.n	8003974 <HAL_RCC_OscConfig+0x38c>
          return HAL_TIMEOUT;
 800398c:	2003      	movs	r0, #3
 800398e:	e14c      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8003990:	6823      	ldr	r3, [r4, #0]
 8003992:	f013 0f04 	tst.w	r3, #4
 8003996:	f000 80b8 	beq.w	8003b0a <HAL_RCC_OscConfig+0x522>
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 800399a:	4b22      	ldr	r3, [pc, #136]	@ (8003a24 <HAL_RCC_OscConfig+0x43c>)
 800399c:	681b      	ldr	r3, [r3, #0]
 800399e:	f413 7f80 	tst.w	r3, #256	@ 0x100
 80039a2:	d110      	bne.n	80039c6 <HAL_RCC_OscConfig+0x3de>
      HAL_PWR_EnableBkUpAccess();
 80039a4:	f7ff fc7e 	bl	80032a4 <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 80039a8:	f7fd f88a 	bl	8000ac0 <HAL_GetTick>
 80039ac:	4606      	mov	r6, r0
 80039ae:	4b1d      	ldr	r3, [pc, #116]	@ (8003a24 <HAL_RCC_OscConfig+0x43c>)
 80039b0:	681b      	ldr	r3, [r3, #0]
 80039b2:	f413 7f80 	tst.w	r3, #256	@ 0x100
 80039b6:	d106      	bne.n	80039c6 <HAL_RCC_OscConfig+0x3de>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80039b8:	f7fd f882 	bl	8000ac0 <HAL_GetTick>
 80039bc:	1b80      	subs	r0, r0, r6
 80039be:	2802      	cmp	r0, #2
 80039c0:	d9f5      	bls.n	80039ae <HAL_RCC_OscConfig+0x3c6>
          return HAL_TIMEOUT;
 80039c2:	2003      	movs	r0, #3
 80039c4:	e131      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80039c6:	68e3      	ldr	r3, [r4, #12]
 80039c8:	2b00      	cmp	r3, #0
 80039ca:	d068      	beq.n	8003a9e <HAL_RCC_OscConfig+0x4b6>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS)
 80039cc:	2b85      	cmp	r3, #133	@ 0x85
 80039ce:	d001      	beq.n	80039d4 <HAL_RCC_OscConfig+0x3ec>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 80039d0:	2b05      	cmp	r3, #5
 80039d2:	d107      	bne.n	80039e4 <HAL_RCC_OscConfig+0x3fc>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 80039d4:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80039d8:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80039dc:	f043 0304 	orr.w	r3, r3, #4
 80039e0:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
      tickstart = HAL_GetTick();
 80039e4:	f7fd f86c 	bl	8000ac0 <HAL_GetTick>
 80039e8:	4606      	mov	r6, r0
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 80039ea:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80039ee:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80039f2:	f043 0301 	orr.w	r3, r3, #1
 80039f6:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 80039fa:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80039fe:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8003a02:	f013 0f02 	tst.w	r3, #2
 8003a06:	d10f      	bne.n	8003a28 <HAL_RCC_OscConfig+0x440>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003a08:	f7fd f85a 	bl	8000ac0 <HAL_GetTick>
 8003a0c:	1b80      	subs	r0, r0, r6
 8003a0e:	f241 3388 	movw	r3, #5000	@ 0x1388
 8003a12:	4298      	cmp	r0, r3
 8003a14:	d9f1      	bls.n	80039fa <HAL_RCC_OscConfig+0x412>
          return HAL_TIMEOUT;
 8003a16:	2003      	movs	r0, #3
 8003a18:	e107      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
 8003a1a:	bf00      	nop
 8003a1c:	20000004 	.word	0x20000004
 8003a20:	2000000c 	.word	0x2000000c
 8003a24:	58000400 	.word	0x58000400
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 8003a28:	68e3      	ldr	r3, [r4, #12]
 8003a2a:	2b81      	cmp	r3, #129	@ 0x81
 8003a2c:	d001      	beq.n	8003a32 <HAL_RCC_OscConfig+0x44a>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS))
 8003a2e:	2b85      	cmp	r3, #133	@ 0x85
 8003a30:	d11a      	bne.n	8003a68 <HAL_RCC_OscConfig+0x480>
        tickstart = HAL_GetTick();
 8003a32:	f7fd f845 	bl	8000ac0 <HAL_GetTick>
 8003a36:	4606      	mov	r6, r0
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8003a38:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003a3c:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8003a40:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8003a44:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8003a48:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003a4c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8003a50:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 8003a54:	d159      	bne.n	8003b0a <HAL_RCC_OscConfig+0x522>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003a56:	f7fd f833 	bl	8000ac0 <HAL_GetTick>
 8003a5a:	1b80      	subs	r0, r0, r6
 8003a5c:	f241 3388 	movw	r3, #5000	@ 0x1388
 8003a60:	4298      	cmp	r0, r3
 8003a62:	d9f1      	bls.n	8003a48 <HAL_RCC_OscConfig+0x460>
            return HAL_TIMEOUT;
 8003a64:	2003      	movs	r0, #3
 8003a66:	e0e0      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        tickstart = HAL_GetTick();
 8003a68:	f7fd f82a 	bl	8000ac0 <HAL_GetTick>
 8003a6c:	4606      	mov	r6, r0
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8003a6e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003a72:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8003a76:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8003a7a:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8003a7e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003a82:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8003a86:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 8003a8a:	d03e      	beq.n	8003b0a <HAL_RCC_OscConfig+0x522>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003a8c:	f7fd f818 	bl	8000ac0 <HAL_GetTick>
 8003a90:	1b80      	subs	r0, r0, r6
 8003a92:	f241 3388 	movw	r3, #5000	@ 0x1388
 8003a96:	4298      	cmp	r0, r3
 8003a98:	d9f1      	bls.n	8003a7e <HAL_RCC_OscConfig+0x496>
            return HAL_TIMEOUT;
 8003a9a:	2003      	movs	r0, #3
 8003a9c:	e0c5      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
      tickstart = HAL_GetTick();
 8003a9e:	f7fd f80f 	bl	8000ac0 <HAL_GetTick>
 8003aa2:	4606      	mov	r6, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8003aa4:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003aa8:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8003aac:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8003ab0:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8003ab4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003ab8:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8003abc:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 8003ac0:	d008      	beq.n	8003ad4 <HAL_RCC_OscConfig+0x4ec>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003ac2:	f7fc fffd 	bl	8000ac0 <HAL_GetTick>
 8003ac6:	1b80      	subs	r0, r0, r6
 8003ac8:	f241 3388 	movw	r3, #5000	@ 0x1388
 8003acc:	4298      	cmp	r0, r3
 8003ace:	d9f1      	bls.n	8003ab4 <HAL_RCC_OscConfig+0x4cc>
          return HAL_TIMEOUT;
 8003ad0:	2003      	movs	r0, #3
 8003ad2:	e0aa      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
      tickstart = HAL_GetTick();
 8003ad4:	f7fc fff4 	bl	8000ac0 <HAL_GetTick>
 8003ad8:	4606      	mov	r6, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8003ada:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003ade:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8003ae2:	f023 0301 	bic.w	r3, r3, #1
 8003ae6:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 8003aea:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003aee:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8003af2:	f013 0f02 	tst.w	r3, #2
 8003af6:	d008      	beq.n	8003b0a <HAL_RCC_OscConfig+0x522>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003af8:	f7fc ffe2 	bl	8000ac0 <HAL_GetTick>
 8003afc:	1b80      	subs	r0, r0, r6
 8003afe:	f241 3388 	movw	r3, #5000	@ 0x1388
 8003b02:	4298      	cmp	r0, r3
 8003b04:	d9f1      	bls.n	8003aea <HAL_RCC_OscConfig+0x502>
          return HAL_TIMEOUT;
 8003b06:	2003      	movs	r0, #3
 8003b08:	e08f      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8003b0a:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8003b0c:	2b00      	cmp	r3, #0
 8003b0e:	f000 808b 	beq.w	8003c28 <HAL_RCC_OscConfig+0x640>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003b12:	2d0c      	cmp	r5, #12
 8003b14:	d060      	beq.n	8003bd8 <HAL_RCC_OscConfig+0x5f0>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8003b16:	2b02      	cmp	r3, #2
 8003b18:	d016      	beq.n	8003b48 <HAL_RCC_OscConfig+0x560>
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8003b1a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003b1e:	6813      	ldr	r3, [r2, #0]
 8003b20:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8003b24:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8003b26:	f7fc ffcb 	bl	8000ac0 <HAL_GetTick>
 8003b2a:	4604      	mov	r4, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8003b2c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003b30:	681b      	ldr	r3, [r3, #0]
 8003b32:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 8003b36:	d148      	bne.n	8003bca <HAL_RCC_OscConfig+0x5e2>
        CLEAR_BIT(RCC->PLLCFGR, (RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLPEN | RCC_PLLCFGR_PLLQEN | RCC_PLLCFGR_PLLREN));
 8003b38:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003b3c:	68d1      	ldr	r1, [r2, #12]
 8003b3e:	4b41      	ldr	r3, [pc, #260]	@ (8003c44 <HAL_RCC_OscConfig+0x65c>)
 8003b40:	400b      	ands	r3, r1
 8003b42:	60d3      	str	r3, [r2, #12]
  return HAL_OK;
 8003b44:	2000      	movs	r0, #0
 8003b46:	e070      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8003b48:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003b4c:	6813      	ldr	r3, [r2, #0]
 8003b4e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8003b52:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8003b54:	f7fc ffb4 	bl	8000ac0 <HAL_GetTick>
 8003b58:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8003b5a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003b5e:	681b      	ldr	r3, [r3, #0]
 8003b60:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 8003b64:	d12a      	bne.n	8003bbc <HAL_RCC_OscConfig+0x5d4>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8003b66:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003b6a:	68d3      	ldr	r3, [r2, #12]
 8003b6c:	4936      	ldr	r1, [pc, #216]	@ (8003c48 <HAL_RCC_OscConfig+0x660>)
 8003b6e:	4019      	ands	r1, r3
 8003b70:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8003b72:	6b60      	ldr	r0, [r4, #52]	@ 0x34
 8003b74:	4303      	orrs	r3, r0
 8003b76:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 8003b78:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8003b7c:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8003b7e:	4303      	orrs	r3, r0
 8003b80:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8003b82:	4303      	orrs	r3, r0
 8003b84:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8003b86:	4303      	orrs	r3, r0
 8003b88:	4319      	orrs	r1, r3
 8003b8a:	60d1      	str	r1, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8003b8c:	6813      	ldr	r3, [r2, #0]
 8003b8e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8003b92:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8003b94:	68d3      	ldr	r3, [r2, #12]
 8003b96:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8003b9a:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 8003b9c:	f7fc ff90 	bl	8000ac0 <HAL_GetTick>
 8003ba0:	4604      	mov	r4, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8003ba2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003ba6:	681b      	ldr	r3, [r3, #0]
 8003ba8:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 8003bac:	d13e      	bne.n	8003c2c <HAL_RCC_OscConfig+0x644>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003bae:	f7fc ff87 	bl	8000ac0 <HAL_GetTick>
 8003bb2:	1b00      	subs	r0, r0, r4
 8003bb4:	280a      	cmp	r0, #10
 8003bb6:	d9f4      	bls.n	8003ba2 <HAL_RCC_OscConfig+0x5ba>
            return HAL_TIMEOUT;
 8003bb8:	2003      	movs	r0, #3
 8003bba:	e036      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003bbc:	f7fc ff80 	bl	8000ac0 <HAL_GetTick>
 8003bc0:	1b40      	subs	r0, r0, r5
 8003bc2:	280a      	cmp	r0, #10
 8003bc4:	d9c9      	bls.n	8003b5a <HAL_RCC_OscConfig+0x572>
            return HAL_TIMEOUT;
 8003bc6:	2003      	movs	r0, #3
 8003bc8:	e02f      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003bca:	f7fc ff79 	bl	8000ac0 <HAL_GetTick>
 8003bce:	1b00      	subs	r0, r0, r4
 8003bd0:	280a      	cmp	r0, #10
 8003bd2:	d9ab      	bls.n	8003b2c <HAL_RCC_OscConfig+0x544>
            return HAL_TIMEOUT;
 8003bd4:	2003      	movs	r0, #3
 8003bd6:	e028      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8003bd8:	2b01      	cmp	r3, #1
 8003bda:	d029      	beq.n	8003c30 <HAL_RCC_OscConfig+0x648>
        pll_config = RCC->PLLCFGR;
 8003bdc:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003be0:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 8003be2:	f003 0103 	and.w	r1, r3, #3
 8003be6:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8003be8:	4291      	cmp	r1, r2
 8003bea:	d123      	bne.n	8003c34 <HAL_RCC_OscConfig+0x64c>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 8003bec:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 8003bf0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8003bf2:	428a      	cmp	r2, r1
 8003bf4:	d120      	bne.n	8003c38 <HAL_RCC_OscConfig+0x650>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 8003bf6:	f403 42fe 	and.w	r2, r3, #32512	@ 0x7f00
 8003bfa:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8003bfc:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8003c00:	d11c      	bne.n	8003c3c <HAL_RCC_OscConfig+0x654>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 8003c02:	f003 4360 	and.w	r3, r3, #3758096384	@ 0xe0000000
 8003c06:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8003c08:	4293      	cmp	r3, r2
 8003c0a:	d119      	bne.n	8003c40 <HAL_RCC_OscConfig+0x658>
  return HAL_OK;
 8003c0c:	2000      	movs	r0, #0
 8003c0e:	e00c      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
    return HAL_ERROR;
 8003c10:	2001      	movs	r0, #1
}
 8003c12:	4770      	bx	lr
        return HAL_ERROR;
 8003c14:	2001      	movs	r0, #1
 8003c16:	e008      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
            return HAL_ERROR;
 8003c18:	2001      	movs	r0, #1
 8003c1a:	e006      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        return HAL_ERROR;
 8003c1c:	2001      	movs	r0, #1
 8003c1e:	e004      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        return HAL_ERROR;
 8003c20:	2001      	movs	r0, #1
 8003c22:	e002      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
          return HAL_ERROR;
 8003c24:	2001      	movs	r0, #1
 8003c26:	e000      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
  return HAL_OK;
 8003c28:	2000      	movs	r0, #0
}
 8003c2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8003c2c:	2000      	movs	r0, #0
 8003c2e:	e7fc      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
        return HAL_ERROR;
 8003c30:	2001      	movs	r0, #1
 8003c32:	e7fa      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
          return HAL_ERROR;
 8003c34:	2001      	movs	r0, #1
 8003c36:	e7f8      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
 8003c38:	2001      	movs	r0, #1
 8003c3a:	e7f6      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
 8003c3c:	2001      	movs	r0, #1
 8003c3e:	e7f4      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
 8003c40:	2001      	movs	r0, #1
 8003c42:	e7f2      	b.n	8003c2a <HAL_RCC_OscConfig+0x642>
 8003c44:	eefefffc 	.word	0xeefefffc
 8003c48:	11c1808c 	.word	0x11c1808c

08003c4c <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8003c4c:	2800      	cmp	r0, #0
 8003c4e:	f000 8127 	beq.w	8003ea0 <HAL_RCC_ClockConfig+0x254>
{
 8003c52:	b570      	push	{r4, r5, r6, lr}
 8003c54:	460c      	mov	r4, r1
 8003c56:	4605      	mov	r5, r0
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8003c58:	4b93      	ldr	r3, [pc, #588]	@ (8003ea8 <HAL_RCC_ClockConfig+0x25c>)
 8003c5a:	681b      	ldr	r3, [r3, #0]
 8003c5c:	f003 0307 	and.w	r3, r3, #7
 8003c60:	428b      	cmp	r3, r1
 8003c62:	d32d      	bcc.n	8003cc0 <HAL_RCC_ClockConfig+0x74>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003c64:	682b      	ldr	r3, [r5, #0]
 8003c66:	f013 0f02 	tst.w	r3, #2
 8003c6a:	d13f      	bne.n	8003cec <HAL_RCC_ClockConfig+0xa0>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 8003c6c:	682b      	ldr	r3, [r5, #0]
 8003c6e:	f013 0f20 	tst.w	r3, #32
 8003c72:	d153      	bne.n	8003d1c <HAL_RCC_ClockConfig+0xd0>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 8003c74:	682b      	ldr	r3, [r5, #0]
 8003c76:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8003c7a:	d16a      	bne.n	8003d52 <HAL_RCC_ClockConfig+0x106>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003c7c:	682b      	ldr	r3, [r5, #0]
 8003c7e:	f013 0f04 	tst.w	r3, #4
 8003c82:	f040 8083 	bne.w	8003d8c <HAL_RCC_ClockConfig+0x140>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003c86:	682b      	ldr	r3, [r5, #0]
 8003c88:	f013 0f08 	tst.w	r3, #8
 8003c8c:	f040 8097 	bne.w	8003dbe <HAL_RCC_ClockConfig+0x172>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003c90:	682b      	ldr	r3, [r5, #0]
 8003c92:	f013 0f01 	tst.w	r3, #1
 8003c96:	f000 80de 	beq.w	8003e56 <HAL_RCC_ClockConfig+0x20a>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003c9a:	686b      	ldr	r3, [r5, #4]
 8003c9c:	2b02      	cmp	r3, #2
 8003c9e:	f000 80a8 	beq.w	8003df2 <HAL_RCC_ClockConfig+0x1a6>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003ca2:	2b03      	cmp	r3, #3
 8003ca4:	f000 80ad 	beq.w	8003e02 <HAL_RCC_ClockConfig+0x1b6>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8003ca8:	2b00      	cmp	r3, #0
 8003caa:	f040 80b2 	bne.w	8003e12 <HAL_RCC_ClockConfig+0x1c6>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8003cae:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003cb2:	6812      	ldr	r2, [r2, #0]
 8003cb4:	f012 0f02 	tst.w	r2, #2
 8003cb8:	f040 80b1 	bne.w	8003e1e <HAL_RCC_ClockConfig+0x1d2>
        return HAL_ERROR;
 8003cbc:	2001      	movs	r0, #1
 8003cbe:	e0ee      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003cc0:	4a79      	ldr	r2, [pc, #484]	@ (8003ea8 <HAL_RCC_ClockConfig+0x25c>)
 8003cc2:	6813      	ldr	r3, [r2, #0]
 8003cc4:	f023 0307 	bic.w	r3, r3, #7
 8003cc8:	430b      	orrs	r3, r1
 8003cca:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8003ccc:	f7fc fef8 	bl	8000ac0 <HAL_GetTick>
 8003cd0:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003cd2:	4b75      	ldr	r3, [pc, #468]	@ (8003ea8 <HAL_RCC_ClockConfig+0x25c>)
 8003cd4:	681b      	ldr	r3, [r3, #0]
 8003cd6:	f003 0307 	and.w	r3, r3, #7
 8003cda:	42a3      	cmp	r3, r4
 8003cdc:	d0c2      	beq.n	8003c64 <HAL_RCC_ClockConfig+0x18>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8003cde:	f7fc feef 	bl	8000ac0 <HAL_GetTick>
 8003ce2:	1b80      	subs	r0, r0, r6
 8003ce4:	2802      	cmp	r0, #2
 8003ce6:	d9f4      	bls.n	8003cd2 <HAL_RCC_ClockConfig+0x86>
        return HAL_TIMEOUT;
 8003ce8:	2003      	movs	r0, #3
 8003cea:	e0d8      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLKDivider);
 8003cec:	68ab      	ldr	r3, [r5, #8]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8003cee:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003cf2:	688a      	ldr	r2, [r1, #8]
 8003cf4:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8003cf8:	4313      	orrs	r3, r2
 8003cfa:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8003cfc:	f7fc fee0 	bl	8000ac0 <HAL_GetTick>
 8003d00:	4606      	mov	r6, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 8003d02:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003d06:	689b      	ldr	r3, [r3, #8]
 8003d08:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 8003d0c:	d1ae      	bne.n	8003c6c <HAL_RCC_ClockConfig+0x20>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8003d0e:	f7fc fed7 	bl	8000ac0 <HAL_GetTick>
 8003d12:	1b80      	subs	r0, r0, r6
 8003d14:	2802      	cmp	r0, #2
 8003d16:	d9f4      	bls.n	8003d02 <HAL_RCC_ClockConfig+0xb6>
        return HAL_TIMEOUT;
 8003d18:	2003      	movs	r0, #3
 8003d1a:	e0c0      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
    LL_C2_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLK2Divider);
 8003d1c:	696b      	ldr	r3, [r5, #20]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 8003d1e:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003d22:	f8d1 2108 	ldr.w	r2, [r1, #264]	@ 0x108
 8003d26:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8003d2a:	4313      	orrs	r3, r2
 8003d2c:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
    tickstart = HAL_GetTick();
 8003d30:	f7fc fec6 	bl	8000ac0 <HAL_GetTick>
 8003d34:	4606      	mov	r6, r0
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 8003d36:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003d3a:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8003d3e:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8003d42:	d197      	bne.n	8003c74 <HAL_RCC_ClockConfig+0x28>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8003d44:	f7fc febc 	bl	8000ac0 <HAL_GetTick>
 8003d48:	1b80      	subs	r0, r0, r6
 8003d4a:	2802      	cmp	r0, #2
 8003d4c:	d9f3      	bls.n	8003d36 <HAL_RCC_ClockConfig+0xea>
        return HAL_TIMEOUT;
 8003d4e:	2003      	movs	r0, #3
 8003d50:	e0a5      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAHB3Prescaler(RCC_ClkInitStruct->AHBCLK3Divider);
 8003d52:	69a9      	ldr	r1, [r5, #24]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 8003d54:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003d58:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
 8003d5c:	f023 030f 	bic.w	r3, r3, #15
 8003d60:	ea43 1311 	orr.w	r3, r3, r1, lsr #4
 8003d64:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
    tickstart = HAL_GetTick();
 8003d68:	f7fc feaa 	bl	8000ac0 <HAL_GetTick>
 8003d6c:	4606      	mov	r6, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 8003d6e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003d72:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8003d76:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 8003d7a:	f47f af7f 	bne.w	8003c7c <HAL_RCC_ClockConfig+0x30>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8003d7e:	f7fc fe9f 	bl	8000ac0 <HAL_GetTick>
 8003d82:	1b80      	subs	r0, r0, r6
 8003d84:	2802      	cmp	r0, #2
 8003d86:	d9f2      	bls.n	8003d6e <HAL_RCC_ClockConfig+0x122>
        return HAL_TIMEOUT;
 8003d88:	2003      	movs	r0, #3
 8003d8a:	e088      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAPB1Prescaler(RCC_ClkInitStruct->APB1CLKDivider);
 8003d8c:	68eb      	ldr	r3, [r5, #12]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8003d8e:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003d92:	688a      	ldr	r2, [r1, #8]
 8003d94:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8003d98:	4313      	orrs	r3, r2
 8003d9a:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8003d9c:	f7fc fe90 	bl	8000ac0 <HAL_GetTick>
 8003da0:	4606      	mov	r6, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 8003da2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003da6:	689b      	ldr	r3, [r3, #8]
 8003da8:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8003dac:	f47f af6b 	bne.w	8003c86 <HAL_RCC_ClockConfig+0x3a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8003db0:	f7fc fe86 	bl	8000ac0 <HAL_GetTick>
 8003db4:	1b80      	subs	r0, r0, r6
 8003db6:	2802      	cmp	r0, #2
 8003db8:	d9f3      	bls.n	8003da2 <HAL_RCC_ClockConfig+0x156>
        return HAL_TIMEOUT;
 8003dba:	2003      	movs	r0, #3
 8003dbc:	e06f      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 8003dbe:	6929      	ldr	r1, [r5, #16]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8003dc0:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003dc4:	6893      	ldr	r3, [r2, #8]
 8003dc6:	f423 5360 	bic.w	r3, r3, #14336	@ 0x3800
 8003dca:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8003dce:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 8003dd0:	f7fc fe76 	bl	8000ac0 <HAL_GetTick>
 8003dd4:	4606      	mov	r6, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 8003dd6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003dda:	689b      	ldr	r3, [r3, #8]
 8003ddc:	f413 2f80 	tst.w	r3, #262144	@ 0x40000
 8003de0:	f47f af56 	bne.w	8003c90 <HAL_RCC_ClockConfig+0x44>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8003de4:	f7fc fe6c 	bl	8000ac0 <HAL_GetTick>
 8003de8:	1b80      	subs	r0, r0, r6
 8003dea:	2802      	cmp	r0, #2
 8003dec:	d9f3      	bls.n	8003dd6 <HAL_RCC_ClockConfig+0x18a>
        return HAL_TIMEOUT;
 8003dee:	2003      	movs	r0, #3
 8003df0:	e055      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8003df2:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003df6:	6812      	ldr	r2, [r2, #0]
 8003df8:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
 8003dfc:	d10f      	bne.n	8003e1e <HAL_RCC_ClockConfig+0x1d2>
        return HAL_ERROR;
 8003dfe:	2001      	movs	r0, #1
 8003e00:	e04d      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8003e02:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003e06:	6812      	ldr	r2, [r2, #0]
 8003e08:	f012 7f00 	tst.w	r2, #33554432	@ 0x2000000
 8003e0c:	d107      	bne.n	8003e1e <HAL_RCC_ClockConfig+0x1d2>
        return HAL_ERROR;
 8003e0e:	2001      	movs	r0, #1
 8003e10:	e045      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8003e12:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003e16:	6812      	ldr	r2, [r2, #0]
 8003e18:	f412 6f80 	tst.w	r2, #1024	@ 0x400
 8003e1c:	d042      	beq.n	8003ea4 <HAL_RCC_ClockConfig+0x258>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8003e1e:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003e22:	688a      	ldr	r2, [r1, #8]
 8003e24:	f022 0203 	bic.w	r2, r2, #3
 8003e28:	4313      	orrs	r3, r2
 8003e2a:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8003e2c:	f7fc fe48 	bl	8000ac0 <HAL_GetTick>
 8003e30:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8003e32:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003e36:	689b      	ldr	r3, [r3, #8]
 8003e38:	f003 030c 	and.w	r3, r3, #12
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003e3c:	686a      	ldr	r2, [r5, #4]
 8003e3e:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8003e42:	d008      	beq.n	8003e56 <HAL_RCC_ClockConfig+0x20a>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003e44:	f7fc fe3c 	bl	8000ac0 <HAL_GetTick>
 8003e48:	1b80      	subs	r0, r0, r6
 8003e4a:	f241 3388 	movw	r3, #5000	@ 0x1388
 8003e4e:	4298      	cmp	r0, r3
 8003e50:	d9ef      	bls.n	8003e32 <HAL_RCC_ClockConfig+0x1e6>
        return HAL_TIMEOUT;
 8003e52:	2003      	movs	r0, #3
 8003e54:	e023      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8003e56:	4b14      	ldr	r3, [pc, #80]	@ (8003ea8 <HAL_RCC_ClockConfig+0x25c>)
 8003e58:	681b      	ldr	r3, [r3, #0]
 8003e5a:	f003 0307 	and.w	r3, r3, #7
 8003e5e:	42a3      	cmp	r3, r4
 8003e60:	d915      	bls.n	8003e8e <HAL_RCC_ClockConfig+0x242>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003e62:	4a11      	ldr	r2, [pc, #68]	@ (8003ea8 <HAL_RCC_ClockConfig+0x25c>)
 8003e64:	6813      	ldr	r3, [r2, #0]
 8003e66:	f023 0307 	bic.w	r3, r3, #7
 8003e6a:	4323      	orrs	r3, r4
 8003e6c:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8003e6e:	f7fc fe27 	bl	8000ac0 <HAL_GetTick>
 8003e72:	4605      	mov	r5, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003e74:	4b0c      	ldr	r3, [pc, #48]	@ (8003ea8 <HAL_RCC_ClockConfig+0x25c>)
 8003e76:	681b      	ldr	r3, [r3, #0]
 8003e78:	f003 0307 	and.w	r3, r3, #7
 8003e7c:	42a3      	cmp	r3, r4
 8003e7e:	d006      	beq.n	8003e8e <HAL_RCC_ClockConfig+0x242>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8003e80:	f7fc fe1e 	bl	8000ac0 <HAL_GetTick>
 8003e84:	1b40      	subs	r0, r0, r5
 8003e86:	2802      	cmp	r0, #2
 8003e88:	d9f4      	bls.n	8003e74 <HAL_RCC_ClockConfig+0x228>
        return HAL_TIMEOUT;
 8003e8a:	2003      	movs	r0, #3
 8003e8c:	e007      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8003e8e:	f7ff fb9b 	bl	80035c8 <HAL_RCC_GetHCLKFreq>
 8003e92:	4b06      	ldr	r3, [pc, #24]	@ (8003eac <HAL_RCC_ClockConfig+0x260>)
 8003e94:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 8003e96:	4b06      	ldr	r3, [pc, #24]	@ (8003eb0 <HAL_RCC_ClockConfig+0x264>)
 8003e98:	6818      	ldr	r0, [r3, #0]
 8003e9a:	f7fe f8d1 	bl	8002040 <HAL_InitTick>
}
 8003e9e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8003ea0:	2001      	movs	r0, #1
}
 8003ea2:	4770      	bx	lr
        return HAL_ERROR;
 8003ea4:	2001      	movs	r0, #1
 8003ea6:	e7fa      	b.n	8003e9e <HAL_RCC_ClockConfig+0x252>
 8003ea8:	58004000 	.word	0x58004000
 8003eac:	20000004 	.word	0x20000004
 8003eb0:	2000000c 	.word	0x2000000c

08003eb4 <HAL_RCC_GetPCLK1Freq>:
{
 8003eb4:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 8003eb6:	f7ff fb87 	bl	80035c8 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8003eba:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003ebe:	689b      	ldr	r3, [r3, #8]
 8003ec0:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8003ec4:	4a02      	ldr	r2, [pc, #8]	@ (8003ed0 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8003ec6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 8003eca:	40d8      	lsrs	r0, r3
 8003ecc:	bd08      	pop	{r3, pc}
 8003ece:	bf00      	nop
 8003ed0:	080068ac 	.word	0x080068ac

08003ed4 <HAL_RCC_GetPCLK2Freq>:
{
 8003ed4:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 8003ed6:	f7ff fb77 	bl	80035c8 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8003eda:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003ede:	689b      	ldr	r3, [r3, #8]
 8003ee0:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8003ee4:	4a02      	ldr	r2, [pc, #8]	@ (8003ef0 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8003ee6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 8003eea:	40d8      	lsrs	r0, r3
 8003eec:	bd08      	pop	{r3, pc}
 8003eee:	bf00      	nop
 8003ef0:	080068ac 	.word	0x080068ac

08003ef4 <HAL_RCC_GetOscConfig>:
  if (RCC_OscInitStruct != NULL)
 8003ef4:	2800      	cmp	r0, #0
 8003ef6:	d042      	beq.n	8003f7e <HAL_RCC_GetOscConfig+0x8a>
{
 8003ef8:	b430      	push	{r4, r5}
 8003efa:	4603      	mov	r3, r0
    RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 8003efc:	222f      	movs	r2, #47	@ 0x2f
 8003efe:	6002      	str	r2, [r0, #0]
    regvalue = RCC->CR; /* Control register */
 8003f00:	f04f 40b0 	mov.w	r0, #1476395008	@ 0x58000000
 8003f04:	6802      	ldr	r2, [r0, #0]
    regICSRvalue = RCC->ICSCR; /* Get Internal Clock Sources Calibration register */
 8003f06:	6844      	ldr	r4, [r0, #4]
    regPLLCFGRvalue = RCC->PLLCFGR; /* Get PLL Configuration register */
 8003f08:	68c1      	ldr	r1, [r0, #12]
    RCC_OscInitStruct->HSEState = (regvalue & RCC_HSE_BYPASS_PWR);
 8003f0a:	f402 1504 	and.w	r5, r2, #2162688	@ 0x210000
 8003f0e:	605d      	str	r5, [r3, #4]
    RCC_OscInitStruct->HSEDiv   = (regvalue & RCC_CR_HSEPRE);
 8003f10:	f402 1580 	and.w	r5, r2, #1048576	@ 0x100000
 8003f14:	609d      	str	r5, [r3, #8]
    RCC_OscInitStruct->MSIState            = (regvalue & RCC_CR_MSION);
 8003f16:	f002 0501 	and.w	r5, r2, #1
 8003f1a:	621d      	str	r5, [r3, #32]
    RCC_OscInitStruct->MSICalibrationValue = ((regICSRvalue & RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos);
 8003f1c:	f3c4 2507 	ubfx	r5, r4, #8, #8
 8003f20:	625d      	str	r5, [r3, #36]	@ 0x24
    RCC_OscInitStruct->MSIClockRange       = (regvalue & RCC_CR_MSIRANGE);
 8003f22:	f002 05f0 	and.w	r5, r2, #240	@ 0xf0
 8003f26:	629d      	str	r5, [r3, #40]	@ 0x28
    RCC_OscInitStruct->HSIState            = (regvalue & RCC_CR_HSION);
 8003f28:	f402 7580 	and.w	r5, r2, #256	@ 0x100
 8003f2c:	611d      	str	r5, [r3, #16]
    RCC_OscInitStruct->HSICalibrationValue = ((regICSRvalue & RCC_ICSCR_HSITRIM) >> RCC_ICSCR_HSITRIM_Pos);
 8003f2e:	f3c4 6406 	ubfx	r4, r4, #24, #7
 8003f32:	615c      	str	r4, [r3, #20]
    RCC_OscInitStruct->PLL.PLLState  = ((regvalue & RCC_CR_PLLON) >> RCC_CR_PLLON_Pos) + 1U;
 8003f34:	f3c2 6200 	ubfx	r2, r2, #24, #1
 8003f38:	3201      	adds	r2, #1
 8003f3a:	62da      	str	r2, [r3, #44]	@ 0x2c
    RCC_OscInitStruct->PLL.PLLSource = (regPLLCFGRvalue & RCC_PLLCFGR_PLLSRC);
 8003f3c:	f001 0203 	and.w	r2, r1, #3
 8003f40:	631a      	str	r2, [r3, #48]	@ 0x30
    RCC_OscInitStruct->PLL.PLLM      = (regPLLCFGRvalue & RCC_PLLCFGR_PLLM);
 8003f42:	f001 0270 	and.w	r2, r1, #112	@ 0x70
 8003f46:	635a      	str	r2, [r3, #52]	@ 0x34
    RCC_OscInitStruct->PLL.PLLN      = ((regPLLCFGRvalue & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8003f48:	f3c1 2206 	ubfx	r2, r1, #8, #7
 8003f4c:	639a      	str	r2, [r3, #56]	@ 0x38
    RCC_OscInitStruct->PLL.PLLP      = (regPLLCFGRvalue & RCC_PLLCFGR_PLLP);
 8003f4e:	f401 1278 	and.w	r2, r1, #4063232	@ 0x3e0000
 8003f52:	63da      	str	r2, [r3, #60]	@ 0x3c
    RCC_OscInitStruct->PLL.PLLQ      = (regPLLCFGRvalue & RCC_PLLCFGR_PLLQ);
 8003f54:	f001 6260 	and.w	r2, r1, #234881024	@ 0xe000000
 8003f58:	641a      	str	r2, [r3, #64]	@ 0x40
    RCC_OscInitStruct->PLL.PLLR      = (regPLLCFGRvalue & RCC_PLLCFGR_PLLR);
 8003f5a:	f001 4160 	and.w	r1, r1, #3758096384	@ 0xe0000000
 8003f5e:	6459      	str	r1, [r3, #68]	@ 0x44
    regvalue = RCC->BDCR;
 8003f60:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
    RCC_OscInitStruct->LSEState = (regvalue & RCC_LSE_BYPASS);
 8003f64:	f002 0285 	and.w	r2, r2, #133	@ 0x85
 8003f68:	60da      	str	r2, [r3, #12]
    regvalue = RCC->CSR;
 8003f6a:	f8d0 2094 	ldr.w	r2, [r0, #148]	@ 0x94
    RCC_OscInitStruct->LSIState = (regvalue & RCC_LSI_ON);
 8003f6e:	f002 0101 	and.w	r1, r2, #1
 8003f72:	6199      	str	r1, [r3, #24]
    RCC_OscInitStruct->LSIDiv = (regvalue & RCC_CSR_LSIPRE);
 8003f74:	f002 0210 	and.w	r2, r2, #16
 8003f78:	61da      	str	r2, [r3, #28]
}
 8003f7a:	bc30      	pop	{r4, r5}
 8003f7c:	4770      	bx	lr
 8003f7e:	4770      	bx	lr

08003f80 <LL_RCC_SetI2CClockSource>:
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 8003f80:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003f84:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 8003f88:	0902      	lsrs	r2, r0, #4
 8003f8a:	f402 227f 	and.w	r2, r2, #1044480	@ 0xff000
 8003f8e:	ea23 0302 	bic.w	r3, r3, r2
 8003f92:	0100      	lsls	r0, r0, #4
 8003f94:	f400 207f 	and.w	r0, r0, #1044480	@ 0xff000
 8003f98:	4303      	orrs	r3, r0
 8003f9a:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
}
 8003f9e:	4770      	bx	lr

08003fa0 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003fa0:	b570      	push	{r4, r5, r6, lr}
 8003fa2:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8003fa4:	6803      	ldr	r3, [r0, #0]
 8003fa6:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 8003faa:	f040 80aa 	bne.w	8004102 <HAL_RCCEx_PeriphCLKConfig+0x162>
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8003fae:	2500      	movs	r5, #0
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8003fb0:	6823      	ldr	r3, [r4, #0]
 8003fb2:	f013 0f01 	tst.w	r3, #1
 8003fb6:	d00a      	beq.n	8003fce <HAL_RCCEx_PeriphCLKConfig+0x2e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8003fb8:	6862      	ldr	r2, [r4, #4]
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 8003fba:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003fbe:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 8003fc2:	ea23 4312 	bic.w	r3, r3, r2, lsr #16
 8003fc6:	b292      	uxth	r2, r2
 8003fc8:	4313      	orrs	r3, r2
 8003fca:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8003fce:	6823      	ldr	r3, [r4, #0]
 8003fd0:	f013 0f02 	tst.w	r3, #2
 8003fd4:	d00a      	beq.n	8003fec <HAL_RCCEx_PeriphCLKConfig+0x4c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8003fd6:	68a2      	ldr	r2, [r4, #8]
 8003fd8:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003fdc:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 8003fe0:	ea23 4312 	bic.w	r3, r3, r2, lsr #16
 8003fe4:	b292      	uxth	r2, r2
 8003fe6:	4313      	orrs	r3, r2
 8003fe8:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8003fec:	6823      	ldr	r3, [r4, #0]
 8003fee:	f013 0f20 	tst.w	r3, #32
 8003ff2:	d009      	beq.n	8004008 <HAL_RCCEx_PeriphCLKConfig+0x68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8003ff4:	6923      	ldr	r3, [r4, #16]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8003ff6:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8003ffa:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8003ffe:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 8004002:	4313      	orrs	r3, r2
 8004004:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8004008:	6823      	ldr	r3, [r4, #0]
 800400a:	f413 7f00 	tst.w	r3, #512	@ 0x200
 800400e:	d00c      	beq.n	800402a <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8004010:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8004012:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8004016:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 800401a:	0c02      	lsrs	r2, r0, #16
 800401c:	0412      	lsls	r2, r2, #16
 800401e:	ea23 0302 	bic.w	r3, r3, r2
 8004022:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8004026:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 800402a:	6823      	ldr	r3, [r4, #0]
 800402c:	f413 6f80 	tst.w	r3, #1024	@ 0x400
 8004030:	d00c      	beq.n	800404c <HAL_RCCEx_PeriphCLKConfig+0xac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8004032:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8004034:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8004038:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 800403c:	0c02      	lsrs	r2, r0, #16
 800403e:	0412      	lsls	r2, r2, #16
 8004040:	ea23 0302 	bic.w	r3, r3, r2
 8004044:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8004048:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 800404c:	6823      	ldr	r3, [r4, #0]
 800404e:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 8004052:	d00c      	beq.n	800406e <HAL_RCCEx_PeriphCLKConfig+0xce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 8004054:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8004056:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 800405a:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 800405e:	0c02      	lsrs	r2, r0, #16
 8004060:	0412      	lsls	r2, r2, #16
 8004062:	ea23 0302 	bic.w	r3, r3, r2
 8004066:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 800406a:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800406e:	6823      	ldr	r3, [r4, #0]
 8004070:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8004074:	f040 809d 	bne.w	80041b2 <HAL_RCCEx_PeriphCLKConfig+0x212>
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004078:	6823      	ldr	r3, [r4, #0]
 800407a:	f013 0f80 	tst.w	r3, #128	@ 0x80
 800407e:	f040 809c 	bne.w	80041ba <HAL_RCCEx_PeriphCLKConfig+0x21a>
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8004082:	6823      	ldr	r3, [r4, #0]
 8004084:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8004088:	f040 809b 	bne.w	80041c2 <HAL_RCCEx_PeriphCLKConfig+0x222>
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 800408c:	6823      	ldr	r3, [r4, #0]
 800408e:	f013 0f10 	tst.w	r3, #16
 8004092:	d00e      	beq.n	80040b2 <HAL_RCCEx_PeriphCLKConfig+0x112>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 8004094:	68e3      	ldr	r3, [r4, #12]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 8004096:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 800409a:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 800409e:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 80040a2:	4313      	orrs	r3, r2
 80040a4:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 80040a8:	68e3      	ldr	r3, [r4, #12]
 80040aa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80040ae:	f000 808c 	beq.w	80041ca <HAL_RCCEx_PeriphCLKConfig+0x22a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80040b2:	6823      	ldr	r3, [r4, #0]
 80040b4:	f413 4f00 	tst.w	r3, #32768	@ 0x8000
 80040b8:	d00f      	beq.n	80040da <HAL_RCCEx_PeriphCLKConfig+0x13a>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80040ba:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 80040bc:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 80040c0:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80040c4:	f022 4240 	bic.w	r2, r2, #3221225472	@ 0xc0000000
 80040c8:	4313      	orrs	r3, r2
 80040ca:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80040ce:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80040d0:	b91b      	cbnz	r3, 80040da <HAL_RCCEx_PeriphCLKConfig+0x13a>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 80040d2:	68cb      	ldr	r3, [r1, #12]
 80040d4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 80040d8:	60cb      	str	r3, [r1, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80040da:	6823      	ldr	r3, [r4, #0]
 80040dc:	f413 4f80 	tst.w	r3, #16384	@ 0x4000
 80040e0:	d00d      	beq.n	80040fe <HAL_RCCEx_PeriphCLKConfig+0x15e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 80040e2:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 80040e4:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 80040e8:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80040ec:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
 80040f0:	4313      	orrs	r3, r2
 80040f2:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 80040f6:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80040f8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80040fc:	d06a      	beq.n	80041d4 <HAL_RCCEx_PeriphCLKConfig+0x234>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
    }
  }

  return status;
}
 80040fe:	4628      	mov	r0, r5
 8004100:	bd70      	pop	{r4, r5, r6, pc}
    HAL_PWR_EnableBkUpAccess();
 8004102:	f7ff f8cf 	bl	80032a4 <HAL_PWR_EnableBkUpAccess>
    tickstart = HAL_GetTick();
 8004106:	f7fc fcdb 	bl	8000ac0 <HAL_GetTick>
 800410a:	4605      	mov	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 800410c:	4b34      	ldr	r3, [pc, #208]	@ (80041e0 <HAL_RCCEx_PeriphCLKConfig+0x240>)
 800410e:	681b      	ldr	r3, [r3, #0]
 8004110:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8004114:	d106      	bne.n	8004124 <HAL_RCCEx_PeriphCLKConfig+0x184>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004116:	f7fc fcd3 	bl	8000ac0 <HAL_GetTick>
 800411a:	1b40      	subs	r0, r0, r5
 800411c:	2802      	cmp	r0, #2
 800411e:	d9f5      	bls.n	800410c <HAL_RCCEx_PeriphCLKConfig+0x16c>
        ret = HAL_TIMEOUT;
 8004120:	2503      	movs	r5, #3
 8004122:	e000      	b.n	8004126 <HAL_RCCEx_PeriphCLKConfig+0x186>
  HAL_StatusTypeDef ret = HAL_OK;   /* Intermediate status */
 8004124:	2500      	movs	r5, #0
    if (ret == HAL_OK)
 8004126:	2d00      	cmp	r5, #0
 8004128:	f47f af42 	bne.w	8003fb0 <HAL_RCCEx_PeriphCLKConfig+0x10>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 800412c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8004130:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8004134:	f403 7340 	and.w	r3, r3, #768	@ 0x300
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 8004138:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 800413a:	429a      	cmp	r2, r3
 800413c:	d024      	beq.n	8004188 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800413e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8004142:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8004146:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 800414a:	f8d3 1090 	ldr.w	r1, [r3, #144]	@ 0x90
 800414e:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
 8004152:	f8c3 1090 	str.w	r1, [r3, #144]	@ 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8004156:	f8d3 1090 	ldr.w	r1, [r3, #144]	@ 0x90
 800415a:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
 800415e:	f8c3 1090 	str.w	r1, [r3, #144]	@ 0x90
        RCC->BDCR = tmpregister;
 8004162:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8004166:	f012 0f02 	tst.w	r2, #2
 800416a:	d10f      	bne.n	800418c <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      if (ret == HAL_OK)
 800416c:	2d00      	cmp	r5, #0
 800416e:	f47f af1f 	bne.w	8003fb0 <HAL_RCCEx_PeriphCLKConfig+0x10>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004172:	6b63      	ldr	r3, [r4, #52]	@ 0x34
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8004174:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8004178:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 800417c:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8004180:	4313      	orrs	r3, r2
 8004182:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
}
 8004186:	e713      	b.n	8003fb0 <HAL_RCCEx_PeriphCLKConfig+0x10>
  uint32_t tmpregister = 0;
 8004188:	2200      	movs	r2, #0
 800418a:	e7ec      	b.n	8004166 <HAL_RCCEx_PeriphCLKConfig+0x1c6>
        tickstart = HAL_GetTick();
 800418c:	f7fc fc98 	bl	8000ac0 <HAL_GetTick>
 8004190:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8004192:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8004196:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800419a:	f013 0f02 	tst.w	r3, #2
 800419e:	d1e5      	bne.n	800416c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80041a0:	f7fc fc8e 	bl	8000ac0 <HAL_GetTick>
 80041a4:	1b80      	subs	r0, r0, r6
 80041a6:	f241 3388 	movw	r3, #5000	@ 0x1388
 80041aa:	4298      	cmp	r0, r3
 80041ac:	d9f1      	bls.n	8004192 <HAL_RCCEx_PeriphCLKConfig+0x1f2>
            ret = HAL_TIMEOUT;
 80041ae:	2503      	movs	r5, #3
 80041b0:	e7dc      	b.n	800416c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80041b2:	6960      	ldr	r0, [r4, #20]
 80041b4:	f7ff fee4 	bl	8003f80 <LL_RCC_SetI2CClockSource>
 80041b8:	e75e      	b.n	8004078 <HAL_RCCEx_PeriphCLKConfig+0xd8>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80041ba:	69a0      	ldr	r0, [r4, #24]
 80041bc:	f7ff fee0 	bl	8003f80 <LL_RCC_SetI2CClockSource>
 80041c0:	e75f      	b.n	8004082 <HAL_RCCEx_PeriphCLKConfig+0xe2>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80041c2:	69e0      	ldr	r0, [r4, #28]
 80041c4:	f7ff fedc 	bl	8003f80 <LL_RCC_SetI2CClockSource>
 80041c8:	e760      	b.n	800408c <HAL_RCCEx_PeriphCLKConfig+0xec>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 80041ca:	68cb      	ldr	r3, [r1, #12]
 80041cc:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 80041d0:	60cb      	str	r3, [r1, #12]
 80041d2:	e76e      	b.n	80040b2 <HAL_RCCEx_PeriphCLKConfig+0x112>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80041d4:	68cb      	ldr	r3, [r1, #12]
 80041d6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80041da:	60cb      	str	r3, [r1, #12]
 80041dc:	e78f      	b.n	80040fe <HAL_RCCEx_PeriphCLKConfig+0x15e>
 80041de:	bf00      	nop
 80041e0:	58000400 	.word	0x58000400

080041e4 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 80041e4:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 80041e6:	f890 202c 	ldrb.w	r2, [r0, #44]	@ 0x2c
 80041ea:	2a01      	cmp	r2, #1
 80041ec:	d035      	beq.n	800425a <HAL_RTC_DeactivateAlarm+0x76>
 80041ee:	2201      	movs	r2, #1
 80041f0:	f880 202c 	strb.w	r2, [r0, #44]	@ 0x2c

  hrtc->State = HAL_RTC_STATE_BUSY;
 80041f4:	2202      	movs	r2, #2
 80041f6:	f880 202d 	strb.w	r2, [r0, #45]	@ 0x2d

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80041fa:	4a19      	ldr	r2, [pc, #100]	@ (8004260 <HAL_RTC_DeactivateAlarm+0x7c>)
 80041fc:	20ca      	movs	r0, #202	@ 0xca
 80041fe:	6250      	str	r0, [r2, #36]	@ 0x24
 8004200:	2053      	movs	r0, #83	@ 0x53
 8004202:	6250      	str	r0, [r2, #36]	@ 0x24

  if (Alarm == RTC_ALARM_A)
 8004204:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 8004208:	d018      	beq.n	800423c <HAL_RTC_DeactivateAlarm+0x58>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
  }
  else
  {
    /* AlarmB, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 800420a:	4a15      	ldr	r2, [pc, #84]	@ (8004260 <HAL_RTC_DeactivateAlarm+0x7c>)
 800420c:	6991      	ldr	r1, [r2, #24]
 800420e:	f421 5108 	bic.w	r1, r1, #8704	@ 0x2200
 8004212:	6191      	str	r1, [r2, #24]

    /* AlarmB, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8004214:	6cd1      	ldr	r1, [r2, #76]	@ 0x4c
 8004216:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 800421a:	64d1      	str	r1, [r2, #76]	@ 0x4c

    /* Store in the handle the Alarm B disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 800421c:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 800421e:	f021 0102 	bic.w	r1, r1, #2
 8004222:	6319      	str	r1, [r3, #48]	@ 0x30

    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8004224:	2102      	movs	r1, #2
 8004226:	65d1      	str	r1, [r2, #92]	@ 0x5c
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004228:	4a0d      	ldr	r2, [pc, #52]	@ (8004260 <HAL_RTC_DeactivateAlarm+0x7c>)
 800422a:	21ff      	movs	r1, #255	@ 0xff
 800422c:	6251      	str	r1, [r2, #36]	@ 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 800422e:	2201      	movs	r2, #1
 8004230:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8004234:	2000      	movs	r0, #0
 8004236:	f883 002c 	strb.w	r0, [r3, #44]	@ 0x2c

  return HAL_OK;
 800423a:	4770      	bx	lr
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 800423c:	6991      	ldr	r1, [r2, #24]
 800423e:	f421 5188 	bic.w	r1, r1, #4352	@ 0x1100
 8004242:	6191      	str	r1, [r2, #24]
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8004244:	6c51      	ldr	r1, [r2, #68]	@ 0x44
 8004246:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 800424a:	6451      	str	r1, [r2, #68]	@ 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 800424c:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 800424e:	f021 0101 	bic.w	r1, r1, #1
 8004252:	6319      	str	r1, [r3, #48]	@ 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8004254:	2101      	movs	r1, #1
 8004256:	65d1      	str	r1, [r2, #92]	@ 0x5c
 8004258:	e7e6      	b.n	8004228 <HAL_RTC_DeactivateAlarm+0x44>
  __HAL_LOCK(hrtc);
 800425a:	2002      	movs	r0, #2
}
 800425c:	4770      	bx	lr
 800425e:	bf00      	nop
 8004260:	40002800 	.word	0x40002800

08004264 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8004264:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 8004266:	e002      	b.n	800426e <RTC_ByteToBcd2+0xa>
  {
    bcdhigh++;
 8004268:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 800426a:	380a      	subs	r0, #10
 800426c:	b2c0      	uxtb	r0, r0
  while (tmp_Value >= 10U)
 800426e:	2809      	cmp	r0, #9
 8004270:	d8fa      	bhi.n	8004268 <RTC_ByteToBcd2+0x4>
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8004272:	011b      	lsls	r3, r3, #4
 8004274:	b2db      	uxtb	r3, r3
}
 8004276:	4318      	orrs	r0, r3
 8004278:	4770      	bx	lr
	...

0800427c <HAL_RTC_SetAlarm_IT>:
  __HAL_LOCK(hrtc);
 800427c:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
 8004280:	2b01      	cmp	r3, #1
 8004282:	f000 80b0 	beq.w	80043e6 <HAL_RTC_SetAlarm_IT+0x16a>
{
 8004286:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800428a:	4605      	mov	r5, r0
 800428c:	460c      	mov	r4, r1
  __HAL_LOCK(hrtc);
 800428e:	2301      	movs	r3, #1
 8004290:	f880 302c 	strb.w	r3, [r0, #44]	@ 0x2c
  hrtc->State = HAL_RTC_STATE_BUSY;
 8004294:	2302      	movs	r3, #2
 8004296:	f880 302d 	strb.w	r3, [r0, #45]	@ 0x2d
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 800429a:	4b54      	ldr	r3, [pc, #336]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 800429c:	68de      	ldr	r6, [r3, #12]
 800429e:	f406 7640 	and.w	r6, r6, #768	@ 0x300
  if (binaryMode != RTC_BINARY_ONLY)
 80042a2:	f5b6 7f80 	cmp.w	r6, #256	@ 0x100
 80042a6:	d043      	beq.n	8004330 <HAL_RTC_SetAlarm_IT+0xb4>
    if (Format == RTC_FORMAT_BIN)
 80042a8:	bb12      	cbnz	r2, 80042f0 <HAL_RTC_SetAlarm_IT+0x74>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 80042aa:	699b      	ldr	r3, [r3, #24]
 80042ac:	f013 0f40 	tst.w	r3, #64	@ 0x40
 80042b0:	d101      	bne.n	80042b6 <HAL_RTC_SetAlarm_IT+0x3a>
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 80042b2:	2300      	movs	r3, #0
 80042b4:	70cb      	strb	r3, [r1, #3]
      if( sAlarm->AlarmMask != RTC_ALARMMASK_DATEWEEKDAY )
 80042b6:	f8d4 8014 	ldr.w	r8, [r4, #20]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80042ba:	7820      	ldrb	r0, [r4, #0]
 80042bc:	f7ff ffd2 	bl	8004264 <RTC_ByteToBcd2>
 80042c0:	0407      	lsls	r7, r0, #16
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80042c2:	7860      	ldrb	r0, [r4, #1]
 80042c4:	f7ff ffce 	bl	8004264 <RTC_ByteToBcd2>
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80042c8:	ea47 2700 	orr.w	r7, r7, r0, lsl #8
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80042cc:	78a0      	ldrb	r0, [r4, #2]
 80042ce:	f7ff ffc9 	bl	8004264 <RTC_ByteToBcd2>
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80042d2:	4307      	orrs	r7, r0
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80042d4:	78e3      	ldrb	r3, [r4, #3]
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80042d6:	ea47 5783 	orr.w	r7, r7, r3, lsl #22
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 80042da:	f894 0024 	ldrb.w	r0, [r4, #36]	@ 0x24
 80042de:	f7ff ffc1 	bl	8004264 <RTC_ByteToBcd2>
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80042e2:	ea47 6000 	orr.w	r0, r7, r0, lsl #24
                ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 80042e6:	6a23      	ldr	r3, [r4, #32]
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 80042e8:	4318      	orrs	r0, r3
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80042ea:	ea48 0000 	orr.w	r0, r8, r0
 80042ee:	e020      	b.n	8004332 <HAL_RTC_SetAlarm_IT+0xb6>
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 80042f0:	6948      	ldr	r0, [r1, #20]
 80042f2:	f1b0 3f80 	cmp.w	r0, #2155905152	@ 0x80808080
 80042f6:	d009      	beq.n	800430c <HAL_RTC_SetAlarm_IT+0x90>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 80042f8:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 80042fc:	d006      	beq.n	800430c <HAL_RTC_SetAlarm_IT+0x90>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 80042fe:	4b3b      	ldr	r3, [pc, #236]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 8004300:	699b      	ldr	r3, [r3, #24]
 8004302:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8004306:	d101      	bne.n	800430c <HAL_RTC_SetAlarm_IT+0x90>
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 8004308:	2300      	movs	r3, #0
 800430a:	70cb      	strb	r3, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 800430c:	7822      	ldrb	r2, [r4, #0]
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 800430e:	7863      	ldrb	r3, [r4, #1]
 8004310:	021b      	lsls	r3, r3, #8
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8004312:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8004316:	78a2      	ldrb	r2, [r4, #2]
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8004318:	4313      	orrs	r3, r2
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 800431a:	78e2      	ldrb	r2, [r4, #3]
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 800431c:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8004320:	f894 2024 	ldrb.w	r2, [r4, #36]	@ 0x24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8004324:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 8004328:	6a22      	ldr	r2, [r4, #32]
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 800432a:	4313      	orrs	r3, r2
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 800432c:	4318      	orrs	r0, r3
 800432e:	e000      	b.n	8004332 <HAL_RTC_SetAlarm_IT+0xb6>
  uint32_t tmpreg = 0;
 8004330:	2000      	movs	r0, #0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004332:	4b2e      	ldr	r3, [pc, #184]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 8004334:	22ca      	movs	r2, #202	@ 0xca
 8004336:	625a      	str	r2, [r3, #36]	@ 0x24
 8004338:	2253      	movs	r2, #83	@ 0x53
 800433a:	625a      	str	r2, [r3, #36]	@ 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 800433c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800433e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004342:	d02a      	beq.n	800439a <HAL_RTC_SetAlarm_IT+0x11e>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8004344:	4b29      	ldr	r3, [pc, #164]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 8004346:	699a      	ldr	r2, [r3, #24]
 8004348:	f422 5208 	bic.w	r2, r2, #8704	@ 0x2200
 800434c:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 800434e:	2202      	movs	r2, #2
 8004350:	65da      	str	r2, [r3, #92]	@ 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 8004352:	f5b6 7f80 	cmp.w	r6, #256	@ 0x100
 8004356:	d040      	beq.n	80043da <HAL_RTC_SetAlarm_IT+0x15e>
      WRITE_REG(RTC->ALRMBR, tmpreg);
 8004358:	4b24      	ldr	r3, [pc, #144]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 800435a:	6498      	str	r0, [r3, #72]	@ 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 800435c:	69a2      	ldr	r2, [r4, #24]
 800435e:	64da      	str	r2, [r3, #76]	@ 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 8004360:	6862      	ldr	r2, [r4, #4]
 8004362:	4b22      	ldr	r3, [pc, #136]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 8004364:	675a      	str	r2, [r3, #116]	@ 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8004366:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 8004368:	f042 0202 	orr.w	r2, r2, #2
 800436c:	632a      	str	r2, [r5, #48]	@ 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 800436e:	699a      	ldr	r2, [r3, #24]
 8004370:	f442 5208 	orr.w	r2, r2, #8704	@ 0x2200
 8004374:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8004376:	4a1e      	ldr	r2, [pc, #120]	@ (80043f0 <HAL_RTC_SetAlarm_IT+0x174>)
 8004378:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
 800437c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004380:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004384:	4b19      	ldr	r3, [pc, #100]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 8004386:	22ff      	movs	r2, #255	@ 0xff
 8004388:	625a      	str	r2, [r3, #36]	@ 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 800438a:	2301      	movs	r3, #1
 800438c:	f885 302d 	strb.w	r3, [r5, #45]	@ 0x2d
  __HAL_UNLOCK(hrtc);
 8004390:	2000      	movs	r0, #0
 8004392:	f885 002c 	strb.w	r0, [r5, #44]	@ 0x2c
}
 8004396:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 800439a:	4b14      	ldr	r3, [pc, #80]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 800439c:	699a      	ldr	r2, [r3, #24]
 800439e:	f422 5288 	bic.w	r2, r2, #4352	@ 0x1100
 80043a2:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 80043a4:	2201      	movs	r2, #1
 80043a6:	65da      	str	r2, [r3, #92]	@ 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 80043a8:	f5b6 7f80 	cmp.w	r6, #256	@ 0x100
 80043ac:	d00f      	beq.n	80043ce <HAL_RTC_SetAlarm_IT+0x152>
      WRITE_REG(RTC->ALRMAR, tmpreg);
 80043ae:	4b0f      	ldr	r3, [pc, #60]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 80043b0:	6418      	str	r0, [r3, #64]	@ 0x40
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 80043b2:	69a2      	ldr	r2, [r4, #24]
 80043b4:	645a      	str	r2, [r3, #68]	@ 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 80043b6:	6862      	ldr	r2, [r4, #4]
 80043b8:	4b0c      	ldr	r3, [pc, #48]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 80043ba:	671a      	str	r2, [r3, #112]	@ 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 80043bc:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 80043be:	f042 0201 	orr.w	r2, r2, #1
 80043c2:	632a      	str	r2, [r5, #48]	@ 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 80043c4:	699a      	ldr	r2, [r3, #24]
 80043c6:	f442 5288 	orr.w	r2, r2, #4352	@ 0x1100
 80043ca:	619a      	str	r2, [r3, #24]
 80043cc:	e7d3      	b.n	8004376 <HAL_RTC_SetAlarm_IT+0xfa>
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 80043ce:	69a3      	ldr	r3, [r4, #24]
 80043d0:	69e2      	ldr	r2, [r4, #28]
 80043d2:	4313      	orrs	r3, r2
 80043d4:	4a05      	ldr	r2, [pc, #20]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 80043d6:	6453      	str	r3, [r2, #68]	@ 0x44
 80043d8:	e7ed      	b.n	80043b6 <HAL_RTC_SetAlarm_IT+0x13a>
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 80043da:	69a3      	ldr	r3, [r4, #24]
 80043dc:	69e2      	ldr	r2, [r4, #28]
 80043de:	4313      	orrs	r3, r2
 80043e0:	4a02      	ldr	r2, [pc, #8]	@ (80043ec <HAL_RTC_SetAlarm_IT+0x170>)
 80043e2:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80043e4:	e7bc      	b.n	8004360 <HAL_RTC_SetAlarm_IT+0xe4>
  __HAL_LOCK(hrtc);
 80043e6:	2002      	movs	r0, #2
}
 80043e8:	4770      	bx	lr
 80043ea:	bf00      	nop
 80043ec:	40002800 	.word	0x40002800
 80043f0:	58000800 	.word	0x58000800

080043f4 <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 80043f4:	0089      	lsls	r1, r1, #2
 80043f6:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 80043fa:	f501 4131 	add.w	r1, r1, #45312	@ 0xb100

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 80043fe:	600a      	str	r2, [r1, #0]
}
 8004400:	4770      	bx	lr

08004402 <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8004402:	0089      	lsls	r1, r1, #2
 8004404:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 8004408:	f501 4131 	add.w	r1, r1, #45312	@ 0xb100

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 800440c:	6808      	ldr	r0, [r1, #0]
}
 800440e:	4770      	bx	lr

08004410 <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 8004410:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004412:	e852 3f00 	ldrex	r3, [r2]
 8004416:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800441a:	e842 3100 	strex	r1, r3, [r2]
 800441e:	2900      	cmp	r1, #0
 8004420:	d1f6      	bne.n	8004410 <UART_EndTxTransfer>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 8004422:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004424:	f102 0308 	add.w	r3, r2, #8
 8004428:	e853 3f00 	ldrex	r3, [r3]
 800442c:	f423 0300 	bic.w	r3, r3, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004430:	3208      	adds	r2, #8
 8004432:	e842 3100 	strex	r1, r3, [r2]
 8004436:	2900      	cmp	r1, #0
 8004438:	d1f3      	bne.n	8004422 <UART_EndTxTransfer+0x12>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800443a:	2320      	movs	r3, #32
 800443c:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
}
 8004440:	4770      	bx	lr

08004442 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8004442:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004444:	e852 3f00 	ldrex	r3, [r2]
 8004448:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800444c:	e842 3100 	strex	r1, r3, [r2]
 8004450:	2900      	cmp	r1, #0
 8004452:	d1f6      	bne.n	8004442 <UART_EndRxTransfer>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8004454:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004456:	f102 0308 	add.w	r3, r2, #8
 800445a:	e853 3f00 	ldrex	r3, [r3]
 800445e:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8004462:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004466:	3208      	adds	r2, #8
 8004468:	e842 3100 	strex	r1, r3, [r2]
 800446c:	2900      	cmp	r1, #0
 800446e:	d1f1      	bne.n	8004454 <UART_EndRxTransfer+0x12>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004470:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 8004472:	2b01      	cmp	r3, #1
 8004474:	d006      	beq.n	8004484 <UART_EndRxTransfer+0x42>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8004476:	2320      	movs	r3, #32
 8004478:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800447c:	2300      	movs	r3, #0
 800447e:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8004480:	6743      	str	r3, [r0, #116]	@ 0x74
}
 8004482:	4770      	bx	lr
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004484:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004486:	e852 3f00 	ldrex	r3, [r2]
 800448a:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800448e:	e842 3100 	strex	r1, r3, [r2]
 8004492:	2900      	cmp	r1, #0
 8004494:	d1f6      	bne.n	8004484 <UART_EndRxTransfer+0x42>
 8004496:	e7ee      	b.n	8004476 <UART_EndRxTransfer+0x34>

08004498 <HAL_UART_Transmit_DMA>:
{
 8004498:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
 800449a:	f8d0 2088 	ldr.w	r2, [r0, #136]	@ 0x88
 800449e:	2a20      	cmp	r2, #32
 80044a0:	d13d      	bne.n	800451e <HAL_UART_Transmit_DMA+0x86>
{
 80044a2:	b510      	push	{r4, lr}
 80044a4:	4604      	mov	r4, r0
    if ((pData == NULL) || (Size == 0U))
 80044a6:	2900      	cmp	r1, #0
 80044a8:	d03b      	beq.n	8004522 <HAL_UART_Transmit_DMA+0x8a>
 80044aa:	2b00      	cmp	r3, #0
 80044ac:	d03b      	beq.n	8004526 <HAL_UART_Transmit_DMA+0x8e>
    huart->pTxBuffPtr  = pData;
 80044ae:	6501      	str	r1, [r0, #80]	@ 0x50
    huart->TxXferSize  = Size;
 80044b0:	f8a0 3054 	strh.w	r3, [r0, #84]	@ 0x54
    huart->TxXferCount = Size;
 80044b4:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80044b8:	2200      	movs	r2, #0
 80044ba:	f8c0 2090 	str.w	r2, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80044be:	2221      	movs	r2, #33	@ 0x21
 80044c0:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
    if (huart->hdmatx != NULL)
 80044c4:	6fc2      	ldr	r2, [r0, #124]	@ 0x7c
 80044c6:	b1ca      	cbz	r2, 80044fc <HAL_UART_Transmit_DMA+0x64>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 80044c8:	4918      	ldr	r1, [pc, #96]	@ (800452c <HAL_UART_Transmit_DMA+0x94>)
 80044ca:	62d1      	str	r1, [r2, #44]	@ 0x2c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 80044cc:	6fc2      	ldr	r2, [r0, #124]	@ 0x7c
 80044ce:	4918      	ldr	r1, [pc, #96]	@ (8004530 <HAL_UART_Transmit_DMA+0x98>)
 80044d0:	6311      	str	r1, [r2, #48]	@ 0x30
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 80044d2:	6fc2      	ldr	r2, [r0, #124]	@ 0x7c
 80044d4:	4917      	ldr	r1, [pc, #92]	@ (8004534 <HAL_UART_Transmit_DMA+0x9c>)
 80044d6:	6351      	str	r1, [r2, #52]	@ 0x34
      huart->hdmatx->XferAbortCallback = NULL;
 80044d8:	6fc2      	ldr	r2, [r0, #124]	@ 0x7c
 80044da:	2100      	movs	r1, #0
 80044dc:	6391      	str	r1, [r2, #56]	@ 0x38
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 80044de:	6802      	ldr	r2, [r0, #0]
 80044e0:	3228      	adds	r2, #40	@ 0x28
 80044e2:	6d01      	ldr	r1, [r0, #80]	@ 0x50
 80044e4:	6fc0      	ldr	r0, [r0, #124]	@ 0x7c
 80044e6:	f7fd ffeb 	bl	80024c0 <HAL_DMA_Start_IT>
 80044ea:	b138      	cbz	r0, 80044fc <HAL_UART_Transmit_DMA+0x64>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 80044ec:	2310      	movs	r3, #16
 80044ee:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        huart->gState = HAL_UART_STATE_READY;
 80044f2:	2320      	movs	r3, #32
 80044f4:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
        return HAL_ERROR;
 80044f8:	2001      	movs	r0, #1
 80044fa:	e00f      	b.n	800451c <HAL_UART_Transmit_DMA+0x84>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 80044fc:	6823      	ldr	r3, [r4, #0]
 80044fe:	2240      	movs	r2, #64	@ 0x40
 8004500:	621a      	str	r2, [r3, #32]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8004502:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004504:	f102 0308 	add.w	r3, r2, #8
 8004508:	e853 3f00 	ldrex	r3, [r3]
 800450c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004510:	3208      	adds	r2, #8
 8004512:	e842 3100 	strex	r1, r3, [r2]
 8004516:	2900      	cmp	r1, #0
 8004518:	d1f3      	bne.n	8004502 <HAL_UART_Transmit_DMA+0x6a>
    return HAL_OK;
 800451a:	2000      	movs	r0, #0
}
 800451c:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
 800451e:	2002      	movs	r0, #2
}
 8004520:	4770      	bx	lr
      return HAL_ERROR;
 8004522:	2001      	movs	r0, #1
 8004524:	e7fa      	b.n	800451c <HAL_UART_Transmit_DMA+0x84>
 8004526:	2001      	movs	r0, #1
 8004528:	e7f8      	b.n	800451c <HAL_UART_Transmit_DMA+0x84>
 800452a:	bf00      	nop
 800452c:	08004539 	.word	0x08004539
 8004530:	080045a7 	.word	0x080045a7
 8004534:	080045b3 	.word	0x080045b3

08004538 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 8004538:	b508      	push	{r3, lr}
 800453a:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800453c:	6a80      	ldr	r0, [r0, #40]	@ 0x28

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 800453e:	681b      	ldr	r3, [r3, #0]
 8004540:	681b      	ldr	r3, [r3, #0]
 8004542:	f013 0f20 	tst.w	r3, #32
 8004546:	d118      	bne.n	800457a <UART_DMATransmitCplt+0x42>
  {
    huart->TxXferCount = 0U;
 8004548:	2300      	movs	r3, #0
 800454a:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800454e:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004550:	f102 0308 	add.w	r3, r2, #8
 8004554:	e853 3f00 	ldrex	r3, [r3]
 8004558:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800455c:	3208      	adds	r2, #8
 800455e:	e842 3100 	strex	r1, r3, [r2]
 8004562:	2900      	cmp	r1, #0
 8004564:	d1f3      	bne.n	800454e <UART_DMATransmitCplt+0x16>

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8004566:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004568:	e852 3f00 	ldrex	r3, [r2]
 800456c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004570:	e842 3100 	strex	r1, r3, [r2]
 8004574:	2900      	cmp	r1, #0
 8004576:	d1f6      	bne.n	8004566 <UART_DMATransmitCplt+0x2e>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 8004578:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 800457a:	f7fc fd03 	bl	8000f84 <HAL_UART_TxCpltCallback>
}
 800457e:	e7fb      	b.n	8004578 <UART_DMATransmitCplt+0x40>

08004580 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 8004580:	b508      	push	{r3, lr}
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8004582:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004584:	e852 3f00 	ldrex	r3, [r2]
 8004588:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800458c:	e842 3100 	strex	r1, r3, [r2]
 8004590:	2900      	cmp	r1, #0
 8004592:	d1f6      	bne.n	8004582 <UART_EndTransmit_IT+0x2>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8004594:	2320      	movs	r3, #32
 8004596:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 800459a:	2300      	movs	r3, #0
 800459c:	6783      	str	r3, [r0, #120]	@ 0x78
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800459e:	f7fc fcf1 	bl	8000f84 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80045a2:	bd08      	pop	{r3, pc}

080045a4 <HAL_UART_TxHalfCpltCallback>:
}
 80045a4:	4770      	bx	lr

080045a6 <UART_DMATxHalfCplt>:
{
 80045a6:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
 80045a8:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 80045aa:	f7ff fffb 	bl	80045a4 <HAL_UART_TxHalfCpltCallback>
}
 80045ae:	bd08      	pop	{r3, pc}

080045b0 <HAL_UART_ErrorCallback>:
}
 80045b0:	4770      	bx	lr

080045b2 <UART_DMAError>:
{
 80045b2:	b538      	push	{r3, r4, r5, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80045b4:	6a84      	ldr	r4, [r0, #40]	@ 0x28
  const HAL_UART_StateTypeDef gstate = huart->gState;
 80045b6:	f8d4 2088 	ldr.w	r2, [r4, #136]	@ 0x88
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 80045ba:	f8d4 508c 	ldr.w	r5, [r4, #140]	@ 0x8c
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 80045be:	6823      	ldr	r3, [r4, #0]
 80045c0:	689b      	ldr	r3, [r3, #8]
 80045c2:	f013 0f80 	tst.w	r3, #128	@ 0x80
 80045c6:	d001      	beq.n	80045cc <UART_DMAError+0x1a>
 80045c8:	2a21      	cmp	r2, #33	@ 0x21
 80045ca:	d010      	beq.n	80045ee <UART_DMAError+0x3c>
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 80045cc:	6823      	ldr	r3, [r4, #0]
 80045ce:	689b      	ldr	r3, [r3, #8]
 80045d0:	f013 0f40 	tst.w	r3, #64	@ 0x40
 80045d4:	d001      	beq.n	80045da <UART_DMAError+0x28>
 80045d6:	2d22      	cmp	r5, #34	@ 0x22
 80045d8:	d010      	beq.n	80045fc <UART_DMAError+0x4a>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 80045da:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 80045de:	f043 0310 	orr.w	r3, r3, #16
 80045e2:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
  HAL_UART_ErrorCallback(huart);
 80045e6:	4620      	mov	r0, r4
 80045e8:	f7ff ffe2 	bl	80045b0 <HAL_UART_ErrorCallback>
}
 80045ec:	bd38      	pop	{r3, r4, r5, pc}
    huart->TxXferCount = 0U;
 80045ee:	2300      	movs	r3, #0
 80045f0:	f8a4 3056 	strh.w	r3, [r4, #86]	@ 0x56
    UART_EndTxTransfer(huart);
 80045f4:	4620      	mov	r0, r4
 80045f6:	f7ff ff0b 	bl	8004410 <UART_EndTxTransfer>
 80045fa:	e7e7      	b.n	80045cc <UART_DMAError+0x1a>
    huart->RxXferCount = 0U;
 80045fc:	2300      	movs	r3, #0
 80045fe:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
    UART_EndRxTransfer(huart);
 8004602:	4620      	mov	r0, r4
 8004604:	f7ff ff1d 	bl	8004442 <UART_EndRxTransfer>
 8004608:	e7e7      	b.n	80045da <UART_DMAError+0x28>

0800460a <UART_DMAAbortOnError>:
{
 800460a:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800460c:	6a80      	ldr	r0, [r0, #40]	@ 0x28
  huart->RxXferCount = 0U;
 800460e:	2300      	movs	r3, #0
 8004610:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
  huart->TxXferCount = 0U;
 8004614:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
  HAL_UART_ErrorCallback(huart);
 8004618:	f7ff ffca 	bl	80045b0 <HAL_UART_ErrorCallback>
}
 800461c:	bd08      	pop	{r3, pc}

0800461e <HAL_UARTEx_RxEventCallback>:
}
 800461e:	4770      	bx	lr

08004620 <HAL_UART_IRQHandler>:
{
 8004620:	b570      	push	{r4, r5, r6, lr}
 8004622:	4604      	mov	r4, r0
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8004624:	6802      	ldr	r2, [r0, #0]
 8004626:	69d3      	ldr	r3, [r2, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8004628:	6810      	ldr	r0, [r2, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800462a:	6891      	ldr	r1, [r2, #8]
  if (errorflags == 0U)
 800462c:	f640 0c0f 	movw	ip, #2063	@ 0x80f
 8004630:	ea13 0f0c 	tst.w	r3, ip
 8004634:	d10d      	bne.n	8004652 <HAL_UART_IRQHandler+0x32>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8004636:	f013 0f20 	tst.w	r3, #32
 800463a:	d010      	beq.n	800465e <HAL_UART_IRQHandler+0x3e>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 800463c:	f010 0f20 	tst.w	r0, #32
 8004640:	d102      	bne.n	8004648 <HAL_UART_IRQHandler+0x28>
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8004642:	f011 5f80 	tst.w	r1, #268435456	@ 0x10000000
 8004646:	d00a      	beq.n	800465e <HAL_UART_IRQHandler+0x3e>
      if (huart->RxISR != NULL)
 8004648:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 800464a:	b393      	cbz	r3, 80046b2 <HAL_UART_IRQHandler+0x92>
        huart->RxISR(huart);
 800464c:	4620      	mov	r0, r4
 800464e:	4798      	blx	r3
      return;
 8004650:	e02f      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 8004652:	4db4      	ldr	r5, [pc, #720]	@ (8004924 <HAL_UART_IRQHandler+0x304>)
 8004654:	400d      	ands	r5, r1
 8004656:	d12d      	bne.n	80046b4 <HAL_UART_IRQHandler+0x94>
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 8004658:	4eb3      	ldr	r6, [pc, #716]	@ (8004928 <HAL_UART_IRQHandler+0x308>)
 800465a:	4230      	tst	r0, r6
 800465c:	d12a      	bne.n	80046b4 <HAL_UART_IRQHandler+0x94>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800465e:	6ee5      	ldr	r5, [r4, #108]	@ 0x6c
 8004660:	2d01      	cmp	r5, #1
 8004662:	f000 80c0 	beq.w	80047e6 <HAL_UART_IRQHandler+0x1c6>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8004666:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 800466a:	d003      	beq.n	8004674 <HAL_UART_IRQHandler+0x54>
 800466c:	f411 0f80 	tst.w	r1, #4194304	@ 0x400000
 8004670:	f040 815e 	bne.w	8004930 <HAL_UART_IRQHandler+0x310>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 8004674:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8004678:	d007      	beq.n	800468a <HAL_UART_IRQHandler+0x6a>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 800467a:	f010 0f80 	tst.w	r0, #128	@ 0x80
 800467e:	f040 815e 	bne.w	800493e <HAL_UART_IRQHandler+0x31e>
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 8004682:	f411 0f00 	tst.w	r1, #8388608	@ 0x800000
 8004686:	f040 815a 	bne.w	800493e <HAL_UART_IRQHandler+0x31e>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800468a:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800468e:	d003      	beq.n	8004698 <HAL_UART_IRQHandler+0x78>
 8004690:	f010 0f40 	tst.w	r0, #64	@ 0x40
 8004694:	f040 815a 	bne.w	800494c <HAL_UART_IRQHandler+0x32c>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 8004698:	f413 0f00 	tst.w	r3, #8388608	@ 0x800000
 800469c:	d003      	beq.n	80046a6 <HAL_UART_IRQHandler+0x86>
 800469e:	f010 4f80 	tst.w	r0, #1073741824	@ 0x40000000
 80046a2:	f040 8157 	bne.w	8004954 <HAL_UART_IRQHandler+0x334>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 80046a6:	f013 7f80 	tst.w	r3, #16777216	@ 0x1000000
 80046aa:	d002      	beq.n	80046b2 <HAL_UART_IRQHandler+0x92>
 80046ac:	2800      	cmp	r0, #0
 80046ae:	f2c0 8155 	blt.w	800495c <HAL_UART_IRQHandler+0x33c>
}
 80046b2:	bd70      	pop	{r4, r5, r6, pc}
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80046b4:	f013 0f01 	tst.w	r3, #1
 80046b8:	d009      	beq.n	80046ce <HAL_UART_IRQHandler+0xae>
 80046ba:	f410 7f80 	tst.w	r0, #256	@ 0x100
 80046be:	d006      	beq.n	80046ce <HAL_UART_IRQHandler+0xae>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80046c0:	2601      	movs	r6, #1
 80046c2:	6216      	str	r6, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80046c4:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 80046c8:	4332      	orrs	r2, r6
 80046ca:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80046ce:	f013 0f02 	tst.w	r3, #2
 80046d2:	d00b      	beq.n	80046ec <HAL_UART_IRQHandler+0xcc>
 80046d4:	f011 0f01 	tst.w	r1, #1
 80046d8:	d008      	beq.n	80046ec <HAL_UART_IRQHandler+0xcc>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80046da:	6822      	ldr	r2, [r4, #0]
 80046dc:	2602      	movs	r6, #2
 80046de:	6216      	str	r6, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80046e0:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 80046e4:	f042 0204 	orr.w	r2, r2, #4
 80046e8:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80046ec:	f013 0f04 	tst.w	r3, #4
 80046f0:	d00b      	beq.n	800470a <HAL_UART_IRQHandler+0xea>
 80046f2:	f011 0f01 	tst.w	r1, #1
 80046f6:	d008      	beq.n	800470a <HAL_UART_IRQHandler+0xea>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80046f8:	6822      	ldr	r2, [r4, #0]
 80046fa:	2604      	movs	r6, #4
 80046fc:	6216      	str	r6, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80046fe:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 8004702:	f042 0202 	orr.w	r2, r2, #2
 8004706:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_ORE) != 0U)
 800470a:	f013 0f08 	tst.w	r3, #8
 800470e:	d00b      	beq.n	8004728 <HAL_UART_IRQHandler+0x108>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 8004710:	f010 0f20 	tst.w	r0, #32
 8004714:	d100      	bne.n	8004718 <HAL_UART_IRQHandler+0xf8>
 8004716:	b13d      	cbz	r5, 8004728 <HAL_UART_IRQHandler+0x108>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8004718:	6822      	ldr	r2, [r4, #0]
 800471a:	2508      	movs	r5, #8
 800471c:	6215      	str	r5, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800471e:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 8004722:	432a      	orrs	r2, r5
 8004724:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8004728:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 800472c:	d00c      	beq.n	8004748 <HAL_UART_IRQHandler+0x128>
 800472e:	f010 6f80 	tst.w	r0, #67108864	@ 0x4000000
 8004732:	d009      	beq.n	8004748 <HAL_UART_IRQHandler+0x128>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8004734:	6822      	ldr	r2, [r4, #0]
 8004736:	f44f 6500 	mov.w	r5, #2048	@ 0x800
 800473a:	6215      	str	r5, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 800473c:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 8004740:	f042 0220 	orr.w	r2, r2, #32
 8004744:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8004748:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 800474c:	2a00      	cmp	r2, #0
 800474e:	d0b0      	beq.n	80046b2 <HAL_UART_IRQHandler+0x92>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8004750:	f013 0f20 	tst.w	r3, #32
 8004754:	d009      	beq.n	800476a <HAL_UART_IRQHandler+0x14a>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8004756:	f010 0f20 	tst.w	r0, #32
 800475a:	d102      	bne.n	8004762 <HAL_UART_IRQHandler+0x142>
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 800475c:	f011 5f80 	tst.w	r1, #268435456	@ 0x10000000
 8004760:	d003      	beq.n	800476a <HAL_UART_IRQHandler+0x14a>
        if (huart->RxISR != NULL)
 8004762:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 8004764:	b10b      	cbz	r3, 800476a <HAL_UART_IRQHandler+0x14a>
          huart->RxISR(huart);
 8004766:	4620      	mov	r0, r4
 8004768:	4798      	blx	r3
      errorcode = huart->ErrorCode;
 800476a:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800476e:	6823      	ldr	r3, [r4, #0]
 8004770:	689b      	ldr	r3, [r3, #8]
 8004772:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8004776:	d102      	bne.n	800477e <HAL_UART_IRQHandler+0x15e>
 8004778:	f012 0f28 	tst.w	r2, #40	@ 0x28
 800477c:	d02c      	beq.n	80047d8 <HAL_UART_IRQHandler+0x1b8>
        UART_EndRxTransfer(huart);
 800477e:	4620      	mov	r0, r4
 8004780:	f7ff fe5f 	bl	8004442 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004784:	6823      	ldr	r3, [r4, #0]
 8004786:	689b      	ldr	r3, [r3, #8]
 8004788:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800478c:	d020      	beq.n	80047d0 <HAL_UART_IRQHandler+0x1b0>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800478e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004790:	f102 0308 	add.w	r3, r2, #8
 8004794:	e853 3f00 	ldrex	r3, [r3]
 8004798:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800479c:	3208      	adds	r2, #8
 800479e:	e842 3100 	strex	r1, r3, [r2]
 80047a2:	2900      	cmp	r1, #0
 80047a4:	d1f3      	bne.n	800478e <HAL_UART_IRQHandler+0x16e>
          if (huart->hdmarx != NULL)
 80047a6:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 80047aa:	b16b      	cbz	r3, 80047c8 <HAL_UART_IRQHandler+0x1a8>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 80047ac:	4a5f      	ldr	r2, [pc, #380]	@ (800492c <HAL_UART_IRQHandler+0x30c>)
 80047ae:	639a      	str	r2, [r3, #56]	@ 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 80047b0:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 80047b4:	f7fd ff0a 	bl	80025cc <HAL_DMA_Abort_IT>
 80047b8:	2800      	cmp	r0, #0
 80047ba:	f43f af7a 	beq.w	80046b2 <HAL_UART_IRQHandler+0x92>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80047be:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 80047c2:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 80047c4:	4798      	blx	r3
 80047c6:	e774      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
            HAL_UART_ErrorCallback(huart);
 80047c8:	4620      	mov	r0, r4
 80047ca:	f7ff fef1 	bl	80045b0 <HAL_UART_ErrorCallback>
 80047ce:	e770      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
          HAL_UART_ErrorCallback(huart);
 80047d0:	4620      	mov	r0, r4
 80047d2:	f7ff feed 	bl	80045b0 <HAL_UART_ErrorCallback>
 80047d6:	e76c      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
        HAL_UART_ErrorCallback(huart);
 80047d8:	4620      	mov	r0, r4
 80047da:	f7ff fee9 	bl	80045b0 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 80047de:	2300      	movs	r3, #0
 80047e0:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
    return;
 80047e4:	e765      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 80047e6:	f013 0f10 	tst.w	r3, #16
 80047ea:	f43f af3c 	beq.w	8004666 <HAL_UART_IRQHandler+0x46>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 80047ee:	f010 0f10 	tst.w	r0, #16
 80047f2:	f43f af38 	beq.w	8004666 <HAL_UART_IRQHandler+0x46>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80047f6:	2310      	movs	r3, #16
 80047f8:	6213      	str	r3, [r2, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80047fa:	6823      	ldr	r3, [r4, #0]
 80047fc:	689b      	ldr	r3, [r3, #8]
 80047fe:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8004802:	d053      	beq.n	80048ac <HAL_UART_IRQHandler+0x28c>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8004804:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
 8004808:	6813      	ldr	r3, [r2, #0]
 800480a:	685b      	ldr	r3, [r3, #4]
 800480c:	b29b      	uxth	r3, r3
      if ((nb_remaining_rx_data > 0U)
 800480e:	2b00      	cmp	r3, #0
 8004810:	f43f af4f 	beq.w	80046b2 <HAL_UART_IRQHandler+0x92>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8004814:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
 8004818:	4299      	cmp	r1, r3
 800481a:	f67f af4a 	bls.w	80046b2 <HAL_UART_IRQHandler+0x92>
        huart->RxXferCount = nb_remaining_rx_data;
 800481e:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 8004822:	6813      	ldr	r3, [r2, #0]
 8004824:	681b      	ldr	r3, [r3, #0]
 8004826:	f013 0f20 	tst.w	r3, #32
 800482a:	d132      	bne.n	8004892 <HAL_UART_IRQHandler+0x272>
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800482c:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800482e:	e852 3f00 	ldrex	r3, [r2]
 8004832:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004836:	e842 3100 	strex	r1, r3, [r2]
 800483a:	2900      	cmp	r1, #0
 800483c:	d1f6      	bne.n	800482c <HAL_UART_IRQHandler+0x20c>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800483e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004840:	f102 0308 	add.w	r3, r2, #8
 8004844:	e853 3f00 	ldrex	r3, [r3]
 8004848:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800484c:	3208      	adds	r2, #8
 800484e:	e842 3100 	strex	r1, r3, [r2]
 8004852:	2900      	cmp	r1, #0
 8004854:	d1f3      	bne.n	800483e <HAL_UART_IRQHandler+0x21e>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8004856:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004858:	f102 0308 	add.w	r3, r2, #8
 800485c:	e853 3f00 	ldrex	r3, [r3]
 8004860:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004864:	3208      	adds	r2, #8
 8004866:	e842 3100 	strex	r1, r3, [r2]
 800486a:	2900      	cmp	r1, #0
 800486c:	d1f3      	bne.n	8004856 <HAL_UART_IRQHandler+0x236>
          huart->RxState = HAL_UART_STATE_READY;
 800486e:	2320      	movs	r3, #32
 8004870:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004874:	2300      	movs	r3, #0
 8004876:	66e3      	str	r3, [r4, #108]	@ 0x6c
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004878:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800487a:	e852 3f00 	ldrex	r3, [r2]
 800487e:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004882:	e842 3100 	strex	r1, r3, [r2]
 8004886:	2900      	cmp	r1, #0
 8004888:	d1f6      	bne.n	8004878 <HAL_UART_IRQHandler+0x258>
          (void)HAL_DMA_Abort(huart->hdmarx);
 800488a:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 800488e:	f7fd fe63 	bl	8002558 <HAL_DMA_Abort>
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 8004892:	2302      	movs	r3, #2
 8004894:	6723      	str	r3, [r4, #112]	@ 0x70
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8004896:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
 800489a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 800489e:	b29b      	uxth	r3, r3
 80048a0:	1ac9      	subs	r1, r1, r3
 80048a2:	b289      	uxth	r1, r1
 80048a4:	4620      	mov	r0, r4
 80048a6:	f7ff feba 	bl	800461e <HAL_UARTEx_RxEventCallback>
      return;
 80048aa:	e702      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80048ac:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
 80048b0:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 80048b4:	b29b      	uxth	r3, r3
 80048b6:	1ac9      	subs	r1, r1, r3
 80048b8:	b289      	uxth	r1, r1
      if ((huart->RxXferCount > 0U)
 80048ba:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 80048be:	b29b      	uxth	r3, r3
 80048c0:	2b00      	cmp	r3, #0
 80048c2:	f43f aef6 	beq.w	80046b2 <HAL_UART_IRQHandler+0x92>
          && (nb_rx_data > 0U))
 80048c6:	2900      	cmp	r1, #0
 80048c8:	f43f aef3 	beq.w	80046b2 <HAL_UART_IRQHandler+0x92>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80048cc:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80048ce:	e852 3f00 	ldrex	r3, [r2]
 80048d2:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80048d6:	e842 3000 	strex	r0, r3, [r2]
 80048da:	2800      	cmp	r0, #0
 80048dc:	d1f6      	bne.n	80048cc <HAL_UART_IRQHandler+0x2ac>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80048de:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80048e0:	f102 0308 	add.w	r3, r2, #8
 80048e4:	e853 3f00 	ldrex	r3, [r3]
 80048e8:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80048ec:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80048f0:	3208      	adds	r2, #8
 80048f2:	e842 3000 	strex	r0, r3, [r2]
 80048f6:	2800      	cmp	r0, #0
 80048f8:	d1f1      	bne.n	80048de <HAL_UART_IRQHandler+0x2be>
        huart->RxState = HAL_UART_STATE_READY;
 80048fa:	2320      	movs	r3, #32
 80048fc:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004900:	2300      	movs	r3, #0
 8004902:	66e3      	str	r3, [r4, #108]	@ 0x6c
        huart->RxISR = NULL;
 8004904:	6763      	str	r3, [r4, #116]	@ 0x74
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004906:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004908:	e852 3f00 	ldrex	r3, [r2]
 800490c:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004910:	e842 3000 	strex	r0, r3, [r2]
 8004914:	2800      	cmp	r0, #0
 8004916:	d1f6      	bne.n	8004906 <HAL_UART_IRQHandler+0x2e6>
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 8004918:	2302      	movs	r3, #2
 800491a:	6723      	str	r3, [r4, #112]	@ 0x70
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 800491c:	4620      	mov	r0, r4
 800491e:	f7ff fe7e 	bl	800461e <HAL_UARTEx_RxEventCallback>
      return;
 8004922:	e6c6      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
 8004924:	10000001 	.word	0x10000001
 8004928:	04000120 	.word	0x04000120
 800492c:	0800460b 	.word	0x0800460b
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8004930:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8004934:	6213      	str	r3, [r2, #32]
    HAL_UARTEx_WakeupCallback(huart);
 8004936:	4620      	mov	r0, r4
 8004938:	f000 fe64 	bl	8005604 <HAL_UARTEx_WakeupCallback>
    return;
 800493c:	e6b9      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
    if (huart->TxISR != NULL)
 800493e:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 8004940:	2b00      	cmp	r3, #0
 8004942:	f43f aeb6 	beq.w	80046b2 <HAL_UART_IRQHandler+0x92>
      huart->TxISR(huart);
 8004946:	4620      	mov	r0, r4
 8004948:	4798      	blx	r3
    return;
 800494a:	e6b2      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
    UART_EndTransmit_IT(huart);
 800494c:	4620      	mov	r0, r4
 800494e:	f7ff fe17 	bl	8004580 <UART_EndTransmit_IT>
    return;
 8004952:	e6ae      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8004954:	4620      	mov	r0, r4
 8004956:	f000 fe57 	bl	8005608 <HAL_UARTEx_TxFifoEmptyCallback>
    return;
 800495a:	e6aa      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>
    HAL_UARTEx_RxFifoFullCallback(huart);
 800495c:	4620      	mov	r0, r4
 800495e:	f000 fe52 	bl	8005606 <HAL_UARTEx_RxFifoFullCallback>
    return;
 8004962:	e6a6      	b.n	80046b2 <HAL_UART_IRQHandler+0x92>

08004964 <UART_RxISR_8BIT>:
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 8004964:	b508      	push	{r3, lr}
  uint16_t uhMask = huart->Mask;
 8004966:	f8b0 3060 	ldrh.w	r3, [r0, #96]	@ 0x60
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800496a:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
 800496e:	2a22      	cmp	r2, #34	@ 0x22
 8004970:	d005      	beq.n	800497e <UART_RxISR_8BIT+0x1a>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004972:	6802      	ldr	r2, [r0, #0]
 8004974:	6993      	ldr	r3, [r2, #24]
 8004976:	f043 0308 	orr.w	r3, r3, #8
 800497a:	6193      	str	r3, [r2, #24]
  }
}
 800497c:	bd08      	pop	{r3, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800497e:	6802      	ldr	r2, [r0, #0]
 8004980:	6a51      	ldr	r1, [r2, #36]	@ 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8004982:	b2db      	uxtb	r3, r3
 8004984:	6d82      	ldr	r2, [r0, #88]	@ 0x58
 8004986:	400b      	ands	r3, r1
 8004988:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
 800498a:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 800498c:	3301      	adds	r3, #1
 800498e:	6583      	str	r3, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 8004990:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
 8004994:	b29b      	uxth	r3, r3
 8004996:	3b01      	subs	r3, #1
 8004998:	b29b      	uxth	r3, r3
 800499a:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
    if (huart->RxXferCount == 0U)
 800499e:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
 80049a2:	b29b      	uxth	r3, r3
 80049a4:	2b00      	cmp	r3, #0
 80049a6:	d1e9      	bne.n	800497c <UART_RxISR_8BIT+0x18>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80049a8:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80049aa:	e852 3f00 	ldrex	r3, [r2]
 80049ae:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80049b2:	e842 3100 	strex	r1, r3, [r2]
 80049b6:	2900      	cmp	r1, #0
 80049b8:	d1f6      	bne.n	80049a8 <UART_RxISR_8BIT+0x44>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80049ba:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80049bc:	f102 0308 	add.w	r3, r2, #8
 80049c0:	e853 3f00 	ldrex	r3, [r3]
 80049c4:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80049c8:	3208      	adds	r2, #8
 80049ca:	e842 3100 	strex	r1, r3, [r2]
 80049ce:	2900      	cmp	r1, #0
 80049d0:	d1f3      	bne.n	80049ba <UART_RxISR_8BIT+0x56>
      huart->RxState = HAL_UART_STATE_READY;
 80049d2:	2320      	movs	r3, #32
 80049d4:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
      huart->RxISR = NULL;
 80049d8:	2300      	movs	r3, #0
 80049da:	6743      	str	r3, [r0, #116]	@ 0x74
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 80049dc:	6703      	str	r3, [r0, #112]	@ 0x70
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 80049de:	6803      	ldr	r3, [r0, #0]
 80049e0:	4a16      	ldr	r2, [pc, #88]	@ (8004a3c <UART_RxISR_8BIT+0xd8>)
 80049e2:	4293      	cmp	r3, r2
 80049e4:	d00c      	beq.n	8004a00 <UART_RxISR_8BIT+0x9c>
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 80049e6:	685b      	ldr	r3, [r3, #4]
 80049e8:	f413 0f00 	tst.w	r3, #8388608	@ 0x800000
 80049ec:	d008      	beq.n	8004a00 <UART_RxISR_8BIT+0x9c>
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 80049ee:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80049f0:	e852 3f00 	ldrex	r3, [r2]
 80049f4:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80049f8:	e842 3100 	strex	r1, r3, [r2]
 80049fc:	2900      	cmp	r1, #0
 80049fe:	d1f6      	bne.n	80049ee <UART_RxISR_8BIT+0x8a>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004a00:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 8004a02:	2b01      	cmp	r3, #1
 8004a04:	d116      	bne.n	8004a34 <UART_RxISR_8BIT+0xd0>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004a06:	2300      	movs	r3, #0
 8004a08:	66c3      	str	r3, [r0, #108]	@ 0x6c
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004a0a:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004a0c:	e852 3f00 	ldrex	r3, [r2]
 8004a10:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004a14:	e842 3100 	strex	r1, r3, [r2]
 8004a18:	2900      	cmp	r1, #0
 8004a1a:	d1f6      	bne.n	8004a0a <UART_RxISR_8BIT+0xa6>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004a1c:	6803      	ldr	r3, [r0, #0]
 8004a1e:	69da      	ldr	r2, [r3, #28]
 8004a20:	f012 0f10 	tst.w	r2, #16
 8004a24:	d001      	beq.n	8004a2a <UART_RxISR_8BIT+0xc6>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004a26:	2210      	movs	r2, #16
 8004a28:	621a      	str	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004a2a:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
 8004a2e:	f7ff fdf6 	bl	800461e <HAL_UARTEx_RxEventCallback>
 8004a32:	e7a3      	b.n	800497c <UART_RxISR_8BIT+0x18>
        HAL_UART_RxCpltCallback(huart);
 8004a34:	f7fc fab6 	bl	8000fa4 <HAL_UART_RxCpltCallback>
 8004a38:	e7a0      	b.n	800497c <UART_RxISR_8BIT+0x18>
 8004a3a:	bf00      	nop
 8004a3c:	40008000 	.word	0x40008000

08004a40 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 8004a40:	b508      	push	{r3, lr}
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 8004a42:	f8b0 2060 	ldrh.w	r2, [r0, #96]	@ 0x60
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004a46:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
 8004a4a:	2b22      	cmp	r3, #34	@ 0x22
 8004a4c:	d005      	beq.n	8004a5a <UART_RxISR_16BIT+0x1a>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004a4e:	6802      	ldr	r2, [r0, #0]
 8004a50:	6993      	ldr	r3, [r2, #24]
 8004a52:	f043 0308 	orr.w	r3, r3, #8
 8004a56:	6193      	str	r3, [r2, #24]
  }
}
 8004a58:	bd08      	pop	{r3, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8004a5a:	6803      	ldr	r3, [r0, #0]
 8004a5c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 8004a5e:	6d81      	ldr	r1, [r0, #88]	@ 0x58
    *tmp = (uint16_t)(uhdata & uhMask);
 8004a60:	4013      	ands	r3, r2
 8004a62:	800b      	strh	r3, [r1, #0]
    huart->pRxBuffPtr += 2U;
 8004a64:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 8004a66:	3302      	adds	r3, #2
 8004a68:	6583      	str	r3, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 8004a6a:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
 8004a6e:	b29b      	uxth	r3, r3
 8004a70:	3b01      	subs	r3, #1
 8004a72:	b29b      	uxth	r3, r3
 8004a74:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
    if (huart->RxXferCount == 0U)
 8004a78:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
 8004a7c:	b29b      	uxth	r3, r3
 8004a7e:	2b00      	cmp	r3, #0
 8004a80:	d1ea      	bne.n	8004a58 <UART_RxISR_16BIT+0x18>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8004a82:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004a84:	e852 3f00 	ldrex	r3, [r2]
 8004a88:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004a8c:	e842 3100 	strex	r1, r3, [r2]
 8004a90:	2900      	cmp	r1, #0
 8004a92:	d1f6      	bne.n	8004a82 <UART_RxISR_16BIT+0x42>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004a94:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004a96:	f102 0308 	add.w	r3, r2, #8
 8004a9a:	e853 3f00 	ldrex	r3, [r3]
 8004a9e:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004aa2:	3208      	adds	r2, #8
 8004aa4:	e842 3100 	strex	r1, r3, [r2]
 8004aa8:	2900      	cmp	r1, #0
 8004aaa:	d1f3      	bne.n	8004a94 <UART_RxISR_16BIT+0x54>
      huart->RxState = HAL_UART_STATE_READY;
 8004aac:	2320      	movs	r3, #32
 8004aae:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
      huart->RxISR = NULL;
 8004ab2:	2300      	movs	r3, #0
 8004ab4:	6743      	str	r3, [r0, #116]	@ 0x74
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 8004ab6:	6703      	str	r3, [r0, #112]	@ 0x70
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8004ab8:	6803      	ldr	r3, [r0, #0]
 8004aba:	4a16      	ldr	r2, [pc, #88]	@ (8004b14 <UART_RxISR_16BIT+0xd4>)
 8004abc:	4293      	cmp	r3, r2
 8004abe:	d00c      	beq.n	8004ada <UART_RxISR_16BIT+0x9a>
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8004ac0:	685b      	ldr	r3, [r3, #4]
 8004ac2:	f413 0f00 	tst.w	r3, #8388608	@ 0x800000
 8004ac6:	d008      	beq.n	8004ada <UART_RxISR_16BIT+0x9a>
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8004ac8:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004aca:	e852 3f00 	ldrex	r3, [r2]
 8004ace:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004ad2:	e842 3100 	strex	r1, r3, [r2]
 8004ad6:	2900      	cmp	r1, #0
 8004ad8:	d1f6      	bne.n	8004ac8 <UART_RxISR_16BIT+0x88>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004ada:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 8004adc:	2b01      	cmp	r3, #1
 8004ade:	d116      	bne.n	8004b0e <UART_RxISR_16BIT+0xce>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004ae0:	2300      	movs	r3, #0
 8004ae2:	66c3      	str	r3, [r0, #108]	@ 0x6c
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004ae4:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004ae6:	e852 3f00 	ldrex	r3, [r2]
 8004aea:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004aee:	e842 3100 	strex	r1, r3, [r2]
 8004af2:	2900      	cmp	r1, #0
 8004af4:	d1f6      	bne.n	8004ae4 <UART_RxISR_16BIT+0xa4>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004af6:	6803      	ldr	r3, [r0, #0]
 8004af8:	69da      	ldr	r2, [r3, #28]
 8004afa:	f012 0f10 	tst.w	r2, #16
 8004afe:	d001      	beq.n	8004b04 <UART_RxISR_16BIT+0xc4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004b00:	2210      	movs	r2, #16
 8004b02:	621a      	str	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004b04:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
 8004b08:	f7ff fd89 	bl	800461e <HAL_UARTEx_RxEventCallback>
 8004b0c:	e7a4      	b.n	8004a58 <UART_RxISR_16BIT+0x18>
        HAL_UART_RxCpltCallback(huart);
 8004b0e:	f7fc fa49 	bl	8000fa4 <HAL_UART_RxCpltCallback>
 8004b12:	e7a1      	b.n	8004a58 <UART_RxISR_16BIT+0x18>
 8004b14:	40008000 	.word	0x40008000

08004b18 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8004b18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint16_t  uhMask = huart->Mask;
 8004b1c:	f8b0 6060 	ldrh.w	r6, [r0, #96]	@ 0x60
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8004b20:	6803      	ldr	r3, [r0, #0]
 8004b22:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8004b24:	f8d3 9000 	ldr.w	r9, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8004b28:	f8d3 8008 	ldr.w	r8, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004b2c:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
 8004b30:	2a22      	cmp	r2, #34	@ 0x22
 8004b32:	d005      	beq.n	8004b40 <UART_RxISR_8BIT_FIFOEN+0x28>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004b34:	699a      	ldr	r2, [r3, #24]
 8004b36:	f042 0208 	orr.w	r2, r2, #8
 8004b3a:	619a      	str	r2, [r3, #24]
  }
}
 8004b3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004b40:	4604      	mov	r4, r0
    nb_rx_data = huart->NbRxDataToProcess;
 8004b42:	f8b0 7068 	ldrh.w	r7, [r0, #104]	@ 0x68
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8004b46:	e008      	b.n	8004b5a <UART_RxISR_8BIT_FIFOEN+0x42>
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8004b48:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004b4c:	2b00      	cmp	r3, #0
 8004b4e:	d14c      	bne.n	8004bea <UART_RxISR_8BIT_FIFOEN+0xd2>
      if (huart->RxXferCount == 0U)
 8004b50:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8004b54:	b29b      	uxth	r3, r3
 8004b56:	2b00      	cmp	r3, #0
 8004b58:	d04e      	beq.n	8004bf8 <UART_RxISR_8BIT_FIFOEN+0xe0>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8004b5a:	2f00      	cmp	r7, #0
 8004b5c:	f000 809a 	beq.w	8004c94 <UART_RxISR_8BIT_FIFOEN+0x17c>
 8004b60:	f015 0f20 	tst.w	r5, #32
 8004b64:	f000 8096 	beq.w	8004c94 <UART_RxISR_8BIT_FIFOEN+0x17c>
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8004b68:	6823      	ldr	r3, [r4, #0]
 8004b6a:	6a59      	ldr	r1, [r3, #36]	@ 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8004b6c:	b2f3      	uxtb	r3, r6
 8004b6e:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 8004b70:	400b      	ands	r3, r1
 8004b72:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 8004b74:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004b76:	3301      	adds	r3, #1
 8004b78:	65a3      	str	r3, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 8004b7a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8004b7e:	b29b      	uxth	r3, r3
 8004b80:	3b01      	subs	r3, #1
 8004b82:	b29b      	uxth	r3, r3
 8004b84:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 8004b88:	6823      	ldr	r3, [r4, #0]
 8004b8a:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 8004b8c:	f015 0f07 	tst.w	r5, #7
 8004b90:	d0de      	beq.n	8004b50 <UART_RxISR_8BIT_FIFOEN+0x38>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8004b92:	f015 0f01 	tst.w	r5, #1
 8004b96:	d009      	beq.n	8004bac <UART_RxISR_8BIT_FIFOEN+0x94>
 8004b98:	f419 7f80 	tst.w	r9, #256	@ 0x100
 8004b9c:	d006      	beq.n	8004bac <UART_RxISR_8BIT_FIFOEN+0x94>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8004b9e:	2201      	movs	r2, #1
 8004ba0:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 8004ba2:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004ba6:	4313      	orrs	r3, r2
 8004ba8:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8004bac:	f015 0f02 	tst.w	r5, #2
 8004bb0:	d00b      	beq.n	8004bca <UART_RxISR_8BIT_FIFOEN+0xb2>
 8004bb2:	f018 0f01 	tst.w	r8, #1
 8004bb6:	d008      	beq.n	8004bca <UART_RxISR_8BIT_FIFOEN+0xb2>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8004bb8:	6823      	ldr	r3, [r4, #0]
 8004bba:	2202      	movs	r2, #2
 8004bbc:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8004bbe:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004bc2:	f043 0304 	orr.w	r3, r3, #4
 8004bc6:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8004bca:	f015 0f04 	tst.w	r5, #4
 8004bce:	d0bb      	beq.n	8004b48 <UART_RxISR_8BIT_FIFOEN+0x30>
 8004bd0:	f018 0f01 	tst.w	r8, #1
 8004bd4:	d0b8      	beq.n	8004b48 <UART_RxISR_8BIT_FIFOEN+0x30>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8004bd6:	6823      	ldr	r3, [r4, #0]
 8004bd8:	2204      	movs	r2, #4
 8004bda:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8004bdc:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004be0:	f043 0302 	orr.w	r3, r3, #2
 8004be4:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
 8004be8:	e7ae      	b.n	8004b48 <UART_RxISR_8BIT_FIFOEN+0x30>
          HAL_UART_ErrorCallback(huart);
 8004bea:	4620      	mov	r0, r4
 8004bec:	f7ff fce0 	bl	80045b0 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004bf0:	2300      	movs	r3, #0
 8004bf2:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
 8004bf6:	e7ab      	b.n	8004b50 <UART_RxISR_8BIT_FIFOEN+0x38>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8004bf8:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004bfa:	e852 3f00 	ldrex	r3, [r2]
 8004bfe:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004c02:	e842 3100 	strex	r1, r3, [r2]
 8004c06:	2900      	cmp	r1, #0
 8004c08:	d1f6      	bne.n	8004bf8 <UART_RxISR_8BIT_FIFOEN+0xe0>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8004c0a:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004c0c:	f102 0308 	add.w	r3, r2, #8
 8004c10:	e853 3f00 	ldrex	r3, [r3]
 8004c14:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8004c18:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004c1c:	3208      	adds	r2, #8
 8004c1e:	e842 3100 	strex	r1, r3, [r2]
 8004c22:	2900      	cmp	r1, #0
 8004c24:	d1f1      	bne.n	8004c0a <UART_RxISR_8BIT_FIFOEN+0xf2>
        huart->RxState = HAL_UART_STATE_READY;
 8004c26:	2320      	movs	r3, #32
 8004c28:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
        huart->RxISR = NULL;
 8004c2c:	2300      	movs	r3, #0
 8004c2e:	6763      	str	r3, [r4, #116]	@ 0x74
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 8004c30:	6723      	str	r3, [r4, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8004c32:	6823      	ldr	r3, [r4, #0]
 8004c34:	4a29      	ldr	r2, [pc, #164]	@ (8004cdc <UART_RxISR_8BIT_FIFOEN+0x1c4>)
 8004c36:	4293      	cmp	r3, r2
 8004c38:	d003      	beq.n	8004c42 <UART_RxISR_8BIT_FIFOEN+0x12a>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8004c3a:	685b      	ldr	r3, [r3, #4]
 8004c3c:	f413 0f00 	tst.w	r3, #8388608	@ 0x800000
 8004c40:	d106      	bne.n	8004c50 <UART_RxISR_8BIT_FIFOEN+0x138>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004c42:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 8004c44:	2b01      	cmp	r3, #1
 8004c46:	d00d      	beq.n	8004c64 <UART_RxISR_8BIT_FIFOEN+0x14c>
          HAL_UART_RxCpltCallback(huart);
 8004c48:	4620      	mov	r0, r4
 8004c4a:	f7fc f9ab 	bl	8000fa4 <HAL_UART_RxCpltCallback>
 8004c4e:	e784      	b.n	8004b5a <UART_RxISR_8BIT_FIFOEN+0x42>
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8004c50:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004c52:	e852 3f00 	ldrex	r3, [r2]
 8004c56:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004c5a:	e842 3100 	strex	r1, r3, [r2]
 8004c5e:	2900      	cmp	r1, #0
 8004c60:	d1f6      	bne.n	8004c50 <UART_RxISR_8BIT_FIFOEN+0x138>
 8004c62:	e7ee      	b.n	8004c42 <UART_RxISR_8BIT_FIFOEN+0x12a>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004c64:	2300      	movs	r3, #0
 8004c66:	66e3      	str	r3, [r4, #108]	@ 0x6c
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004c68:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004c6a:	e852 3f00 	ldrex	r3, [r2]
 8004c6e:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004c72:	e842 3100 	strex	r1, r3, [r2]
 8004c76:	2900      	cmp	r1, #0
 8004c78:	d1f6      	bne.n	8004c68 <UART_RxISR_8BIT_FIFOEN+0x150>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004c7a:	6823      	ldr	r3, [r4, #0]
 8004c7c:	69da      	ldr	r2, [r3, #28]
 8004c7e:	f012 0f10 	tst.w	r2, #16
 8004c82:	d001      	beq.n	8004c88 <UART_RxISR_8BIT_FIFOEN+0x170>
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004c84:	2210      	movs	r2, #16
 8004c86:	621a      	str	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004c88:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
 8004c8c:	4620      	mov	r0, r4
 8004c8e:	f7ff fcc6 	bl	800461e <HAL_UARTEx_RxEventCallback>
 8004c92:	e762      	b.n	8004b5a <UART_RxISR_8BIT_FIFOEN+0x42>
    rxdatacount = huart->RxXferCount;
 8004c94:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8004c98:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 8004c9a:	2b00      	cmp	r3, #0
 8004c9c:	f43f af4e 	beq.w	8004b3c <UART_RxISR_8BIT_FIFOEN+0x24>
 8004ca0:	f8b4 2068 	ldrh.w	r2, [r4, #104]	@ 0x68
 8004ca4:	429a      	cmp	r2, r3
 8004ca6:	f67f af49 	bls.w	8004b3c <UART_RxISR_8BIT_FIFOEN+0x24>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8004caa:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004cac:	f102 0308 	add.w	r3, r2, #8
 8004cb0:	e853 3f00 	ldrex	r3, [r3]
 8004cb4:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004cb8:	3208      	adds	r2, #8
 8004cba:	e842 3100 	strex	r1, r3, [r2]
 8004cbe:	2900      	cmp	r1, #0
 8004cc0:	d1f3      	bne.n	8004caa <UART_RxISR_8BIT_FIFOEN+0x192>
      huart->RxISR = UART_RxISR_8BIT;
 8004cc2:	4b07      	ldr	r3, [pc, #28]	@ (8004ce0 <UART_RxISR_8BIT_FIFOEN+0x1c8>)
 8004cc4:	6763      	str	r3, [r4, #116]	@ 0x74
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8004cc6:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004cc8:	e852 3f00 	ldrex	r3, [r2]
 8004ccc:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004cd0:	e842 3100 	strex	r1, r3, [r2]
 8004cd4:	2900      	cmp	r1, #0
 8004cd6:	d1f6      	bne.n	8004cc6 <UART_RxISR_8BIT_FIFOEN+0x1ae>
 8004cd8:	e730      	b.n	8004b3c <UART_RxISR_8BIT_FIFOEN+0x24>
 8004cda:	bf00      	nop
 8004cdc:	40008000 	.word	0x40008000
 8004ce0:	08004965 	.word	0x08004965

08004ce4 <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8004ce4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
 8004ce8:	f8b0 6060 	ldrh.w	r6, [r0, #96]	@ 0x60
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8004cec:	6803      	ldr	r3, [r0, #0]
 8004cee:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8004cf0:	f8d3 9000 	ldr.w	r9, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8004cf4:	f8d3 8008 	ldr.w	r8, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004cf8:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
 8004cfc:	2a22      	cmp	r2, #34	@ 0x22
 8004cfe:	d005      	beq.n	8004d0c <UART_RxISR_16BIT_FIFOEN+0x28>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004d00:	699a      	ldr	r2, [r3, #24]
 8004d02:	f042 0208 	orr.w	r2, r2, #8
 8004d06:	619a      	str	r2, [r3, #24]
  }
}
 8004d08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004d0c:	4604      	mov	r4, r0
    nb_rx_data = huart->NbRxDataToProcess;
 8004d0e:	f8b0 7068 	ldrh.w	r7, [r0, #104]	@ 0x68
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8004d12:	e008      	b.n	8004d26 <UART_RxISR_16BIT_FIFOEN+0x42>
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8004d14:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004d18:	2b00      	cmp	r3, #0
 8004d1a:	d14b      	bne.n	8004db4 <UART_RxISR_16BIT_FIFOEN+0xd0>
      if (huart->RxXferCount == 0U)
 8004d1c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8004d20:	b29b      	uxth	r3, r3
 8004d22:	2b00      	cmp	r3, #0
 8004d24:	d04d      	beq.n	8004dc2 <UART_RxISR_16BIT_FIFOEN+0xde>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8004d26:	2f00      	cmp	r7, #0
 8004d28:	f000 8099 	beq.w	8004e5e <UART_RxISR_16BIT_FIFOEN+0x17a>
 8004d2c:	f015 0f20 	tst.w	r5, #32
 8004d30:	f000 8095 	beq.w	8004e5e <UART_RxISR_16BIT_FIFOEN+0x17a>
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8004d34:	6823      	ldr	r3, [r4, #0]
 8004d36:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      tmp = (uint16_t *) huart->pRxBuffPtr ;
 8004d38:	6da2      	ldr	r2, [r4, #88]	@ 0x58
      *tmp = (uint16_t)(uhdata & uhMask);
 8004d3a:	4033      	ands	r3, r6
 8004d3c:	8013      	strh	r3, [r2, #0]
      huart->pRxBuffPtr += 2U;
 8004d3e:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004d40:	3302      	adds	r3, #2
 8004d42:	65a3      	str	r3, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 8004d44:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8004d48:	b29b      	uxth	r3, r3
 8004d4a:	3b01      	subs	r3, #1
 8004d4c:	b29b      	uxth	r3, r3
 8004d4e:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 8004d52:	6823      	ldr	r3, [r4, #0]
 8004d54:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 8004d56:	f015 0f07 	tst.w	r5, #7
 8004d5a:	d0df      	beq.n	8004d1c <UART_RxISR_16BIT_FIFOEN+0x38>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8004d5c:	f015 0f01 	tst.w	r5, #1
 8004d60:	d009      	beq.n	8004d76 <UART_RxISR_16BIT_FIFOEN+0x92>
 8004d62:	f419 7f80 	tst.w	r9, #256	@ 0x100
 8004d66:	d006      	beq.n	8004d76 <UART_RxISR_16BIT_FIFOEN+0x92>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8004d68:	2201      	movs	r2, #1
 8004d6a:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 8004d6c:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004d70:	4313      	orrs	r3, r2
 8004d72:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8004d76:	f015 0f02 	tst.w	r5, #2
 8004d7a:	d00b      	beq.n	8004d94 <UART_RxISR_16BIT_FIFOEN+0xb0>
 8004d7c:	f018 0f01 	tst.w	r8, #1
 8004d80:	d008      	beq.n	8004d94 <UART_RxISR_16BIT_FIFOEN+0xb0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8004d82:	6823      	ldr	r3, [r4, #0]
 8004d84:	2202      	movs	r2, #2
 8004d86:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8004d88:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004d8c:	f043 0304 	orr.w	r3, r3, #4
 8004d90:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8004d94:	f015 0f04 	tst.w	r5, #4
 8004d98:	d0bc      	beq.n	8004d14 <UART_RxISR_16BIT_FIFOEN+0x30>
 8004d9a:	f018 0f01 	tst.w	r8, #1
 8004d9e:	d0b9      	beq.n	8004d14 <UART_RxISR_16BIT_FIFOEN+0x30>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8004da0:	6823      	ldr	r3, [r4, #0]
 8004da2:	2204      	movs	r2, #4
 8004da4:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8004da6:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8004daa:	f043 0302 	orr.w	r3, r3, #2
 8004dae:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
 8004db2:	e7af      	b.n	8004d14 <UART_RxISR_16BIT_FIFOEN+0x30>
          HAL_UART_ErrorCallback(huart);
 8004db4:	4620      	mov	r0, r4
 8004db6:	f7ff fbfb 	bl	80045b0 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004dba:	2300      	movs	r3, #0
 8004dbc:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
 8004dc0:	e7ac      	b.n	8004d1c <UART_RxISR_16BIT_FIFOEN+0x38>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8004dc2:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004dc4:	e852 3f00 	ldrex	r3, [r2]
 8004dc8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004dcc:	e842 3100 	strex	r1, r3, [r2]
 8004dd0:	2900      	cmp	r1, #0
 8004dd2:	d1f6      	bne.n	8004dc2 <UART_RxISR_16BIT_FIFOEN+0xde>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8004dd4:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004dd6:	f102 0308 	add.w	r3, r2, #8
 8004dda:	e853 3f00 	ldrex	r3, [r3]
 8004dde:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8004de2:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004de6:	3208      	adds	r2, #8
 8004de8:	e842 3100 	strex	r1, r3, [r2]
 8004dec:	2900      	cmp	r1, #0
 8004dee:	d1f1      	bne.n	8004dd4 <UART_RxISR_16BIT_FIFOEN+0xf0>
        huart->RxState = HAL_UART_STATE_READY;
 8004df0:	2320      	movs	r3, #32
 8004df2:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
        huart->RxISR = NULL;
 8004df6:	2300      	movs	r3, #0
 8004df8:	6763      	str	r3, [r4, #116]	@ 0x74
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 8004dfa:	6723      	str	r3, [r4, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8004dfc:	6823      	ldr	r3, [r4, #0]
 8004dfe:	4a29      	ldr	r2, [pc, #164]	@ (8004ea4 <UART_RxISR_16BIT_FIFOEN+0x1c0>)
 8004e00:	4293      	cmp	r3, r2
 8004e02:	d003      	beq.n	8004e0c <UART_RxISR_16BIT_FIFOEN+0x128>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8004e04:	685b      	ldr	r3, [r3, #4]
 8004e06:	f413 0f00 	tst.w	r3, #8388608	@ 0x800000
 8004e0a:	d106      	bne.n	8004e1a <UART_RxISR_16BIT_FIFOEN+0x136>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004e0c:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 8004e0e:	2b01      	cmp	r3, #1
 8004e10:	d00d      	beq.n	8004e2e <UART_RxISR_16BIT_FIFOEN+0x14a>
          HAL_UART_RxCpltCallback(huart);
 8004e12:	4620      	mov	r0, r4
 8004e14:	f7fc f8c6 	bl	8000fa4 <HAL_UART_RxCpltCallback>
 8004e18:	e785      	b.n	8004d26 <UART_RxISR_16BIT_FIFOEN+0x42>
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8004e1a:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004e1c:	e852 3f00 	ldrex	r3, [r2]
 8004e20:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004e24:	e842 3100 	strex	r1, r3, [r2]
 8004e28:	2900      	cmp	r1, #0
 8004e2a:	d1f6      	bne.n	8004e1a <UART_RxISR_16BIT_FIFOEN+0x136>
 8004e2c:	e7ee      	b.n	8004e0c <UART_RxISR_16BIT_FIFOEN+0x128>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004e2e:	2300      	movs	r3, #0
 8004e30:	66e3      	str	r3, [r4, #108]	@ 0x6c
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004e32:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004e34:	e852 3f00 	ldrex	r3, [r2]
 8004e38:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004e3c:	e842 3100 	strex	r1, r3, [r2]
 8004e40:	2900      	cmp	r1, #0
 8004e42:	d1f6      	bne.n	8004e32 <UART_RxISR_16BIT_FIFOEN+0x14e>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004e44:	6823      	ldr	r3, [r4, #0]
 8004e46:	69da      	ldr	r2, [r3, #28]
 8004e48:	f012 0f10 	tst.w	r2, #16
 8004e4c:	d001      	beq.n	8004e52 <UART_RxISR_16BIT_FIFOEN+0x16e>
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004e4e:	2210      	movs	r2, #16
 8004e50:	621a      	str	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004e52:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
 8004e56:	4620      	mov	r0, r4
 8004e58:	f7ff fbe1 	bl	800461e <HAL_UARTEx_RxEventCallback>
 8004e5c:	e763      	b.n	8004d26 <UART_RxISR_16BIT_FIFOEN+0x42>
    rxdatacount = huart->RxXferCount;
 8004e5e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8004e62:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 8004e64:	2b00      	cmp	r3, #0
 8004e66:	f43f af4f 	beq.w	8004d08 <UART_RxISR_16BIT_FIFOEN+0x24>
 8004e6a:	f8b4 2068 	ldrh.w	r2, [r4, #104]	@ 0x68
 8004e6e:	429a      	cmp	r2, r3
 8004e70:	f67f af4a 	bls.w	8004d08 <UART_RxISR_16BIT_FIFOEN+0x24>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8004e74:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004e76:	f102 0308 	add.w	r3, r2, #8
 8004e7a:	e853 3f00 	ldrex	r3, [r3]
 8004e7e:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004e82:	3208      	adds	r2, #8
 8004e84:	e842 3100 	strex	r1, r3, [r2]
 8004e88:	2900      	cmp	r1, #0
 8004e8a:	d1f3      	bne.n	8004e74 <UART_RxISR_16BIT_FIFOEN+0x190>
      huart->RxISR = UART_RxISR_16BIT;
 8004e8c:	4b06      	ldr	r3, [pc, #24]	@ (8004ea8 <UART_RxISR_16BIT_FIFOEN+0x1c4>)
 8004e8e:	6763      	str	r3, [r4, #116]	@ 0x74
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8004e90:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004e92:	e852 3f00 	ldrex	r3, [r2]
 8004e96:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004e9a:	e842 3100 	strex	r1, r3, [r2]
 8004e9e:	2900      	cmp	r1, #0
 8004ea0:	d1f6      	bne.n	8004e90 <UART_RxISR_16BIT_FIFOEN+0x1ac>
 8004ea2:	e731      	b.n	8004d08 <UART_RxISR_16BIT_FIFOEN+0x24>
 8004ea4:	40008000 	.word	0x40008000
 8004ea8:	08004a41 	.word	0x08004a41

08004eac <UART_SetConfig>:
{
 8004eac:	b570      	push	{r4, r5, r6, lr}
 8004eae:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 8004eb0:	6801      	ldr	r1, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004eb2:	6883      	ldr	r3, [r0, #8]
 8004eb4:	6902      	ldr	r2, [r0, #16]
 8004eb6:	4313      	orrs	r3, r2
 8004eb8:	6942      	ldr	r2, [r0, #20]
 8004eba:	4313      	orrs	r3, r2
 8004ebc:	69c2      	ldr	r2, [r0, #28]
 8004ebe:	4313      	orrs	r3, r2
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004ec0:	6808      	ldr	r0, [r1, #0]
 8004ec2:	4a9d      	ldr	r2, [pc, #628]	@ (8005138 <UART_SetConfig+0x28c>)
 8004ec4:	4002      	ands	r2, r0
 8004ec6:	431a      	orrs	r2, r3
 8004ec8:	600a      	str	r2, [r1, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8004eca:	6822      	ldr	r2, [r4, #0]
 8004ecc:	6853      	ldr	r3, [r2, #4]
 8004ece:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8004ed2:	68e1      	ldr	r1, [r4, #12]
 8004ed4:	430b      	orrs	r3, r1
 8004ed6:	6053      	str	r3, [r2, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8004ed8:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8004eda:	6822      	ldr	r2, [r4, #0]
 8004edc:	4b97      	ldr	r3, [pc, #604]	@ (800513c <UART_SetConfig+0x290>)
 8004ede:	429a      	cmp	r2, r3
 8004ee0:	d001      	beq.n	8004ee6 <UART_SetConfig+0x3a>
    tmpreg |= huart->Init.OneBitSampling;
 8004ee2:	6a23      	ldr	r3, [r4, #32]
 8004ee4:	4319      	orrs	r1, r3
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8004ee6:	6893      	ldr	r3, [r2, #8]
 8004ee8:	f023 436e 	bic.w	r3, r3, #3992977408	@ 0xee000000
 8004eec:	f423 6330 	bic.w	r3, r3, #2816	@ 0xb00
 8004ef0:	430b      	orrs	r3, r1
 8004ef2:	6093      	str	r3, [r2, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8004ef4:	6822      	ldr	r2, [r4, #0]
 8004ef6:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004ef8:	f023 030f 	bic.w	r3, r3, #15
 8004efc:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8004efe:	430b      	orrs	r3, r1
 8004f00:	62d3      	str	r3, [r2, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004f02:	6823      	ldr	r3, [r4, #0]
 8004f04:	4a8e      	ldr	r2, [pc, #568]	@ (8005140 <UART_SetConfig+0x294>)
 8004f06:	4293      	cmp	r3, r2
 8004f08:	d01c      	beq.n	8004f44 <UART_SetConfig+0x98>
 8004f0a:	4a8e      	ldr	r2, [pc, #568]	@ (8005144 <UART_SetConfig+0x298>)
 8004f0c:	4293      	cmp	r3, r2
 8004f0e:	d031      	beq.n	8004f74 <UART_SetConfig+0xc8>
 8004f10:	4a8a      	ldr	r2, [pc, #552]	@ (800513c <UART_SetConfig+0x290>)
 8004f12:	4293      	cmp	r3, r2
 8004f14:	d04b      	beq.n	8004fae <UART_SetConfig+0x102>
 8004f16:	2210      	movs	r2, #16
  if (UART_INSTANCE_LOWPOWER(huart))
 8004f18:	4988      	ldr	r1, [pc, #544]	@ (800513c <UART_SetConfig+0x290>)
 8004f1a:	428b      	cmp	r3, r1
 8004f1c:	d068      	beq.n	8004ff0 <UART_SetConfig+0x144>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004f1e:	69e0      	ldr	r0, [r4, #28]
 8004f20:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8004f24:	f000 80a5 	beq.w	8005072 <UART_SetConfig+0x1c6>
    switch (clocksource)
 8004f28:	2a08      	cmp	r2, #8
 8004f2a:	f200 811f 	bhi.w	800516c <UART_SetConfig+0x2c0>
 8004f2e:	e8df f012 	tbh	[pc, r2, lsl #1]
 8004f32:	00d3      	.short	0x00d3
 8004f34:	00d100f5 	.word	0x00d100f5
 8004f38:	00f8011d 	.word	0x00f8011d
 8004f3c:	011d011d 	.word	0x011d011d
 8004f40:	00fb011d 	.word	0x00fb011d
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 8004f44:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8004f48:	f8d2 2088 	ldr.w	r2, [r2, #136]	@ 0x88
 8004f4c:	f002 0203 	and.w	r2, r2, #3
 8004f50:	f442 3240 	orr.w	r2, r2, #196608	@ 0x30000
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004f54:	f5a2 3240 	sub.w	r2, r2, #196608	@ 0x30000
 8004f58:	2a03      	cmp	r2, #3
 8004f5a:	d809      	bhi.n	8004f70 <UART_SetConfig+0xc4>
 8004f5c:	e8df f002 	tbb	[pc, r2]
 8004f60:	063c0402 	.word	0x063c0402
 8004f64:	2201      	movs	r2, #1
 8004f66:	e7d7      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004f68:	2204      	movs	r2, #4
 8004f6a:	e7d5      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004f6c:	2208      	movs	r2, #8
 8004f6e:	e7d3      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004f70:	2210      	movs	r2, #16
 8004f72:	e7d1      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004f74:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8004f78:	f8d2 2088 	ldr.w	r2, [r2, #136]	@ 0x88
 8004f7c:	f002 020c 	and.w	r2, r2, #12
 8004f80:	f442 2240 	orr.w	r2, r2, #786432	@ 0xc0000
 8004f84:	f5a2 2240 	sub.w	r2, r2, #786432	@ 0xc0000
 8004f88:	2a0c      	cmp	r2, #12
 8004f8a:	d80e      	bhi.n	8004faa <UART_SetConfig+0xfe>
 8004f8c:	e8df f002 	tbb	[pc, r2]
 8004f90:	0d0d0d07 	.word	0x0d0d0d07
 8004f94:	0d0d0d09 	.word	0x0d0d0d09
 8004f98:	0d0d0d26 	.word	0x0d0d0d26
 8004f9c:	0b          	.byte	0x0b
 8004f9d:	00          	.byte	0x00
 8004f9e:	2200      	movs	r2, #0
 8004fa0:	e7ba      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fa2:	2204      	movs	r2, #4
 8004fa4:	e7b8      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fa6:	2208      	movs	r2, #8
 8004fa8:	e7b6      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004faa:	2210      	movs	r2, #16
 8004fac:	e7b4      	b.n	8004f18 <UART_SetConfig+0x6c>
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 8004fae:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8004fb2:	f8d2 2088 	ldr.w	r2, [r2, #136]	@ 0x88
 8004fb6:	f402 6240 	and.w	r2, r2, #3072	@ 0xc00
 8004fba:	f5b2 6f00 	cmp.w	r2, #2048	@ 0x800
 8004fbe:	d00f      	beq.n	8004fe0 <UART_SetConfig+0x134>
 8004fc0:	d805      	bhi.n	8004fce <UART_SetConfig+0x122>
 8004fc2:	b17a      	cbz	r2, 8004fe4 <UART_SetConfig+0x138>
 8004fc4:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
 8004fc8:	d10e      	bne.n	8004fe8 <UART_SetConfig+0x13c>
 8004fca:	2204      	movs	r2, #4
 8004fcc:	e7a4      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fce:	f5b2 6f40 	cmp.w	r2, #3072	@ 0xc00
 8004fd2:	d10b      	bne.n	8004fec <UART_SetConfig+0x140>
 8004fd4:	2208      	movs	r2, #8
 8004fd6:	e79f      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fd8:	2202      	movs	r2, #2
 8004fda:	e79d      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fdc:	2202      	movs	r2, #2
 8004fde:	e79b      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fe0:	2202      	movs	r2, #2
 8004fe2:	e799      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fe4:	2200      	movs	r2, #0
 8004fe6:	e797      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fe8:	2210      	movs	r2, #16
 8004fea:	e795      	b.n	8004f18 <UART_SetConfig+0x6c>
 8004fec:	2210      	movs	r2, #16
 8004fee:	e793      	b.n	8004f18 <UART_SetConfig+0x6c>
    switch (clocksource)
 8004ff0:	2a08      	cmp	r2, #8
 8004ff2:	f200 809c 	bhi.w	800512e <UART_SetConfig+0x282>
 8004ff6:	e8df f002 	tbb	[pc, r2]
 8004ffa:	9a08      	.short	0x9a08
 8004ffc:	9a379a3a 	.word	0x9a379a3a
 8005000:	9a9a      	.short	0x9a9a
 8005002:	05          	.byte	0x05
 8005003:	00          	.byte	0x00
 8005004:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 8005008:	e004      	b.n	8005014 <UART_SetConfig+0x168>
        pclk = HAL_RCC_GetPCLK1Freq();
 800500a:	f7fe ff53 	bl	8003eb4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800500e:	2800      	cmp	r0, #0
 8005010:	f000 808f 	beq.w	8005132 <UART_SetConfig+0x286>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8005014:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8005016:	4b4c      	ldr	r3, [pc, #304]	@ (8005148 <UART_SetConfig+0x29c>)
 8005018:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 800501c:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005020:	6865      	ldr	r5, [r4, #4]
 8005022:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 8005026:	4299      	cmp	r1, r3
 8005028:	f200 8094 	bhi.w	8005154 <UART_SetConfig+0x2a8>
 800502c:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 8005030:	f200 8092 	bhi.w	8005158 <UART_SetConfig+0x2ac>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005034:	2600      	movs	r6, #0
 8005036:	4633      	mov	r3, r6
 8005038:	4631      	mov	r1, r6
 800503a:	f7fb f8a5 	bl	8000188 <__aeabi_uldivmod>
 800503e:	0209      	lsls	r1, r1, #8
 8005040:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 8005044:	0200      	lsls	r0, r0, #8
 8005046:	086b      	lsrs	r3, r5, #1
 8005048:	18c0      	adds	r0, r0, r3
 800504a:	462a      	mov	r2, r5
 800504c:	4633      	mov	r3, r6
 800504e:	f141 0100 	adc.w	r1, r1, #0
 8005052:	f7fb f899 	bl	8000188 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8005056:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
 800505a:	4b3c      	ldr	r3, [pc, #240]	@ (800514c <UART_SetConfig+0x2a0>)
 800505c:	429a      	cmp	r2, r3
 800505e:	d87d      	bhi.n	800515c <UART_SetConfig+0x2b0>
          huart->Instance->BRR = usartdiv;
 8005060:	6823      	ldr	r3, [r4, #0]
 8005062:	60d8      	str	r0, [r3, #12]
 8005064:	4630      	mov	r0, r6
 8005066:	e050      	b.n	800510a <UART_SetConfig+0x25e>
        pclk = HAL_RCC_GetSysClockFreq();
 8005068:	f7fe fa26 	bl	80034b8 <HAL_RCC_GetSysClockFreq>
        break;
 800506c:	e7cf      	b.n	800500e <UART_SetConfig+0x162>
        pclk = (uint32_t) HSI_VALUE;
 800506e:	4838      	ldr	r0, [pc, #224]	@ (8005150 <UART_SetConfig+0x2a4>)
 8005070:	e7d0      	b.n	8005014 <UART_SetConfig+0x168>
    switch (clocksource)
 8005072:	2a08      	cmp	r2, #8
 8005074:	d874      	bhi.n	8005160 <UART_SetConfig+0x2b4>
 8005076:	e8df f002 	tbb	[pc, r2]
 800507a:	2707      	.short	0x2707
 800507c:	732a7305 	.word	0x732a7305
 8005080:	7373      	.short	0x7373
 8005082:	0b          	.byte	0x0b
 8005083:	00          	.byte	0x00
 8005084:	4832      	ldr	r0, [pc, #200]	@ (8005150 <UART_SetConfig+0x2a4>)
 8005086:	e003      	b.n	8005090 <UART_SetConfig+0x1e4>
        pclk = HAL_RCC_GetPCLK1Freq();
 8005088:	f7fe ff14 	bl	8003eb4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800508c:	2800      	cmp	r0, #0
 800508e:	d069      	beq.n	8005164 <UART_SetConfig+0x2b8>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005090:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8005092:	4b2d      	ldr	r3, [pc, #180]	@ (8005148 <UART_SetConfig+0x29c>)
 8005094:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8005098:	fbb0 f0f3 	udiv	r0, r0, r3
 800509c:	6862      	ldr	r2, [r4, #4]
 800509e:	0853      	lsrs	r3, r2, #1
 80050a0:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80050a4:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80050a8:	f1a3 0110 	sub.w	r1, r3, #16
 80050ac:	f64f 72ef 	movw	r2, #65519	@ 0xffef
 80050b0:	4291      	cmp	r1, r2
 80050b2:	d859      	bhi.n	8005168 <UART_SetConfig+0x2bc>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80050b4:	b29a      	uxth	r2, r3
 80050b6:	f022 020f 	bic.w	r2, r2, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80050ba:	f3c3 0342 	ubfx	r3, r3, #1, #3
 80050be:	4313      	orrs	r3, r2
        huart->Instance->BRR = brrtemp;
 80050c0:	6822      	ldr	r2, [r4, #0]
 80050c2:	60d3      	str	r3, [r2, #12]
 80050c4:	2000      	movs	r0, #0
 80050c6:	e020      	b.n	800510a <UART_SetConfig+0x25e>
        pclk = HAL_RCC_GetPCLK2Freq();
 80050c8:	f7fe ff04 	bl	8003ed4 <HAL_RCC_GetPCLK2Freq>
        break;
 80050cc:	e7de      	b.n	800508c <UART_SetConfig+0x1e0>
        pclk = HAL_RCC_GetSysClockFreq();
 80050ce:	f7fe f9f3 	bl	80034b8 <HAL_RCC_GetSysClockFreq>
        break;
 80050d2:	e7db      	b.n	800508c <UART_SetConfig+0x1e0>
    switch (clocksource)
 80050d4:	481e      	ldr	r0, [pc, #120]	@ (8005150 <UART_SetConfig+0x2a4>)
 80050d6:	e003      	b.n	80050e0 <UART_SetConfig+0x234>
        pclk = HAL_RCC_GetPCLK1Freq();
 80050d8:	f7fe feec 	bl	8003eb4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80050dc:	2800      	cmp	r0, #0
 80050de:	d047      	beq.n	8005170 <UART_SetConfig+0x2c4>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80050e0:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 80050e2:	4b19      	ldr	r3, [pc, #100]	@ (8005148 <UART_SetConfig+0x29c>)
 80050e4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80050e8:	fbb0 f0f3 	udiv	r0, r0, r3
 80050ec:	6863      	ldr	r3, [r4, #4]
 80050ee:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80050f2:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80050f6:	f1a0 0210 	sub.w	r2, r0, #16
 80050fa:	f64f 73ef 	movw	r3, #65519	@ 0xffef
 80050fe:	429a      	cmp	r2, r3
 8005100:	d838      	bhi.n	8005174 <UART_SetConfig+0x2c8>
        huart->Instance->BRR = (uint16_t)usartdiv;
 8005102:	6823      	ldr	r3, [r4, #0]
 8005104:	b280      	uxth	r0, r0
 8005106:	60d8      	str	r0, [r3, #12]
 8005108:	2000      	movs	r0, #0
  huart->NbTxDataToProcess = 1;
 800510a:	2301      	movs	r3, #1
 800510c:	f8a4 306a 	strh.w	r3, [r4, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
 8005110:	f8a4 3068 	strh.w	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
 8005114:	2300      	movs	r3, #0
 8005116:	6763      	str	r3, [r4, #116]	@ 0x74
  huart->TxISR = NULL;
 8005118:	67a3      	str	r3, [r4, #120]	@ 0x78
}
 800511a:	bd70      	pop	{r4, r5, r6, pc}
        pclk = HAL_RCC_GetPCLK2Freq();
 800511c:	f7fe feda 	bl	8003ed4 <HAL_RCC_GetPCLK2Freq>
        break;
 8005120:	e7dc      	b.n	80050dc <UART_SetConfig+0x230>
        pclk = HAL_RCC_GetSysClockFreq();
 8005122:	f7fe f9c9 	bl	80034b8 <HAL_RCC_GetSysClockFreq>
        break;
 8005126:	e7d9      	b.n	80050dc <UART_SetConfig+0x230>
        pclk = (uint32_t) LSE_VALUE;
 8005128:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 800512c:	e7d8      	b.n	80050e0 <UART_SetConfig+0x234>
    switch (clocksource)
 800512e:	2001      	movs	r0, #1
 8005130:	e7eb      	b.n	800510a <UART_SetConfig+0x25e>
 8005132:	2000      	movs	r0, #0
 8005134:	e7e9      	b.n	800510a <UART_SetConfig+0x25e>
 8005136:	bf00      	nop
 8005138:	cfff69f3 	.word	0xcfff69f3
 800513c:	40008000 	.word	0x40008000
 8005140:	40013800 	.word	0x40013800
 8005144:	40004400 	.word	0x40004400
 8005148:	0800690c 	.word	0x0800690c
 800514c:	000ffcff 	.word	0x000ffcff
 8005150:	00f42400 	.word	0x00f42400
        ret = HAL_ERROR;
 8005154:	2001      	movs	r0, #1
 8005156:	e7d8      	b.n	800510a <UART_SetConfig+0x25e>
 8005158:	2001      	movs	r0, #1
 800515a:	e7d6      	b.n	800510a <UART_SetConfig+0x25e>
          ret = HAL_ERROR;
 800515c:	2001      	movs	r0, #1
 800515e:	e7d4      	b.n	800510a <UART_SetConfig+0x25e>
    switch (clocksource)
 8005160:	2001      	movs	r0, #1
 8005162:	e7d2      	b.n	800510a <UART_SetConfig+0x25e>
 8005164:	2000      	movs	r0, #0
 8005166:	e7d0      	b.n	800510a <UART_SetConfig+0x25e>
        ret = HAL_ERROR;
 8005168:	2001      	movs	r0, #1
 800516a:	e7ce      	b.n	800510a <UART_SetConfig+0x25e>
    switch (clocksource)
 800516c:	2001      	movs	r0, #1
 800516e:	e7cc      	b.n	800510a <UART_SetConfig+0x25e>
 8005170:	2000      	movs	r0, #0
 8005172:	e7ca      	b.n	800510a <UART_SetConfig+0x25e>
        ret = HAL_ERROR;
 8005174:	2001      	movs	r0, #1
 8005176:	e7c8      	b.n	800510a <UART_SetConfig+0x25e>

08005178 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8005178:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800517a:	f013 0f08 	tst.w	r3, #8
 800517e:	d006      	beq.n	800518e <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8005180:	6802      	ldr	r2, [r0, #0]
 8005182:	6853      	ldr	r3, [r2, #4]
 8005184:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8005188:	6b81      	ldr	r1, [r0, #56]	@ 0x38
 800518a:	430b      	orrs	r3, r1
 800518c:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800518e:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 8005190:	f013 0f01 	tst.w	r3, #1
 8005194:	d006      	beq.n	80051a4 <UART_AdvFeatureConfig+0x2c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8005196:	6802      	ldr	r2, [r0, #0]
 8005198:	6853      	ldr	r3, [r2, #4]
 800519a:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
 800519e:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 80051a0:	430b      	orrs	r3, r1
 80051a2:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80051a4:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80051a6:	f013 0f02 	tst.w	r3, #2
 80051aa:	d006      	beq.n	80051ba <UART_AdvFeatureConfig+0x42>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80051ac:	6802      	ldr	r2, [r0, #0]
 80051ae:	6853      	ldr	r3, [r2, #4]
 80051b0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80051b4:	6b01      	ldr	r1, [r0, #48]	@ 0x30
 80051b6:	430b      	orrs	r3, r1
 80051b8:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80051ba:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80051bc:	f013 0f04 	tst.w	r3, #4
 80051c0:	d006      	beq.n	80051d0 <UART_AdvFeatureConfig+0x58>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80051c2:	6802      	ldr	r2, [r0, #0]
 80051c4:	6853      	ldr	r3, [r2, #4]
 80051c6:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80051ca:	6b41      	ldr	r1, [r0, #52]	@ 0x34
 80051cc:	430b      	orrs	r3, r1
 80051ce:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80051d0:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80051d2:	f013 0f10 	tst.w	r3, #16
 80051d6:	d006      	beq.n	80051e6 <UART_AdvFeatureConfig+0x6e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80051d8:	6802      	ldr	r2, [r0, #0]
 80051da:	6893      	ldr	r3, [r2, #8]
 80051dc:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80051e0:	6bc1      	ldr	r1, [r0, #60]	@ 0x3c
 80051e2:	430b      	orrs	r3, r1
 80051e4:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80051e6:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80051e8:	f013 0f20 	tst.w	r3, #32
 80051ec:	d006      	beq.n	80051fc <UART_AdvFeatureConfig+0x84>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80051ee:	6802      	ldr	r2, [r0, #0]
 80051f0:	6893      	ldr	r3, [r2, #8]
 80051f2:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80051f6:	6c01      	ldr	r1, [r0, #64]	@ 0x40
 80051f8:	430b      	orrs	r3, r1
 80051fa:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80051fc:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80051fe:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8005202:	d00a      	beq.n	800521a <UART_AdvFeatureConfig+0xa2>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8005204:	6802      	ldr	r2, [r0, #0]
 8005206:	6853      	ldr	r3, [r2, #4]
 8005208:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 800520c:	6c41      	ldr	r1, [r0, #68]	@ 0x44
 800520e:	430b      	orrs	r3, r1
 8005210:	6053      	str	r3, [r2, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8005212:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 8005214:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8005218:	d00b      	beq.n	8005232 <UART_AdvFeatureConfig+0xba>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800521a:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800521c:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8005220:	d006      	beq.n	8005230 <UART_AdvFeatureConfig+0xb8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8005222:	6802      	ldr	r2, [r0, #0]
 8005224:	6853      	ldr	r3, [r2, #4]
 8005226:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 800522a:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 800522c:	430b      	orrs	r3, r1
 800522e:	6053      	str	r3, [r2, #4]
}
 8005230:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8005232:	6802      	ldr	r2, [r0, #0]
 8005234:	6853      	ldr	r3, [r2, #4]
 8005236:	f423 03c0 	bic.w	r3, r3, #6291456	@ 0x600000
 800523a:	6c81      	ldr	r1, [r0, #72]	@ 0x48
 800523c:	430b      	orrs	r3, r1
 800523e:	6053      	str	r3, [r2, #4]
 8005240:	e7eb      	b.n	800521a <UART_AdvFeatureConfig+0xa2>

08005242 <UART_WaitOnFlagUntilTimeout>:
{
 8005242:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005246:	4605      	mov	r5, r0
 8005248:	460e      	mov	r6, r1
 800524a:	4617      	mov	r7, r2
 800524c:	4699      	mov	r9, r3
 800524e:	f8dd 8020 	ldr.w	r8, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005252:	682b      	ldr	r3, [r5, #0]
 8005254:	69dc      	ldr	r4, [r3, #28]
 8005256:	ea36 0404 	bics.w	r4, r6, r4
 800525a:	bf0c      	ite	eq
 800525c:	2401      	moveq	r4, #1
 800525e:	2400      	movne	r4, #0
 8005260:	42bc      	cmp	r4, r7
 8005262:	d15b      	bne.n	800531c <UART_WaitOnFlagUntilTimeout+0xda>
    if (Timeout != HAL_MAX_DELAY)
 8005264:	f1b8 3fff 	cmp.w	r8, #4294967295
 8005268:	d0f3      	beq.n	8005252 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800526a:	f7fb fc29 	bl	8000ac0 <HAL_GetTick>
 800526e:	eba0 0009 	sub.w	r0, r0, r9
 8005272:	4540      	cmp	r0, r8
 8005274:	d833      	bhi.n	80052de <UART_WaitOnFlagUntilTimeout+0x9c>
 8005276:	f1b8 0f00 	cmp.w	r8, #0
 800527a:	d030      	beq.n	80052de <UART_WaitOnFlagUntilTimeout+0x9c>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 800527c:	682b      	ldr	r3, [r5, #0]
 800527e:	681a      	ldr	r2, [r3, #0]
 8005280:	f012 0f04 	tst.w	r2, #4
 8005284:	d0e5      	beq.n	8005252 <UART_WaitOnFlagUntilTimeout+0x10>
 8005286:	2e80      	cmp	r6, #128	@ 0x80
 8005288:	d0e3      	beq.n	8005252 <UART_WaitOnFlagUntilTimeout+0x10>
 800528a:	2e40      	cmp	r6, #64	@ 0x40
 800528c:	d0e1      	beq.n	8005252 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800528e:	69da      	ldr	r2, [r3, #28]
 8005290:	f412 6f00 	tst.w	r2, #2048	@ 0x800
 8005294:	d0dd      	beq.n	8005252 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8005296:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 800529a:	621a      	str	r2, [r3, #32]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 800529c:	682a      	ldr	r2, [r5, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800529e:	e852 3f00 	ldrex	r3, [r2]
 80052a2:	f423 73d0 	bic.w	r3, r3, #416	@ 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052a6:	e842 3100 	strex	r1, r3, [r2]
 80052aa:	2900      	cmp	r1, #0
 80052ac:	d1f6      	bne.n	800529c <UART_WaitOnFlagUntilTimeout+0x5a>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80052ae:	682a      	ldr	r2, [r5, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80052b0:	f102 0308 	add.w	r3, r2, #8
 80052b4:	e853 3f00 	ldrex	r3, [r3]
 80052b8:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052bc:	3208      	adds	r2, #8
 80052be:	e842 3100 	strex	r1, r3, [r2]
 80052c2:	2900      	cmp	r1, #0
 80052c4:	d1f3      	bne.n	80052ae <UART_WaitOnFlagUntilTimeout+0x6c>
          huart->gState = HAL_UART_STATE_READY;
 80052c6:	2320      	movs	r3, #32
 80052c8:	f8c5 3088 	str.w	r3, [r5, #136]	@ 0x88
          huart->RxState = HAL_UART_STATE_READY;
 80052cc:	f8c5 308c 	str.w	r3, [r5, #140]	@ 0x8c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 80052d0:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
          __HAL_UNLOCK(huart);
 80052d4:	2300      	movs	r3, #0
 80052d6:	f885 3084 	strb.w	r3, [r5, #132]	@ 0x84
          return HAL_TIMEOUT;
 80052da:	2003      	movs	r0, #3
 80052dc:	e01f      	b.n	800531e <UART_WaitOnFlagUntilTimeout+0xdc>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 80052de:	682a      	ldr	r2, [r5, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80052e0:	e852 3f00 	ldrex	r3, [r2]
 80052e4:	f423 73d0 	bic.w	r3, r3, #416	@ 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052e8:	e842 3100 	strex	r1, r3, [r2]
 80052ec:	2900      	cmp	r1, #0
 80052ee:	d1f6      	bne.n	80052de <UART_WaitOnFlagUntilTimeout+0x9c>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80052f0:	682a      	ldr	r2, [r5, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80052f2:	f102 0308 	add.w	r3, r2, #8
 80052f6:	e853 3f00 	ldrex	r3, [r3]
 80052fa:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052fe:	3208      	adds	r2, #8
 8005300:	e842 3100 	strex	r1, r3, [r2]
 8005304:	2900      	cmp	r1, #0
 8005306:	d1f3      	bne.n	80052f0 <UART_WaitOnFlagUntilTimeout+0xae>
        huart->gState = HAL_UART_STATE_READY;
 8005308:	2320      	movs	r3, #32
 800530a:	f8c5 3088 	str.w	r3, [r5, #136]	@ 0x88
        huart->RxState = HAL_UART_STATE_READY;
 800530e:	f8c5 308c 	str.w	r3, [r5, #140]	@ 0x8c
        __HAL_UNLOCK(huart);
 8005312:	2300      	movs	r3, #0
 8005314:	f885 3084 	strb.w	r3, [r5, #132]	@ 0x84
        return HAL_TIMEOUT;
 8005318:	2003      	movs	r0, #3
 800531a:	e000      	b.n	800531e <UART_WaitOnFlagUntilTimeout+0xdc>
  return HAL_OK;
 800531c:	2000      	movs	r0, #0
}
 800531e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08005322 <UART_CheckIdleState>:
{
 8005322:	b530      	push	{r4, r5, lr}
 8005324:	b083      	sub	sp, #12
 8005326:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005328:	2300      	movs	r3, #0
 800532a:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
 800532e:	f7fb fbc7 	bl	8000ac0 <HAL_GetTick>
 8005332:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8005334:	6822      	ldr	r2, [r4, #0]
 8005336:	6812      	ldr	r2, [r2, #0]
 8005338:	f012 0f08 	tst.w	r2, #8
 800533c:	d110      	bne.n	8005360 <UART_CheckIdleState+0x3e>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800533e:	6823      	ldr	r3, [r4, #0]
 8005340:	681b      	ldr	r3, [r3, #0]
 8005342:	f013 0f04 	tst.w	r3, #4
 8005346:	d119      	bne.n	800537c <UART_CheckIdleState+0x5a>
  huart->gState = HAL_UART_STATE_READY;
 8005348:	2320      	movs	r3, #32
 800534a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 800534e:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005352:	2000      	movs	r0, #0
 8005354:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8005356:	6720      	str	r0, [r4, #112]	@ 0x70
  __HAL_UNLOCK(huart);
 8005358:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 800535c:	b003      	add	sp, #12
 800535e:	bd30      	pop	{r4, r5, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8005360:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 8005364:	9300      	str	r3, [sp, #0]
 8005366:	4603      	mov	r3, r0
 8005368:	2200      	movs	r2, #0
 800536a:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 800536e:	4620      	mov	r0, r4
 8005370:	f7ff ff67 	bl	8005242 <UART_WaitOnFlagUntilTimeout>
 8005374:	2800      	cmp	r0, #0
 8005376:	d0e2      	beq.n	800533e <UART_CheckIdleState+0x1c>
      return HAL_TIMEOUT;
 8005378:	2003      	movs	r0, #3
 800537a:	e7ef      	b.n	800535c <UART_CheckIdleState+0x3a>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800537c:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 8005380:	9300      	str	r3, [sp, #0]
 8005382:	462b      	mov	r3, r5
 8005384:	2200      	movs	r2, #0
 8005386:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 800538a:	4620      	mov	r0, r4
 800538c:	f7ff ff59 	bl	8005242 <UART_WaitOnFlagUntilTimeout>
 8005390:	2800      	cmp	r0, #0
 8005392:	d0d9      	beq.n	8005348 <UART_CheckIdleState+0x26>
      return HAL_TIMEOUT;
 8005394:	2003      	movs	r0, #3
 8005396:	e7e1      	b.n	800535c <UART_CheckIdleState+0x3a>

08005398 <HAL_UART_Init>:
  if (huart == NULL)
 8005398:	b378      	cbz	r0, 80053fa <HAL_UART_Init+0x62>
{
 800539a:	b510      	push	{r4, lr}
 800539c:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 800539e:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 80053a2:	b30b      	cbz	r3, 80053e8 <HAL_UART_Init+0x50>
  huart->gState = HAL_UART_STATE_BUSY;
 80053a4:	2324      	movs	r3, #36	@ 0x24
 80053a6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 80053aa:	6822      	ldr	r2, [r4, #0]
 80053ac:	6813      	ldr	r3, [r2, #0]
 80053ae:	f023 0301 	bic.w	r3, r3, #1
 80053b2:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80053b4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80053b6:	b9e3      	cbnz	r3, 80053f2 <HAL_UART_Init+0x5a>
  if (UART_SetConfig(huart) == HAL_ERROR)
 80053b8:	4620      	mov	r0, r4
 80053ba:	f7ff fd77 	bl	8004eac <UART_SetConfig>
 80053be:	2801      	cmp	r0, #1
 80053c0:	d011      	beq.n	80053e6 <HAL_UART_Init+0x4e>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80053c2:	6822      	ldr	r2, [r4, #0]
 80053c4:	6853      	ldr	r3, [r2, #4]
 80053c6:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 80053ca:	6053      	str	r3, [r2, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80053cc:	6822      	ldr	r2, [r4, #0]
 80053ce:	6893      	ldr	r3, [r2, #8]
 80053d0:	f023 032a 	bic.w	r3, r3, #42	@ 0x2a
 80053d4:	6093      	str	r3, [r2, #8]
  __HAL_UART_ENABLE(huart);
 80053d6:	6822      	ldr	r2, [r4, #0]
 80053d8:	6813      	ldr	r3, [r2, #0]
 80053da:	f043 0301 	orr.w	r3, r3, #1
 80053de:	6013      	str	r3, [r2, #0]
  return (UART_CheckIdleState(huart));
 80053e0:	4620      	mov	r0, r4
 80053e2:	f7ff ff9e 	bl	8005322 <UART_CheckIdleState>
}
 80053e6:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 80053e8:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 80053ec:	f7fb fcc6 	bl	8000d7c <HAL_UART_MspInit>
 80053f0:	e7d8      	b.n	80053a4 <HAL_UART_Init+0xc>
    UART_AdvFeatureConfig(huart);
 80053f2:	4620      	mov	r0, r4
 80053f4:	f7ff fec0 	bl	8005178 <UART_AdvFeatureConfig>
 80053f8:	e7de      	b.n	80053b8 <HAL_UART_Init+0x20>
    return HAL_ERROR;
 80053fa:	2001      	movs	r0, #1
}
 80053fc:	4770      	bx	lr
	...

08005400 <UART_Start_Receive_IT>:
{
 8005400:	b410      	push	{r4}
  huart->pRxBuffPtr  = pData;
 8005402:	6581      	str	r1, [r0, #88]	@ 0x58
  huart->RxXferSize  = Size;
 8005404:	f8a0 205c 	strh.w	r2, [r0, #92]	@ 0x5c
  huart->RxXferCount = Size;
 8005408:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
  huart->RxISR       = NULL;
 800540c:	2300      	movs	r3, #0
 800540e:	6743      	str	r3, [r0, #116]	@ 0x74
  UART_MASK_COMPUTATION(huart);
 8005410:	6883      	ldr	r3, [r0, #8]
 8005412:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8005416:	d006      	beq.n	8005426 <UART_Start_Receive_IT+0x26>
 8005418:	b9a3      	cbnz	r3, 8005444 <UART_Start_Receive_IT+0x44>
 800541a:	6903      	ldr	r3, [r0, #16]
 800541c:	b973      	cbnz	r3, 800543c <UART_Start_Receive_IT+0x3c>
 800541e:	23ff      	movs	r3, #255	@ 0xff
 8005420:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
 8005424:	e014      	b.n	8005450 <UART_Start_Receive_IT+0x50>
 8005426:	6903      	ldr	r3, [r0, #16]
 8005428:	b923      	cbnz	r3, 8005434 <UART_Start_Receive_IT+0x34>
 800542a:	f240 13ff 	movw	r3, #511	@ 0x1ff
 800542e:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
 8005432:	e00d      	b.n	8005450 <UART_Start_Receive_IT+0x50>
 8005434:	23ff      	movs	r3, #255	@ 0xff
 8005436:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
 800543a:	e009      	b.n	8005450 <UART_Start_Receive_IT+0x50>
 800543c:	237f      	movs	r3, #127	@ 0x7f
 800543e:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
 8005442:	e005      	b.n	8005450 <UART_Start_Receive_IT+0x50>
 8005444:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8005448:	d02d      	beq.n	80054a6 <UART_Start_Receive_IT+0xa6>
 800544a:	2300      	movs	r3, #0
 800544c:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005450:	2300      	movs	r3, #0
 8005452:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8005456:	2322      	movs	r3, #34	@ 0x22
 8005458:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800545c:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800545e:	f101 0308 	add.w	r3, r1, #8
 8005462:	e853 3f00 	ldrex	r3, [r3]
 8005466:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800546a:	3108      	adds	r1, #8
 800546c:	e841 3400 	strex	r4, r3, [r1]
 8005470:	2c00      	cmp	r4, #0
 8005472:	d1f3      	bne.n	800545c <UART_Start_Receive_IT+0x5c>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8005474:	6e43      	ldr	r3, [r0, #100]	@ 0x64
 8005476:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800547a:	d01e      	beq.n	80054ba <UART_Start_Receive_IT+0xba>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800547c:	6883      	ldr	r3, [r0, #8]
 800547e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8005482:	d042      	beq.n	800550a <UART_Start_Receive_IT+0x10a>
      huart->RxISR = UART_RxISR_8BIT;
 8005484:	4b29      	ldr	r3, [pc, #164]	@ (800552c <UART_Start_Receive_IT+0x12c>)
 8005486:	6743      	str	r3, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 8005488:	6903      	ldr	r3, [r0, #16]
 800548a:	2b00      	cmp	r3, #0
 800548c:	d043      	beq.n	8005516 <UART_Start_Receive_IT+0x116>
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 800548e:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005490:	e852 3f00 	ldrex	r3, [r2]
 8005494:	f443 7390 	orr.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005498:	e842 3100 	strex	r1, r3, [r2]
 800549c:	2900      	cmp	r1, #0
 800549e:	d1f6      	bne.n	800548e <UART_Start_Receive_IT+0x8e>
}
 80054a0:	2000      	movs	r0, #0
 80054a2:	bc10      	pop	{r4}
 80054a4:	4770      	bx	lr
  UART_MASK_COMPUTATION(huart);
 80054a6:	6903      	ldr	r3, [r0, #16]
 80054a8:	b91b      	cbnz	r3, 80054b2 <UART_Start_Receive_IT+0xb2>
 80054aa:	237f      	movs	r3, #127	@ 0x7f
 80054ac:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
 80054b0:	e7ce      	b.n	8005450 <UART_Start_Receive_IT+0x50>
 80054b2:	233f      	movs	r3, #63	@ 0x3f
 80054b4:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
 80054b8:	e7ca      	b.n	8005450 <UART_Start_Receive_IT+0x50>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 80054ba:	f8b0 3068 	ldrh.w	r3, [r0, #104]	@ 0x68
 80054be:	4293      	cmp	r3, r2
 80054c0:	d8dc      	bhi.n	800547c <UART_Start_Receive_IT+0x7c>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80054c2:	6883      	ldr	r3, [r0, #8]
 80054c4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80054c8:	d019      	beq.n	80054fe <UART_Start_Receive_IT+0xfe>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 80054ca:	4b19      	ldr	r3, [pc, #100]	@ (8005530 <UART_Start_Receive_IT+0x130>)
 80054cc:	6743      	str	r3, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 80054ce:	6903      	ldr	r3, [r0, #16]
 80054d0:	b143      	cbz	r3, 80054e4 <UART_Start_Receive_IT+0xe4>
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80054d2:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80054d4:	e852 3f00 	ldrex	r3, [r2]
 80054d8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80054dc:	e842 3100 	strex	r1, r3, [r2]
 80054e0:	2900      	cmp	r1, #0
 80054e2:	d1f6      	bne.n	80054d2 <UART_Start_Receive_IT+0xd2>
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 80054e4:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80054e6:	f102 0308 	add.w	r3, r2, #8
 80054ea:	e853 3f00 	ldrex	r3, [r3]
 80054ee:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80054f2:	3208      	adds	r2, #8
 80054f4:	e842 3100 	strex	r1, r3, [r2]
 80054f8:	2900      	cmp	r1, #0
 80054fa:	d1f3      	bne.n	80054e4 <UART_Start_Receive_IT+0xe4>
 80054fc:	e7d0      	b.n	80054a0 <UART_Start_Receive_IT+0xa0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80054fe:	6903      	ldr	r3, [r0, #16]
 8005500:	2b00      	cmp	r3, #0
 8005502:	d1e2      	bne.n	80054ca <UART_Start_Receive_IT+0xca>
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 8005504:	4b0b      	ldr	r3, [pc, #44]	@ (8005534 <UART_Start_Receive_IT+0x134>)
 8005506:	6743      	str	r3, [r0, #116]	@ 0x74
 8005508:	e7e1      	b.n	80054ce <UART_Start_Receive_IT+0xce>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800550a:	6903      	ldr	r3, [r0, #16]
 800550c:	2b00      	cmp	r3, #0
 800550e:	d1b9      	bne.n	8005484 <UART_Start_Receive_IT+0x84>
      huart->RxISR = UART_RxISR_16BIT;
 8005510:	4b09      	ldr	r3, [pc, #36]	@ (8005538 <UART_Start_Receive_IT+0x138>)
 8005512:	6743      	str	r3, [r0, #116]	@ 0x74
 8005514:	e7b8      	b.n	8005488 <UART_Start_Receive_IT+0x88>
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8005516:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005518:	e852 3f00 	ldrex	r3, [r2]
 800551c:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005520:	e842 3100 	strex	r1, r3, [r2]
 8005524:	2900      	cmp	r1, #0
 8005526:	d1f6      	bne.n	8005516 <UART_Start_Receive_IT+0x116>
 8005528:	e7ba      	b.n	80054a0 <UART_Start_Receive_IT+0xa0>
 800552a:	bf00      	nop
 800552c:	08004965 	.word	0x08004965
 8005530:	08004b19 	.word	0x08004b19
 8005534:	08004ce5 	.word	0x08004ce5
 8005538:	08004a41 	.word	0x08004a41

0800553c <HAL_UART_Receive_IT>:
{
 800553c:	b538      	push	{r3, r4, r5, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 800553e:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
 8005542:	2b20      	cmp	r3, #32
 8005544:	d117      	bne.n	8005576 <HAL_UART_Receive_IT+0x3a>
    if ((pData == NULL) || (Size == 0U))
 8005546:	b1c1      	cbz	r1, 800557a <HAL_UART_Receive_IT+0x3e>
 8005548:	b1ca      	cbz	r2, 800557e <HAL_UART_Receive_IT+0x42>
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800554a:	2300      	movs	r3, #0
 800554c:	66c3      	str	r3, [r0, #108]	@ 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800554e:	6803      	ldr	r3, [r0, #0]
 8005550:	4c0c      	ldr	r4, [pc, #48]	@ (8005584 <HAL_UART_Receive_IT+0x48>)
 8005552:	42a3      	cmp	r3, r4
 8005554:	d00c      	beq.n	8005570 <HAL_UART_Receive_IT+0x34>
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8005556:	685b      	ldr	r3, [r3, #4]
 8005558:	f413 0f00 	tst.w	r3, #8388608	@ 0x800000
 800555c:	d008      	beq.n	8005570 <HAL_UART_Receive_IT+0x34>
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800555e:	6804      	ldr	r4, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005560:	e854 3f00 	ldrex	r3, [r4]
 8005564:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005568:	e844 3500 	strex	r5, r3, [r4]
 800556c:	2d00      	cmp	r5, #0
 800556e:	d1f6      	bne.n	800555e <HAL_UART_Receive_IT+0x22>
    return (UART_Start_Receive_IT(huart, pData, Size));
 8005570:	f7ff ff46 	bl	8005400 <UART_Start_Receive_IT>
 8005574:	e000      	b.n	8005578 <HAL_UART_Receive_IT+0x3c>
    return HAL_BUSY;
 8005576:	2002      	movs	r0, #2
}
 8005578:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
 800557a:	2001      	movs	r0, #1
 800557c:	e7fc      	b.n	8005578 <HAL_UART_Receive_IT+0x3c>
 800557e:	2001      	movs	r0, #1
 8005580:	e7fa      	b.n	8005578 <HAL_UART_Receive_IT+0x3c>
 8005582:	bf00      	nop
 8005584:	40008000 	.word	0x40008000

08005588 <UARTEx_Wakeup_AddressConfig>:
  * @param huart           UART handle.
  * @param WakeUpSelection UART wake up from stop mode parameters.
  * @retval None
  */
static void UARTEx_Wakeup_AddressConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
{
 8005588:	b082      	sub	sp, #8
 800558a:	ab02      	add	r3, sp, #8
 800558c:	e903 0006 	stmdb	r3, {r1, r2}
  assert_param(IS_UART_ADDRESSLENGTH_DETECT(WakeUpSelection.AddressLength));

  /* Set the USART address length */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8005590:	6802      	ldr	r2, [r0, #0]
 8005592:	6853      	ldr	r3, [r2, #4]
 8005594:	f023 0310 	bic.w	r3, r3, #16
 8005598:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 800559c:	430b      	orrs	r3, r1
 800559e:	6053      	str	r3, [r2, #4]

  /* Set the USART address node */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
 80055a0:	6802      	ldr	r2, [r0, #0]
 80055a2:	6853      	ldr	r3, [r2, #4]
 80055a4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 80055a8:	f89d 1006 	ldrb.w	r1, [sp, #6]
 80055ac:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 80055b0:	6053      	str	r3, [r2, #4]
}
 80055b2:	b002      	add	sp, #8
 80055b4:	4770      	bx	lr
	...

080055b8 <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80055b8:	6e43      	ldr	r3, [r0, #100]	@ 0x64
 80055ba:	b92b      	cbnz	r3, 80055c8 <UARTEx_SetNbDataToProcess+0x10>
  {
    huart->NbTxDataToProcess = 1U;
 80055bc:	2301      	movs	r3, #1
 80055be:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
 80055c2:	f8a0 3068 	strh.w	r3, [r0, #104]	@ 0x68
 80055c6:	4770      	bx	lr
{
 80055c8:	b430      	push	{r4, r5}
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80055ca:	6803      	ldr	r3, [r0, #0]
 80055cc:	689a      	ldr	r2, [r3, #8]
 80055ce:	f3c2 6242 	ubfx	r2, r2, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80055d2:	6899      	ldr	r1, [r3, #8]
 80055d4:	0f49      	lsrs	r1, r1, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80055d6:	4d09      	ldr	r5, [pc, #36]	@ (80055fc <UARTEx_SetNbDataToProcess+0x44>)
 80055d8:	5c6b      	ldrb	r3, [r5, r1]
 80055da:	00db      	lsls	r3, r3, #3
                               (uint16_t)denominator[tx_fifo_threshold];
 80055dc:	4c08      	ldr	r4, [pc, #32]	@ (8005600 <UARTEx_SetNbDataToProcess+0x48>)
 80055de:	5c61      	ldrb	r1, [r4, r1]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80055e0:	fb93 f3f1 	sdiv	r3, r3, r1
 80055e4:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80055e8:	5cab      	ldrb	r3, [r5, r2]
 80055ea:	00db      	lsls	r3, r3, #3
                               (uint16_t)denominator[rx_fifo_threshold];
 80055ec:	5ca2      	ldrb	r2, [r4, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80055ee:	fb93 f3f2 	sdiv	r3, r3, r2
 80055f2:	f8a0 3068 	strh.w	r3, [r0, #104]	@ 0x68
  }
}
 80055f6:	bc30      	pop	{r4, r5}
 80055f8:	4770      	bx	lr
 80055fa:	bf00      	nop
 80055fc:	0800692c 	.word	0x0800692c
 8005600:	08006924 	.word	0x08006924

08005604 <HAL_UARTEx_WakeupCallback>:
}
 8005604:	4770      	bx	lr

08005606 <HAL_UARTEx_RxFifoFullCallback>:
}
 8005606:	4770      	bx	lr

08005608 <HAL_UARTEx_TxFifoEmptyCallback>:
}
 8005608:	4770      	bx	lr

0800560a <HAL_UARTEx_StopModeWakeUpSourceConfig>:
{
 800560a:	b510      	push	{r4, lr}
 800560c:	b084      	sub	sp, #16
 800560e:	ab04      	add	r3, sp, #16
 8005610:	e903 0006 	stmdb	r3, {r1, r2}
  __HAL_LOCK(huart);
 8005614:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8005618:	2b01      	cmp	r3, #1
 800561a:	d035      	beq.n	8005688 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7e>
 800561c:	4604      	mov	r4, r0
 800561e:	2301      	movs	r3, #1
 8005620:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 8005624:	2324      	movs	r3, #36	@ 0x24
 8005626:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 800562a:	6802      	ldr	r2, [r0, #0]
 800562c:	6813      	ldr	r3, [r2, #0]
 800562e:	f023 0301 	bic.w	r3, r3, #1
 8005632:	6013      	str	r3, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
 8005634:	6801      	ldr	r1, [r0, #0]
 8005636:	688b      	ldr	r3, [r1, #8]
 8005638:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
 800563c:	9a02      	ldr	r2, [sp, #8]
 800563e:	4313      	orrs	r3, r2
 8005640:	608b      	str	r3, [r1, #8]
  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
 8005642:	b1aa      	cbz	r2, 8005670 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x66>
  __HAL_UART_ENABLE(huart);
 8005644:	6822      	ldr	r2, [r4, #0]
 8005646:	6813      	ldr	r3, [r2, #0]
 8005648:	f043 0301 	orr.w	r3, r3, #1
 800564c:	6013      	str	r3, [r2, #0]
  tickstart = HAL_GetTick();
 800564e:	f7fb fa37 	bl	8000ac0 <HAL_GetTick>
 8005652:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8005654:	f06f 427e 	mvn.w	r2, #4261412864	@ 0xfe000000
 8005658:	9200      	str	r2, [sp, #0]
 800565a:	2200      	movs	r2, #0
 800565c:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 8005660:	4620      	mov	r0, r4
 8005662:	f7ff fdee 	bl	8005242 <UART_WaitOnFlagUntilTimeout>
 8005666:	b948      	cbnz	r0, 800567c <HAL_UARTEx_StopModeWakeUpSourceConfig+0x72>
    huart->gState = HAL_UART_STATE_READY;
 8005668:	2320      	movs	r3, #32
 800566a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
 800566e:	e006      	b.n	800567e <HAL_UARTEx_StopModeWakeUpSourceConfig+0x74>
    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
 8005670:	ab04      	add	r3, sp, #16
 8005672:	e913 0006 	ldmdb	r3, {r1, r2}
 8005676:	f7ff ff87 	bl	8005588 <UARTEx_Wakeup_AddressConfig>
 800567a:	e7e3      	b.n	8005644 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x3a>
    status = HAL_TIMEOUT;
 800567c:	2003      	movs	r0, #3
  __HAL_UNLOCK(huart);
 800567e:	2300      	movs	r3, #0
 8005680:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 8005684:	b004      	add	sp, #16
 8005686:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 8005688:	2002      	movs	r0, #2
 800568a:	e7fb      	b.n	8005684 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7a>

0800568c <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
 800568c:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8005690:	2b01      	cmp	r3, #1
 8005692:	d010      	beq.n	80056b6 <HAL_UARTEx_EnableStopMode+0x2a>
 8005694:	2301      	movs	r3, #1
 8005696:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
 800569a:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800569c:	e852 3f00 	ldrex	r3, [r2]
 80056a0:	f043 0302 	orr.w	r3, r3, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80056a4:	e842 3100 	strex	r1, r3, [r2]
 80056a8:	2900      	cmp	r1, #0
 80056aa:	d1f6      	bne.n	800569a <HAL_UARTEx_EnableStopMode+0xe>
  __HAL_UNLOCK(huart);
 80056ac:	2300      	movs	r3, #0
 80056ae:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  return HAL_OK;
 80056b2:	4618      	mov	r0, r3
 80056b4:	4770      	bx	lr
  __HAL_LOCK(huart);
 80056b6:	2002      	movs	r0, #2
}
 80056b8:	4770      	bx	lr

080056ba <HAL_UARTEx_EnableFifoMode>:
  __HAL_LOCK(huart);
 80056ba:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 80056be:	2b01      	cmp	r3, #1
 80056c0:	d01d      	beq.n	80056fe <HAL_UARTEx_EnableFifoMode+0x44>
{
 80056c2:	b510      	push	{r4, lr}
 80056c4:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 80056c6:	2301      	movs	r3, #1
 80056c8:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 80056cc:	2324      	movs	r3, #36	@ 0x24
 80056ce:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80056d2:	6802      	ldr	r2, [r0, #0]
 80056d4:	6813      	ldr	r3, [r2, #0]
  __HAL_UART_DISABLE(huart);
 80056d6:	6811      	ldr	r1, [r2, #0]
 80056d8:	f021 0101 	bic.w	r1, r1, #1
 80056dc:	6011      	str	r1, [r2, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
 80056de:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 80056e2:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 80056e6:	6642      	str	r2, [r0, #100]	@ 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80056e8:	6802      	ldr	r2, [r0, #0]
 80056ea:	6013      	str	r3, [r2, #0]
  UARTEx_SetNbDataToProcess(huart);
 80056ec:	f7ff ff64 	bl	80055b8 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
 80056f0:	2320      	movs	r3, #32
 80056f2:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 80056f6:	2000      	movs	r0, #0
 80056f8:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 80056fc:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 80056fe:	2002      	movs	r0, #2
}
 8005700:	4770      	bx	lr

08005702 <HAL_UARTEx_SetTxFifoThreshold>:
{
 8005702:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8005704:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8005708:	2b01      	cmp	r3, #1
 800570a:	d01d      	beq.n	8005748 <HAL_UARTEx_SetTxFifoThreshold+0x46>
 800570c:	4604      	mov	r4, r0
 800570e:	2301      	movs	r3, #1
 8005710:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 8005714:	2324      	movs	r3, #36	@ 0x24
 8005716:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800571a:	6803      	ldr	r3, [r0, #0]
 800571c:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 800571e:	681a      	ldr	r2, [r3, #0]
 8005720:	f022 0201 	bic.w	r2, r2, #1
 8005724:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8005726:	6802      	ldr	r2, [r0, #0]
 8005728:	6893      	ldr	r3, [r2, #8]
 800572a:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
 800572e:	4319      	orrs	r1, r3
 8005730:	6091      	str	r1, [r2, #8]
  UARTEx_SetNbDataToProcess(huart);
 8005732:	f7ff ff41 	bl	80055b8 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8005736:	6823      	ldr	r3, [r4, #0]
 8005738:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 800573a:	2320      	movs	r3, #32
 800573c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 8005740:	2000      	movs	r0, #0
 8005742:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 8005746:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8005748:	2002      	movs	r0, #2
 800574a:	e7fc      	b.n	8005746 <HAL_UARTEx_SetTxFifoThreshold+0x44>

0800574c <HAL_UARTEx_SetRxFifoThreshold>:
{
 800574c:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 800574e:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8005752:	2b01      	cmp	r3, #1
 8005754:	d01d      	beq.n	8005792 <HAL_UARTEx_SetRxFifoThreshold+0x46>
 8005756:	4604      	mov	r4, r0
 8005758:	2301      	movs	r3, #1
 800575a:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 800575e:	2324      	movs	r3, #36	@ 0x24
 8005760:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8005764:	6803      	ldr	r3, [r0, #0]
 8005766:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8005768:	681a      	ldr	r2, [r3, #0]
 800576a:	f022 0201 	bic.w	r2, r2, #1
 800576e:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8005770:	6802      	ldr	r2, [r0, #0]
 8005772:	6893      	ldr	r3, [r2, #8]
 8005774:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
 8005778:	4319      	orrs	r1, r3
 800577a:	6091      	str	r1, [r2, #8]
  UARTEx_SetNbDataToProcess(huart);
 800577c:	f7ff ff1c 	bl	80055b8 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8005780:	6823      	ldr	r3, [r4, #0]
 8005782:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8005784:	2320      	movs	r3, #32
 8005786:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 800578a:	2000      	movs	r0, #0
 800578c:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 8005790:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8005792:	2002      	movs	r0, #2
 8005794:	e7fc      	b.n	8005790 <HAL_UARTEx_SetRxFifoThreshold+0x44>
	...

08005798 <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 8005798:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800579a:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800579e:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 80057a0:	4b1e      	ldr	r3, [pc, #120]	@ (800581c <TRACE_AllocateBufer+0x84>)
 80057a2:	f8b3 e012 	ldrh.w	lr, [r3, #18]
 80057a6:	8a1a      	ldrh	r2, [r3, #16]
 80057a8:	4596      	cmp	lr, r2
 80057aa:	d011      	beq.n	80057d0 <TRACE_AllocateBufer+0x38>
#endif
  }
  else
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 80057ac:	4596      	cmp	lr, r2
 80057ae:	d921      	bls.n	80057f4 <TRACE_AllocateBufer+0x5c>
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 80057b0:	f5ce 7300 	rsb	r3, lr, #512	@ 0x200
 80057b4:	b29b      	uxth	r3, r3
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 80057b6:	4283      	cmp	r3, r0
 80057b8:	d81f      	bhi.n	80057fa <TRACE_AllocateBufer+0x62>
 80057ba:	4282      	cmp	r2, r0
 80057bc:	d91d      	bls.n	80057fa <TRACE_AllocateBufer+0x62>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 80057be:	4b17      	ldr	r3, [pc, #92]	@ (800581c <TRACE_AllocateBufer+0x84>)
 80057c0:	2401      	movs	r4, #1
 80057c2:	709c      	strb	r4, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 80057c4:	f8a3 e000 	strh.w	lr, [r3]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 80057c8:	2400      	movs	r4, #0
 80057ca:	825c      	strh	r4, [r3, #18]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
 80057cc:	4613      	mov	r3, r2
 80057ce:	e014      	b.n	80057fa <TRACE_AllocateBufer+0x62>
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 80057d0:	f5ce 7300 	rsb	r3, lr, #512	@ 0x200
 80057d4:	b29b      	uxth	r3, r3
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 80057d6:	4298      	cmp	r0, r3
 80057d8:	d30f      	bcc.n	80057fa <TRACE_AllocateBufer+0x62>
 80057da:	4282      	cmp	r2, r0
 80057dc:	d90d      	bls.n	80057fa <TRACE_AllocateBufer+0x62>
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 80057de:	4b0f      	ldr	r3, [pc, #60]	@ (800581c <TRACE_AllocateBufer+0x84>)
 80057e0:	2401      	movs	r4, #1
 80057e2:	709c      	strb	r4, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 80057e4:	f8a3 e000 	strh.w	lr, [r3]
      ADV_TRACE_Ctx.TraceWrPtr = 0;
 80057e8:	f04f 0e00 	mov.w	lr, #0
 80057ec:	f8a3 e012 	strh.w	lr, [r3, #18]
      freesize = ADV_TRACE_Ctx.TraceRdPtr;
 80057f0:	4613      	mov	r3, r2
 80057f2:	e002      	b.n	80057fa <TRACE_AllocateBufer+0x62>
      }
    }
    else
    {
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 80057f4:	eba2 020e 	sub.w	r2, r2, lr
 80057f8:	b293      	uxth	r3, r2
      freesize = ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr;
    }
#endif
  }

  if(freesize > Size)
 80057fa:	4283      	cmp	r3, r0
 80057fc:	d90a      	bls.n	8005814 <TRACE_AllocateBufer+0x7c>
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 80057fe:	4a07      	ldr	r2, [pc, #28]	@ (800581c <TRACE_AllocateBufer+0x84>)
 8005800:	8a53      	ldrh	r3, [r2, #18]
 8005802:	800b      	strh	r3, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 8005804:	4403      	add	r3, r0
 8005806:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800580a:	8253      	strh	r3, [r2, #18]
    ret = 0;
 800580c:	2000      	movs	r0, #0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800580e:	f38c 8810 	msr	PRIMASK, ip
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 8005812:	bd10      	pop	{r4, pc}
  int16_t ret = -1;
 8005814:	f04f 30ff 	mov.w	r0, #4294967295
 8005818:	e7f9      	b.n	800580e <TRACE_AllocateBufer+0x76>
 800581a:	bf00      	nop
 800581c:	20000788 	.word	0x20000788

08005820 <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005820:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005824:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 8005826:	4a03      	ldr	r2, [pc, #12]	@ (8005834 <TRACE_Lock+0x14>)
 8005828:	8ad3      	ldrh	r3, [r2, #22]
 800582a:	3301      	adds	r3, #1
 800582c:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800582e:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 8005832:	4770      	bx	lr
 8005834:	20000788 	.word	0x20000788

08005838 <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005838:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800583c:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 800583e:	4a03      	ldr	r2, [pc, #12]	@ (800584c <TRACE_UnLock+0x14>)
 8005840:	8ad3      	ldrh	r3, [r2, #22]
 8005842:	3b01      	subs	r3, #1
 8005844:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005846:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 800584a:	4770      	bx	lr
 800584c:	20000788 	.word	0x20000788

08005850 <TRACE_IsLocked>:
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 8005850:	4b02      	ldr	r3, [pc, #8]	@ (800585c <TRACE_IsLocked+0xc>)
 8005852:	8ad8      	ldrh	r0, [r3, #22]
}
 8005854:	3800      	subs	r0, #0
 8005856:	bf18      	it	ne
 8005858:	2001      	movne	r0, #1
 800585a:	4770      	bx	lr
 800585c:	20000788 	.word	0x20000788

08005860 <UTIL_ADV_TRACE_Init>:
{
 8005860:	b508      	push	{r3, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 8005862:	2218      	movs	r2, #24
 8005864:	2100      	movs	r1, #0
 8005866:	4807      	ldr	r0, [pc, #28]	@ (8005884 <UTIL_ADV_TRACE_Init+0x24>)
 8005868:	f000 f9bc 	bl	8005be4 <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 800586c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8005870:	2100      	movs	r1, #0
 8005872:	4805      	ldr	r0, [pc, #20]	@ (8005888 <UTIL_ADV_TRACE_Init+0x28>)
 8005874:	f000 f9b6 	bl	8005be4 <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 8005878:	4b04      	ldr	r3, [pc, #16]	@ (800588c <UTIL_ADV_TRACE_Init+0x2c>)
 800587a:	681b      	ldr	r3, [r3, #0]
 800587c:	4804      	ldr	r0, [pc, #16]	@ (8005890 <UTIL_ADV_TRACE_Init+0x30>)
 800587e:	4798      	blx	r3
}
 8005880:	bd08      	pop	{r3, pc}
 8005882:	bf00      	nop
 8005884:	20000788 	.word	0x20000788
 8005888:	20000588 	.word	0x20000588
 800588c:	08006590 	.word	0x08006590
 8005890:	08005a81 	.word	0x08005a81

08005894 <UTIL_ADV_TRACE_IsBufferEmpty>:
  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 8005894:	4b04      	ldr	r3, [pc, #16]	@ (80058a8 <UTIL_ADV_TRACE_IsBufferEmpty+0x14>)
 8005896:	8a5a      	ldrh	r2, [r3, #18]
 8005898:	8a1b      	ldrh	r3, [r3, #16]
 800589a:	429a      	cmp	r2, r3
 800589c:	d001      	beq.n	80058a2 <UTIL_ADV_TRACE_IsBufferEmpty+0xe>
  return 0;
 800589e:	2000      	movs	r0, #0
 80058a0:	4770      	bx	lr
    return 1;
 80058a2:	2001      	movs	r0, #1
}
 80058a4:	4770      	bx	lr
 80058a6:	bf00      	nop
 80058a8:	20000788 	.word	0x20000788

080058ac <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 80058ac:	4b01      	ldr	r3, [pc, #4]	@ (80058b4 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 80058ae:	6058      	str	r0, [r3, #4]
}
 80058b0:	4770      	bx	lr
 80058b2:	bf00      	nop
 80058b4:	20000788 	.word	0x20000788

080058b8 <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 80058b8:	4b01      	ldr	r3, [pc, #4]	@ (80058c0 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 80058ba:	7218      	strb	r0, [r3, #8]
}
 80058bc:	4770      	bx	lr
 80058be:	bf00      	nop
 80058c0:	20000788 	.word	0x20000788

080058c4 <TRACE_Send>:
{
 80058c4:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80058c6:	f3ef 8310 	mrs	r3, PRIMASK
 80058ca:	461c      	mov	r4, r3
  __ASM volatile ("cpsid i" : : : "memory");
 80058cc:	b672      	cpsid	i
  if(TRACE_IsLocked() == 0u)
 80058ce:	f7ff ffbf 	bl	8005850 <TRACE_IsLocked>
 80058d2:	b118      	cbz	r0, 80058dc <TRACE_Send+0x18>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80058d4:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 80058d8:	2000      	movs	r0, #0
}
 80058da:	bd70      	pop	{r4, r5, r6, pc}
    TRACE_Lock();
 80058dc:	f7ff ffa0 	bl	8005820 <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 80058e0:	4b1c      	ldr	r3, [pc, #112]	@ (8005954 <TRACE_Send+0x90>)
 80058e2:	8a1a      	ldrh	r2, [r3, #16]
 80058e4:	8a5b      	ldrh	r3, [r3, #18]
 80058e6:	429a      	cmp	r2, r3
 80058e8:	d02e      	beq.n	8005948 <TRACE_Send+0x84>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 80058ea:	491a      	ldr	r1, [pc, #104]	@ (8005954 <TRACE_Send+0x90>)
 80058ec:	7889      	ldrb	r1, [r1, #2]
 80058ee:	2901      	cmp	r1, #1
 80058f0:	d017      	beq.n	8005922 <TRACE_Send+0x5e>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 80058f2:	4a18      	ldr	r2, [pc, #96]	@ (8005954 <TRACE_Send+0x90>)
 80058f4:	7892      	ldrb	r2, [r2, #2]
 80058f6:	b932      	cbnz	r2, 8005906 <TRACE_Send+0x42>
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 80058f8:	4a16      	ldr	r2, [pc, #88]	@ (8005954 <TRACE_Send+0x90>)
 80058fa:	8a12      	ldrh	r2, [r2, #16]
 80058fc:	4293      	cmp	r3, r2
 80058fe:	d91e      	bls.n	800593e <TRACE_Send+0x7a>
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8005900:	1a9b      	subs	r3, r3, r2
 8005902:	4a14      	ldr	r2, [pc, #80]	@ (8005954 <TRACE_Send+0x90>)
 8005904:	8293      	strh	r3, [r2, #20]
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8005906:	4e13      	ldr	r6, [pc, #76]	@ (8005954 <TRACE_Send+0x90>)
 8005908:	8a35      	ldrh	r5, [r6, #16]
 800590a:	4b13      	ldr	r3, [pc, #76]	@ (8005958 <TRACE_Send+0x94>)
 800590c:	441d      	add	r5, r3
 800590e:	f384 8810 	msr	PRIMASK, r4
      UTIL_ADV_TRACE_PreSendHook();
 8005912:	f7fb f8c8 	bl	8000aa6 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8005916:	4b11      	ldr	r3, [pc, #68]	@ (800595c <TRACE_Send+0x98>)
 8005918:	68db      	ldr	r3, [r3, #12]
 800591a:	8ab1      	ldrh	r1, [r6, #20]
 800591c:	4628      	mov	r0, r5
 800591e:	4798      	blx	r3
 8005920:	e7db      	b.n	80058da <TRACE_Send+0x16>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 8005922:	480c      	ldr	r0, [pc, #48]	@ (8005954 <TRACE_Send+0x90>)
 8005924:	8801      	ldrh	r1, [r0, #0]
 8005926:	1a8a      	subs	r2, r1, r2
 8005928:	b292      	uxth	r2, r2
 800592a:	8282      	strh	r2, [r0, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 800592c:	2102      	movs	r1, #2
 800592e:	7081      	strb	r1, [r0, #2]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 8005930:	2100      	movs	r1, #0
 8005932:	8001      	strh	r1, [r0, #0]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8005934:	2a00      	cmp	r2, #0
 8005936:	d1dc      	bne.n	80058f2 <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8005938:	7081      	strb	r1, [r0, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 800593a:	8201      	strh	r1, [r0, #16]
 800593c:	e7d9      	b.n	80058f2 <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 800593e:	f5c2 7200 	rsb	r2, r2, #512	@ 0x200
 8005942:	4b04      	ldr	r3, [pc, #16]	@ (8005954 <TRACE_Send+0x90>)
 8005944:	829a      	strh	r2, [r3, #20]
 8005946:	e7de      	b.n	8005906 <TRACE_Send+0x42>
      TRACE_UnLock();
 8005948:	f7ff ff76 	bl	8005838 <TRACE_UnLock>
 800594c:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 8005950:	2000      	movs	r0, #0
}
 8005952:	e7c2      	b.n	80058da <TRACE_Send+0x16>
 8005954:	20000788 	.word	0x20000788
 8005958:	20000588 	.word	0x20000588
 800595c:	08006590 	.word	0x08006590

08005960 <UTIL_ADV_TRACE_COND_FSend>:
{
 8005960:	b408      	push	{r3}
 8005962:	b530      	push	{r4, r5, lr}
 8005964:	b086      	sub	sp, #24
 8005966:	9c09      	ldr	r4, [sp, #36]	@ 0x24
  uint16_t timestamp_size = 0u;
 8005968:	2300      	movs	r3, #0
 800596a:	f8ad 3002 	strh.w	r3, [sp, #2]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 800596e:	4b2b      	ldr	r3, [pc, #172]	@ (8005a1c <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8005970:	7a1b      	ldrb	r3, [r3, #8]
 8005972:	4283      	cmp	r3, r0
 8005974:	d34c      	bcc.n	8005a10 <UTIL_ADV_TRACE_COND_FSend+0xb0>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 8005976:	4b29      	ldr	r3, [pc, #164]	@ (8005a1c <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8005978:	68db      	ldr	r3, [r3, #12]
 800597a:	4399      	bics	r1, r3
 800597c:	d14b      	bne.n	8005a16 <UTIL_ADV_TRACE_COND_FSend+0xb6>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 800597e:	4b27      	ldr	r3, [pc, #156]	@ (8005a1c <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8005980:	685b      	ldr	r3, [r3, #4]
 8005982:	b123      	cbz	r3, 800598e <UTIL_ADV_TRACE_COND_FSend+0x2e>
 8005984:	b11a      	cbz	r2, 800598e <UTIL_ADV_TRACE_COND_FSend+0x2e>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 8005986:	f10d 0102 	add.w	r1, sp, #2
 800598a:	a801      	add	r0, sp, #4
 800598c:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 800598e:	ab0a      	add	r3, sp, #40	@ 0x28
 8005990:	9305      	str	r3, [sp, #20]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8005992:	4622      	mov	r2, r4
 8005994:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8005998:	4821      	ldr	r0, [pc, #132]	@ (8005a20 <UTIL_ADV_TRACE_COND_FSend+0xc0>)
 800599a:	f000 fc01 	bl	80061a0 <tiny_vsnprintf_like>
 800599e:	b285      	uxth	r5, r0
  TRACE_Lock();
 80059a0:	f7ff ff3e 	bl	8005820 <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 80059a4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80059a8:	18e8      	adds	r0, r5, r3
 80059aa:	4669      	mov	r1, sp
 80059ac:	b280      	uxth	r0, r0
 80059ae:	f7ff fef3 	bl	8005798 <TRACE_AllocateBufer>
 80059b2:	f1b0 3fff 	cmp.w	r0, #4294967295
 80059b6:	d026      	beq.n	8005a06 <UTIL_ADV_TRACE_COND_FSend+0xa6>
    for (idx = 0u; idx < timestamp_size; idx++)
 80059b8:	2300      	movs	r3, #0
 80059ba:	e00d      	b.n	80059d8 <UTIL_ADV_TRACE_COND_FSend+0x78>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 80059bc:	f8bd 2000 	ldrh.w	r2, [sp]
 80059c0:	f103 0118 	add.w	r1, r3, #24
 80059c4:	4469      	add	r1, sp
 80059c6:	f811 0c14 	ldrb.w	r0, [r1, #-20]
 80059ca:	4916      	ldr	r1, [pc, #88]	@ (8005a24 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 80059cc:	5488      	strb	r0, [r1, r2]
      writepos = writepos + 1u;
 80059ce:	3201      	adds	r2, #1
 80059d0:	f8ad 2000 	strh.w	r2, [sp]
    for (idx = 0u; idx < timestamp_size; idx++)
 80059d4:	3301      	adds	r3, #1
 80059d6:	b29b      	uxth	r3, r3
 80059d8:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 80059dc:	429a      	cmp	r2, r3
 80059de:	d8ed      	bhi.n	80059bc <UTIL_ADV_TRACE_COND_FSend+0x5c>
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 80059e0:	f8bd 0000 	ldrh.w	r0, [sp]
 80059e4:	9b05      	ldr	r3, [sp, #20]
 80059e6:	4622      	mov	r2, r4
 80059e8:	f44f 7180 	mov.w	r1, #256	@ 0x100
 80059ec:	4c0d      	ldr	r4, [pc, #52]	@ (8005a24 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 80059ee:	4420      	add	r0, r4
 80059f0:	f000 fbd6 	bl	80061a0 <tiny_vsnprintf_like>
    TRACE_UnLock();
 80059f4:	f7ff ff20 	bl	8005838 <TRACE_UnLock>
    return TRACE_Send();
 80059f8:	f7ff ff64 	bl	80058c4 <TRACE_Send>
}
 80059fc:	b006      	add	sp, #24
 80059fe:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8005a02:	b001      	add	sp, #4
 8005a04:	4770      	bx	lr
  TRACE_UnLock();
 8005a06:	f7ff ff17 	bl	8005838 <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 8005a0a:	f06f 0002 	mvn.w	r0, #2
 8005a0e:	e7f5      	b.n	80059fc <UTIL_ADV_TRACE_COND_FSend+0x9c>
    return UTIL_ADV_TRACE_GIVEUP;
 8005a10:	f06f 0004 	mvn.w	r0, #4
 8005a14:	e7f2      	b.n	80059fc <UTIL_ADV_TRACE_COND_FSend+0x9c>
    return UTIL_ADV_TRACE_REGIONMASKED;
 8005a16:	f06f 0005 	mvn.w	r0, #5
 8005a1a:	e7ef      	b.n	80059fc <UTIL_ADV_TRACE_COND_FSend+0x9c>
 8005a1c:	20000788 	.word	0x20000788
 8005a20:	20000488 	.word	0x20000488
 8005a24:	20000588 	.word	0x20000588

08005a28 <UTIL_ADV_TRACE_Send>:
{
 8005a28:	b570      	push	{r4, r5, r6, lr}
 8005a2a:	b082      	sub	sp, #8
 8005a2c:	4606      	mov	r6, r0
 8005a2e:	460d      	mov	r5, r1
  TRACE_Lock();
 8005a30:	f7ff fef6 	bl	8005820 <TRACE_Lock>
  if (TRACE_AllocateBufer(Length,&writepos) != -1)
 8005a34:	f10d 0106 	add.w	r1, sp, #6
 8005a38:	4628      	mov	r0, r5
 8005a3a:	f7ff fead 	bl	8005798 <TRACE_AllocateBufer>
 8005a3e:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005a42:	d016      	beq.n	8005a72 <UTIL_ADV_TRACE_Send+0x4a>
    for (idx = 0u; idx < Length; idx++)
 8005a44:	2200      	movs	r2, #0
 8005a46:	e00c      	b.n	8005a62 <UTIL_ADV_TRACE_Send+0x3a>
      ADV_TRACE_Buffer[writepos] = pData[idx];
 8005a48:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8005a4c:	f816 c002 	ldrb.w	ip, [r6, r2]
 8005a50:	4c0a      	ldr	r4, [pc, #40]	@ (8005a7c <UTIL_ADV_TRACE_Send+0x54>)
 8005a52:	f804 c003 	strb.w	ip, [r4, r3]
      writepos = (uint16_t) ((writepos + 1u) % UTIL_ADV_TRACE_FIFO_SIZE);
 8005a56:	3301      	adds	r3, #1
 8005a58:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005a5c:	f8ad 3006 	strh.w	r3, [sp, #6]
    for (idx = 0u; idx < Length; idx++)
 8005a60:	3201      	adds	r2, #1
 8005a62:	4295      	cmp	r5, r2
 8005a64:	d8f0      	bhi.n	8005a48 <UTIL_ADV_TRACE_Send+0x20>
    TRACE_UnLock();
 8005a66:	f7ff fee7 	bl	8005838 <TRACE_UnLock>
    ret = TRACE_Send();
 8005a6a:	f7ff ff2b 	bl	80058c4 <TRACE_Send>
}
 8005a6e:	b002      	add	sp, #8
 8005a70:	bd70      	pop	{r4, r5, r6, pc}
    TRACE_UnLock();
 8005a72:	f7ff fee1 	bl	8005838 <TRACE_UnLock>
    ret = UTIL_ADV_TRACE_MEM_FULL;
 8005a76:	f06f 0002 	mvn.w	r0, #2
 8005a7a:	e7f8      	b.n	8005a6e <UTIL_ADV_TRACE_Send+0x46>
 8005a7c:	20000588 	.word	0x20000588

08005a80 <TRACE_TxCpltCallback>:
{
 8005a80:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005a82:	f3ef 8310 	mrs	r3, PRIMASK
 8005a86:	4619      	mov	r1, r3
  __ASM volatile ("cpsid i" : : : "memory");
 8005a88:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 8005a8a:	4b26      	ldr	r3, [pc, #152]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005a8c:	789b      	ldrb	r3, [r3, #2]
 8005a8e:	2b02      	cmp	r3, #2
 8005a90:	d016      	beq.n	8005ac0 <TRACE_TxCpltCallback+0x40>
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 8005a92:	4a24      	ldr	r2, [pc, #144]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005a94:	8a13      	ldrh	r3, [r2, #16]
 8005a96:	8a90      	ldrh	r0, [r2, #20]
 8005a98:	4403      	add	r3, r0
 8005a9a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005a9e:	8213      	strh	r3, [r2, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 8005aa0:	4b20      	ldr	r3, [pc, #128]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005aa2:	8a1a      	ldrh	r2, [r3, #16]
 8005aa4:	8a5b      	ldrh	r3, [r3, #18]
 8005aa6:	429a      	cmp	r2, r3
 8005aa8:	d003      	beq.n	8005ab2 <TRACE_TxCpltCallback+0x32>
 8005aaa:	481e      	ldr	r0, [pc, #120]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005aac:	8ac0      	ldrh	r0, [r0, #22]
 8005aae:	2801      	cmp	r0, #1
 8005ab0:	d00b      	beq.n	8005aca <TRACE_TxCpltCallback+0x4a>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005ab2:	f381 8810 	msr	PRIMASK, r1
    UTIL_ADV_TRACE_PostSendHook();
 8005ab6:	f7fa fffc 	bl	8000ab2 <UTIL_ADV_TRACE_PostSendHook>
    TRACE_UnLock();
 8005aba:	f7ff febd 	bl	8005838 <TRACE_UnLock>
}
 8005abe:	bd10      	pop	{r4, pc}
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8005ac0:	4b18      	ldr	r3, [pc, #96]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005ac2:	2200      	movs	r2, #0
 8005ac4:	709a      	strb	r2, [r3, #2]
    ADV_TRACE_Ctx.TraceRdPtr = 0;
 8005ac6:	821a      	strh	r2, [r3, #16]
    UTIL_ADV_TRACE_DEBUG("\nTRACE_TxCpltCallback::unchunk complete\n");
 8005ac8:	e7ea      	b.n	8005aa0 <TRACE_TxCpltCallback+0x20>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8005aca:	4816      	ldr	r0, [pc, #88]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005acc:	7880      	ldrb	r0, [r0, #2]
 8005ace:	2801      	cmp	r0, #1
 8005ad0:	d014      	beq.n	8005afc <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8005ad2:	4a14      	ldr	r2, [pc, #80]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005ad4:	7892      	ldrb	r2, [r2, #2]
 8005ad6:	b932      	cbnz	r2, 8005ae6 <TRACE_TxCpltCallback+0x66>
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8005ad8:	4a12      	ldr	r2, [pc, #72]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005ada:	8a12      	ldrh	r2, [r2, #16]
 8005adc:	4293      	cmp	r3, r2
 8005ade:	d91b      	bls.n	8005b18 <TRACE_TxCpltCallback+0x98>
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8005ae0:	1a9b      	subs	r3, r3, r2
 8005ae2:	4a10      	ldr	r2, [pc, #64]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005ae4:	8293      	strh	r3, [r2, #20]
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8005ae6:	4b0f      	ldr	r3, [pc, #60]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005ae8:	8a18      	ldrh	r0, [r3, #16]
 8005aea:	4a0f      	ldr	r2, [pc, #60]	@ (8005b28 <TRACE_TxCpltCallback+0xa8>)
 8005aec:	4410      	add	r0, r2
 8005aee:	f381 8810 	msr	PRIMASK, r1
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8005af2:	4a0e      	ldr	r2, [pc, #56]	@ (8005b2c <TRACE_TxCpltCallback+0xac>)
 8005af4:	68d2      	ldr	r2, [r2, #12]
 8005af6:	8a99      	ldrh	r1, [r3, #20]
 8005af8:	4790      	blx	r2
 8005afa:	e7e0      	b.n	8005abe <TRACE_TxCpltCallback+0x3e>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 8005afc:	4c09      	ldr	r4, [pc, #36]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005afe:	8820      	ldrh	r0, [r4, #0]
 8005b00:	1a82      	subs	r2, r0, r2
 8005b02:	b292      	uxth	r2, r2
 8005b04:	82a2      	strh	r2, [r4, #20]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 8005b06:	2002      	movs	r0, #2
 8005b08:	70a0      	strb	r0, [r4, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 8005b0a:	2000      	movs	r0, #0
 8005b0c:	8020      	strh	r0, [r4, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8005b0e:	2a00      	cmp	r2, #0
 8005b10:	d1df      	bne.n	8005ad2 <TRACE_TxCpltCallback+0x52>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8005b12:	70a0      	strb	r0, [r4, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 8005b14:	8220      	strh	r0, [r4, #16]
 8005b16:	e7dc      	b.n	8005ad2 <TRACE_TxCpltCallback+0x52>
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 8005b18:	f5c2 7200 	rsb	r2, r2, #512	@ 0x200
 8005b1c:	4b01      	ldr	r3, [pc, #4]	@ (8005b24 <TRACE_TxCpltCallback+0xa4>)
 8005b1e:	829a      	strh	r2, [r3, #20]
 8005b20:	e7e1      	b.n	8005ae6 <TRACE_TxCpltCallback+0x66>
 8005b22:	bf00      	nop
 8005b24:	20000788 	.word	0x20000788
 8005b28:	20000588 	.word	0x20000588
 8005b2c:	08006590 	.word	0x08006590

08005b30 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 8005b30:	2300      	movs	r3, #0
 8005b32:	4a02      	ldr	r2, [pc, #8]	@ (8005b3c <UTIL_LPM_Init+0xc>)
 8005b34:	6013      	str	r3, [r2, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 8005b36:	4a02      	ldr	r2, [pc, #8]	@ (8005b40 <UTIL_LPM_Init+0x10>)
 8005b38:	6013      	str	r3, [r2, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 8005b3a:	4770      	bx	lr
 8005b3c:	200007a4 	.word	0x200007a4
 8005b40:	200007a0 	.word	0x200007a0

08005b44 <UTIL_LPM_SetStopMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005b44:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005b48:	b672      	cpsid	i

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 8005b4a:	b141      	cbz	r1, 8005b5e <UTIL_LPM_SetStopMode+0x1a>
 8005b4c:	2901      	cmp	r1, #1
 8005b4e:	d103      	bne.n	8005b58 <UTIL_LPM_SetStopMode+0x14>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 8005b50:	4906      	ldr	r1, [pc, #24]	@ (8005b6c <UTIL_LPM_SetStopMode+0x28>)
 8005b52:	680a      	ldr	r2, [r1, #0]
 8005b54:	4302      	orrs	r2, r0
 8005b56:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005b58:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8005b5c:	4770      	bx	lr
      StopModeDisable &= ( ~lpm_id_bm );
 8005b5e:	4903      	ldr	r1, [pc, #12]	@ (8005b6c <UTIL_LPM_SetStopMode+0x28>)
 8005b60:	680a      	ldr	r2, [r1, #0]
 8005b62:	ea22 0200 	bic.w	r2, r2, r0
 8005b66:	600a      	str	r2, [r1, #0]
      break;
 8005b68:	e7f6      	b.n	8005b58 <UTIL_LPM_SetStopMode+0x14>
 8005b6a:	bf00      	nop
 8005b6c:	200007a4 	.word	0x200007a4

08005b70 <UTIL_LPM_SetOffMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005b70:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005b74:	b672      	cpsid	i

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 8005b76:	b141      	cbz	r1, 8005b8a <UTIL_LPM_SetOffMode+0x1a>
 8005b78:	2901      	cmp	r1, #1
 8005b7a:	d103      	bne.n	8005b84 <UTIL_LPM_SetOffMode+0x14>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 8005b7c:	4906      	ldr	r1, [pc, #24]	@ (8005b98 <UTIL_LPM_SetOffMode+0x28>)
 8005b7e:	680a      	ldr	r2, [r1, #0]
 8005b80:	4302      	orrs	r2, r0
 8005b82:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005b84:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8005b88:	4770      	bx	lr
      OffModeDisable &= ( ~lpm_id_bm );
 8005b8a:	4903      	ldr	r1, [pc, #12]	@ (8005b98 <UTIL_LPM_SetOffMode+0x28>)
 8005b8c:	680a      	ldr	r2, [r1, #0]
 8005b8e:	ea22 0200 	bic.w	r2, r2, r0
 8005b92:	600a      	str	r2, [r1, #0]
      break;
 8005b94:	e7f6      	b.n	8005b84 <UTIL_LPM_SetOffMode+0x14>
 8005b96:	bf00      	nop
 8005b98:	200007a0 	.word	0x200007a0

08005b9c <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 8005b9c:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005b9e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005ba2:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 8005ba4:	4b0c      	ldr	r3, [pc, #48]	@ (8005bd8 <UTIL_LPM_EnterLowPower+0x3c>)
 8005ba6:	681b      	ldr	r3, [r3, #0]
 8005ba8:	b13b      	cbz	r3, 8005bba <UTIL_LPM_EnterLowPower+0x1e>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 8005baa:	4d0c      	ldr	r5, [pc, #48]	@ (8005bdc <UTIL_LPM_EnterLowPower+0x40>)
 8005bac:	682b      	ldr	r3, [r5, #0]
 8005bae:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 8005bb0:	686b      	ldr	r3, [r5, #4]
 8005bb2:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005bb4:	f384 8810 	msr	PRIMASK, r4
      UTIL_PowerDriver.ExitOffMode( );
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 8005bb8:	bd38      	pop	{r3, r4, r5, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 8005bba:	4b09      	ldr	r3, [pc, #36]	@ (8005be0 <UTIL_LPM_EnterLowPower+0x44>)
 8005bbc:	681b      	ldr	r3, [r3, #0]
 8005bbe:	b12b      	cbz	r3, 8005bcc <UTIL_LPM_EnterLowPower+0x30>
        UTIL_PowerDriver.EnterStopMode( );
 8005bc0:	4d06      	ldr	r5, [pc, #24]	@ (8005bdc <UTIL_LPM_EnterLowPower+0x40>)
 8005bc2:	68ab      	ldr	r3, [r5, #8]
 8005bc4:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 8005bc6:	68eb      	ldr	r3, [r5, #12]
 8005bc8:	4798      	blx	r3
 8005bca:	e7f3      	b.n	8005bb4 <UTIL_LPM_EnterLowPower+0x18>
      UTIL_PowerDriver.EnterOffMode( );
 8005bcc:	4d03      	ldr	r5, [pc, #12]	@ (8005bdc <UTIL_LPM_EnterLowPower+0x40>)
 8005bce:	692b      	ldr	r3, [r5, #16]
 8005bd0:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 8005bd2:	696b      	ldr	r3, [r5, #20]
 8005bd4:	4798      	blx	r3
 8005bd6:	e7ed      	b.n	8005bb4 <UTIL_LPM_EnterLowPower+0x18>
 8005bd8:	200007a4 	.word	0x200007a4
 8005bdc:	080063b4 	.word	0x080063b4
 8005be0:	200007a0 	.word	0x200007a0

08005be4 <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 8005be4:	e002      	b.n	8005bec <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
 8005be6:	f800 1b01 	strb.w	r1, [r0], #1
  while( size-- )
 8005bea:	461a      	mov	r2, r3
 8005bec:	1e53      	subs	r3, r2, #1
 8005bee:	b29b      	uxth	r3, r3
 8005bf0:	2a00      	cmp	r2, #0
 8005bf2:	d1f8      	bne.n	8005be6 <UTIL_MEM_set_8+0x2>
  }
}
 8005bf4:	4770      	bx	lr
	...

08005bf8 <UTIL_SEQ_SetTask>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005bf8:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005bfc:	b672      	cpsid	i

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 8005bfe:	4a06      	ldr	r2, [pc, #24]	@ (8005c18 <UTIL_SEQ_SetTask+0x20>)
 8005c00:	6813      	ldr	r3, [r2, #0]
 8005c02:	4303      	orrs	r3, r0
 8005c04:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 8005c06:	4a05      	ldr	r2, [pc, #20]	@ (8005c1c <UTIL_SEQ_SetTask+0x24>)
 8005c08:	f852 3031 	ldr.w	r3, [r2, r1, lsl #3]
 8005c0c:	4303      	orrs	r3, r0
 8005c0e:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005c12:	f38c 8810 	msr	PRIMASK, ip

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 8005c16:	4770      	bx	lr
 8005c18:	200007c8 	.word	0x200007c8
 8005c1c:	200007a8 	.word	0x200007a8

08005c20 <UTIL_SEQ_SetEvt>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005c20:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005c24:	b672      	cpsid	i

void UTIL_SEQ_SetEvt( UTIL_SEQ_bm_t EvtId_bm )
{
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  EvtSet |= EvtId_bm;
 8005c26:	4a03      	ldr	r2, [pc, #12]	@ (8005c34 <UTIL_SEQ_SetEvt+0x14>)
 8005c28:	6813      	ldr	r3, [r2, #0]
 8005c2a:	4318      	orrs	r0, r3
 8005c2c:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005c2e:	f381 8810 	msr	PRIMASK, r1

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 8005c32:	4770      	bx	lr
 8005c34:	200007c4 	.word	0x200007c4

08005c38 <UTIL_SEQ_PreIdle>:
{
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 8005c38:	4770      	bx	lr

08005c3a <UTIL_SEQ_PostIdle>:
{
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 8005c3a:	4770      	bx	lr

08005c3c <SEQ_BitPosition>:
uint8_t SEQ_BitPosition(uint32_t Value)
{
uint8_t n = 0U;
uint32_t lvalue = Value;

  if ((lvalue & 0xFFFF0000U) == 0U)  { n  = 16U; lvalue <<= 16U;  }
 8005c3c:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 8005c40:	d216      	bcs.n	8005c70 <SEQ_BitPosition+0x34>
 8005c42:	0400      	lsls	r0, r0, #16
 8005c44:	2310      	movs	r3, #16
  if ((lvalue & 0xFF000000U) == 0U)  { n +=  8U; lvalue <<=  8U;  }
 8005c46:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 8005c4a:	d202      	bcs.n	8005c52 <SEQ_BitPosition+0x16>
 8005c4c:	3308      	adds	r3, #8
 8005c4e:	b2db      	uxtb	r3, r3
 8005c50:	0200      	lsls	r0, r0, #8
  if ((lvalue & 0xF0000000U) == 0U)  { n +=  4U; lvalue <<=  4U;  }
 8005c52:	f1b0 5f80 	cmp.w	r0, #268435456	@ 0x10000000
 8005c56:	d202      	bcs.n	8005c5e <SEQ_BitPosition+0x22>
 8005c58:	3304      	adds	r3, #4
 8005c5a:	b2db      	uxtb	r3, r3
 8005c5c:	0100      	lsls	r0, r0, #4

  n += SEQ_clz_table_4bit[lvalue >> (32-4)];
 8005c5e:	0f00      	lsrs	r0, r0, #28
 8005c60:	4a04      	ldr	r2, [pc, #16]	@ (8005c74 <SEQ_BitPosition+0x38>)
 8005c62:	5c10      	ldrb	r0, [r2, r0]
 8005c64:	4418      	add	r0, r3
 8005c66:	b2c0      	uxtb	r0, r0

  return (uint8_t)(31U-n);
 8005c68:	f1c0 001f 	rsb	r0, r0, #31
}
 8005c6c:	b2c0      	uxtb	r0, r0
 8005c6e:	4770      	bx	lr
uint8_t n = 0U;
 8005c70:	2300      	movs	r3, #0
 8005c72:	e7e8      	b.n	8005c46 <SEQ_BitPosition+0xa>
 8005c74:	08006934 	.word	0x08006934

08005c78 <UTIL_SEQ_Run>:
{
 8005c78:	b570      	push	{r4, r5, r6, lr}
  super_mask_backup = SuperMask;
 8005c7a:	4b42      	ldr	r3, [pc, #264]	@ (8005d84 <UTIL_SEQ_Run+0x10c>)
 8005c7c:	681c      	ldr	r4, [r3, #0]
  SuperMask &= Mask_bm;
 8005c7e:	4020      	ands	r0, r4
 8005c80:	6018      	str	r0, [r3, #0]
  local_taskset = TaskSet;
 8005c82:	4b41      	ldr	r3, [pc, #260]	@ (8005d88 <UTIL_SEQ_Run+0x110>)
 8005c84:	681a      	ldr	r2, [r3, #0]
  local_evtset = EvtSet;
 8005c86:	4b41      	ldr	r3, [pc, #260]	@ (8005d8c <UTIL_SEQ_Run+0x114>)
 8005c88:	681b      	ldr	r3, [r3, #0]
  local_taskmask = TaskMask;
 8005c8a:	4941      	ldr	r1, [pc, #260]	@ (8005d90 <UTIL_SEQ_Run+0x118>)
 8005c8c:	6808      	ldr	r0, [r1, #0]
  local_evtwaited =  EvtWaited;
 8005c8e:	4941      	ldr	r1, [pc, #260]	@ (8005d94 <UTIL_SEQ_Run+0x11c>)
 8005c90:	6809      	ldr	r1, [r1, #0]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8005c92:	e02f      	b.n	8005cf4 <UTIL_SEQ_Run+0x7c>
      counter++;
 8005c94:	3301      	adds	r3, #1
 8005c96:	e034      	b.n	8005d02 <UTIL_SEQ_Run+0x8a>
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 8005c98:	4d3f      	ldr	r5, [pc, #252]	@ (8005d98 <UTIL_SEQ_Run+0x120>)
 8005c9a:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 8005c9e:	6868      	ldr	r0, [r5, #4]
 8005ca0:	4010      	ands	r0, r2
 8005ca2:	f7ff ffcb 	bl	8005c3c <SEQ_BitPosition>
 8005ca6:	4e3d      	ldr	r6, [pc, #244]	@ (8005d9c <UTIL_SEQ_Run+0x124>)
 8005ca8:	6030      	str	r0, [r6, #0]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 8005caa:	686a      	ldr	r2, [r5, #4]
 8005cac:	2301      	movs	r3, #1
 8005cae:	fa03 f000 	lsl.w	r0, r3, r0
 8005cb2:	ea22 0200 	bic.w	r2, r2, r0
 8005cb6:	606a      	str	r2, [r5, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005cb8:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005cbc:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 8005cbe:	6832      	ldr	r2, [r6, #0]
 8005cc0:	fa03 f202 	lsl.w	r2, r3, r2
 8005cc4:	43d6      	mvns	r6, r2
 8005cc6:	4d30      	ldr	r5, [pc, #192]	@ (8005d88 <UTIL_SEQ_Run+0x110>)
 8005cc8:	6828      	ldr	r0, [r5, #0]
 8005cca:	ea20 0202 	bic.w	r2, r0, r2
 8005cce:	602a      	str	r2, [r5, #0]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8005cd0:	2b00      	cmp	r3, #0
 8005cd2:	d12d      	bne.n	8005d30 <UTIL_SEQ_Run+0xb8>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005cd4:	f381 8810 	msr	PRIMASK, r1
    TaskCb[CurrentTaskIdx]( );
 8005cd8:	4b30      	ldr	r3, [pc, #192]	@ (8005d9c <UTIL_SEQ_Run+0x124>)
 8005cda:	681a      	ldr	r2, [r3, #0]
 8005cdc:	4b30      	ldr	r3, [pc, #192]	@ (8005da0 <UTIL_SEQ_Run+0x128>)
 8005cde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005ce2:	4798      	blx	r3
    local_taskset = TaskSet;
 8005ce4:	4b28      	ldr	r3, [pc, #160]	@ (8005d88 <UTIL_SEQ_Run+0x110>)
 8005ce6:	681a      	ldr	r2, [r3, #0]
    local_evtset = EvtSet;
 8005ce8:	4b28      	ldr	r3, [pc, #160]	@ (8005d8c <UTIL_SEQ_Run+0x114>)
 8005cea:	681b      	ldr	r3, [r3, #0]
    local_taskmask = TaskMask;
 8005cec:	4928      	ldr	r1, [pc, #160]	@ (8005d90 <UTIL_SEQ_Run+0x118>)
 8005cee:	6808      	ldr	r0, [r1, #0]
    local_evtwaited = EvtWaited;
 8005cf0:	4928      	ldr	r1, [pc, #160]	@ (8005d94 <UTIL_SEQ_Run+0x11c>)
 8005cf2:	6809      	ldr	r1, [r1, #0]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8005cf4:	4002      	ands	r2, r0
 8005cf6:	4d23      	ldr	r5, [pc, #140]	@ (8005d84 <UTIL_SEQ_Run+0x10c>)
 8005cf8:	682d      	ldr	r5, [r5, #0]
 8005cfa:	422a      	tst	r2, r5
 8005cfc:	d020      	beq.n	8005d40 <UTIL_SEQ_Run+0xc8>
 8005cfe:	400b      	ands	r3, r1
 8005d00:	d11e      	bne.n	8005d40 <UTIL_SEQ_Run+0xc8>
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 8005d02:	4a25      	ldr	r2, [pc, #148]	@ (8005d98 <UTIL_SEQ_Run+0x120>)
 8005d04:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8005d08:	4002      	ands	r2, r0
 8005d0a:	422a      	tst	r2, r5
 8005d0c:	d0c2      	beq.n	8005c94 <UTIL_SEQ_Run+0x1c>
    current_task_set = TaskPrio[counter].priority & local_taskmask & SuperMask;
 8005d0e:	4922      	ldr	r1, [pc, #136]	@ (8005d98 <UTIL_SEQ_Run+0x120>)
 8005d10:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
 8005d14:	4002      	ands	r2, r0
 8005d16:	402a      	ands	r2, r5
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 8005d18:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8005d1c:	6849      	ldr	r1, [r1, #4]
 8005d1e:	4211      	tst	r1, r2
 8005d20:	d1ba      	bne.n	8005c98 <UTIL_SEQ_Run+0x20>
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 8005d22:	491d      	ldr	r1, [pc, #116]	@ (8005d98 <UTIL_SEQ_Run+0x120>)
 8005d24:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8005d28:	f04f 30ff 	mov.w	r0, #4294967295
 8005d2c:	6048      	str	r0, [r1, #4]
 8005d2e:	e7b3      	b.n	8005c98 <UTIL_SEQ_Run+0x20>
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 8005d30:	3b01      	subs	r3, #1
 8005d32:	4819      	ldr	r0, [pc, #100]	@ (8005d98 <UTIL_SEQ_Run+0x120>)
 8005d34:	f850 2033 	ldr.w	r2, [r0, r3, lsl #3]
 8005d38:	4032      	ands	r2, r6
 8005d3a:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8005d3e:	e7c7      	b.n	8005cd0 <UTIL_SEQ_Run+0x58>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 8005d40:	4b16      	ldr	r3, [pc, #88]	@ (8005d9c <UTIL_SEQ_Run+0x124>)
 8005d42:	f04f 32ff 	mov.w	r2, #4294967295
 8005d46:	601a      	str	r2, [r3, #0]
  UTIL_SEQ_PreIdle( );
 8005d48:	f7ff ff76 	bl	8005c38 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005d4c:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005d50:	b672      	cpsid	i
  local_taskset = TaskSet;
 8005d52:	4b0d      	ldr	r3, [pc, #52]	@ (8005d88 <UTIL_SEQ_Run+0x110>)
 8005d54:	681b      	ldr	r3, [r3, #0]
  local_evtset = EvtSet;
 8005d56:	4a0d      	ldr	r2, [pc, #52]	@ (8005d8c <UTIL_SEQ_Run+0x114>)
 8005d58:	6811      	ldr	r1, [r2, #0]
  local_taskmask = TaskMask;
 8005d5a:	4a0d      	ldr	r2, [pc, #52]	@ (8005d90 <UTIL_SEQ_Run+0x118>)
 8005d5c:	6812      	ldr	r2, [r2, #0]
  if ((local_taskset & local_taskmask & SuperMask) == 0U)
 8005d5e:	4013      	ands	r3, r2
 8005d60:	4a08      	ldr	r2, [pc, #32]	@ (8005d84 <UTIL_SEQ_Run+0x10c>)
 8005d62:	6812      	ldr	r2, [r2, #0]
 8005d64:	4213      	tst	r3, r2
 8005d66:	d103      	bne.n	8005d70 <UTIL_SEQ_Run+0xf8>
    if ((local_evtset & EvtWaited)== 0U)
 8005d68:	4b0a      	ldr	r3, [pc, #40]	@ (8005d94 <UTIL_SEQ_Run+0x11c>)
 8005d6a:	681b      	ldr	r3, [r3, #0]
 8005d6c:	420b      	tst	r3, r1
 8005d6e:	d006      	beq.n	8005d7e <UTIL_SEQ_Run+0x106>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005d70:	f385 8810 	msr	PRIMASK, r5
  UTIL_SEQ_PostIdle( );
 8005d74:	f7ff ff61 	bl	8005c3a <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 8005d78:	4b02      	ldr	r3, [pc, #8]	@ (8005d84 <UTIL_SEQ_Run+0x10c>)
 8005d7a:	601c      	str	r4, [r3, #0]
}
 8005d7c:	bd70      	pop	{r4, r5, r6, pc}
      UTIL_SEQ_Idle( );
 8005d7e:	f7fa fe8e 	bl	8000a9e <UTIL_SEQ_Idle>
 8005d82:	e7f5      	b.n	8005d70 <UTIL_SEQ_Run+0xf8>
 8005d84:	20000010 	.word	0x20000010
 8005d88:	200007c8 	.word	0x200007c8
 8005d8c:	200007c4 	.word	0x200007c4
 8005d90:	20000014 	.word	0x20000014
 8005d94:	200007c0 	.word	0x200007c0
 8005d98:	200007a8 	.word	0x200007a8
 8005d9c:	200007bc 	.word	0x200007bc
 8005da0:	200007b0 	.word	0x200007b0

08005da4 <UTIL_SEQ_WaitEvt>:
{
 8005da4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005da6:	4604      	mov	r4, r0
  current_task_idx = CurrentTaskIdx;
 8005da8:	4b11      	ldr	r3, [pc, #68]	@ (8005df0 <UTIL_SEQ_WaitEvt+0x4c>)
 8005daa:	681e      	ldr	r6, [r3, #0]
  if(UTIL_SEQ_NOTASKRUNNING == CurrentTaskIdx)
 8005dac:	f1b6 3fff 	cmp.w	r6, #4294967295
 8005db0:	d005      	beq.n	8005dbe <UTIL_SEQ_WaitEvt+0x1a>
    wait_task_idx = (uint32_t)1u << CurrentTaskIdx;
 8005db2:	2501      	movs	r5, #1
 8005db4:	40b5      	lsls	r5, r6
  event_waited_id_backup = EvtWaited;
 8005db6:	4b0f      	ldr	r3, [pc, #60]	@ (8005df4 <UTIL_SEQ_WaitEvt+0x50>)
 8005db8:	681f      	ldr	r7, [r3, #0]
  EvtWaited = EvtId_bm;
 8005dba:	601c      	str	r4, [r3, #0]
  while ((EvtSet & EvtId_bm) == 0U)
 8005dbc:	e005      	b.n	8005dca <UTIL_SEQ_WaitEvt+0x26>
    wait_task_idx = 0u;
 8005dbe:	2500      	movs	r5, #0
 8005dc0:	e7f9      	b.n	8005db6 <UTIL_SEQ_WaitEvt+0x12>
    UTIL_SEQ_EvtIdle(wait_task_idx, EvtId_bm);
 8005dc2:	4621      	mov	r1, r4
 8005dc4:	4628      	mov	r0, r5
 8005dc6:	f7fa fe65 	bl	8000a94 <UTIL_SEQ_EvtIdle>
  while ((EvtSet & EvtId_bm) == 0U)
 8005dca:	4b0b      	ldr	r3, [pc, #44]	@ (8005df8 <UTIL_SEQ_WaitEvt+0x54>)
 8005dcc:	681b      	ldr	r3, [r3, #0]
 8005dce:	4223      	tst	r3, r4
 8005dd0:	d0f7      	beq.n	8005dc2 <UTIL_SEQ_WaitEvt+0x1e>
  CurrentTaskIdx = current_task_idx;
 8005dd2:	4b07      	ldr	r3, [pc, #28]	@ (8005df0 <UTIL_SEQ_WaitEvt+0x4c>)
 8005dd4:	601e      	str	r6, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005dd6:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005dda:	b672      	cpsid	i
  EvtSet &= (~EvtId_bm);
 8005ddc:	4a06      	ldr	r2, [pc, #24]	@ (8005df8 <UTIL_SEQ_WaitEvt+0x54>)
 8005dde:	6813      	ldr	r3, [r2, #0]
 8005de0:	ea23 0304 	bic.w	r3, r3, r4
 8005de4:	6013      	str	r3, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005de6:	f381 8810 	msr	PRIMASK, r1
  EvtWaited = event_waited_id_backup;
 8005dea:	4b02      	ldr	r3, [pc, #8]	@ (8005df4 <UTIL_SEQ_WaitEvt+0x50>)
 8005dec:	601f      	str	r7, [r3, #0]
}
 8005dee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005df0:	200007bc 	.word	0x200007bc
 8005df4:	200007c0 	.word	0x200007c0
 8005df8:	200007c4 	.word	0x200007c4

08005dfc <UTIL_SEQ_RegTask>:
{
 8005dfc:	b538      	push	{r3, r4, r5, lr}
 8005dfe:	4614      	mov	r4, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005e00:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005e04:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 8005e06:	f7ff ff19 	bl	8005c3c <SEQ_BitPosition>
 8005e0a:	4b03      	ldr	r3, [pc, #12]	@ (8005e18 <UTIL_SEQ_RegTask+0x1c>)
 8005e0c:	f843 4020 	str.w	r4, [r3, r0, lsl #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005e10:	f385 8810 	msr	PRIMASK, r5
}
 8005e14:	bd38      	pop	{r3, r4, r5, pc}
 8005e16:	bf00      	nop
 8005e18:	200007b0 	.word	0x200007b0

08005e1c <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 8005e1c:	b082      	sub	sp, #8
 8005e1e:	b082      	sub	sp, #8
 8005e20:	f10d 0c08 	add.w	ip, sp, #8
 8005e24:	e90c 0006 	stmdb	ip, {r1, r2}
 8005e28:	9303      	str	r3, [sp, #12]
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };
 8005e2a:	2200      	movs	r2, #0
 8005e2c:	6002      	str	r2, [r0, #0]
 8005e2e:	8082      	strh	r2, [r0, #4]

  c.Seconds = a.Seconds + b.Seconds;
 8005e30:	440b      	add	r3, r1
 8005e32:	6003      	str	r3, [r0, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8005e34:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 8005e38:	f8bd 1010 	ldrh.w	r1, [sp, #16]
 8005e3c:	440a      	add	r2, r1
 8005e3e:	b291      	uxth	r1, r2
 8005e40:	b212      	sxth	r2, r2
 8005e42:	8082      	strh	r2, [r0, #4]
  if( c.SubSeconds >= 1000 )
 8005e44:	f5b2 7f7a 	cmp.w	r2, #1000	@ 0x3e8
 8005e48:	db04      	blt.n	8005e54 <SysTimeAdd+0x38>
  {
    c.Seconds++;
 8005e4a:	3301      	adds	r3, #1
 8005e4c:	6003      	str	r3, [r0, #0]
    c.SubSeconds -= 1000;
 8005e4e:	f5a1 717a 	sub.w	r1, r1, #1000	@ 0x3e8
 8005e52:	8081      	strh	r1, [r0, #4]
  }
  return c;
}
 8005e54:	b002      	add	sp, #8
 8005e56:	b002      	add	sp, #8
 8005e58:	4770      	bx	lr
	...

08005e5c <SysTimeGet>:
  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
}

SysTime_t SysTimeGet( void )
{
 8005e5c:	b530      	push	{r4, r5, lr}
 8005e5e:	b087      	sub	sp, #28
 8005e60:	4604      	mov	r4, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8005e62:	2300      	movs	r3, #0
 8005e64:	9304      	str	r3, [sp, #16]
 8005e66:	f8ad 3014 	strh.w	r3, [sp, #20]
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
 8005e6a:	6003      	str	r3, [r0, #0]
 8005e6c:	8083      	strh	r3, [r0, #4]
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8005e6e:	4d0b      	ldr	r5, [pc, #44]	@ (8005e9c <SysTimeGet+0x40>)
 8005e70:	692b      	ldr	r3, [r5, #16]
 8005e72:	a805      	add	r0, sp, #20
 8005e74:	4798      	blx	r3
 8005e76:	9004      	str	r0, [sp, #16]

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8005e78:	68eb      	ldr	r3, [r5, #12]
 8005e7a:	4798      	blx	r3
 8005e7c:	f8ad 000c 	strh.w	r0, [sp, #12]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8005e80:	686b      	ldr	r3, [r5, #4]
 8005e82:	4798      	blx	r3
 8005e84:	9002      	str	r0, [sp, #8]

  sysTime = SysTimeAdd( DeltaTime, calendarTime );
 8005e86:	9b05      	ldr	r3, [sp, #20]
 8005e88:	9300      	str	r3, [sp, #0]
 8005e8a:	9b04      	ldr	r3, [sp, #16]
 8005e8c:	aa02      	add	r2, sp, #8
 8005e8e:	ca06      	ldmia	r2, {r1, r2}
 8005e90:	4620      	mov	r0, r4
 8005e92:	f7ff ffc3 	bl	8005e1c <SysTimeAdd>

  return sysTime;
}
 8005e96:	4620      	mov	r0, r4
 8005e98:	b007      	add	sp, #28
 8005e9a:	bd30      	pop	{r4, r5, pc}
 8005e9c:	08006550 	.word	0x08006550

08005ea0 <UTIL_TIMER_Init>:
  * @addtogroup TIMER_SERVER_exported_function
  *  @{
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
 8005ea0:	b508      	push	{r3, lr}
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 8005ea2:	4b03      	ldr	r3, [pc, #12]	@ (8005eb0 <UTIL_TIMER_Init+0x10>)
 8005ea4:	2200      	movs	r2, #0
 8005ea6:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 8005ea8:	4b02      	ldr	r3, [pc, #8]	@ (8005eb4 <UTIL_TIMER_Init+0x14>)
 8005eaa:	681b      	ldr	r3, [r3, #0]
 8005eac:	4798      	blx	r3
}
 8005eae:	bd08      	pop	{r3, pc}
 8005eb0:	200007cc 	.word	0x200007cc
 8005eb4:	08006564 	.word	0x08006564

08005eb8 <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8005eb8:	4b05      	ldr	r3, [pc, #20]	@ (8005ed0 <TimerExists+0x18>)
 8005eba:	681b      	ldr	r3, [r3, #0]

  while( cur != NULL )
 8005ebc:	e000      	b.n	8005ec0 <TimerExists+0x8>
  {
    if( cur == TimerObject )
    {
      return true;
    }
    cur = cur->Next;
 8005ebe:	695b      	ldr	r3, [r3, #20]
  while( cur != NULL )
 8005ec0:	b11b      	cbz	r3, 8005eca <TimerExists+0x12>
    if( cur == TimerObject )
 8005ec2:	4283      	cmp	r3, r0
 8005ec4:	d1fb      	bne.n	8005ebe <TimerExists+0x6>
      return true;
 8005ec6:	2001      	movs	r0, #1
  }
  return false;
}
 8005ec8:	4770      	bx	lr
  return false;
 8005eca:	2000      	movs	r0, #0
 8005ecc:	4770      	bx	lr
 8005ece:	bf00      	nop
 8005ed0:	200007cc 	.word	0x200007cc

08005ed4 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 8005ed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ed6:	4604      	mov	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 8005ed8:	4e09      	ldr	r6, [pc, #36]	@ (8005f00 <TimerSetTimeout+0x2c>)
 8005eda:	6a33      	ldr	r3, [r6, #32]
 8005edc:	4798      	blx	r3
 8005ede:	4605      	mov	r5, r0
  TimerObject->IsPending = 1;
 8005ee0:	2301      	movs	r3, #1
 8005ee2:	7223      	strb	r3, [r4, #8]

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8005ee4:	6827      	ldr	r7, [r4, #0]
 8005ee6:	69b6      	ldr	r6, [r6, #24]
 8005ee8:	47b0      	blx	r6
 8005eea:	4428      	add	r0, r5
 8005eec:	4287      	cmp	r7, r0
 8005eee:	d202      	bcs.n	8005ef6 <TimerSetTimeout+0x22>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 8005ef0:	47b0      	blx	r6
 8005ef2:	4428      	add	r0, r5
 8005ef4:	6020      	str	r0, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 8005ef6:	4b02      	ldr	r3, [pc, #8]	@ (8005f00 <TimerSetTimeout+0x2c>)
 8005ef8:	689b      	ldr	r3, [r3, #8]
 8005efa:	6820      	ldr	r0, [r4, #0]
 8005efc:	4798      	blx	r3
}
 8005efe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005f00:	08006564 	.word	0x08006564

08005f04 <TimerInsertTimer>:
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8005f04:	4b09      	ldr	r3, [pc, #36]	@ (8005f2c <TimerInsertTimer+0x28>)
 8005f06:	681a      	ldr	r2, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 8005f08:	6953      	ldr	r3, [r2, #20]

  while (cur->Next != NULL )
 8005f0a:	e001      	b.n	8005f10 <TimerInsertTimer+0xc>
  {  
    if( TimerObject->Timestamp  > next->Timestamp )
    {
        cur = next;
 8005f0c:	461a      	mov	r2, r3
        next = next->Next;
 8005f0e:	695b      	ldr	r3, [r3, #20]
  while (cur->Next != NULL )
 8005f10:	6951      	ldr	r1, [r2, #20]
 8005f12:	b139      	cbz	r1, 8005f24 <TimerInsertTimer+0x20>
    if( TimerObject->Timestamp  > next->Timestamp )
 8005f14:	6819      	ldr	r1, [r3, #0]
 8005f16:	f8d0 c000 	ldr.w	ip, [r0]
 8005f1a:	458c      	cmp	ip, r1
 8005f1c:	d8f6      	bhi.n	8005f0c <TimerInsertTimer+0x8>
    }
    else
    {
        cur->Next = TimerObject;
 8005f1e:	6150      	str	r0, [r2, #20]
        TimerObject->Next = next;
 8005f20:	6143      	str	r3, [r0, #20]
        return;
 8005f22:	4770      	bx	lr

    }
  }
  cur->Next = TimerObject;
 8005f24:	6150      	str	r0, [r2, #20]
  TimerObject->Next = NULL;
 8005f26:	2300      	movs	r3, #0
 8005f28:	6143      	str	r3, [r0, #20]
}
 8005f2a:	4770      	bx	lr
 8005f2c:	200007cc 	.word	0x200007cc

08005f30 <TimerInsertNewHeadTimer>:
 *
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
 8005f30:	b508      	push	{r3, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8005f32:	4b05      	ldr	r3, [pc, #20]	@ (8005f48 <TimerInsertNewHeadTimer+0x18>)
 8005f34:	681b      	ldr	r3, [r3, #0]

  if( cur != NULL )
 8005f36:	b10b      	cbz	r3, 8005f3c <TimerInsertNewHeadTimer+0xc>
  {
    cur->IsPending = 0;
 8005f38:	2200      	movs	r2, #0
 8005f3a:	721a      	strb	r2, [r3, #8]
  }

  TimerObject->Next = cur;
 8005f3c:	6143      	str	r3, [r0, #20]
  TimerListHead = TimerObject;
 8005f3e:	4b02      	ldr	r3, [pc, #8]	@ (8005f48 <TimerInsertNewHeadTimer+0x18>)
 8005f40:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 8005f42:	f7ff ffc7 	bl	8005ed4 <TimerSetTimeout>
}
 8005f46:	bd08      	pop	{r3, pc}
 8005f48:	200007cc 	.word	0x200007cc

08005f4c <UTIL_TIMER_Start>:
{
 8005f4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 8005f4e:	2800      	cmp	r0, #0
 8005f50:	d036      	beq.n	8005fc0 <UTIL_TIMER_Start+0x74>
 8005f52:	4604      	mov	r4, r0
 8005f54:	f7ff ffb0 	bl	8005eb8 <TimerExists>
 8005f58:	2800      	cmp	r0, #0
 8005f5a:	d134      	bne.n	8005fc6 <UTIL_TIMER_Start+0x7a>
 8005f5c:	7a65      	ldrb	r5, [r4, #9]
 8005f5e:	2d00      	cmp	r5, #0
 8005f60:	d133      	bne.n	8005fca <UTIL_TIMER_Start+0x7e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005f62:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005f66:	b672      	cpsid	i
    ticks = TimerObject->ReloadValue;
 8005f68:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 8005f6a:	4b19      	ldr	r3, [pc, #100]	@ (8005fd0 <UTIL_TIMER_Start+0x84>)
 8005f6c:	6a1b      	ldr	r3, [r3, #32]
 8005f6e:	4798      	blx	r3
    if( ticks < minValue )
 8005f70:	4287      	cmp	r7, r0
 8005f72:	d300      	bcc.n	8005f76 <UTIL_TIMER_Start+0x2a>
    ticks = TimerObject->ReloadValue;
 8005f74:	4638      	mov	r0, r7
    TimerObject->Timestamp = ticks;
 8005f76:	6020      	str	r0, [r4, #0]
    TimerObject->IsPending = 0U;
 8005f78:	2300      	movs	r3, #0
 8005f7a:	7223      	strb	r3, [r4, #8]
    TimerObject->IsRunning = 1U;
 8005f7c:	2201      	movs	r2, #1
 8005f7e:	7262      	strb	r2, [r4, #9]
    TimerObject->IsReloadStopped = 0U;
 8005f80:	72a3      	strb	r3, [r4, #10]
    if( TimerListHead == NULL )
 8005f82:	4b14      	ldr	r3, [pc, #80]	@ (8005fd4 <UTIL_TIMER_Start+0x88>)
 8005f84:	681b      	ldr	r3, [r3, #0]
 8005f86:	b183      	cbz	r3, 8005faa <UTIL_TIMER_Start+0x5e>
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 8005f88:	4b11      	ldr	r3, [pc, #68]	@ (8005fd0 <UTIL_TIMER_Start+0x84>)
 8005f8a:	699b      	ldr	r3, [r3, #24]
 8005f8c:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 8005f8e:	6823      	ldr	r3, [r4, #0]
 8005f90:	4418      	add	r0, r3
 8005f92:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 8005f94:	4b0f      	ldr	r3, [pc, #60]	@ (8005fd4 <UTIL_TIMER_Start+0x88>)
 8005f96:	681b      	ldr	r3, [r3, #0]
 8005f98:	681b      	ldr	r3, [r3, #0]
 8005f9a:	4298      	cmp	r0, r3
 8005f9c:	d20c      	bcs.n	8005fb8 <UTIL_TIMER_Start+0x6c>
        TimerInsertNewHeadTimer( TimerObject);
 8005f9e:	4620      	mov	r0, r4
 8005fa0:	f7ff ffc6 	bl	8005f30 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005fa4:	f386 8810 	msr	PRIMASK, r6
}
 8005fa8:	e00b      	b.n	8005fc2 <UTIL_TIMER_Start+0x76>
      UTIL_TimerDriver.SetTimerContext();
 8005faa:	4b09      	ldr	r3, [pc, #36]	@ (8005fd0 <UTIL_TIMER_Start+0x84>)
 8005fac:	691b      	ldr	r3, [r3, #16]
 8005fae:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 8005fb0:	4620      	mov	r0, r4
 8005fb2:	f7ff ffbd 	bl	8005f30 <TimerInsertNewHeadTimer>
 8005fb6:	e7f5      	b.n	8005fa4 <UTIL_TIMER_Start+0x58>
        TimerInsertTimer( TimerObject);
 8005fb8:	4620      	mov	r0, r4
 8005fba:	f7ff ffa3 	bl	8005f04 <TimerInsertTimer>
 8005fbe:	e7f1      	b.n	8005fa4 <UTIL_TIMER_Start+0x58>
    ret =  UTIL_TIMER_INVALID_PARAM;
 8005fc0:	2501      	movs	r5, #1
}
 8005fc2:	4628      	mov	r0, r5
 8005fc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret =  UTIL_TIMER_INVALID_PARAM;
 8005fc6:	2501      	movs	r5, #1
 8005fc8:	e7fb      	b.n	8005fc2 <UTIL_TIMER_Start+0x76>
 8005fca:	2501      	movs	r5, #1
 8005fcc:	e7f9      	b.n	8005fc2 <UTIL_TIMER_Start+0x76>
 8005fce:	bf00      	nop
 8005fd0:	08006564 	.word	0x08006564
 8005fd4:	200007cc 	.word	0x200007cc

08005fd8 <UTIL_TIMER_IRQ_Handler>:
{
 8005fd8:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005fda:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005fde:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 8005fe0:	4c1e      	ldr	r4, [pc, #120]	@ (800605c <UTIL_TIMER_IRQ_Handler+0x84>)
 8005fe2:	6963      	ldr	r3, [r4, #20]
 8005fe4:	4798      	blx	r3
 8005fe6:	4606      	mov	r6, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 8005fe8:	6923      	ldr	r3, [r4, #16]
 8005fea:	4798      	blx	r3
  DeltaContext = now  - old; /*intentional wrap around */
 8005fec:	1b84      	subs	r4, r0, r6
  if ( TimerListHead != NULL )
 8005fee:	4b1c      	ldr	r3, [pc, #112]	@ (8006060 <UTIL_TIMER_IRQ_Handler+0x88>)
 8005ff0:	681b      	ldr	r3, [r3, #0]
 8005ff2:	b923      	cbnz	r3, 8005ffe <UTIL_TIMER_IRQ_Handler+0x26>
 8005ff4:	e018      	b.n	8006028 <UTIL_TIMER_IRQ_Handler+0x50>
        cur->Timestamp = 0;
 8005ff6:	2200      	movs	r2, #0
 8005ff8:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 8005ffa:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 8005ffc:	b1a3      	cbz	r3, 8006028 <UTIL_TIMER_IRQ_Handler+0x50>
      if (cur->Timestamp > DeltaContext)
 8005ffe:	681a      	ldr	r2, [r3, #0]
 8006000:	42a2      	cmp	r2, r4
 8006002:	d9f8      	bls.n	8005ff6 <UTIL_TIMER_IRQ_Handler+0x1e>
        cur->Timestamp -= DeltaContext;
 8006004:	1a31      	subs	r1, r6, r0
 8006006:	440a      	add	r2, r1
 8006008:	601a      	str	r2, [r3, #0]
 800600a:	e7f6      	b.n	8005ffa <UTIL_TIMER_IRQ_Handler+0x22>
      cur = TimerListHead;
 800600c:	4b14      	ldr	r3, [pc, #80]	@ (8006060 <UTIL_TIMER_IRQ_Handler+0x88>)
 800600e:	681c      	ldr	r4, [r3, #0]
      TimerListHead = TimerListHead->Next;
 8006010:	6962      	ldr	r2, [r4, #20]
 8006012:	601a      	str	r2, [r3, #0]
      cur->IsPending = 0;
 8006014:	2300      	movs	r3, #0
 8006016:	7223      	strb	r3, [r4, #8]
      cur->IsRunning = 0;
 8006018:	7263      	strb	r3, [r4, #9]
      cur->Callback(cur->argument);
 800601a:	68e3      	ldr	r3, [r4, #12]
 800601c:	6920      	ldr	r0, [r4, #16]
 800601e:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 8006020:	8963      	ldrh	r3, [r4, #10]
 8006022:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8006026:	d012      	beq.n	800604e <UTIL_TIMER_IRQ_Handler+0x76>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 8006028:	4b0d      	ldr	r3, [pc, #52]	@ (8006060 <UTIL_TIMER_IRQ_Handler+0x88>)
 800602a:	681b      	ldr	r3, [r3, #0]
 800602c:	b13b      	cbz	r3, 800603e <UTIL_TIMER_IRQ_Handler+0x66>
 800602e:	681c      	ldr	r4, [r3, #0]
 8006030:	2c00      	cmp	r4, #0
 8006032:	d0eb      	beq.n	800600c <UTIL_TIMER_IRQ_Handler+0x34>
 8006034:	4b09      	ldr	r3, [pc, #36]	@ (800605c <UTIL_TIMER_IRQ_Handler+0x84>)
 8006036:	699b      	ldr	r3, [r3, #24]
 8006038:	4798      	blx	r3
 800603a:	4284      	cmp	r4, r0
 800603c:	d3e6      	bcc.n	800600c <UTIL_TIMER_IRQ_Handler+0x34>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 800603e:	4b08      	ldr	r3, [pc, #32]	@ (8006060 <UTIL_TIMER_IRQ_Handler+0x88>)
 8006040:	6818      	ldr	r0, [r3, #0]
 8006042:	b108      	cbz	r0, 8006048 <UTIL_TIMER_IRQ_Handler+0x70>
 8006044:	7a03      	ldrb	r3, [r0, #8]
 8006046:	b133      	cbz	r3, 8006056 <UTIL_TIMER_IRQ_Handler+0x7e>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8006048:	f385 8810 	msr	PRIMASK, r5
}
 800604c:	bd70      	pop	{r4, r5, r6, pc}
        (void)UTIL_TIMER_Start(cur);
 800604e:	4620      	mov	r0, r4
 8006050:	f7ff ff7c 	bl	8005f4c <UTIL_TIMER_Start>
 8006054:	e7e8      	b.n	8006028 <UTIL_TIMER_IRQ_Handler+0x50>
    TimerSetTimeout( TimerListHead );
 8006056:	f7ff ff3d 	bl	8005ed4 <TimerSetTimeout>
 800605a:	e7f5      	b.n	8006048 <UTIL_TIMER_IRQ_Handler+0x70>
 800605c:	08006564 	.word	0x08006564
 8006060:	200007cc 	.word	0x200007cc

08006064 <ee_skip_atoi>:
  return sc - s;
}
#endif

static int ee_skip_atoi(const char **s)
{
 8006064:	4601      	mov	r1, r0
  int i = 0;
 8006066:	2000      	movs	r0, #0
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 8006068:	e008      	b.n	800607c <ee_skip_atoi+0x18>
 800606a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800606e:	1c53      	adds	r3, r2, #1
 8006070:	600b      	str	r3, [r1, #0]
 8006072:	7813      	ldrb	r3, [r2, #0]
 8006074:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8006078:	f1a3 0030 	sub.w	r0, r3, #48	@ 0x30
 800607c:	680a      	ldr	r2, [r1, #0]
 800607e:	7813      	ldrb	r3, [r2, #0]
 8006080:	3b30      	subs	r3, #48	@ 0x30
 8006082:	b2db      	uxtb	r3, r3
 8006084:	2b09      	cmp	r3, #9
 8006086:	d9f0      	bls.n	800606a <ee_skip_atoi+0x6>
  return i;
}
 8006088:	4770      	bx	lr
	...

0800608c <ee_number>:

#define ASSIGN_STR(_c)  do { *str++ = (_c); max_size--; if (max_size == 0) return str; } while (0)

static char *ee_number(char *str, int max_size, long num, int base, int size, int precision, int type)
{
 800608c:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
 8006090:	b093      	sub	sp, #76	@ 0x4c
 8006092:	9d1b      	ldr	r5, [sp, #108]	@ 0x6c
 8006094:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
  char c;
  char sign, tmp[66];
  char *dig = lower_digits;
  int i;

  if (type & UPPERCASE)  dig = upper_digits;
 8006096:	f016 0f40 	tst.w	r6, #64	@ 0x40
 800609a:	d110      	bne.n	80060be <ee_number+0x32>
  char *dig = lower_digits;
 800609c:	f8df a0f8 	ldr.w	sl, [pc, #248]	@ 8006198 <ee_number+0x10c>
#ifdef TINY_PRINTF
#else
  if (type & LEFT) type &= ~ZEROPAD;
#endif
  if (base < 2 || base > 36) return 0;
 80060a0:	1e9f      	subs	r7, r3, #2
 80060a2:	2f22      	cmp	r7, #34	@ 0x22
 80060a4:	d875      	bhi.n	8006192 <ee_number+0x106>

  c = (type & ZEROPAD) ? '0' : ' ';
 80060a6:	f016 0401 	ands.w	r4, r6, #1
 80060aa:	d00b      	beq.n	80060c4 <ee_number+0x38>
 80060ac:	f04f 0e30 	mov.w	lr, #48	@ 0x30
  sign = 0;
  if (type & SIGN)
 80060b0:	f016 0f02 	tst.w	r6, #2
 80060b4:	d00f      	beq.n	80060d6 <ee_number+0x4a>
  {
    if (num < 0)
 80060b6:	2a00      	cmp	r2, #0
 80060b8:	db07      	blt.n	80060ca <ee_number+0x3e>
  sign = 0;
 80060ba:	2700      	movs	r7, #0
 80060bc:	e00c      	b.n	80060d8 <ee_number+0x4c>
  if (type & UPPERCASE)  dig = upper_digits;
 80060be:	f8df a0dc 	ldr.w	sl, [pc, #220]	@ 800619c <ee_number+0x110>
 80060c2:	e7ed      	b.n	80060a0 <ee_number+0x14>
  c = (type & ZEROPAD) ? '0' : ' ';
 80060c4:	f04f 0e20 	mov.w	lr, #32
 80060c8:	e7f2      	b.n	80060b0 <ee_number+0x24>
    {
      sign = '-';
      num = -num;
 80060ca:	4252      	negs	r2, r2
      size--;
 80060cc:	9e1a      	ldr	r6, [sp, #104]	@ 0x68
 80060ce:	3e01      	subs	r6, #1
 80060d0:	961a      	str	r6, [sp, #104]	@ 0x68
      sign = '-';
 80060d2:	272d      	movs	r7, #45	@ 0x2d
 80060d4:	e000      	b.n	80060d8 <ee_number+0x4c>
  sign = 0;
 80060d6:	2700      	movs	r7, #0
  }
#endif

  i = 0;

  if (num == 0)
 80060d8:	bb5a      	cbnz	r2, 8006132 <ee_number+0xa6>
    tmp[i++] = '0';
 80060da:	2330      	movs	r3, #48	@ 0x30
 80060dc:	f88d 3004 	strb.w	r3, [sp, #4]
 80060e0:	f04f 0c01 	mov.w	ip, #1
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
      num = ((unsigned long) num) / (unsigned) base;
    }
  }

  if (i > precision) precision = i;
 80060e4:	45ac      	cmp	ip, r5
 80060e6:	dd00      	ble.n	80060ea <ee_number+0x5e>
 80060e8:	4665      	mov	r5, ip
  size -= precision;
 80060ea:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
 80060ec:	1b5b      	subs	r3, r3, r5
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 80060ee:	b31c      	cbz	r4, 8006138 <ee_number+0xac>
  if (sign) ASSIGN_STR(sign);
 80060f0:	b11f      	cbz	r7, 80060fa <ee_number+0x6e>
 80060f2:	f800 7b01 	strb.w	r7, [r0], #1
 80060f6:	3901      	subs	r1, #1
 80060f8:	d007      	beq.n	800610a <ee_number+0x7e>
    }
  }
#endif

#ifdef TINY_PRINTF
  while (size-- > 0) ASSIGN_STR(c);
 80060fa:	2b00      	cmp	r3, #0
 80060fc:	f103 33ff 	add.w	r3, r3, #4294967295
 8006100:	dd24      	ble.n	800614c <ee_number+0xc0>
 8006102:	f800 eb01 	strb.w	lr, [r0], #1
 8006106:	3901      	subs	r1, #1
 8006108:	d1f7      	bne.n	80060fa <ee_number+0x6e>
  while (i < precision--) ASSIGN_STR('0');
  while (i-- > 0) ASSIGN_STR(tmp[i]);
  while (size-- > 0) ASSIGN_STR(' ');

  return str;
}
 800610a:	b013      	add	sp, #76	@ 0x4c
 800610c:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 8006110:	fbb2 f6f3 	udiv	r6, r2, r3
 8006114:	fb03 2216 	mls	r2, r3, r6, r2
 8006118:	f81a 8002 	ldrb.w	r8, [sl, r2]
 800611c:	f10c 0248 	add.w	r2, ip, #72	@ 0x48
 8006120:	446a      	add	r2, sp
 8006122:	f802 8c44 	strb.w	r8, [r2, #-68]
      num = ((unsigned long) num) / (unsigned) base;
 8006126:	4632      	mov	r2, r6
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 8006128:	f10c 0c01 	add.w	ip, ip, #1
    while (num != 0)
 800612c:	2a00      	cmp	r2, #0
 800612e:	d1ef      	bne.n	8006110 <ee_number+0x84>
 8006130:	e7d8      	b.n	80060e4 <ee_number+0x58>
  i = 0;
 8006132:	f04f 0c00 	mov.w	ip, #0
 8006136:	e7f9      	b.n	800612c <ee_number+0xa0>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 8006138:	2b00      	cmp	r3, #0
 800613a:	f103 33ff 	add.w	r3, r3, #4294967295
 800613e:	ddd7      	ble.n	80060f0 <ee_number+0x64>
 8006140:	2220      	movs	r2, #32
 8006142:	f800 2b01 	strb.w	r2, [r0], #1
 8006146:	3901      	subs	r1, #1
 8006148:	d1f6      	bne.n	8006138 <ee_number+0xac>
 800614a:	e7de      	b.n	800610a <ee_number+0x7e>
  while (i < precision--) ASSIGN_STR('0');
 800614c:	4565      	cmp	r5, ip
 800614e:	f105 35ff 	add.w	r5, r5, #4294967295
 8006152:	dd05      	ble.n	8006160 <ee_number+0xd4>
 8006154:	2230      	movs	r2, #48	@ 0x30
 8006156:	f800 2b01 	strb.w	r2, [r0], #1
 800615a:	3901      	subs	r1, #1
 800615c:	d1f6      	bne.n	800614c <ee_number+0xc0>
 800615e:	e7d4      	b.n	800610a <ee_number+0x7e>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 8006160:	4662      	mov	r2, ip
 8006162:	2a00      	cmp	r2, #0
 8006164:	f10c 3cff 	add.w	ip, ip, #4294967295
 8006168:	dd09      	ble.n	800617e <ee_number+0xf2>
 800616a:	f10c 0248 	add.w	r2, ip, #72	@ 0x48
 800616e:	446a      	add	r2, sp
 8006170:	f812 2c44 	ldrb.w	r2, [r2, #-68]
 8006174:	f800 2b01 	strb.w	r2, [r0], #1
 8006178:	3901      	subs	r1, #1
 800617a:	d1f1      	bne.n	8006160 <ee_number+0xd4>
 800617c:	e7c5      	b.n	800610a <ee_number+0x7e>
  while (size-- > 0) ASSIGN_STR(' ');
 800617e:	2b00      	cmp	r3, #0
 8006180:	f103 33ff 	add.w	r3, r3, #4294967295
 8006184:	ddc1      	ble.n	800610a <ee_number+0x7e>
 8006186:	2220      	movs	r2, #32
 8006188:	f800 2b01 	strb.w	r2, [r0], #1
 800618c:	3901      	subs	r1, #1
 800618e:	d1f6      	bne.n	800617e <ee_number+0xf2>
 8006190:	e7bb      	b.n	800610a <ee_number+0x7e>
  if (base < 2 || base > 36) return 0;
 8006192:	2000      	movs	r0, #0
 8006194:	e7b9      	b.n	800610a <ee_number+0x7e>
 8006196:	bf00      	nop
 8006198:	08006944 	.word	0x08006944
 800619c:	0800696c 	.word	0x0800696c

080061a0 <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 80061a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80061a4:	b087      	sub	sp, #28
 80061a6:	9205      	str	r2, [sp, #20]
 80061a8:	9304      	str	r3, [sp, #16]

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 80061aa:	1e0f      	subs	r7, r1, #0
 80061ac:	f340 80b8 	ble.w	8006320 <tiny_vsnprintf_like+0x180>
 80061b0:	4606      	mov	r6, r0
  {
    return 0;
  }

  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 80061b2:	4604      	mov	r4, r0
 80061b4:	e004      	b.n	80061c0 <tiny_vsnprintf_like+0x20>
  {
    CHECK_STR_SIZE(buf, str, size);

    if (*fmt != '%')
    {
      *str++ = *fmt;
 80061b6:	f804 2b01 	strb.w	r2, [r4], #1
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 80061ba:	9b05      	ldr	r3, [sp, #20]
 80061bc:	3301      	adds	r3, #1
 80061be:	9305      	str	r3, [sp, #20]
 80061c0:	9905      	ldr	r1, [sp, #20]
 80061c2:	780a      	ldrb	r2, [r1, #0]
 80061c4:	b922      	cbnz	r2, 80061d0 <tiny_vsnprintf_like+0x30>
 80061c6:	1ba3      	subs	r3, r4, r6
 80061c8:	1e78      	subs	r0, r7, #1
 80061ca:	4283      	cmp	r3, r0
 80061cc:	f2c0 80a2 	blt.w	8006314 <tiny_vsnprintf_like+0x174>
    CHECK_STR_SIZE(buf, str, size);
 80061d0:	1ba3      	subs	r3, r4, r6
 80061d2:	f107 38ff 	add.w	r8, r7, #4294967295
 80061d6:	4543      	cmp	r3, r8
 80061d8:	f280 809c 	bge.w	8006314 <tiny_vsnprintf_like+0x174>
    if (*fmt != '%')
 80061dc:	2a25      	cmp	r2, #37	@ 0x25
 80061de:	d1ea      	bne.n	80061b6 <tiny_vsnprintf_like+0x16>

    // Process flags
    flags = 0;
#ifdef TINY_PRINTF
    /* Support %0, but not %-, %+, %space and %# */
    fmt++;
 80061e0:	1c4b      	adds	r3, r1, #1
 80061e2:	9305      	str	r3, [sp, #20]
    if (*fmt == '0')
 80061e4:	784b      	ldrb	r3, [r1, #1]
 80061e6:	2b30      	cmp	r3, #48	@ 0x30
 80061e8:	d020      	beq.n	800622c <tiny_vsnprintf_like+0x8c>
    flags = 0;
 80061ea:	f04f 0900 	mov.w	r9, #0
    }
#endif

    // Get field width
    field_width = -1;
    if (is_digit(*fmt))
 80061ee:	3b30      	subs	r3, #48	@ 0x30
 80061f0:	b2db      	uxtb	r3, r3
 80061f2:	2b09      	cmp	r3, #9
 80061f4:	d91d      	bls.n	8006232 <tiny_vsnprintf_like+0x92>
    field_width = -1;
 80061f6:	f04f 35ff 	mov.w	r5, #4294967295
#endif

    // Default base
    base = 10;

    switch (*fmt)
 80061fa:	9b05      	ldr	r3, [sp, #20]
 80061fc:	781a      	ldrb	r2, [r3, #0]
 80061fe:	f1a2 0358 	sub.w	r3, r2, #88	@ 0x58
 8006202:	2b20      	cmp	r3, #32
 8006204:	d867      	bhi.n	80062d6 <tiny_vsnprintf_like+0x136>
 8006206:	e8df f003 	tbb	[pc, r3]
 800620a:	664a      	.short	0x664a
 800620c:	66666666 	.word	0x66666666
 8006210:	66666666 	.word	0x66666666
 8006214:	66621e66 	.word	0x66621e66
 8006218:	62666666 	.word	0x62666666
 800621c:	66666666 	.word	0x66666666
 8006220:	66666666 	.word	0x66666666
 8006224:	19662866 	.word	0x19662866
 8006228:	6666      	.short	0x6666
 800622a:	7c          	.byte	0x7c
 800622b:	00          	.byte	0x00
      flags |= ZEROPAD;
 800622c:	f04f 0901 	mov.w	r9, #1
 8006230:	e7dd      	b.n	80061ee <tiny_vsnprintf_like+0x4e>
      field_width = ee_skip_atoi(&fmt);
 8006232:	a805      	add	r0, sp, #20
 8006234:	f7ff ff16 	bl	8006064 <ee_skip_atoi>
 8006238:	4605      	mov	r5, r0
 800623a:	e7de      	b.n	80061fa <tiny_vsnprintf_like+0x5a>
    switch (*fmt)
 800623c:	230a      	movs	r3, #10
 800623e:	e031      	b.n	80062a4 <tiny_vsnprintf_like+0x104>
      case 'c':
#ifdef TINY_PRINTF
#else
        if (!(flags & LEFT))
#endif
          while (--field_width > 0) *str++ = ' ';
 8006240:	2320      	movs	r3, #32
 8006242:	f804 3b01 	strb.w	r3, [r4], #1
 8006246:	3d01      	subs	r5, #1
 8006248:	2d00      	cmp	r5, #0
 800624a:	dcf9      	bgt.n	8006240 <tiny_vsnprintf_like+0xa0>
        *str++ = (unsigned char) va_arg(args, int);
 800624c:	9b04      	ldr	r3, [sp, #16]
 800624e:	1d1a      	adds	r2, r3, #4
 8006250:	9204      	str	r2, [sp, #16]
 8006252:	781b      	ldrb	r3, [r3, #0]
 8006254:	f804 3b01 	strb.w	r3, [r4], #1
#ifdef TINY_PRINTF
#else
        while (--field_width > 0) *str++ = ' ';
#endif
        continue;
 8006258:	e7af      	b.n	80061ba <tiny_vsnprintf_like+0x1a>

      case 's':
        s = va_arg(args, char *);
 800625a:	9b04      	ldr	r3, [sp, #16]
 800625c:	1d1a      	adds	r2, r3, #4
 800625e:	9204      	str	r2, [sp, #16]
 8006260:	f8d3 8000 	ldr.w	r8, [r3]
        if (!s) s = "<NULL>";
 8006264:	f1b8 0f00 	cmp.w	r8, #0
 8006268:	d003      	beq.n	8006272 <tiny_vsnprintf_like+0xd2>
#ifdef TINY_PRINTF
        len = strlen(s);
 800626a:	4640      	mov	r0, r8
 800626c:	f7f9 ff84 	bl	8000178 <strlen>
#else
        len = strnlen(s, precision);
        if (!(flags & LEFT))
#endif
          while (len < field_width--) *str++ = ' ';
 8006270:	e006      	b.n	8006280 <tiny_vsnprintf_like+0xe0>
        if (!s) s = "<NULL>";
 8006272:	f8df 80b0 	ldr.w	r8, [pc, #176]	@ 8006324 <tiny_vsnprintf_like+0x184>
 8006276:	e7f8      	b.n	800626a <tiny_vsnprintf_like+0xca>
          while (len < field_width--) *str++ = ' ';
 8006278:	2220      	movs	r2, #32
 800627a:	f804 2b01 	strb.w	r2, [r4], #1
 800627e:	461d      	mov	r5, r3
 8006280:	1e6b      	subs	r3, r5, #1
 8006282:	4285      	cmp	r5, r0
 8006284:	dcf8      	bgt.n	8006278 <tiny_vsnprintf_like+0xd8>
        for (i = 0; i < len; ++i) *str++ = *s++;
 8006286:	2200      	movs	r2, #0
 8006288:	e006      	b.n	8006298 <tiny_vsnprintf_like+0xf8>
 800628a:	4643      	mov	r3, r8
 800628c:	f813 1b01 	ldrb.w	r1, [r3], #1
 8006290:	f804 1b01 	strb.w	r1, [r4], #1
 8006294:	3201      	adds	r2, #1
 8006296:	4698      	mov	r8, r3
 8006298:	4282      	cmp	r2, r0
 800629a:	dbf6      	blt.n	800628a <tiny_vsnprintf_like+0xea>
 800629c:	e78d      	b.n	80061ba <tiny_vsnprintf_like+0x1a>
        base = 8;
        break;
#endif

      case 'X':
        flags |= UPPERCASE;
 800629e:	f049 0940 	orr.w	r9, r9, #64	@ 0x40

      case 'x':
        base = 16;
 80062a2:	2310      	movs	r3, #16
        continue;
    }

    if (qualifier == 'l')
      num = va_arg(args, unsigned long);
    else if (flags & SIGN)
 80062a4:	f019 0f02 	tst.w	r9, #2
 80062a8:	d02f      	beq.n	800630a <tiny_vsnprintf_like+0x16a>
      num = va_arg(args, int);
 80062aa:	9a04      	ldr	r2, [sp, #16]
 80062ac:	1d11      	adds	r1, r2, #4
 80062ae:	9104      	str	r1, [sp, #16]
 80062b0:	6812      	ldr	r2, [r2, #0]
    else
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 80062b2:	1ba1      	subs	r1, r4, r6
 80062b4:	f8cd 9008 	str.w	r9, [sp, #8]
 80062b8:	f04f 30ff 	mov.w	r0, #4294967295
 80062bc:	9001      	str	r0, [sp, #4]
 80062be:	9500      	str	r5, [sp, #0]
 80062c0:	eba8 0101 	sub.w	r1, r8, r1
 80062c4:	4620      	mov	r0, r4
 80062c6:	f7ff fee1 	bl	800608c <ee_number>
 80062ca:	4604      	mov	r4, r0
 80062cc:	e775      	b.n	80061ba <tiny_vsnprintf_like+0x1a>
        flags |= SIGN;
 80062ce:	f049 0902 	orr.w	r9, r9, #2
    base = 10;
 80062d2:	230a      	movs	r3, #10
 80062d4:	e7e6      	b.n	80062a4 <tiny_vsnprintf_like+0x104>
        if (*fmt != '%') *str++ = '%';
 80062d6:	2a25      	cmp	r2, #37	@ 0x25
 80062d8:	d002      	beq.n	80062e0 <tiny_vsnprintf_like+0x140>
 80062da:	2325      	movs	r3, #37	@ 0x25
 80062dc:	f804 3b01 	strb.w	r3, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 80062e0:	1ba3      	subs	r3, r4, r6
 80062e2:	4598      	cmp	r8, r3
 80062e4:	dd0f      	ble.n	8006306 <tiny_vsnprintf_like+0x166>
        if (*fmt)
 80062e6:	9b05      	ldr	r3, [sp, #20]
 80062e8:	781a      	ldrb	r2, [r3, #0]
 80062ea:	b13a      	cbz	r2, 80062fc <tiny_vsnprintf_like+0x15c>
          *str++ = *fmt;
 80062ec:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 80062f0:	1ba3      	subs	r3, r4, r6
 80062f2:	4598      	cmp	r8, r3
 80062f4:	f73f af61 	bgt.w	80061ba <tiny_vsnprintf_like+0x1a>
    base = 10;
 80062f8:	230a      	movs	r3, #10
 80062fa:	e7d3      	b.n	80062a4 <tiny_vsnprintf_like+0x104>
          --fmt;
 80062fc:	3b01      	subs	r3, #1
 80062fe:	9305      	str	r3, [sp, #20]
 8006300:	e7f6      	b.n	80062f0 <tiny_vsnprintf_like+0x150>
        base = 16;
 8006302:	2310      	movs	r3, #16
 8006304:	e7ce      	b.n	80062a4 <tiny_vsnprintf_like+0x104>
    base = 10;
 8006306:	230a      	movs	r3, #10
 8006308:	e7cc      	b.n	80062a4 <tiny_vsnprintf_like+0x104>
      num = va_arg(args, unsigned int);
 800630a:	9a04      	ldr	r2, [sp, #16]
 800630c:	1d11      	adds	r1, r2, #4
 800630e:	9104      	str	r1, [sp, #16]
 8006310:	6812      	ldr	r2, [r2, #0]
 8006312:	e7ce      	b.n	80062b2 <tiny_vsnprintf_like+0x112>
  }

  *str = '\0';
 8006314:	2300      	movs	r3, #0
 8006316:	7023      	strb	r3, [r4, #0]
  return str - buf;
 8006318:	1ba0      	subs	r0, r4, r6
}
 800631a:	b007      	add	sp, #28
 800631c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return 0;
 8006320:	2000      	movs	r0, #0
 8006322:	e7fa      	b.n	800631a <tiny_vsnprintf_like+0x17a>
 8006324:	08006994 	.word	0x08006994

08006328 <memset>:
 8006328:	4402      	add	r2, r0
 800632a:	4603      	mov	r3, r0
 800632c:	4293      	cmp	r3, r2
 800632e:	d100      	bne.n	8006332 <memset+0xa>
 8006330:	4770      	bx	lr
 8006332:	f803 1b01 	strb.w	r1, [r3], #1
 8006336:	e7f9      	b.n	800632c <memset+0x4>

08006338 <__libc_init_array>:
 8006338:	b570      	push	{r4, r5, r6, lr}
 800633a:	4d0d      	ldr	r5, [pc, #52]	@ (8006370 <__libc_init_array+0x38>)
 800633c:	4c0d      	ldr	r4, [pc, #52]	@ (8006374 <__libc_init_array+0x3c>)
 800633e:	1b64      	subs	r4, r4, r5
 8006340:	10a4      	asrs	r4, r4, #2
 8006342:	2600      	movs	r6, #0
 8006344:	42a6      	cmp	r6, r4
 8006346:	d109      	bne.n	800635c <__libc_init_array+0x24>
 8006348:	4d0b      	ldr	r5, [pc, #44]	@ (8006378 <__libc_init_array+0x40>)
 800634a:	4c0c      	ldr	r4, [pc, #48]	@ (800637c <__libc_init_array+0x44>)
 800634c:	f000 f818 	bl	8006380 <_init>
 8006350:	1b64      	subs	r4, r4, r5
 8006352:	10a4      	asrs	r4, r4, #2
 8006354:	2600      	movs	r6, #0
 8006356:	42a6      	cmp	r6, r4
 8006358:	d105      	bne.n	8006366 <__libc_init_array+0x2e>
 800635a:	bd70      	pop	{r4, r5, r6, pc}
 800635c:	f855 3b04 	ldr.w	r3, [r5], #4
 8006360:	4798      	blx	r3
 8006362:	3601      	adds	r6, #1
 8006364:	e7ee      	b.n	8006344 <__libc_init_array+0xc>
 8006366:	f855 3b04 	ldr.w	r3, [r5], #4
 800636a:	4798      	blx	r3
 800636c:	3601      	adds	r6, #1
 800636e:	e7f2      	b.n	8006356 <__libc_init_array+0x1e>
 8006370:	080069a8 	.word	0x080069a8
 8006374:	080069a8 	.word	0x080069a8
 8006378:	080069a8 	.word	0x080069a8
 800637c:	080069ac 	.word	0x080069ac

08006380 <_init>:
 8006380:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006382:	bf00      	nop
 8006384:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006386:	bc08      	pop	{r3}
 8006388:	469e      	mov	lr, r3
 800638a:	4770      	bx	lr

0800638c <_fini>:
 800638c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800638e:	bf00      	nop
 8006390:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006392:	bc08      	pop	{r3}
 8006394:	469e      	mov	lr, r3
 8006396:	4770      	bx	lr
