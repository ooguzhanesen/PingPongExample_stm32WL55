
SubGHz_Phy_PingPong_DualCore_CM0PLUS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08020000  08020000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006248  080200c0  080200c0  000010c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000005e8  08026308  08026308  00007308  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080268f0  080268f0  00009048  2**0
                  CONTENTS
  4 .ARM          00000008  080268f0  080268f0  000078f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080268f8  080268f8  00009048  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  080268f8  080268f8  000078f8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000008  08026900  08026900  00007900  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000018  2000a000  08026908  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .MB_MEM2      00000048  20009000  08026920  00009000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .MB_MEM3      00000300  20009048  08026968  00009048  2**2
                  ALLOC
 11 .bss          00000460  2000a018  2000a018  0000a018  2**2
                  ALLOC
 12 ._user_heap_stack 00001400  2000a478  2000a478  0000a018  2**0
                  ALLOC
 13 .ARM.attributes 00000028  00000000  00000000  00009048  2**0
                  CONTENTS, READONLY
 14 .debug_info   00024803  00000000  00000000  00009070  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 00006d73  00000000  00000000  0002d873  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_loclists 000096cd  00000000  00000000  000345e6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 000018c0  00000000  00000000  0003dcb8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 000012bf  00000000  00000000  0003f578  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_macro  0000a1de  00000000  00000000  00040837  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_line   0002a5c5  00000000  00000000  0004aa15  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_str    000bad8c  00000000  00000000  00074fda  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .comment      00000043  00000000  00000000  0012fd66  2**0
                  CONTENTS, READONLY
 23 .debug_frame  00003d4c  00000000  00000000  0012fdac  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_line_str 00000097  00000000  00000000  00133af8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080200c0 <__do_global_dtors_aux>:
 80200c0:	b510      	push	{r4, lr}
 80200c2:	4c06      	ldr	r4, [pc, #24]	@ (80200dc <__do_global_dtors_aux+0x1c>)
 80200c4:	7823      	ldrb	r3, [r4, #0]
 80200c6:	2b00      	cmp	r3, #0
 80200c8:	d107      	bne.n	80200da <__do_global_dtors_aux+0x1a>
 80200ca:	4b05      	ldr	r3, [pc, #20]	@ (80200e0 <__do_global_dtors_aux+0x20>)
 80200cc:	2b00      	cmp	r3, #0
 80200ce:	d002      	beq.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d0:	4804      	ldr	r0, [pc, #16]	@ (80200e4 <__do_global_dtors_aux+0x24>)
 80200d2:	e000      	b.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d4:	bf00      	nop
 80200d6:	2301      	movs	r3, #1
 80200d8:	7023      	strb	r3, [r4, #0]
 80200da:	bd10      	pop	{r4, pc}
 80200dc:	2000a018 	.word	0x2000a018
 80200e0:	00000000 	.word	0x00000000
 80200e4:	080262ec 	.word	0x080262ec

080200e8 <frame_dummy>:
 80200e8:	4b04      	ldr	r3, [pc, #16]	@ (80200fc <frame_dummy+0x14>)
 80200ea:	b510      	push	{r4, lr}
 80200ec:	2b00      	cmp	r3, #0
 80200ee:	d003      	beq.n	80200f8 <frame_dummy+0x10>
 80200f0:	4903      	ldr	r1, [pc, #12]	@ (8020100 <frame_dummy+0x18>)
 80200f2:	4804      	ldr	r0, [pc, #16]	@ (8020104 <frame_dummy+0x1c>)
 80200f4:	e000      	b.n	80200f8 <frame_dummy+0x10>
 80200f6:	bf00      	nop
 80200f8:	bd10      	pop	{r4, pc}
 80200fa:	46c0      	nop			@ (mov r8, r8)
 80200fc:	00000000 	.word	0x00000000
 8020100:	2000a01c 	.word	0x2000a01c
 8020104:	080262ec 	.word	0x080262ec

08020108 <strlen>:
 8020108:	2300      	movs	r3, #0
 802010a:	5cc2      	ldrb	r2, [r0, r3]
 802010c:	3301      	adds	r3, #1
 802010e:	2a00      	cmp	r2, #0
 8020110:	d1fb      	bne.n	802010a <strlen+0x2>
 8020112:	1e58      	subs	r0, r3, #1
 8020114:	4770      	bx	lr
	...

08020118 <__udivsi3>:
 8020118:	2200      	movs	r2, #0
 802011a:	0843      	lsrs	r3, r0, #1
 802011c:	428b      	cmp	r3, r1
 802011e:	d374      	bcc.n	802020a <__udivsi3+0xf2>
 8020120:	0903      	lsrs	r3, r0, #4
 8020122:	428b      	cmp	r3, r1
 8020124:	d35f      	bcc.n	80201e6 <__udivsi3+0xce>
 8020126:	0a03      	lsrs	r3, r0, #8
 8020128:	428b      	cmp	r3, r1
 802012a:	d344      	bcc.n	80201b6 <__udivsi3+0x9e>
 802012c:	0b03      	lsrs	r3, r0, #12
 802012e:	428b      	cmp	r3, r1
 8020130:	d328      	bcc.n	8020184 <__udivsi3+0x6c>
 8020132:	0c03      	lsrs	r3, r0, #16
 8020134:	428b      	cmp	r3, r1
 8020136:	d30d      	bcc.n	8020154 <__udivsi3+0x3c>
 8020138:	22ff      	movs	r2, #255	@ 0xff
 802013a:	0209      	lsls	r1, r1, #8
 802013c:	ba12      	rev	r2, r2
 802013e:	0c03      	lsrs	r3, r0, #16
 8020140:	428b      	cmp	r3, r1
 8020142:	d302      	bcc.n	802014a <__udivsi3+0x32>
 8020144:	1212      	asrs	r2, r2, #8
 8020146:	0209      	lsls	r1, r1, #8
 8020148:	d065      	beq.n	8020216 <__udivsi3+0xfe>
 802014a:	0b03      	lsrs	r3, r0, #12
 802014c:	428b      	cmp	r3, r1
 802014e:	d319      	bcc.n	8020184 <__udivsi3+0x6c>
 8020150:	e000      	b.n	8020154 <__udivsi3+0x3c>
 8020152:	0a09      	lsrs	r1, r1, #8
 8020154:	0bc3      	lsrs	r3, r0, #15
 8020156:	428b      	cmp	r3, r1
 8020158:	d301      	bcc.n	802015e <__udivsi3+0x46>
 802015a:	03cb      	lsls	r3, r1, #15
 802015c:	1ac0      	subs	r0, r0, r3
 802015e:	4152      	adcs	r2, r2
 8020160:	0b83      	lsrs	r3, r0, #14
 8020162:	428b      	cmp	r3, r1
 8020164:	d301      	bcc.n	802016a <__udivsi3+0x52>
 8020166:	038b      	lsls	r3, r1, #14
 8020168:	1ac0      	subs	r0, r0, r3
 802016a:	4152      	adcs	r2, r2
 802016c:	0b43      	lsrs	r3, r0, #13
 802016e:	428b      	cmp	r3, r1
 8020170:	d301      	bcc.n	8020176 <__udivsi3+0x5e>
 8020172:	034b      	lsls	r3, r1, #13
 8020174:	1ac0      	subs	r0, r0, r3
 8020176:	4152      	adcs	r2, r2
 8020178:	0b03      	lsrs	r3, r0, #12
 802017a:	428b      	cmp	r3, r1
 802017c:	d301      	bcc.n	8020182 <__udivsi3+0x6a>
 802017e:	030b      	lsls	r3, r1, #12
 8020180:	1ac0      	subs	r0, r0, r3
 8020182:	4152      	adcs	r2, r2
 8020184:	0ac3      	lsrs	r3, r0, #11
 8020186:	428b      	cmp	r3, r1
 8020188:	d301      	bcc.n	802018e <__udivsi3+0x76>
 802018a:	02cb      	lsls	r3, r1, #11
 802018c:	1ac0      	subs	r0, r0, r3
 802018e:	4152      	adcs	r2, r2
 8020190:	0a83      	lsrs	r3, r0, #10
 8020192:	428b      	cmp	r3, r1
 8020194:	d301      	bcc.n	802019a <__udivsi3+0x82>
 8020196:	028b      	lsls	r3, r1, #10
 8020198:	1ac0      	subs	r0, r0, r3
 802019a:	4152      	adcs	r2, r2
 802019c:	0a43      	lsrs	r3, r0, #9
 802019e:	428b      	cmp	r3, r1
 80201a0:	d301      	bcc.n	80201a6 <__udivsi3+0x8e>
 80201a2:	024b      	lsls	r3, r1, #9
 80201a4:	1ac0      	subs	r0, r0, r3
 80201a6:	4152      	adcs	r2, r2
 80201a8:	0a03      	lsrs	r3, r0, #8
 80201aa:	428b      	cmp	r3, r1
 80201ac:	d301      	bcc.n	80201b2 <__udivsi3+0x9a>
 80201ae:	020b      	lsls	r3, r1, #8
 80201b0:	1ac0      	subs	r0, r0, r3
 80201b2:	4152      	adcs	r2, r2
 80201b4:	d2cd      	bcs.n	8020152 <__udivsi3+0x3a>
 80201b6:	09c3      	lsrs	r3, r0, #7
 80201b8:	428b      	cmp	r3, r1
 80201ba:	d301      	bcc.n	80201c0 <__udivsi3+0xa8>
 80201bc:	01cb      	lsls	r3, r1, #7
 80201be:	1ac0      	subs	r0, r0, r3
 80201c0:	4152      	adcs	r2, r2
 80201c2:	0983      	lsrs	r3, r0, #6
 80201c4:	428b      	cmp	r3, r1
 80201c6:	d301      	bcc.n	80201cc <__udivsi3+0xb4>
 80201c8:	018b      	lsls	r3, r1, #6
 80201ca:	1ac0      	subs	r0, r0, r3
 80201cc:	4152      	adcs	r2, r2
 80201ce:	0943      	lsrs	r3, r0, #5
 80201d0:	428b      	cmp	r3, r1
 80201d2:	d301      	bcc.n	80201d8 <__udivsi3+0xc0>
 80201d4:	014b      	lsls	r3, r1, #5
 80201d6:	1ac0      	subs	r0, r0, r3
 80201d8:	4152      	adcs	r2, r2
 80201da:	0903      	lsrs	r3, r0, #4
 80201dc:	428b      	cmp	r3, r1
 80201de:	d301      	bcc.n	80201e4 <__udivsi3+0xcc>
 80201e0:	010b      	lsls	r3, r1, #4
 80201e2:	1ac0      	subs	r0, r0, r3
 80201e4:	4152      	adcs	r2, r2
 80201e6:	08c3      	lsrs	r3, r0, #3
 80201e8:	428b      	cmp	r3, r1
 80201ea:	d301      	bcc.n	80201f0 <__udivsi3+0xd8>
 80201ec:	00cb      	lsls	r3, r1, #3
 80201ee:	1ac0      	subs	r0, r0, r3
 80201f0:	4152      	adcs	r2, r2
 80201f2:	0883      	lsrs	r3, r0, #2
 80201f4:	428b      	cmp	r3, r1
 80201f6:	d301      	bcc.n	80201fc <__udivsi3+0xe4>
 80201f8:	008b      	lsls	r3, r1, #2
 80201fa:	1ac0      	subs	r0, r0, r3
 80201fc:	4152      	adcs	r2, r2
 80201fe:	0843      	lsrs	r3, r0, #1
 8020200:	428b      	cmp	r3, r1
 8020202:	d301      	bcc.n	8020208 <__udivsi3+0xf0>
 8020204:	004b      	lsls	r3, r1, #1
 8020206:	1ac0      	subs	r0, r0, r3
 8020208:	4152      	adcs	r2, r2
 802020a:	1a41      	subs	r1, r0, r1
 802020c:	d200      	bcs.n	8020210 <__udivsi3+0xf8>
 802020e:	4601      	mov	r1, r0
 8020210:	4152      	adcs	r2, r2
 8020212:	4610      	mov	r0, r2
 8020214:	4770      	bx	lr
 8020216:	e7ff      	b.n	8020218 <__udivsi3+0x100>
 8020218:	b501      	push	{r0, lr}
 802021a:	2000      	movs	r0, #0
 802021c:	f000 f8f0 	bl	8020400 <__aeabi_idiv0>
 8020220:	bd02      	pop	{r1, pc}
 8020222:	46c0      	nop			@ (mov r8, r8)

08020224 <__aeabi_uidivmod>:
 8020224:	2900      	cmp	r1, #0
 8020226:	d0f7      	beq.n	8020218 <__udivsi3+0x100>
 8020228:	e776      	b.n	8020118 <__udivsi3>
 802022a:	4770      	bx	lr

0802022c <__divsi3>:
 802022c:	4603      	mov	r3, r0
 802022e:	430b      	orrs	r3, r1
 8020230:	d47f      	bmi.n	8020332 <__divsi3+0x106>
 8020232:	2200      	movs	r2, #0
 8020234:	0843      	lsrs	r3, r0, #1
 8020236:	428b      	cmp	r3, r1
 8020238:	d374      	bcc.n	8020324 <__divsi3+0xf8>
 802023a:	0903      	lsrs	r3, r0, #4
 802023c:	428b      	cmp	r3, r1
 802023e:	d35f      	bcc.n	8020300 <__divsi3+0xd4>
 8020240:	0a03      	lsrs	r3, r0, #8
 8020242:	428b      	cmp	r3, r1
 8020244:	d344      	bcc.n	80202d0 <__divsi3+0xa4>
 8020246:	0b03      	lsrs	r3, r0, #12
 8020248:	428b      	cmp	r3, r1
 802024a:	d328      	bcc.n	802029e <__divsi3+0x72>
 802024c:	0c03      	lsrs	r3, r0, #16
 802024e:	428b      	cmp	r3, r1
 8020250:	d30d      	bcc.n	802026e <__divsi3+0x42>
 8020252:	22ff      	movs	r2, #255	@ 0xff
 8020254:	0209      	lsls	r1, r1, #8
 8020256:	ba12      	rev	r2, r2
 8020258:	0c03      	lsrs	r3, r0, #16
 802025a:	428b      	cmp	r3, r1
 802025c:	d302      	bcc.n	8020264 <__divsi3+0x38>
 802025e:	1212      	asrs	r2, r2, #8
 8020260:	0209      	lsls	r1, r1, #8
 8020262:	d065      	beq.n	8020330 <__divsi3+0x104>
 8020264:	0b03      	lsrs	r3, r0, #12
 8020266:	428b      	cmp	r3, r1
 8020268:	d319      	bcc.n	802029e <__divsi3+0x72>
 802026a:	e000      	b.n	802026e <__divsi3+0x42>
 802026c:	0a09      	lsrs	r1, r1, #8
 802026e:	0bc3      	lsrs	r3, r0, #15
 8020270:	428b      	cmp	r3, r1
 8020272:	d301      	bcc.n	8020278 <__divsi3+0x4c>
 8020274:	03cb      	lsls	r3, r1, #15
 8020276:	1ac0      	subs	r0, r0, r3
 8020278:	4152      	adcs	r2, r2
 802027a:	0b83      	lsrs	r3, r0, #14
 802027c:	428b      	cmp	r3, r1
 802027e:	d301      	bcc.n	8020284 <__divsi3+0x58>
 8020280:	038b      	lsls	r3, r1, #14
 8020282:	1ac0      	subs	r0, r0, r3
 8020284:	4152      	adcs	r2, r2
 8020286:	0b43      	lsrs	r3, r0, #13
 8020288:	428b      	cmp	r3, r1
 802028a:	d301      	bcc.n	8020290 <__divsi3+0x64>
 802028c:	034b      	lsls	r3, r1, #13
 802028e:	1ac0      	subs	r0, r0, r3
 8020290:	4152      	adcs	r2, r2
 8020292:	0b03      	lsrs	r3, r0, #12
 8020294:	428b      	cmp	r3, r1
 8020296:	d301      	bcc.n	802029c <__divsi3+0x70>
 8020298:	030b      	lsls	r3, r1, #12
 802029a:	1ac0      	subs	r0, r0, r3
 802029c:	4152      	adcs	r2, r2
 802029e:	0ac3      	lsrs	r3, r0, #11
 80202a0:	428b      	cmp	r3, r1
 80202a2:	d301      	bcc.n	80202a8 <__divsi3+0x7c>
 80202a4:	02cb      	lsls	r3, r1, #11
 80202a6:	1ac0      	subs	r0, r0, r3
 80202a8:	4152      	adcs	r2, r2
 80202aa:	0a83      	lsrs	r3, r0, #10
 80202ac:	428b      	cmp	r3, r1
 80202ae:	d301      	bcc.n	80202b4 <__divsi3+0x88>
 80202b0:	028b      	lsls	r3, r1, #10
 80202b2:	1ac0      	subs	r0, r0, r3
 80202b4:	4152      	adcs	r2, r2
 80202b6:	0a43      	lsrs	r3, r0, #9
 80202b8:	428b      	cmp	r3, r1
 80202ba:	d301      	bcc.n	80202c0 <__divsi3+0x94>
 80202bc:	024b      	lsls	r3, r1, #9
 80202be:	1ac0      	subs	r0, r0, r3
 80202c0:	4152      	adcs	r2, r2
 80202c2:	0a03      	lsrs	r3, r0, #8
 80202c4:	428b      	cmp	r3, r1
 80202c6:	d301      	bcc.n	80202cc <__divsi3+0xa0>
 80202c8:	020b      	lsls	r3, r1, #8
 80202ca:	1ac0      	subs	r0, r0, r3
 80202cc:	4152      	adcs	r2, r2
 80202ce:	d2cd      	bcs.n	802026c <__divsi3+0x40>
 80202d0:	09c3      	lsrs	r3, r0, #7
 80202d2:	428b      	cmp	r3, r1
 80202d4:	d301      	bcc.n	80202da <__divsi3+0xae>
 80202d6:	01cb      	lsls	r3, r1, #7
 80202d8:	1ac0      	subs	r0, r0, r3
 80202da:	4152      	adcs	r2, r2
 80202dc:	0983      	lsrs	r3, r0, #6
 80202de:	428b      	cmp	r3, r1
 80202e0:	d301      	bcc.n	80202e6 <__divsi3+0xba>
 80202e2:	018b      	lsls	r3, r1, #6
 80202e4:	1ac0      	subs	r0, r0, r3
 80202e6:	4152      	adcs	r2, r2
 80202e8:	0943      	lsrs	r3, r0, #5
 80202ea:	428b      	cmp	r3, r1
 80202ec:	d301      	bcc.n	80202f2 <__divsi3+0xc6>
 80202ee:	014b      	lsls	r3, r1, #5
 80202f0:	1ac0      	subs	r0, r0, r3
 80202f2:	4152      	adcs	r2, r2
 80202f4:	0903      	lsrs	r3, r0, #4
 80202f6:	428b      	cmp	r3, r1
 80202f8:	d301      	bcc.n	80202fe <__divsi3+0xd2>
 80202fa:	010b      	lsls	r3, r1, #4
 80202fc:	1ac0      	subs	r0, r0, r3
 80202fe:	4152      	adcs	r2, r2
 8020300:	08c3      	lsrs	r3, r0, #3
 8020302:	428b      	cmp	r3, r1
 8020304:	d301      	bcc.n	802030a <__divsi3+0xde>
 8020306:	00cb      	lsls	r3, r1, #3
 8020308:	1ac0      	subs	r0, r0, r3
 802030a:	4152      	adcs	r2, r2
 802030c:	0883      	lsrs	r3, r0, #2
 802030e:	428b      	cmp	r3, r1
 8020310:	d301      	bcc.n	8020316 <__divsi3+0xea>
 8020312:	008b      	lsls	r3, r1, #2
 8020314:	1ac0      	subs	r0, r0, r3
 8020316:	4152      	adcs	r2, r2
 8020318:	0843      	lsrs	r3, r0, #1
 802031a:	428b      	cmp	r3, r1
 802031c:	d301      	bcc.n	8020322 <__divsi3+0xf6>
 802031e:	004b      	lsls	r3, r1, #1
 8020320:	1ac0      	subs	r0, r0, r3
 8020322:	4152      	adcs	r2, r2
 8020324:	1a41      	subs	r1, r0, r1
 8020326:	d200      	bcs.n	802032a <__divsi3+0xfe>
 8020328:	4601      	mov	r1, r0
 802032a:	4152      	adcs	r2, r2
 802032c:	4610      	mov	r0, r2
 802032e:	4770      	bx	lr
 8020330:	e05d      	b.n	80203ee <__divsi3+0x1c2>
 8020332:	0fca      	lsrs	r2, r1, #31
 8020334:	d000      	beq.n	8020338 <__divsi3+0x10c>
 8020336:	4249      	negs	r1, r1
 8020338:	1003      	asrs	r3, r0, #32
 802033a:	d300      	bcc.n	802033e <__divsi3+0x112>
 802033c:	4240      	negs	r0, r0
 802033e:	4053      	eors	r3, r2
 8020340:	2200      	movs	r2, #0
 8020342:	469c      	mov	ip, r3
 8020344:	0903      	lsrs	r3, r0, #4
 8020346:	428b      	cmp	r3, r1
 8020348:	d32d      	bcc.n	80203a6 <__divsi3+0x17a>
 802034a:	0a03      	lsrs	r3, r0, #8
 802034c:	428b      	cmp	r3, r1
 802034e:	d312      	bcc.n	8020376 <__divsi3+0x14a>
 8020350:	22fc      	movs	r2, #252	@ 0xfc
 8020352:	0189      	lsls	r1, r1, #6
 8020354:	ba12      	rev	r2, r2
 8020356:	0a03      	lsrs	r3, r0, #8
 8020358:	428b      	cmp	r3, r1
 802035a:	d30c      	bcc.n	8020376 <__divsi3+0x14a>
 802035c:	0189      	lsls	r1, r1, #6
 802035e:	1192      	asrs	r2, r2, #6
 8020360:	428b      	cmp	r3, r1
 8020362:	d308      	bcc.n	8020376 <__divsi3+0x14a>
 8020364:	0189      	lsls	r1, r1, #6
 8020366:	1192      	asrs	r2, r2, #6
 8020368:	428b      	cmp	r3, r1
 802036a:	d304      	bcc.n	8020376 <__divsi3+0x14a>
 802036c:	0189      	lsls	r1, r1, #6
 802036e:	d03a      	beq.n	80203e6 <__divsi3+0x1ba>
 8020370:	1192      	asrs	r2, r2, #6
 8020372:	e000      	b.n	8020376 <__divsi3+0x14a>
 8020374:	0989      	lsrs	r1, r1, #6
 8020376:	09c3      	lsrs	r3, r0, #7
 8020378:	428b      	cmp	r3, r1
 802037a:	d301      	bcc.n	8020380 <__divsi3+0x154>
 802037c:	01cb      	lsls	r3, r1, #7
 802037e:	1ac0      	subs	r0, r0, r3
 8020380:	4152      	adcs	r2, r2
 8020382:	0983      	lsrs	r3, r0, #6
 8020384:	428b      	cmp	r3, r1
 8020386:	d301      	bcc.n	802038c <__divsi3+0x160>
 8020388:	018b      	lsls	r3, r1, #6
 802038a:	1ac0      	subs	r0, r0, r3
 802038c:	4152      	adcs	r2, r2
 802038e:	0943      	lsrs	r3, r0, #5
 8020390:	428b      	cmp	r3, r1
 8020392:	d301      	bcc.n	8020398 <__divsi3+0x16c>
 8020394:	014b      	lsls	r3, r1, #5
 8020396:	1ac0      	subs	r0, r0, r3
 8020398:	4152      	adcs	r2, r2
 802039a:	0903      	lsrs	r3, r0, #4
 802039c:	428b      	cmp	r3, r1
 802039e:	d301      	bcc.n	80203a4 <__divsi3+0x178>
 80203a0:	010b      	lsls	r3, r1, #4
 80203a2:	1ac0      	subs	r0, r0, r3
 80203a4:	4152      	adcs	r2, r2
 80203a6:	08c3      	lsrs	r3, r0, #3
 80203a8:	428b      	cmp	r3, r1
 80203aa:	d301      	bcc.n	80203b0 <__divsi3+0x184>
 80203ac:	00cb      	lsls	r3, r1, #3
 80203ae:	1ac0      	subs	r0, r0, r3
 80203b0:	4152      	adcs	r2, r2
 80203b2:	0883      	lsrs	r3, r0, #2
 80203b4:	428b      	cmp	r3, r1
 80203b6:	d301      	bcc.n	80203bc <__divsi3+0x190>
 80203b8:	008b      	lsls	r3, r1, #2
 80203ba:	1ac0      	subs	r0, r0, r3
 80203bc:	4152      	adcs	r2, r2
 80203be:	d2d9      	bcs.n	8020374 <__divsi3+0x148>
 80203c0:	0843      	lsrs	r3, r0, #1
 80203c2:	428b      	cmp	r3, r1
 80203c4:	d301      	bcc.n	80203ca <__divsi3+0x19e>
 80203c6:	004b      	lsls	r3, r1, #1
 80203c8:	1ac0      	subs	r0, r0, r3
 80203ca:	4152      	adcs	r2, r2
 80203cc:	1a41      	subs	r1, r0, r1
 80203ce:	d200      	bcs.n	80203d2 <__divsi3+0x1a6>
 80203d0:	4601      	mov	r1, r0
 80203d2:	4663      	mov	r3, ip
 80203d4:	4152      	adcs	r2, r2
 80203d6:	105b      	asrs	r3, r3, #1
 80203d8:	4610      	mov	r0, r2
 80203da:	d301      	bcc.n	80203e0 <__divsi3+0x1b4>
 80203dc:	4240      	negs	r0, r0
 80203de:	2b00      	cmp	r3, #0
 80203e0:	d500      	bpl.n	80203e4 <__divsi3+0x1b8>
 80203e2:	4249      	negs	r1, r1
 80203e4:	4770      	bx	lr
 80203e6:	4663      	mov	r3, ip
 80203e8:	105b      	asrs	r3, r3, #1
 80203ea:	d300      	bcc.n	80203ee <__divsi3+0x1c2>
 80203ec:	4240      	negs	r0, r0
 80203ee:	b501      	push	{r0, lr}
 80203f0:	2000      	movs	r0, #0
 80203f2:	f000 f805 	bl	8020400 <__aeabi_idiv0>
 80203f6:	bd02      	pop	{r1, pc}

080203f8 <__aeabi_idivmod>:
 80203f8:	2900      	cmp	r1, #0
 80203fa:	d0f8      	beq.n	80203ee <__divsi3+0x1c2>
 80203fc:	e716      	b.n	802022c <__divsi3>
 80203fe:	4770      	bx	lr

08020400 <__aeabi_idiv0>:
 8020400:	4770      	bx	lr
 8020402:	46c0      	nop			@ (mov r8, r8)

08020404 <__aeabi_uldivmod>:
 8020404:	2b00      	cmp	r3, #0
 8020406:	d111      	bne.n	802042c <__aeabi_uldivmod+0x28>
 8020408:	2a00      	cmp	r2, #0
 802040a:	d10f      	bne.n	802042c <__aeabi_uldivmod+0x28>
 802040c:	2900      	cmp	r1, #0
 802040e:	d100      	bne.n	8020412 <__aeabi_uldivmod+0xe>
 8020410:	2800      	cmp	r0, #0
 8020412:	d002      	beq.n	802041a <__aeabi_uldivmod+0x16>
 8020414:	2100      	movs	r1, #0
 8020416:	43c9      	mvns	r1, r1
 8020418:	0008      	movs	r0, r1
 802041a:	b407      	push	{r0, r1, r2}
 802041c:	4802      	ldr	r0, [pc, #8]	@ (8020428 <__aeabi_uldivmod+0x24>)
 802041e:	a102      	add	r1, pc, #8	@ (adr r1, 8020428 <__aeabi_uldivmod+0x24>)
 8020420:	1840      	adds	r0, r0, r1
 8020422:	9002      	str	r0, [sp, #8]
 8020424:	bd03      	pop	{r0, r1, pc}
 8020426:	46c0      	nop			@ (mov r8, r8)
 8020428:	ffffffd9 	.word	0xffffffd9
 802042c:	b403      	push	{r0, r1}
 802042e:	4668      	mov	r0, sp
 8020430:	b501      	push	{r0, lr}
 8020432:	9802      	ldr	r0, [sp, #8]
 8020434:	f000 f834 	bl	80204a0 <__udivmoddi4>
 8020438:	9b01      	ldr	r3, [sp, #4]
 802043a:	469e      	mov	lr, r3
 802043c:	b002      	add	sp, #8
 802043e:	bc0c      	pop	{r2, r3}
 8020440:	4770      	bx	lr
 8020442:	46c0      	nop			@ (mov r8, r8)

08020444 <__aeabi_lmul>:
 8020444:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020446:	46ce      	mov	lr, r9
 8020448:	4699      	mov	r9, r3
 802044a:	0c03      	lsrs	r3, r0, #16
 802044c:	469c      	mov	ip, r3
 802044e:	0413      	lsls	r3, r2, #16
 8020450:	4647      	mov	r7, r8
 8020452:	0c1b      	lsrs	r3, r3, #16
 8020454:	001d      	movs	r5, r3
 8020456:	000e      	movs	r6, r1
 8020458:	4661      	mov	r1, ip
 802045a:	0404      	lsls	r4, r0, #16
 802045c:	0c24      	lsrs	r4, r4, #16
 802045e:	b580      	push	{r7, lr}
 8020460:	0007      	movs	r7, r0
 8020462:	0c10      	lsrs	r0, r2, #16
 8020464:	434b      	muls	r3, r1
 8020466:	4365      	muls	r5, r4
 8020468:	4341      	muls	r1, r0
 802046a:	4360      	muls	r0, r4
 802046c:	0c2c      	lsrs	r4, r5, #16
 802046e:	18c0      	adds	r0, r0, r3
 8020470:	1824      	adds	r4, r4, r0
 8020472:	468c      	mov	ip, r1
 8020474:	42a3      	cmp	r3, r4
 8020476:	d903      	bls.n	8020480 <__aeabi_lmul+0x3c>
 8020478:	2380      	movs	r3, #128	@ 0x80
 802047a:	025b      	lsls	r3, r3, #9
 802047c:	4698      	mov	r8, r3
 802047e:	44c4      	add	ip, r8
 8020480:	4649      	mov	r1, r9
 8020482:	4379      	muls	r1, r7
 8020484:	4356      	muls	r6, r2
 8020486:	0c23      	lsrs	r3, r4, #16
 8020488:	042d      	lsls	r5, r5, #16
 802048a:	0c2d      	lsrs	r5, r5, #16
 802048c:	1989      	adds	r1, r1, r6
 802048e:	4463      	add	r3, ip
 8020490:	0424      	lsls	r4, r4, #16
 8020492:	1960      	adds	r0, r4, r5
 8020494:	18c9      	adds	r1, r1, r3
 8020496:	bcc0      	pop	{r6, r7}
 8020498:	46b9      	mov	r9, r7
 802049a:	46b0      	mov	r8, r6
 802049c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802049e:	46c0      	nop			@ (mov r8, r8)

080204a0 <__udivmoddi4>:
 80204a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80204a2:	4657      	mov	r7, sl
 80204a4:	464e      	mov	r6, r9
 80204a6:	4645      	mov	r5, r8
 80204a8:	46de      	mov	lr, fp
 80204aa:	b5e0      	push	{r5, r6, r7, lr}
 80204ac:	0004      	movs	r4, r0
 80204ae:	000d      	movs	r5, r1
 80204b0:	4692      	mov	sl, r2
 80204b2:	4699      	mov	r9, r3
 80204b4:	b083      	sub	sp, #12
 80204b6:	428b      	cmp	r3, r1
 80204b8:	d830      	bhi.n	802051c <__udivmoddi4+0x7c>
 80204ba:	d02d      	beq.n	8020518 <__udivmoddi4+0x78>
 80204bc:	4649      	mov	r1, r9
 80204be:	4650      	mov	r0, sl
 80204c0:	f000 f8ba 	bl	8020638 <__clzdi2>
 80204c4:	0029      	movs	r1, r5
 80204c6:	0006      	movs	r6, r0
 80204c8:	0020      	movs	r0, r4
 80204ca:	f000 f8b5 	bl	8020638 <__clzdi2>
 80204ce:	1a33      	subs	r3, r6, r0
 80204d0:	4698      	mov	r8, r3
 80204d2:	3b20      	subs	r3, #32
 80204d4:	d434      	bmi.n	8020540 <__udivmoddi4+0xa0>
 80204d6:	469b      	mov	fp, r3
 80204d8:	4653      	mov	r3, sl
 80204da:	465a      	mov	r2, fp
 80204dc:	4093      	lsls	r3, r2
 80204de:	4642      	mov	r2, r8
 80204e0:	001f      	movs	r7, r3
 80204e2:	4653      	mov	r3, sl
 80204e4:	4093      	lsls	r3, r2
 80204e6:	001e      	movs	r6, r3
 80204e8:	42af      	cmp	r7, r5
 80204ea:	d83b      	bhi.n	8020564 <__udivmoddi4+0xc4>
 80204ec:	42af      	cmp	r7, r5
 80204ee:	d100      	bne.n	80204f2 <__udivmoddi4+0x52>
 80204f0:	e079      	b.n	80205e6 <__udivmoddi4+0x146>
 80204f2:	465b      	mov	r3, fp
 80204f4:	1ba4      	subs	r4, r4, r6
 80204f6:	41bd      	sbcs	r5, r7
 80204f8:	2b00      	cmp	r3, #0
 80204fa:	da00      	bge.n	80204fe <__udivmoddi4+0x5e>
 80204fc:	e076      	b.n	80205ec <__udivmoddi4+0x14c>
 80204fe:	2200      	movs	r2, #0
 8020500:	2300      	movs	r3, #0
 8020502:	9200      	str	r2, [sp, #0]
 8020504:	9301      	str	r3, [sp, #4]
 8020506:	2301      	movs	r3, #1
 8020508:	465a      	mov	r2, fp
 802050a:	4093      	lsls	r3, r2
 802050c:	9301      	str	r3, [sp, #4]
 802050e:	2301      	movs	r3, #1
 8020510:	4642      	mov	r2, r8
 8020512:	4093      	lsls	r3, r2
 8020514:	9300      	str	r3, [sp, #0]
 8020516:	e029      	b.n	802056c <__udivmoddi4+0xcc>
 8020518:	4282      	cmp	r2, r0
 802051a:	d9cf      	bls.n	80204bc <__udivmoddi4+0x1c>
 802051c:	2200      	movs	r2, #0
 802051e:	2300      	movs	r3, #0
 8020520:	9200      	str	r2, [sp, #0]
 8020522:	9301      	str	r3, [sp, #4]
 8020524:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8020526:	2b00      	cmp	r3, #0
 8020528:	d001      	beq.n	802052e <__udivmoddi4+0x8e>
 802052a:	601c      	str	r4, [r3, #0]
 802052c:	605d      	str	r5, [r3, #4]
 802052e:	9800      	ldr	r0, [sp, #0]
 8020530:	9901      	ldr	r1, [sp, #4]
 8020532:	b003      	add	sp, #12
 8020534:	bcf0      	pop	{r4, r5, r6, r7}
 8020536:	46bb      	mov	fp, r7
 8020538:	46b2      	mov	sl, r6
 802053a:	46a9      	mov	r9, r5
 802053c:	46a0      	mov	r8, r4
 802053e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020540:	4642      	mov	r2, r8
 8020542:	469b      	mov	fp, r3
 8020544:	2320      	movs	r3, #32
 8020546:	1a9b      	subs	r3, r3, r2
 8020548:	4652      	mov	r2, sl
 802054a:	40da      	lsrs	r2, r3
 802054c:	4641      	mov	r1, r8
 802054e:	0013      	movs	r3, r2
 8020550:	464a      	mov	r2, r9
 8020552:	408a      	lsls	r2, r1
 8020554:	0017      	movs	r7, r2
 8020556:	4642      	mov	r2, r8
 8020558:	431f      	orrs	r7, r3
 802055a:	4653      	mov	r3, sl
 802055c:	4093      	lsls	r3, r2
 802055e:	001e      	movs	r6, r3
 8020560:	42af      	cmp	r7, r5
 8020562:	d9c3      	bls.n	80204ec <__udivmoddi4+0x4c>
 8020564:	2200      	movs	r2, #0
 8020566:	2300      	movs	r3, #0
 8020568:	9200      	str	r2, [sp, #0]
 802056a:	9301      	str	r3, [sp, #4]
 802056c:	4643      	mov	r3, r8
 802056e:	2b00      	cmp	r3, #0
 8020570:	d0d8      	beq.n	8020524 <__udivmoddi4+0x84>
 8020572:	07fb      	lsls	r3, r7, #31
 8020574:	0872      	lsrs	r2, r6, #1
 8020576:	431a      	orrs	r2, r3
 8020578:	4646      	mov	r6, r8
 802057a:	087b      	lsrs	r3, r7, #1
 802057c:	e00e      	b.n	802059c <__udivmoddi4+0xfc>
 802057e:	42ab      	cmp	r3, r5
 8020580:	d101      	bne.n	8020586 <__udivmoddi4+0xe6>
 8020582:	42a2      	cmp	r2, r4
 8020584:	d80c      	bhi.n	80205a0 <__udivmoddi4+0x100>
 8020586:	1aa4      	subs	r4, r4, r2
 8020588:	419d      	sbcs	r5, r3
 802058a:	2001      	movs	r0, #1
 802058c:	1924      	adds	r4, r4, r4
 802058e:	416d      	adcs	r5, r5
 8020590:	2100      	movs	r1, #0
 8020592:	3e01      	subs	r6, #1
 8020594:	1824      	adds	r4, r4, r0
 8020596:	414d      	adcs	r5, r1
 8020598:	2e00      	cmp	r6, #0
 802059a:	d006      	beq.n	80205aa <__udivmoddi4+0x10a>
 802059c:	42ab      	cmp	r3, r5
 802059e:	d9ee      	bls.n	802057e <__udivmoddi4+0xde>
 80205a0:	3e01      	subs	r6, #1
 80205a2:	1924      	adds	r4, r4, r4
 80205a4:	416d      	adcs	r5, r5
 80205a6:	2e00      	cmp	r6, #0
 80205a8:	d1f8      	bne.n	802059c <__udivmoddi4+0xfc>
 80205aa:	9800      	ldr	r0, [sp, #0]
 80205ac:	9901      	ldr	r1, [sp, #4]
 80205ae:	465b      	mov	r3, fp
 80205b0:	1900      	adds	r0, r0, r4
 80205b2:	4169      	adcs	r1, r5
 80205b4:	2b00      	cmp	r3, #0
 80205b6:	db24      	blt.n	8020602 <__udivmoddi4+0x162>
 80205b8:	002b      	movs	r3, r5
 80205ba:	465a      	mov	r2, fp
 80205bc:	4644      	mov	r4, r8
 80205be:	40d3      	lsrs	r3, r2
 80205c0:	002a      	movs	r2, r5
 80205c2:	40e2      	lsrs	r2, r4
 80205c4:	001c      	movs	r4, r3
 80205c6:	465b      	mov	r3, fp
 80205c8:	0015      	movs	r5, r2
 80205ca:	2b00      	cmp	r3, #0
 80205cc:	db2a      	blt.n	8020624 <__udivmoddi4+0x184>
 80205ce:	0026      	movs	r6, r4
 80205d0:	409e      	lsls	r6, r3
 80205d2:	0033      	movs	r3, r6
 80205d4:	0026      	movs	r6, r4
 80205d6:	4647      	mov	r7, r8
 80205d8:	40be      	lsls	r6, r7
 80205da:	0032      	movs	r2, r6
 80205dc:	1a80      	subs	r0, r0, r2
 80205de:	4199      	sbcs	r1, r3
 80205e0:	9000      	str	r0, [sp, #0]
 80205e2:	9101      	str	r1, [sp, #4]
 80205e4:	e79e      	b.n	8020524 <__udivmoddi4+0x84>
 80205e6:	42a3      	cmp	r3, r4
 80205e8:	d8bc      	bhi.n	8020564 <__udivmoddi4+0xc4>
 80205ea:	e782      	b.n	80204f2 <__udivmoddi4+0x52>
 80205ec:	4642      	mov	r2, r8
 80205ee:	2320      	movs	r3, #32
 80205f0:	2100      	movs	r1, #0
 80205f2:	1a9b      	subs	r3, r3, r2
 80205f4:	2200      	movs	r2, #0
 80205f6:	9100      	str	r1, [sp, #0]
 80205f8:	9201      	str	r2, [sp, #4]
 80205fa:	2201      	movs	r2, #1
 80205fc:	40da      	lsrs	r2, r3
 80205fe:	9201      	str	r2, [sp, #4]
 8020600:	e785      	b.n	802050e <__udivmoddi4+0x6e>
 8020602:	4642      	mov	r2, r8
 8020604:	2320      	movs	r3, #32
 8020606:	1a9b      	subs	r3, r3, r2
 8020608:	002a      	movs	r2, r5
 802060a:	4646      	mov	r6, r8
 802060c:	409a      	lsls	r2, r3
 802060e:	0023      	movs	r3, r4
 8020610:	40f3      	lsrs	r3, r6
 8020612:	4644      	mov	r4, r8
 8020614:	4313      	orrs	r3, r2
 8020616:	002a      	movs	r2, r5
 8020618:	40e2      	lsrs	r2, r4
 802061a:	001c      	movs	r4, r3
 802061c:	465b      	mov	r3, fp
 802061e:	0015      	movs	r5, r2
 8020620:	2b00      	cmp	r3, #0
 8020622:	dad4      	bge.n	80205ce <__udivmoddi4+0x12e>
 8020624:	4642      	mov	r2, r8
 8020626:	002f      	movs	r7, r5
 8020628:	2320      	movs	r3, #32
 802062a:	0026      	movs	r6, r4
 802062c:	4097      	lsls	r7, r2
 802062e:	1a9b      	subs	r3, r3, r2
 8020630:	40de      	lsrs	r6, r3
 8020632:	003b      	movs	r3, r7
 8020634:	4333      	orrs	r3, r6
 8020636:	e7cd      	b.n	80205d4 <__udivmoddi4+0x134>

08020638 <__clzdi2>:
 8020638:	b510      	push	{r4, lr}
 802063a:	2900      	cmp	r1, #0
 802063c:	d103      	bne.n	8020646 <__clzdi2+0xe>
 802063e:	f000 f807 	bl	8020650 <__clzsi2>
 8020642:	3020      	adds	r0, #32
 8020644:	e002      	b.n	802064c <__clzdi2+0x14>
 8020646:	0008      	movs	r0, r1
 8020648:	f000 f802 	bl	8020650 <__clzsi2>
 802064c:	bd10      	pop	{r4, pc}
 802064e:	46c0      	nop			@ (mov r8, r8)

08020650 <__clzsi2>:
 8020650:	211c      	movs	r1, #28
 8020652:	2301      	movs	r3, #1
 8020654:	041b      	lsls	r3, r3, #16
 8020656:	4298      	cmp	r0, r3
 8020658:	d301      	bcc.n	802065e <__clzsi2+0xe>
 802065a:	0c00      	lsrs	r0, r0, #16
 802065c:	3910      	subs	r1, #16
 802065e:	0a1b      	lsrs	r3, r3, #8
 8020660:	4298      	cmp	r0, r3
 8020662:	d301      	bcc.n	8020668 <__clzsi2+0x18>
 8020664:	0a00      	lsrs	r0, r0, #8
 8020666:	3908      	subs	r1, #8
 8020668:	091b      	lsrs	r3, r3, #4
 802066a:	4298      	cmp	r0, r3
 802066c:	d301      	bcc.n	8020672 <__clzsi2+0x22>
 802066e:	0900      	lsrs	r0, r0, #4
 8020670:	3904      	subs	r1, #4
 8020672:	a202      	add	r2, pc, #8	@ (adr r2, 802067c <__clzsi2+0x2c>)
 8020674:	5c10      	ldrb	r0, [r2, r0]
 8020676:	1840      	adds	r0, r0, r1
 8020678:	4770      	bx	lr
 802067a:	46c0      	nop			@ (mov r8, r8)
 802067c:	02020304 	.word	0x02020304
 8020680:	01010101 	.word	0x01010101
	...

0802068c <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
 802068c:	b530      	push	{r4, r5, lr}
 802068e:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8020690:	2214      	movs	r2, #20
 8020692:	2100      	movs	r1, #0
 8020694:	a801      	add	r0, sp, #4
 8020696:	f005 fdfd 	bl	8026294 <memset>
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB2ENR, Periphs);
 802069a:	21b0      	movs	r1, #176	@ 0xb0
 802069c:	05c9      	lsls	r1, r1, #23
 802069e:	22a6      	movs	r2, #166	@ 0xa6
 80206a0:	0052      	lsls	r2, r2, #1
 80206a2:	5888      	ldr	r0, [r1, r2]
 80206a4:	2302      	movs	r3, #2
 80206a6:	4318      	orrs	r0, r3
 80206a8:	5088      	str	r0, [r1, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB2ENR, Periphs);
 80206aa:	588a      	ldr	r2, [r1, r2]
 80206ac:	4013      	ands	r3, r2
 80206ae:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 80206b0:	9b00      	ldr	r3, [sp, #0]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, PROB2_Pin|PROB1_Pin, GPIO_PIN_RESET);
 80206b2:	25c0      	movs	r5, #192	@ 0xc0
 80206b4:	01ad      	lsls	r5, r5, #6
 80206b6:	4c09      	ldr	r4, [pc, #36]	@ (80206dc <MX_GPIO_Init+0x50>)
 80206b8:	2200      	movs	r2, #0
 80206ba:	0029      	movs	r1, r5
 80206bc:	0020      	movs	r0, r4
 80206be:	f001 fc5f 	bl	8021f80 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PBPin PBPin */
  GPIO_InitStruct.Pin = PROB2_Pin|PROB1_Pin;
 80206c2:	9501      	str	r5, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80206c4:	2301      	movs	r3, #1
 80206c6:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80206c8:	2300      	movs	r3, #0
 80206ca:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80206cc:	3303      	adds	r3, #3
 80206ce:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80206d0:	a901      	add	r1, sp, #4
 80206d2:	0020      	movs	r0, r4
 80206d4:	f001 fba0 	bl	8021e18 <HAL_GPIO_Init>

}
 80206d8:	b007      	add	sp, #28
 80206da:	bd30      	pop	{r4, r5, pc}
 80206dc:	48000400 	.word	0x48000400

080206e0 <MX_IPCC_Init>:

IPCC_HandleTypeDef hipcc;

/* IPCC init function */
void MX_IPCC_Init(void)
{
 80206e0:	b510      	push	{r4, lr}
  /* USER CODE END IPCC_Init 0 */

  /* USER CODE BEGIN IPCC_Init 1 */

  /* USER CODE END IPCC_Init 1 */
  hipcc.Instance = IPCC;
 80206e2:	4805      	ldr	r0, [pc, #20]	@ (80206f8 <MX_IPCC_Init+0x18>)
 80206e4:	4b05      	ldr	r3, [pc, #20]	@ (80206fc <MX_IPCC_Init+0x1c>)
 80206e6:	6003      	str	r3, [r0, #0]
  if (HAL_IPCC_Init(&hipcc) != HAL_OK)
 80206e8:	f001 fd2e 	bl	8022148 <HAL_IPCC_Init>
 80206ec:	2800      	cmp	r0, #0
 80206ee:	d100      	bne.n	80206f2 <MX_IPCC_Init+0x12>
  }
  /* USER CODE BEGIN IPCC_Init 2 */

  /* USER CODE END IPCC_Init 2 */

}
 80206f0:	bd10      	pop	{r4, pc}
    Error_Handler();
 80206f2:	f000 f89f 	bl	8020834 <Error_Handler>
}
 80206f6:	e7fb      	b.n	80206f0 <MX_IPCC_Init+0x10>
 80206f8:	2000a034 	.word	0x2000a034
 80206fc:	58000c00 	.word	0x58000c00

08020700 <HAL_IPCC_MspInit>:

void HAL_IPCC_MspInit(IPCC_HandleTypeDef* ipccHandle)
{
 8020700:	b500      	push	{lr}
 8020702:	b083      	sub	sp, #12

  if(ipccHandle->Instance==IPCC)
 8020704:	6802      	ldr	r2, [r0, #0]
 8020706:	4b0d      	ldr	r3, [pc, #52]	@ (802073c <HAL_IPCC_MspInit+0x3c>)
 8020708:	429a      	cmp	r2, r3
 802070a:	d001      	beq.n	8020710 <HAL_IPCC_MspInit+0x10>
    HAL_NVIC_EnableIRQ(IPCC_C2_RX_C2_TX_IRQn);
  /* USER CODE BEGIN IPCC_MspInit 1 */

  /* USER CODE END IPCC_MspInit 1 */
  }
}
 802070c:	b003      	add	sp, #12
 802070e:	bd00      	pop	{pc}
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 8020710:	22b0      	movs	r2, #176	@ 0xb0
 8020712:	05d2      	lsls	r2, r2, #23
 8020714:	23a8      	movs	r3, #168	@ 0xa8
 8020716:	005b      	lsls	r3, r3, #1
 8020718:	58d1      	ldr	r1, [r2, r3]
 802071a:	2080      	movs	r0, #128	@ 0x80
 802071c:	0340      	lsls	r0, r0, #13
 802071e:	4301      	orrs	r1, r0
 8020720:	50d1      	str	r1, [r2, r3]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 8020722:	58d3      	ldr	r3, [r2, r3]
 8020724:	4003      	ands	r3, r0
 8020726:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8020728:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(IPCC_C2_RX_C2_TX_IRQn, 1, 0);
 802072a:	2200      	movs	r2, #0
 802072c:	2101      	movs	r1, #1
 802072e:	2012      	movs	r0, #18
 8020730:	f001 fa24 	bl	8021b7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(IPCC_C2_RX_C2_TX_IRQn);
 8020734:	2012      	movs	r0, #18
 8020736:	f001 fa25 	bl	8021b84 <HAL_NVIC_EnableIRQ>
}
 802073a:	e7e7      	b.n	802070c <HAL_IPCC_MspInit+0xc>
 802073c:	58000c00 	.word	0x58000c00

08020740 <IpccIfIsrTxCb>:
/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/

static void IpccIfIsrTxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 8020740:	b510      	push	{r4, lr}
 8020742:	0008      	movs	r0, r1

  /* USER CODE END IpccIfIsrTxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccAcknowledgeRcv(ChannelIndex);
 8020744:	4b01      	ldr	r3, [pc, #4]	@ (802074c <IpccIfIsrTxCb+0xc>)
 8020746:	681b      	ldr	r3, [r3, #0]
 8020748:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrTxCb_2 */

  /* USER CODE END IpccIfIsrTxCb_2 */
}
 802074a:	bd10      	pop	{r4, pc}
 802074c:	2000a070 	.word	0x2000a070

08020750 <IpccIfIsrRxCb>:

static void IpccIfIsrRxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 8020750:	b510      	push	{r4, lr}
 8020752:	0008      	movs	r0, r1

  /* USER CODE END IpccIfIsrRxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccCommandRcv(ChannelIndex);
 8020754:	4b01      	ldr	r3, [pc, #4]	@ (802075c <IpccIfIsrRxCb+0xc>)
 8020756:	681b      	ldr	r3, [r3, #0]
 8020758:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrRxCb_2 */

  /* USER CODE END IpccIfIsrRxCb_2 */
}
 802075a:	bd10      	pop	{r4, pc}
 802075c:	2000a074 	.word	0x2000a074

08020760 <IPCC_IF_Init>:
{
 8020760:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020762:	b083      	sub	sp, #12
 8020764:	0007      	movs	r7, r0
 8020766:	000e      	movs	r6, r1
  MX_IPCC_Init();
 8020768:	f7ff ffba 	bl	80206e0 <MX_IPCC_Init>
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 802076c:	22b0      	movs	r2, #176	@ 0xb0
 802076e:	05d2      	lsls	r2, r2, #23
 8020770:	23a8      	movs	r3, #168	@ 0xa8
 8020772:	005b      	lsls	r3, r3, #1
 8020774:	58d1      	ldr	r1, [r2, r3]
 8020776:	2080      	movs	r0, #128	@ 0x80
 8020778:	0340      	lsls	r0, r0, #13
 802077a:	4301      	orrs	r1, r0
 802077c:	50d1      	str	r1, [r2, r3]
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 802077e:	58d3      	ldr	r3, [r2, r3]
 8020780:	4003      	ands	r3, r0
 8020782:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8020784:	9b01      	ldr	r3, [sp, #4]
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_C2_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->C2IMR2, ExtiLine);
 8020786:	4b10      	ldr	r3, [pc, #64]	@ (80207c8 <IPCC_IF_Init+0x68>)
 8020788:	20d0      	movs	r0, #208	@ 0xd0
 802078a:	581a      	ldr	r2, [r3, r0]
 802078c:	2120      	movs	r1, #32
 802078e:	430a      	orrs	r2, r1
 8020790:	501a      	str	r2, [r3, r0]
  *         @arg @ref LL_EXTI_LINE_45
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->RTSR2, ExtiLine);
 8020792:	6a1a      	ldr	r2, [r3, #32]
 8020794:	430a      	orrs	r2, r1
 8020796:	621a      	str	r2, [r3, #32]
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8020798:	2400      	movs	r4, #0
 802079a:	e00d      	b.n	80207b8 <IPCC_IF_Init+0x58>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_TX, IpccIfIsrTxCb);
 802079c:	4b0b      	ldr	r3, [pc, #44]	@ (80207cc <IPCC_IF_Init+0x6c>)
 802079e:	4d0c      	ldr	r5, [pc, #48]	@ (80207d0 <IPCC_IF_Init+0x70>)
 80207a0:	2200      	movs	r2, #0
 80207a2:	0021      	movs	r1, r4
 80207a4:	0028      	movs	r0, r5
 80207a6:	f001 fc5d 	bl	8022064 <HAL_IPCC_ActivateNotification>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_RX, IpccIfIsrRxCb);
 80207aa:	4b0a      	ldr	r3, [pc, #40]	@ (80207d4 <IPCC_IF_Init+0x74>)
 80207ac:	2201      	movs	r2, #1
 80207ae:	0021      	movs	r1, r4
 80207b0:	0028      	movs	r0, r5
 80207b2:	f001 fc57 	bl	8022064 <HAL_IPCC_ActivateNotification>
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 80207b6:	3401      	adds	r4, #1
 80207b8:	2c05      	cmp	r4, #5
 80207ba:	d9ef      	bls.n	802079c <IPCC_IF_Init+0x3c>
  IpccCommandRcv = IPCC_IF_CommandRcv_cb;
 80207bc:	4b06      	ldr	r3, [pc, #24]	@ (80207d8 <IPCC_IF_Init+0x78>)
 80207be:	601f      	str	r7, [r3, #0]
  IpccAcknowledgeRcv = IPCC_IF_AcknowledgeRcv_cb;
 80207c0:	4b06      	ldr	r3, [pc, #24]	@ (80207dc <IPCC_IF_Init+0x7c>)
 80207c2:	601e      	str	r6, [r3, #0]
}
 80207c4:	b003      	add	sp, #12
 80207c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80207c8:	58000800 	.word	0x58000800
 80207cc:	08020741 	.word	0x08020741
 80207d0:	2000a034 	.word	0x2000a034
 80207d4:	08020751 	.word	0x08020751
 80207d8:	2000a074 	.word	0x2000a074
 80207dc:	2000a070 	.word	0x2000a070

080207e0 <IPCC_IF_NotificationSnd>:
{
 80207e0:	b510      	push	{r4, lr}
 80207e2:	0001      	movs	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_TX))
 80207e4:	4b05      	ldr	r3, [pc, #20]	@ (80207fc <IPCC_IF_NotificationSnd+0x1c>)
 80207e6:	2200      	movs	r2, #0
 80207e8:	0018      	movs	r0, r3
 80207ea:	f001 fc6b 	bl	80220c4 <HAL_IPCC_NotifyCPU>
 80207ee:	2800      	cmp	r0, #0
 80207f0:	d101      	bne.n	80207f6 <IPCC_IF_NotificationSnd+0x16>
    return 0;
 80207f2:	2000      	movs	r0, #0
}
 80207f4:	bd10      	pop	{r4, pc}
    return -1;
 80207f6:	2001      	movs	r0, #1
 80207f8:	4240      	negs	r0, r0
 80207fa:	e7fb      	b.n	80207f4 <IPCC_IF_NotificationSnd+0x14>
 80207fc:	2000a034 	.word	0x2000a034

08020800 <IPCC_IF_ResponseSnd>:
{
 8020800:	b510      	push	{r4, lr}
 8020802:	0001      	movs	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_RX))
 8020804:	4b05      	ldr	r3, [pc, #20]	@ (802081c <IPCC_IF_ResponseSnd+0x1c>)
 8020806:	2201      	movs	r2, #1
 8020808:	0018      	movs	r0, r3
 802080a:	f001 fc5b 	bl	80220c4 <HAL_IPCC_NotifyCPU>
 802080e:	2800      	cmp	r0, #0
 8020810:	d101      	bne.n	8020816 <IPCC_IF_ResponseSnd+0x16>
    return 0;
 8020812:	2000      	movs	r0, #0
}
 8020814:	bd10      	pop	{r4, pc}
    return -1;
 8020816:	2001      	movs	r0, #1
 8020818:	4240      	negs	r0, r0
 802081a:	e7fb      	b.n	8020814 <IPCC_IF_ResponseSnd+0x14>
 802081c:	2000a034 	.word	0x2000a034

08020820 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8020820:	b510      	push	{r4, lr}
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8020822:	f001 f931 	bl	8021a88 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8020826:	f7ff ff31 	bl	802068c <MX_GPIO_Init>
  MX_SubGHz_Phy_Init();
 802082a:	f001 f83e 	bl	80218aa <MX_SubGHz_Phy_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
    MX_SubGHz_Phy_Process();
 802082e:	f001 f840 	bl	80218b2 <MX_SubGHz_Phy_Process>
  while (1)
 8020832:	e7fc      	b.n	802082e <main+0xe>

08020834 <Error_Handler>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8020834:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8020836:	e7fe      	b.n	8020836 <Error_Handler+0x2>

08020838 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 8020838:	b500      	push	{lr}
 802083a:	b08d      	sub	sp, #52	@ 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 802083c:	222c      	movs	r2, #44	@ 0x2c
 802083e:	2100      	movs	r1, #0
 8020840:	a801      	add	r0, sp, #4
 8020842:	f005 fd27 	bl	8026294 <memset>

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 8020846:	481a      	ldr	r0, [pc, #104]	@ (80208b0 <MX_RTC_Init+0x78>)
 8020848:	4b1a      	ldr	r3, [pc, #104]	@ (80208b4 <MX_RTC_Init+0x7c>)
 802084a:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 802084c:	231f      	movs	r3, #31
 802084e:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8020850:	2300      	movs	r3, #0
 8020852:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 8020854:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8020856:	6183      	str	r3, [r0, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8020858:	2280      	movs	r2, #128	@ 0x80
 802085a:	05d2      	lsls	r2, r2, #23
 802085c:	61c2      	str	r2, [r0, #28]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 802085e:	6203      	str	r3, [r0, #32]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 8020860:	3301      	adds	r3, #1
 8020862:	33ff      	adds	r3, #255	@ 0xff
 8020864:	6243      	str	r3, [r0, #36]	@ 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8020866:	f001 ffa5 	bl	80227b4 <HAL_RTC_Init>
 802086a:	2800      	cmp	r0, #0
 802086c:	d117      	bne.n	802089e <MX_RTC_Init+0x66>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 802086e:	4810      	ldr	r0, [pc, #64]	@ (80208b0 <MX_RTC_Init+0x78>)
 8020870:	f002 f8f8 	bl	8022a64 <HAL_RTCEx_SetSSRU_IT>
 8020874:	2800      	cmp	r0, #0
 8020876:	d115      	bne.n	80208a4 <MX_RTC_Init+0x6c>
    Error_Handler();
  }

  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8020878:	2300      	movs	r3, #0
 802087a:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 802087c:	9302      	str	r3, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802087e:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8020880:	2380      	movs	r3, #128	@ 0x80
 8020882:	059b      	lsls	r3, r3, #22
 8020884:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
 8020886:	2380      	movs	r3, #128	@ 0x80
 8020888:	005b      	lsls	r3, r3, #1
 802088a:	930b      	str	r3, [sp, #44]	@ 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802088c:	4808      	ldr	r0, [pc, #32]	@ (80208b0 <MX_RTC_Init+0x78>)
 802088e:	2200      	movs	r2, #0
 8020890:	a901      	add	r1, sp, #4
 8020892:	f001 fffb 	bl	802288c <HAL_RTC_SetAlarm_IT>
 8020896:	2800      	cmp	r0, #0
 8020898:	d107      	bne.n	80208aa <MX_RTC_Init+0x72>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 802089a:	b00d      	add	sp, #52	@ 0x34
 802089c:	bd00      	pop	{pc}
    Error_Handler();
 802089e:	f7ff ffc9 	bl	8020834 <Error_Handler>
 80208a2:	e7e4      	b.n	802086e <MX_RTC_Init+0x36>
    Error_Handler();
 80208a4:	f7ff ffc6 	bl	8020834 <Error_Handler>
 80208a8:	e7e6      	b.n	8020878 <MX_RTC_Init+0x40>
    Error_Handler();
 80208aa:	f7ff ffc3 	bl	8020834 <Error_Handler>
}
 80208ae:	e7f4      	b.n	802089a <MX_RTC_Init+0x62>
 80208b0:	2000a078 	.word	0x2000a078
 80208b4:	40002800 	.word	0x40002800

080208b8 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 80208b8:	b510      	push	{r4, lr}
 80208ba:	b090      	sub	sp, #64	@ 0x40
 80208bc:	0004      	movs	r4, r0

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80208be:	2238      	movs	r2, #56	@ 0x38
 80208c0:	2100      	movs	r1, #0
 80208c2:	a802      	add	r0, sp, #8
 80208c4:	f005 fce6 	bl	8026294 <memset>
  if(rtcHandle->Instance==RTC)
 80208c8:	6822      	ldr	r2, [r4, #0]
 80208ca:	4b17      	ldr	r3, [pc, #92]	@ (8020928 <HAL_RTC_MspInit+0x70>)
 80208cc:	429a      	cmp	r2, r3
 80208ce:	d001      	beq.n	80208d4 <HAL_RTC_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(RTC_LSECSS_IRQn);
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 80208d0:	b010      	add	sp, #64	@ 0x40
 80208d2:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 80208d4:	2380      	movs	r3, #128	@ 0x80
 80208d6:	025b      	lsls	r3, r3, #9
 80208d8:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 80208da:	2380      	movs	r3, #128	@ 0x80
 80208dc:	005b      	lsls	r3, r3, #1
 80208de:	930f      	str	r3, [sp, #60]	@ 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80208e0:	a802      	add	r0, sp, #8
 80208e2:	f001 fd8b 	bl	80223fc <HAL_RCCEx_PeriphCLKConfig>
 80208e6:	2800      	cmp	r0, #0
 80208e8:	d11b      	bne.n	8020922 <HAL_RTC_MspInit+0x6a>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 80208ea:	23b0      	movs	r3, #176	@ 0xb0
 80208ec:	05db      	lsls	r3, r3, #23
 80208ee:	2190      	movs	r1, #144	@ 0x90
 80208f0:	5858      	ldr	r0, [r3, r1]
 80208f2:	2280      	movs	r2, #128	@ 0x80
 80208f4:	0212      	lsls	r2, r2, #8
 80208f6:	4302      	orrs	r2, r0
 80208f8:	505a      	str	r2, [r3, r1]
  * @retval None
  */
__STATIC_INLINE void LL_C2_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2APB1ENR1, Periphs);
 80208fa:	22ac      	movs	r2, #172	@ 0xac
 80208fc:	0052      	lsls	r2, r2, #1
 80208fe:	5899      	ldr	r1, [r3, r2]
 8020900:	2080      	movs	r0, #128	@ 0x80
 8020902:	00c0      	lsls	r0, r0, #3
 8020904:	4301      	orrs	r1, r0
 8020906:	5099      	str	r1, [r3, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2APB1ENR1, Periphs);
 8020908:	589b      	ldr	r3, [r3, r2]
 802090a:	4003      	ands	r3, r0
 802090c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802090e:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(RTC_LSECSS_IRQn, 0, 0);
 8020910:	2200      	movs	r2, #0
 8020912:	2100      	movs	r1, #0
 8020914:	2002      	movs	r0, #2
 8020916:	f001 f931 	bl	8021b7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_LSECSS_IRQn);
 802091a:	2002      	movs	r0, #2
 802091c:	f001 f932 	bl	8021b84 <HAL_NVIC_EnableIRQ>
}
 8020920:	e7d6      	b.n	80208d0 <HAL_RTC_MspInit+0x18>
      Error_Handler();
 8020922:	f7ff ff87 	bl	8020834 <Error_Handler>
 8020926:	e7e0      	b.n	80208ea <HAL_RTC_MspInit+0x32>
 8020928:	40002800 	.word	0x40002800

0802092c <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 802092c:	4770      	bx	lr

0802092e <PWR_ExitOffMode>:
void PWR_ExitOffMode(void)
{
  /* USER CODE BEGIN ExitOffMode_1 */

  /* USER CODE END ExitOffMode_1 */
}
 802092e:	4770      	bx	lr

08020930 <PWR_EnterStopMode>:

void PWR_EnterStopMode(void)
{
 8020930:	b510      	push	{r4, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 8020932:	f001 f8c7 	bl	8021ac4 <HAL_SuspendTick>
  * @rmtoll EXTSCR       C2CSSF        LL_PWR_ClearFlag_C2STOP_C2STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C2STOP_C2STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C2CSSF);
 8020936:	4a04      	ldr	r2, [pc, #16]	@ (8020948 <PWR_EnterStopMode+0x18>)
 8020938:	2388      	movs	r3, #136	@ 0x88
 802093a:	2102      	movs	r1, #2
 802093c:	50d1      	str	r1, [r2, r3]
  LL_PWR_ClearFlag_C2STOP_C2STB();

  /* USER CODE BEGIN EnterStopMode_2 */

  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 802093e:	2001      	movs	r0, #1
 8020940:	f001 fc84 	bl	802224c <HAL_PWREx_EnterSTOP2Mode>
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 8020944:	bd10      	pop	{r4, pc}
 8020946:	46c0      	nop			@ (mov r8, r8)
 8020948:	58000400 	.word	0x58000400

0802094c <PWR_ExitStopMode>:

void PWR_ExitStopMode(void)
{
 802094c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN ExitStopMode_1 */

  /* USER CODE END ExitStopMode_1 */
  /* Resume sysTick : work around for debugger problem in dual core */
  HAL_ResumeTick();
 802094e:	f001 f8c1 	bl	8021ad4 <HAL_ResumeTick>
    SRAM ctrls, DMAx, DMAMux, AES, RNG, HSEM  */

  /* USER CODE BEGIN ExitStopMode_2 */

  /* USER CODE END ExitStopMode_2 */
}
 8020952:	bd10      	pop	{r4, pc}

08020954 <PWR_ExitSleepMode>:

  /* USER CODE END EnterSleepMode_3 */
}

void PWR_ExitSleepMode(void)
{
 8020954:	b510      	push	{r4, lr}
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Resume sysTick */
  HAL_ResumeTick();
 8020956:	f001 f8bd 	bl	8021ad4 <HAL_ResumeTick>

  /* USER CODE BEGIN ExitSleepMode_2 */

  /* USER CODE END ExitSleepMode_2 */
}
 802095a:	bd10      	pop	{r4, pc}

0802095c <PWR_EnterSleepMode>:
{
 802095c:	b510      	push	{r4, lr}
  HAL_SuspendTick();
 802095e:	f001 f8b1 	bl	8021ac4 <HAL_SuspendTick>
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 8020962:	2101      	movs	r1, #1
 8020964:	2000      	movs	r0, #0
 8020966:	f001 fc1b 	bl	80221a0 <HAL_PWR_EnterSLEEPMode>
}
 802096a:	bd10      	pop	{r4, pc}

0802096c <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802096c:	4770      	bx	lr

0802096e <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 802096e:	e7fe      	b.n	802096e <NMI_Handler>

08020970 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8020970:	e7fe      	b.n	8020970 <HardFault_Handler>

08020972 <SVC_Handler>:

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 8020972:	4770      	bx	lr

08020974 <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8020974:	4770      	bx	lr

08020976 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8020976:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8020978:	f001 f898 	bl	8021aac <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 802097c:	bd10      	pop	{r4, pc}
	...

08020980 <RTC_LSECSS_IRQHandler>:

/**
  * @brief This function handles RTC Wakeup + RTC Tamper and RTC TimeStamp + RTC Alarms (A & B) and RTC SSRU Interrupts and LSECSS Interrupts.
  */
void RTC_LSECSS_IRQHandler(void)
{
 8020980:	b510      	push	{r4, lr}
  /* USER CODE BEGIN RTC_LSECSS_IRQn 0 */

  /* USER CODE END RTC_LSECSS_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 8020982:	4c04      	ldr	r4, [pc, #16]	@ (8020994 <RTC_LSECSS_IRQHandler+0x14>)
 8020984:	0020      	movs	r0, r4
 8020986:	f001 fe8f 	bl	80226a8 <HAL_RTC_AlarmIRQHandler>
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 802098a:	0020      	movs	r0, r4
 802098c:	f002 f89a 	bl	8022ac4 <HAL_RTCEx_SSRUIRQHandler>
  /* USER CODE BEGIN RTC_LSECSS_IRQn 1 */

  /* USER CODE END RTC_LSECSS_IRQn 1 */
}
 8020990:	bd10      	pop	{r4, pc}
 8020992:	46c0      	nop			@ (mov r8, r8)
 8020994:	2000a078 	.word	0x2000a078

08020998 <IPCC_C2_RX_C2_TX_IRQHandler>:

/**
  * @brief This function handles IPCC RX Occupied and TX Free Interrupt.
  */
void IPCC_C2_RX_C2_TX_IRQHandler(void)
{
 8020998:	b510      	push	{r4, lr}
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 0 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 0 */
  HAL_IPCC_RX_IRQHandler(&hipcc);
 802099a:	4c04      	ldr	r4, [pc, #16]	@ (80209ac <IPCC_C2_RX_C2_TX_IRQHandler+0x14>)
 802099c:	0020      	movs	r0, r4
 802099e:	f001 fb21 	bl	8021fe4 <HAL_IPCC_RX_IRQHandler>
  HAL_IPCC_TX_IRQHandler(&hipcc);
 80209a2:	0020      	movs	r0, r4
 80209a4:	f001 faf4 	bl	8021f90 <HAL_IPCC_TX_IRQHandler>
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 1 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 1 */
}
 80209a8:	bd10      	pop	{r4, pc}
 80209aa:	46c0      	nop			@ (mov r8, r8)
 80209ac:	2000a034 	.word	0x2000a034

080209b0 <SUBGHZ_Radio_IRQHandler>:

/**
  * @brief This function handles SUBGHZ Radio Interrupt.
  */
void SUBGHZ_Radio_IRQHandler(void)
{
 80209b0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 80209b2:	4802      	ldr	r0, [pc, #8]	@ (80209bc <SUBGHZ_Radio_IRQHandler+0xc>)
 80209b4:	f002 fb4e 	bl	8023054 <HAL_SUBGHZ_IRQHandler>
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 1 */

  /* USER CODE END SUBGHZ_Radio_IRQn 1 */
}
 80209b8:	bd10      	pop	{r4, pc}
 80209ba:	46c0      	nop			@ (mov r8, r8)
 80209bc:	2000a0b0 	.word	0x2000a0b0

080209c0 <MX_SUBGHZ_Init>:

SUBGHZ_HandleTypeDef hsubghz;

/* SUBGHZ init function */
void MX_SUBGHZ_Init(void)
{
 80209c0:	b510      	push	{r4, lr}
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 80209c2:	4805      	ldr	r0, [pc, #20]	@ (80209d8 <MX_SUBGHZ_Init+0x18>)
 80209c4:	2308      	movs	r3, #8
 80209c6:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 80209c8:	f002 f8b0 	bl	8022b2c <HAL_SUBGHZ_Init>
 80209cc:	2800      	cmp	r0, #0
 80209ce:	d100      	bne.n	80209d2 <MX_SUBGHZ_Init+0x12>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 80209d0:	bd10      	pop	{r4, pc}
    Error_Handler();
 80209d2:	f7ff ff2f 	bl	8020834 <Error_Handler>
}
 80209d6:	e7fb      	b.n	80209d0 <MX_SUBGHZ_Init+0x10>
 80209d8:	2000a0b0 	.word	0x2000a0b0

080209dc <HAL_SUBGHZ_MspInit>:

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 80209dc:	b500      	push	{lr}
 80209de:	b083      	sub	sp, #12
  * @retval None
  */
__STATIC_INLINE void LL_C2_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2APB3ENR, Periphs);
 80209e0:	21b0      	movs	r1, #176	@ 0xb0
 80209e2:	05c9      	lsls	r1, r1, #23
 80209e4:	22b2      	movs	r2, #178	@ 0xb2
 80209e6:	0052      	lsls	r2, r2, #1
 80209e8:	5888      	ldr	r0, [r1, r2]
 80209ea:	2301      	movs	r3, #1
 80209ec:	4318      	orrs	r0, r3
 80209ee:	5088      	str	r0, [r1, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2APB3ENR, Periphs);
 80209f0:	588a      	ldr	r2, [r1, r2]
 80209f2:	4013      	ands	r3, r2
 80209f4:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80209f6:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 80209f8:	2200      	movs	r2, #0
 80209fa:	2100      	movs	r1, #0
 80209fc:	201f      	movs	r0, #31
 80209fe:	f001 f8bd 	bl	8021b7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 8020a02:	201f      	movs	r0, #31
 8020a04:	f001 f8be 	bl	8021b84 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 8020a08:	b003      	add	sp, #12
 8020a0a:	bd00      	pop	{pc}

08020a0c <System_Init>:

/* USER CODE END EF */

/* Private functions ---------------------------------------------------------*/
static void System_Init(void)
{
 8020a0c:	b570      	push	{r4, r5, r6, lr}
  CLEAR_BIT(PWR->C2CR3, PWR_C2CR3_EIWUL);
 8020a0e:	4d13      	ldr	r5, [pc, #76]	@ (8020a5c <System_Init+0x50>)
 8020a10:	2484      	movs	r4, #132	@ 0x84
 8020a12:	592b      	ldr	r3, [r5, r4]
 8020a14:	4e12      	ldr	r6, [pc, #72]	@ (8020a60 <System_Init+0x54>)
 8020a16:	4033      	ands	r3, r6
 8020a18:	512b      	str	r3, [r5, r4]
  CLEAR_BIT(EXTI->C2IMR1, ExtiLine);
 8020a1a:	4b12      	ldr	r3, [pc, #72]	@ (8020a64 <System_Init+0x58>)
 8020a1c:	21c0      	movs	r1, #192	@ 0xc0
 8020a1e:	585a      	ldr	r2, [r3, r1]
 8020a20:	2090      	movs	r0, #144	@ 0x90
 8020a22:	0340      	lsls	r0, r0, #13
 8020a24:	4002      	ands	r2, r0
 8020a26:	505a      	str	r2, [r3, r1]
  CLEAR_BIT(EXTI->C2IMR2, ExtiLine);
 8020a28:	22d0      	movs	r2, #208	@ 0xd0
 8020a2a:	5899      	ldr	r1, [r3, r2]
 8020a2c:	480e      	ldr	r0, [pc, #56]	@ (8020a68 <System_Init+0x5c>)
 8020a2e:	4001      	ands	r1, r0
 8020a30:	5099      	str	r1, [r3, r2]
  MODIFY_REG(PWR->C2CR3, PWR_C2CR3_EWRFIRQ, RadioIRQTrigger);
 8020a32:	5929      	ldr	r1, [r5, r4]
 8020a34:	480d      	ldr	r0, [pc, #52]	@ (8020a6c <System_Init+0x60>)
 8020a36:	4001      	ands	r1, r0
 8020a38:	2080      	movs	r0, #128	@ 0x80
 8020a3a:	0180      	lsls	r0, r0, #6
 8020a3c:	4301      	orrs	r1, r0
 8020a3e:	5129      	str	r1, [r5, r4]
  SET_BIT(EXTI->C2IMR2, ExtiLine);
 8020a40:	589c      	ldr	r4, [r3, r2]
 8020a42:	2180      	movs	r1, #128	@ 0x80
 8020a44:	0149      	lsls	r1, r1, #5
 8020a46:	4321      	orrs	r1, r4
 8020a48:	5099      	str	r1, [r3, r2]
 8020a4a:	5899      	ldr	r1, [r3, r2]
 8020a4c:	4308      	orrs	r0, r1
 8020a4e:	5098      	str	r0, [r3, r2]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 8020a50:	22b0      	movs	r2, #176	@ 0xb0
 8020a52:	05d2      	lsls	r2, r2, #23
 8020a54:	6893      	ldr	r3, [r2, #8]
 8020a56:	4033      	ands	r3, r6
 8020a58:	6093      	str	r3, [r2, #8]
  /* Ensure that MSI is wake-up system clock */
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
  /* USER CODE BEGIN System_Init_Last */

  /* USER CODE END System_Init_Last */
}
 8020a5a:	bd70      	pop	{r4, r5, r6, pc}
 8020a5c:	58000400 	.word	0x58000400
 8020a60:	ffff7fff 	.word	0xffff7fff
 8020a64:	58000800 	.word	0x58000800
 8020a68:	000070a0 	.word	0x000070a0
 8020a6c:	ffffdfff 	.word	0xffffdfff

08020a70 <tiny_snprintf_like>:

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
{
 8020a70:	b40c      	push	{r2, r3}
 8020a72:	b500      	push	{lr}
 8020a74:	b083      	sub	sp, #12
 8020a76:	ab04      	add	r3, sp, #16
 8020a78:	cb04      	ldmia	r3!, {r2}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
 8020a7a:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 8020a7c:	f005 fb46 	bl	802610c <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 8020a80:	b003      	add	sp, #12
 8020a82:	bc08      	pop	{r3}
 8020a84:	b002      	add	sp, #8
 8020a86:	4718      	bx	r3

08020a88 <SystemApp_Init>:
{
 8020a88:	b510      	push	{r4, lr}
  UTIL_TIMER_Init();
 8020a8a:	f005 f903 	bl	8025c94 <UTIL_TIMER_Init>
  SYS_TimerInitialisedFlag = 1;
 8020a8e:	4b0a      	ldr	r3, [pc, #40]	@ (8020ab8 <SystemApp_Init+0x30>)
 8020a90:	2201      	movs	r2, #1
 8020a92:	701a      	strb	r2, [r3, #0]
  UTIL_LPM_Init();
 8020a94:	f004 ff32 	bl	80258fc <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 8020a98:	2101      	movs	r1, #1
 8020a9a:	2001      	movs	r0, #1
 8020a9c:	f004 ff4e 	bl	802593c <UTIL_LPM_SetOffMode>
  FEAT_INFO_Init();
 8020aa0:	f000 f9bd 	bl	8020e1e <FEAT_INFO_Init>
  init_status = MBMUXIF_SystemInit();
 8020aa4:	f000 fbca 	bl	802123c <MBMUXIF_SystemInit>
  if (init_status < 0)
 8020aa8:	2800      	cmp	r0, #0
 8020aaa:	db02      	blt.n	8020ab2 <SystemApp_Init+0x2a>
  System_Init();
 8020aac:	f7ff ffae 	bl	8020a0c <System_Init>
}
 8020ab0:	bd10      	pop	{r4, pc}
    Error_Handler();
 8020ab2:	f7ff febf 	bl	8020834 <Error_Handler>
 8020ab6:	e7f9      	b.n	8020aac <SystemApp_Init+0x24>
 8020ab8:	2000a0bc 	.word	0x2000a0bc

08020abc <TimestampNow>:
{
 8020abc:	b570      	push	{r4, r5, r6, lr}
 8020abe:	b084      	sub	sp, #16
 8020ac0:	0004      	movs	r4, r0
 8020ac2:	000d      	movs	r5, r1
  SysTime_t curtime = SysTimeGet();
 8020ac4:	ae02      	add	r6, sp, #8
 8020ac6:	0030      	movs	r0, r6
 8020ac8:	f005 f8c2 	bl	8025c50 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 8020acc:	2304      	movs	r3, #4
 8020ace:	5ef1      	ldrsh	r1, [r6, r3]
 8020ad0:	9b02      	ldr	r3, [sp, #8]
 8020ad2:	4a06      	ldr	r2, [pc, #24]	@ (8020aec <TimestampNow+0x30>)
 8020ad4:	9100      	str	r1, [sp, #0]
 8020ad6:	2110      	movs	r1, #16
 8020ad8:	0020      	movs	r0, r4
 8020ada:	f7ff ffc9 	bl	8020a70 <tiny_snprintf_like>
  *size = strlen((char *)buff);
 8020ade:	0020      	movs	r0, r4
 8020ae0:	f7ff fb12 	bl	8020108 <strlen>
 8020ae4:	8028      	strh	r0, [r5, #0]
}
 8020ae6:	b004      	add	sp, #16
 8020ae8:	bd70      	pop	{r4, r5, r6, pc}
 8020aea:	46c0      	nop			@ (mov r8, r8)
 8020aec:	08026344 	.word	0x08026344

08020af0 <Process_Sys_Cmd>:
{
 8020af0:	b510      	push	{r4, lr}
  APP_LOG(TS_ON, VLEVEL_L, ">CM0PLUS(System)\r\n");
 8020af2:	4b08      	ldr	r3, [pc, #32]	@ (8020b14 <Process_Sys_Cmd+0x24>)
 8020af4:	2201      	movs	r2, #1
 8020af6:	2100      	movs	r1, #0
 8020af8:	2001      	movs	r0, #1
 8020afa:	f004 fe43 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_ON, VLEVEL_M, "<CM0PLUS(System)\r\n");
 8020afe:	4b06      	ldr	r3, [pc, #24]	@ (8020b18 <Process_Sys_Cmd+0x28>)
 8020b00:	2201      	movs	r2, #1
 8020b02:	2100      	movs	r1, #0
 8020b04:	2002      	movs	r0, #2
 8020b06:	f004 fe3d 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 8020b0a:	2000      	movs	r0, #0
 8020b0c:	f000 fa68 	bl	8020fe0 <MBMUX_ResponseSnd>
}
 8020b10:	bd10      	pop	{r4, pc}
 8020b12:	46c0      	nop			@ (mov r8, r8)
 8020b14:	08026350 	.word	0x08026350
 8020b18:	08026364 	.word	0x08026364

08020b1c <UTIL_SEQ_EvtIdle>:
{
 8020b1c:	b510      	push	{r4, lr}
  UTIL_SEQ_Run(~TaskId_bm);
 8020b1e:	43c0      	mvns	r0, r0
 8020b20:	f004 ffa2 	bl	8025a68 <UTIL_SEQ_Run>
}
 8020b24:	bd10      	pop	{r4, pc}

08020b26 <UTIL_SEQ_Idle>:
{
 8020b26:	b510      	push	{r4, lr}
  UTIL_LPM_EnterLowPower();
 8020b28:	f004 ff1e 	bl	8025968 <UTIL_LPM_EnterLowPower>
}
 8020b2c:	bd10      	pop	{r4, pc}

08020b2e <UTIL_ADV_TRACE_PreSendHook>:
{
 8020b2e:	b510      	push	{r4, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 8020b30:	2101      	movs	r1, #1
 8020b32:	2002      	movs	r0, #2
 8020b34:	f004 feec 	bl	8025910 <UTIL_LPM_SetStopMode>
}
 8020b38:	bd10      	pop	{r4, pc}

08020b3a <UTIL_ADV_TRACE_PostSendHook>:
{
 8020b3a:	b510      	push	{r4, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 8020b3c:	2100      	movs	r1, #0
 8020b3e:	2002      	movs	r0, #2
 8020b40:	f004 fee6 	bl	8025910 <UTIL_LPM_SetStopMode>
}
 8020b44:	bd10      	pop	{r4, pc}
	...

08020b48 <HAL_GetTick>:

/**
  * @note This function overwrites the __weak one from HAL
  */
uint32_t HAL_GetTick(void)
{
 8020b48:	b510      	push	{r4, lr}
  uint32_t ret = 0;
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  if (SYS_TimerInitialisedFlag == 0)
 8020b4a:	4b04      	ldr	r3, [pc, #16]	@ (8020b5c <HAL_GetTick+0x14>)
 8020b4c:	781b      	ldrb	r3, [r3, #0]
 8020b4e:	2b00      	cmp	r3, #0
 8020b50:	d101      	bne.n	8020b56 <HAL_GetTick+0xe>
  uint32_t ret = 0;
 8020b52:	2000      	movs	r0, #0
  }
  /* USER CODE BEGIN HAL_GetTick_2 */

  /* USER CODE END HAL_GetTick_2 */
  return ret;
}
 8020b54:	bd10      	pop	{r4, pc}
    ret = TIMER_IF_GetTimerValue();
 8020b56:	f000 f835 	bl	8020bc4 <TIMER_IF_GetTimerValue>
 8020b5a:	e7fb      	b.n	8020b54 <HAL_GetTick+0xc>
 8020b5c:	2000a0bc 	.word	0x2000a0bc

08020b60 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 8020b60:	b500      	push	{lr}
 8020b62:	b083      	sub	sp, #12
 8020b64:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 8020b66:	9801      	ldr	r0, [sp, #4]
 8020b68:	f000 f918 	bl	8020d9c <TIMER_IF_DelayMs>
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 8020b6c:	b003      	add	sp, #12
 8020b6e:	bd00      	pop	{pc}

08020b70 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 8020b70:	4b06      	ldr	r3, [pc, #24]	@ (8020b8c <TIMER_IF_SetTimerContext+0x1c>)
 8020b72:	6898      	ldr	r0, [r3, #8]
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  uint32_t ssr = LL_RTC_TIME_GetSubSecond(RTC);
  /* read twice to make sure value it valid*/
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8020b74:	e001      	b.n	8020b7a <TIMER_IF_SetTimerContext+0xa>
 8020b76:	4b05      	ldr	r3, [pc, #20]	@ (8020b8c <TIMER_IF_SetTimerContext+0x1c>)
 8020b78:	6898      	ldr	r0, [r3, #8]
 8020b7a:	4b04      	ldr	r3, [pc, #16]	@ (8020b8c <TIMER_IF_SetTimerContext+0x1c>)
 8020b7c:	689b      	ldr	r3, [r3, #8]
 8020b7e:	4283      	cmp	r3, r0
 8020b80:	d1f9      	bne.n	8020b76 <TIMER_IF_SetTimerContext+0x6>
  {
    ssr = LL_RTC_TIME_GetSubSecond(RTC);
  }
  return UINT32_MAX - ssr;
 8020b82:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 8020b84:	4b02      	ldr	r3, [pc, #8]	@ (8020b90 <TIMER_IF_SetTimerContext+0x20>)
 8020b86:	6018      	str	r0, [r3, #0]
}
 8020b88:	4770      	bx	lr
 8020b8a:	46c0      	nop			@ (mov r8, r8)
 8020b8c:	40002800 	.word	0x40002800
 8020b90:	2000a0c0 	.word	0x2000a0c0

08020b94 <TIMER_IF_GetTimerContext>:
  return RtcTimerContext;
 8020b94:	4b01      	ldr	r3, [pc, #4]	@ (8020b9c <TIMER_IF_GetTimerContext+0x8>)
 8020b96:	6818      	ldr	r0, [r3, #0]
}
 8020b98:	4770      	bx	lr
 8020b9a:	46c0      	nop			@ (mov r8, r8)
 8020b9c:	2000a0c0 	.word	0x2000a0c0

08020ba0 <TIMER_IF_GetTimerElapsedTime>:
 8020ba0:	4b06      	ldr	r3, [pc, #24]	@ (8020bbc <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8020ba2:	6898      	ldr	r0, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8020ba4:	e001      	b.n	8020baa <TIMER_IF_GetTimerElapsedTime+0xa>
 8020ba6:	4b05      	ldr	r3, [pc, #20]	@ (8020bbc <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8020ba8:	6898      	ldr	r0, [r3, #8]
 8020baa:	4b04      	ldr	r3, [pc, #16]	@ (8020bbc <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8020bac:	689b      	ldr	r3, [r3, #8]
 8020bae:	4283      	cmp	r3, r0
 8020bb0:	d1f9      	bne.n	8020ba6 <TIMER_IF_GetTimerElapsedTime+0x6>
  return UINT32_MAX - ssr;
 8020bb2:	43c0      	mvns	r0, r0
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 8020bb4:	4b02      	ldr	r3, [pc, #8]	@ (8020bc0 <TIMER_IF_GetTimerElapsedTime+0x20>)
 8020bb6:	681b      	ldr	r3, [r3, #0]
 8020bb8:	1ac0      	subs	r0, r0, r3
}
 8020bba:	4770      	bx	lr
 8020bbc:	40002800 	.word	0x40002800
 8020bc0:	2000a0c0 	.word	0x2000a0c0

08020bc4 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 8020bc4:	4b08      	ldr	r3, [pc, #32]	@ (8020be8 <TIMER_IF_GetTimerValue+0x24>)
 8020bc6:	781b      	ldrb	r3, [r3, #0]
 8020bc8:	2b00      	cmp	r3, #0
 8020bca:	d00a      	beq.n	8020be2 <TIMER_IF_GetTimerValue+0x1e>
 8020bcc:	4b07      	ldr	r3, [pc, #28]	@ (8020bec <TIMER_IF_GetTimerValue+0x28>)
 8020bce:	6898      	ldr	r0, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8020bd0:	e001      	b.n	8020bd6 <TIMER_IF_GetTimerValue+0x12>
 8020bd2:	4b06      	ldr	r3, [pc, #24]	@ (8020bec <TIMER_IF_GetTimerValue+0x28>)
 8020bd4:	6898      	ldr	r0, [r3, #8]
 8020bd6:	4b05      	ldr	r3, [pc, #20]	@ (8020bec <TIMER_IF_GetTimerValue+0x28>)
 8020bd8:	689b      	ldr	r3, [r3, #8]
 8020bda:	4283      	cmp	r3, r0
 8020bdc:	d1f9      	bne.n	8020bd2 <TIMER_IF_GetTimerValue+0xe>
  return UINT32_MAX - ssr;
 8020bde:	43c0      	mvns	r0, r0
}
 8020be0:	4770      	bx	lr
  uint32_t ret = 0;
 8020be2:	2000      	movs	r0, #0
  return ret;
 8020be4:	e7fc      	b.n	8020be0 <TIMER_IF_GetTimerValue+0x1c>
 8020be6:	46c0      	nop			@ (mov r8, r8)
 8020be8:	2000a0c4 	.word	0x2000a0c4
 8020bec:	40002800 	.word	0x40002800

08020bf0 <TIMER_IF_GetMinimumTimeout>:
}
 8020bf0:	2003      	movs	r0, #3
 8020bf2:	4770      	bx	lr

08020bf4 <TIMER_IF_Convert_ms2Tick>:
{
 8020bf4:	b510      	push	{r4, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 8020bf6:	0d81      	lsrs	r1, r0, #22
 8020bf8:	0280      	lsls	r0, r0, #10
 8020bfa:	22fa      	movs	r2, #250	@ 0xfa
 8020bfc:	0092      	lsls	r2, r2, #2
 8020bfe:	2300      	movs	r3, #0
 8020c00:	f7ff fc00 	bl	8020404 <__aeabi_uldivmod>
}
 8020c04:	bd10      	pop	{r4, pc}

08020c06 <TIMER_IF_Convert_Tick2ms>:
{
 8020c06:	b510      	push	{r4, lr}
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8020c08:	22fa      	movs	r2, #250	@ 0xfa
 8020c0a:	0092      	lsls	r2, r2, #2
 8020c0c:	2300      	movs	r3, #0
 8020c0e:	2100      	movs	r1, #0
 8020c10:	f7ff fc18 	bl	8020444 <__aeabi_lmul>
 8020c14:	0589      	lsls	r1, r1, #22
 8020c16:	0a80      	lsrs	r0, r0, #10
 8020c18:	4308      	orrs	r0, r1
}
 8020c1a:	bd10      	pop	{r4, pc}

08020c1c <TIMER_IF_StopTimer>:
{
 8020c1c:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRBF);
 8020c1e:	4b07      	ldr	r3, [pc, #28]	@ (8020c3c <TIMER_IF_StopTimer+0x20>)
 8020c20:	2202      	movs	r2, #2
 8020c22:	65da      	str	r2, [r3, #92]	@ 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_B);
 8020c24:	2180      	movs	r1, #128	@ 0x80
 8020c26:	4c06      	ldr	r4, [pc, #24]	@ (8020c40 <TIMER_IF_StopTimer+0x24>)
 8020c28:	0089      	lsls	r1, r1, #2
 8020c2a:	0020      	movs	r0, r4
 8020c2c:	f001 fcf8 	bl	8022620 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8020c30:	2301      	movs	r3, #1
 8020c32:	425b      	negs	r3, r3
 8020c34:	6323      	str	r3, [r4, #48]	@ 0x30
}
 8020c36:	2000      	movs	r0, #0
 8020c38:	bd10      	pop	{r4, pc}
 8020c3a:	46c0      	nop			@ (mov r8, r8)
 8020c3c:	40002800 	.word	0x40002800
 8020c40:	2000a078 	.word	0x2000a078

08020c44 <TIMER_IF_BkUp_Write_MSBticks>:
{
 8020c44:	b510      	push	{r4, lr}
 8020c46:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 8020c48:	4b02      	ldr	r3, [pc, #8]	@ (8020c54 <TIMER_IF_BkUp_Write_MSBticks+0x10>)
 8020c4a:	2102      	movs	r1, #2
 8020c4c:	0018      	movs	r0, r3
 8020c4e:	f001 ff4b 	bl	8022ae8 <HAL_RTCEx_BKUPWrite>
}
 8020c52:	bd10      	pop	{r4, pc}
 8020c54:	2000a078 	.word	0x2000a078

08020c58 <TIMER_IF_Init>:
{
 8020c58:	b570      	push	{r4, r5, r6, lr}
  if (RTC_Initialized == false)
 8020c5a:	4b12      	ldr	r3, [pc, #72]	@ (8020ca4 <TIMER_IF_Init+0x4c>)
 8020c5c:	781b      	ldrb	r3, [r3, #0]
 8020c5e:	2b00      	cmp	r3, #0
 8020c60:	d001      	beq.n	8020c66 <TIMER_IF_Init+0xe>
}
 8020c62:	2000      	movs	r0, #0
 8020c64:	bd70      	pop	{r4, r5, r6, pc}
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8020c66:	4c10      	ldr	r4, [pc, #64]	@ (8020ca8 <TIMER_IF_Init+0x50>)
 8020c68:	2501      	movs	r5, #1
 8020c6a:	426d      	negs	r5, r5
 8020c6c:	6325      	str	r5, [r4, #48]	@ 0x30
    MX_RTC_Init();
 8020c6e:	f7ff fde3 	bl	8020838 <MX_RTC_Init>
    TIMER_IF_StopTimer();
 8020c72:	f7ff ffd3 	bl	8020c1c <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A); /* handled by Cm4 */
 8020c76:	2180      	movs	r1, #128	@ 0x80
 8020c78:	0049      	lsls	r1, r1, #1
 8020c7a:	0020      	movs	r0, r4
 8020c7c:	f001 fcd0 	bl	8022620 <HAL_RTC_DeactivateAlarm>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_B); /* handled by Cm0plus */
 8020c80:	2180      	movs	r1, #128	@ 0x80
 8020c82:	0089      	lsls	r1, r1, #2
 8020c84:	0020      	movs	r0, r4
 8020c86:	f001 fccb 	bl	8022620 <HAL_RTC_DeactivateAlarm>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8020c8a:	6325      	str	r5, [r4, #48]	@ 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 8020c8c:	0020      	movs	r0, r4
 8020c8e:	f001 fec9 	bl	8022a24 <HAL_RTCEx_EnableBypassShadow>
    TIMER_IF_BkUp_Write_MSBticks(0);
 8020c92:	2000      	movs	r0, #0
 8020c94:	f7ff ffd6 	bl	8020c44 <TIMER_IF_BkUp_Write_MSBticks>
    TIMER_IF_SetTimerContext();
 8020c98:	f7ff ff6a 	bl	8020b70 <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 8020c9c:	4b01      	ldr	r3, [pc, #4]	@ (8020ca4 <TIMER_IF_Init+0x4c>)
 8020c9e:	2201      	movs	r2, #1
 8020ca0:	701a      	strb	r2, [r3, #0]
 8020ca2:	e7de      	b.n	8020c62 <TIMER_IF_Init+0xa>
 8020ca4:	2000a0c4 	.word	0x2000a0c4
 8020ca8:	2000a078 	.word	0x2000a078

08020cac <TIMER_IF_BkUp_Write_Seconds>:
{
 8020cac:	b510      	push	{r4, lr}
 8020cae:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 8020cb0:	4b02      	ldr	r3, [pc, #8]	@ (8020cbc <TIMER_IF_BkUp_Write_Seconds+0x10>)
 8020cb2:	2100      	movs	r1, #0
 8020cb4:	0018      	movs	r0, r3
 8020cb6:	f001 ff17 	bl	8022ae8 <HAL_RTCEx_BKUPWrite>
}
 8020cba:	bd10      	pop	{r4, pc}
 8020cbc:	2000a078 	.word	0x2000a078

08020cc0 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 8020cc0:	b510      	push	{r4, lr}
 8020cc2:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 8020cc4:	4b02      	ldr	r3, [pc, #8]	@ (8020cd0 <TIMER_IF_BkUp_Write_SubSeconds+0x10>)
 8020cc6:	2101      	movs	r1, #1
 8020cc8:	0018      	movs	r0, r3
 8020cca:	f001 ff0d 	bl	8022ae8 <HAL_RTCEx_BKUPWrite>
}
 8020cce:	bd10      	pop	{r4, pc}
 8020cd0:	2000a078 	.word	0x2000a078

08020cd4 <TIMER_IF_StartTimer>:
{
 8020cd4:	b510      	push	{r4, lr}
 8020cd6:	b08c      	sub	sp, #48	@ 0x30
 8020cd8:	0004      	movs	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 8020cda:	222c      	movs	r2, #44	@ 0x2c
 8020cdc:	2100      	movs	r1, #0
 8020cde:	a801      	add	r0, sp, #4
 8020ce0:	f005 fad8 	bl	8026294 <memset>
  TIMER_IF_StopTimer();
 8020ce4:	f7ff ff9a 	bl	8020c1c <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 8020ce8:	4b0d      	ldr	r3, [pc, #52]	@ (8020d20 <TIMER_IF_StartTimer+0x4c>)
 8020cea:	681b      	ldr	r3, [r3, #0]
 8020cec:	18e4      	adds	r4, r4, r3
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8020cee:	2300      	movs	r3, #0
 8020cf0:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 8020cf2:	43e4      	mvns	r4, r4
 8020cf4:	9402      	str	r4, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8020cf6:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8020cf8:	2380      	movs	r3, #128	@ 0x80
 8020cfa:	059b      	lsls	r3, r3, #22
 8020cfc:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_B;
 8020cfe:	2380      	movs	r3, #128	@ 0x80
 8020d00:	009b      	lsls	r3, r3, #2
 8020d02:	930b      	str	r3, [sp, #44]	@ 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8020d04:	4807      	ldr	r0, [pc, #28]	@ (8020d24 <TIMER_IF_StartTimer+0x50>)
 8020d06:	2201      	movs	r2, #1
 8020d08:	a901      	add	r1, sp, #4
 8020d0a:	f001 fdbf 	bl	802288c <HAL_RTC_SetAlarm_IT>
 8020d0e:	2800      	cmp	r0, #0
 8020d10:	d102      	bne.n	8020d18 <TIMER_IF_StartTimer+0x44>
}
 8020d12:	2000      	movs	r0, #0
 8020d14:	b00c      	add	sp, #48	@ 0x30
 8020d16:	bd10      	pop	{r4, pc}
    Error_Handler();
 8020d18:	f7ff fd8c 	bl	8020834 <Error_Handler>
 8020d1c:	e7f9      	b.n	8020d12 <TIMER_IF_StartTimer+0x3e>
 8020d1e:	46c0      	nop			@ (mov r8, r8)
 8020d20:	2000a0c0 	.word	0x2000a0c0
 8020d24:	2000a078 	.word	0x2000a078

08020d28 <TIMER_IF_BkUp_Read_MSBticks>:
{
 8020d28:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8020d2a:	4802      	ldr	r0, [pc, #8]	@ (8020d34 <TIMER_IF_BkUp_Read_MSBticks+0xc>)
 8020d2c:	2102      	movs	r1, #2
 8020d2e:	f001 fee3 	bl	8022af8 <HAL_RTCEx_BKUPRead>
}
 8020d32:	bd10      	pop	{r4, pc}
 8020d34:	2000a078 	.word	0x2000a078

08020d38 <TIMER_IF_GetTime>:
{
 8020d38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020d3a:	0005      	movs	r5, r0
 8020d3c:	4b0e      	ldr	r3, [pc, #56]	@ (8020d78 <TIMER_IF_GetTime+0x40>)
 8020d3e:	689c      	ldr	r4, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8020d40:	e001      	b.n	8020d46 <TIMER_IF_GetTime+0xe>
 8020d42:	4b0d      	ldr	r3, [pc, #52]	@ (8020d78 <TIMER_IF_GetTime+0x40>)
 8020d44:	689c      	ldr	r4, [r3, #8]
 8020d46:	4a0c      	ldr	r2, [pc, #48]	@ (8020d78 <TIMER_IF_GetTime+0x40>)
 8020d48:	6892      	ldr	r2, [r2, #8]
 8020d4a:	42a2      	cmp	r2, r4
 8020d4c:	d1f9      	bne.n	8020d42 <TIMER_IF_GetTime+0xa>
  return UINT32_MAX - ssr;
 8020d4e:	43e4      	mvns	r4, r4
  uint32_t timerValueMSB = TIMER_IF_BkUp_Read_MSBticks();
 8020d50:	f7ff ffea 	bl	8020d28 <TIMER_IF_BkUp_Read_MSBticks>
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 8020d54:	2200      	movs	r2, #0
 8020d56:	0003      	movs	r3, r0
 8020d58:	0026      	movs	r6, r4
 8020d5a:	2700      	movs	r7, #0
 8020d5c:	1992      	adds	r2, r2, r6
 8020d5e:	417b      	adcs	r3, r7
 8020d60:	0011      	movs	r1, r2
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 8020d62:	059b      	lsls	r3, r3, #22
 8020d64:	0a8c      	lsrs	r4, r1, #10
 8020d66:	431c      	orrs	r4, r3
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 8020d68:	058a      	lsls	r2, r1, #22
 8020d6a:	0d90      	lsrs	r0, r2, #22
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 8020d6c:	f7ff ff4b 	bl	8020c06 <TIMER_IF_Convert_Tick2ms>
 8020d70:	8028      	strh	r0, [r5, #0]
}
 8020d72:	0020      	movs	r0, r4
 8020d74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020d76:	46c0      	nop			@ (mov r8, r8)
 8020d78:	40002800 	.word	0x40002800

08020d7c <TIMER_IF_BkUp_Read_Seconds>:
{
 8020d7c:	b510      	push	{r4, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 8020d7e:	4802      	ldr	r0, [pc, #8]	@ (8020d88 <TIMER_IF_BkUp_Read_Seconds+0xc>)
 8020d80:	2100      	movs	r1, #0
 8020d82:	f001 feb9 	bl	8022af8 <HAL_RTCEx_BKUPRead>
}
 8020d86:	bd10      	pop	{r4, pc}
 8020d88:	2000a078 	.word	0x2000a078

08020d8c <TIMER_IF_BkUp_Read_SubSeconds>:
{
 8020d8c:	b510      	push	{r4, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 8020d8e:	4802      	ldr	r0, [pc, #8]	@ (8020d98 <TIMER_IF_BkUp_Read_SubSeconds+0xc>)
 8020d90:	2101      	movs	r1, #1
 8020d92:	f001 feb1 	bl	8022af8 <HAL_RTCEx_BKUPRead>
}
 8020d96:	bd10      	pop	{r4, pc}
 8020d98:	2000a078 	.word	0x2000a078

08020d9c <TIMER_IF_DelayMs>:
{
 8020d9c:	b510      	push	{r4, lr}
  uint32_t delayTicks = TIMER_IF_Convert_ms2Tick(delay);
 8020d9e:	f7ff ff29 	bl	8020bf4 <TIMER_IF_Convert_ms2Tick>
 8020da2:	4b0d      	ldr	r3, [pc, #52]	@ (8020dd8 <TIMER_IF_DelayMs+0x3c>)
 8020da4:	6899      	ldr	r1, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8020da6:	e001      	b.n	8020dac <TIMER_IF_DelayMs+0x10>
 8020da8:	4b0b      	ldr	r3, [pc, #44]	@ (8020dd8 <TIMER_IF_DelayMs+0x3c>)
 8020daa:	6899      	ldr	r1, [r3, #8]
 8020dac:	4a0a      	ldr	r2, [pc, #40]	@ (8020dd8 <TIMER_IF_DelayMs+0x3c>)
 8020dae:	6892      	ldr	r2, [r2, #8]
 8020db0:	428a      	cmp	r2, r1
 8020db2:	d1f9      	bne.n	8020da8 <TIMER_IF_DelayMs+0xc>
  return UINT32_MAX - ssr;
 8020db4:	43c9      	mvns	r1, r1
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8020db6:	e00a      	b.n	8020dce <TIMER_IF_DelayMs+0x32>
 8020db8:	4b07      	ldr	r3, [pc, #28]	@ (8020dd8 <TIMER_IF_DelayMs+0x3c>)
 8020dba:	689b      	ldr	r3, [r3, #8]
 8020dbc:	4a06      	ldr	r2, [pc, #24]	@ (8020dd8 <TIMER_IF_DelayMs+0x3c>)
 8020dbe:	6892      	ldr	r2, [r2, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8020dc0:	429a      	cmp	r2, r3
 8020dc2:	d1f9      	bne.n	8020db8 <TIMER_IF_DelayMs+0x1c>
  return UINT32_MAX - ssr;
 8020dc4:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8020dc6:	1a5b      	subs	r3, r3, r1
 8020dc8:	4283      	cmp	r3, r0
 8020dca:	d203      	bcs.n	8020dd4 <TIMER_IF_DelayMs+0x38>
    __NOP();
 8020dcc:	46c0      	nop			@ (mov r8, r8)
 8020dce:	4b02      	ldr	r3, [pc, #8]	@ (8020dd8 <TIMER_IF_DelayMs+0x3c>)
 8020dd0:	689b      	ldr	r3, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8020dd2:	e7f3      	b.n	8020dbc <TIMER_IF_DelayMs+0x20>
}
 8020dd4:	bd10      	pop	{r4, pc}
 8020dd6:	46c0      	nop			@ (mov r8, r8)
 8020dd8:	40002800 	.word	0x40002800

08020ddc <HAL_RTC_AlarmAEventCallback>:
{
 8020ddc:	b510      	push	{r4, lr}
  if (MBMUXIF_GetCpusSynchroFlag() == CPUS_BOOT_SYNC_RTC_REGISTERED)
 8020dde:	f000 fa73 	bl	80212c8 <MBMUXIF_GetCpusSynchroFlag>
 8020de2:	4b08      	ldr	r3, [pc, #32]	@ (8020e04 <HAL_RTC_AlarmAEventCallback+0x28>)
 8020de4:	4298      	cmp	r0, r3
 8020de6:	d000      	beq.n	8020dea <HAL_RTC_AlarmAEventCallback+0xe>
}
 8020de8:	bd10      	pop	{r4, pc}
    com_obj = MBMUXIF_GetSystemFeatureNotifComPtr(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 8020dea:	2002      	movs	r0, #2
 8020dec:	f000 fa76 	bl	80212dc <MBMUXIF_GetSystemFeatureNotifComPtr>
    if (com_obj != NULL)
 8020df0:	2800      	cmp	r0, #0
 8020df2:	d0f9      	beq.n	8020de8 <HAL_RTC_AlarmAEventCallback+0xc>
      com_obj->MsgId = SYS_RTC_ALARM_MSG_ID;
 8020df4:	2302      	movs	r3, #2
 8020df6:	6003      	str	r3, [r0, #0]
      com_obj->ParamCnt = 0;
 8020df8:	2300      	movs	r3, #0
 8020dfa:	81c3      	strh	r3, [r0, #14]
      MBMUXIF_SystemSendNotif_NoWait(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 8020dfc:	2002      	movs	r0, #2
 8020dfe:	f000 fa78 	bl	80212f2 <MBMUXIF_SystemSendNotif_NoWait>
}
 8020e02:	e7f1      	b.n	8020de8 <HAL_RTC_AlarmAEventCallback+0xc>
 8020e04:	00009999 	.word	0x00009999

08020e08 <HAL_RTCEx_AlarmBEventCallback>:
{
 8020e08:	b510      	push	{r4, lr}
  UTIL_TIMER_IRQ_MAP_PROCESS();
 8020e0a:	f005 f873 	bl	8025ef4 <UTIL_TIMER_IRQ_Handler>
}
 8020e0e:	bd10      	pop	{r4, pc}

08020e10 <HAL_RTCEx_SSRUEventCallback>:
{
 8020e10:	b510      	push	{r4, lr}
  uint32_t MSB_ticks = TIMER_IF_BkUp_Read_MSBticks();
 8020e12:	f7ff ff89 	bl	8020d28 <TIMER_IF_BkUp_Read_MSBticks>
  TIMER_IF_BkUp_Write_MSBticks(MSB_ticks + 1);
 8020e16:	3001      	adds	r0, #1
 8020e18:	f7ff ff14 	bl	8020c44 <TIMER_IF_BkUp_Write_MSBticks>
}
 8020e1c:	bd10      	pop	{r4, pc}

08020e1e <FEAT_INFO_Init>:
  /* USER CODE END FEAT_INFO_Init_1 */

  /* USER CODE BEGIN FEAT_INFO_Init_2 */

  /* USER CODE END FEAT_INFO_Init_2 */
}
 8020e1e:	4770      	bx	lr

08020e20 <FEAT_INFO_GetListPtr>:
FEAT_INFO_List_t *FEAT_INFO_GetListPtr(void)
{
  /* USER CODE BEGIN FEAT_INFO_GetListPtr_1 */

  /* USER CODE END FEAT_INFO_GetListPtr_1 */
  return (FEAT_INFO_List_t *) &Feat_Info_List;
 8020e20:	4800      	ldr	r0, [pc, #0]	@ (8020e24 <FEAT_INFO_GetListPtr+0x4>)
  /* USER CODE BEGIN FEAT_INFO_GetListPtr_2 */

  /* USER CODE END FEAT_INFO_GetListPtr_2 */
}
 8020e22:	4770      	bx	lr
 8020e24:	20009000 	.word	0x20009000

08020e28 <MBMUX_IsrCommandRcvCb>:

  /* USER CODE END MBMUX_RetrieveSecureSramConfig_Last */
}

static void MBMUX_IsrCommandRcvCb(uint32_t channelIdx)
{
 8020e28:	b510      	push	{r4, lr}
 8020e2a:	0003      	movs	r3, r0
  /* USER CODE BEGIN MBMUX_IsrCommandRcvCb_1 */

  /* USER CODE END MBMUX_IsrCommandRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBCmdRespParam[channelIdx];
 8020e2c:	4a05      	ldr	r2, [pc, #20]	@ (8020e44 <MBMUX_IsrCommandRcvCb+0x1c>)
 8020e2e:	6810      	ldr	r0, [r2, #0]
 8020e30:	005a      	lsls	r2, r3, #1
 8020e32:	18d2      	adds	r2, r2, r3
 8020e34:	00d2      	lsls	r2, r2, #3
 8020e36:	1880      	adds	r0, r0, r2
  /* call registered callback */
  MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[channelIdx].MsgCm0plusCb(com_obj);
 8020e38:	4a03      	ldr	r2, [pc, #12]	@ (8020e48 <MBMUX_IsrCommandRcvCb+0x20>)
 8020e3a:	009b      	lsls	r3, r3, #2
 8020e3c:	589b      	ldr	r3, [r3, r2]
 8020e3e:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrCommandRcvCb_Last */

  /* USER CODE END MBMUX_IsrCommandRcvCb_Last */
  return;
}
 8020e40:	bd10      	pop	{r4, pc}
 8020e42:	46c0      	nop			@ (mov r8, r8)
 8020e44:	2000a158 	.word	0x2000a158
 8020e48:	2000a128 	.word	0x2000a128

08020e4c <MBMUX_IsrAcknowledgeRcvCb>:

static void MBMUX_IsrAcknowledgeRcvCb(uint32_t channelIdx)
{
 8020e4c:	b510      	push	{r4, lr}
 8020e4e:	0003      	movs	r3, r0
  /* USER CODE BEGIN MBMUX_IsrAcknowledgeRcvCb_1 */

  /* USER CODE END MBMUX_IsrAcknowledgeRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBNotifAckParam[channelIdx];
 8020e50:	4a06      	ldr	r2, [pc, #24]	@ (8020e6c <MBMUX_IsrAcknowledgeRcvCb+0x20>)
 8020e52:	6810      	ldr	r0, [r2, #0]
 8020e54:	005a      	lsls	r2, r3, #1
 8020e56:	18d2      	adds	r2, r2, r3
 8020e58:	00d2      	lsls	r2, r2, #3
 8020e5a:	3290      	adds	r2, #144	@ 0x90
 8020e5c:	1880      	adds	r0, r0, r2
  /* call registered callback */
  MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[channelIdx].MsgCm0plusCb(com_obj);
 8020e5e:	4a04      	ldr	r2, [pc, #16]	@ (8020e70 <MBMUX_IsrAcknowledgeRcvCb+0x24>)
 8020e60:	3306      	adds	r3, #6
 8020e62:	009b      	lsls	r3, r3, #2
 8020e64:	589b      	ldr	r3, [r3, r2]
 8020e66:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrAcknowledgeRcvCb_Last */

  /* USER CODE END MBMUX_IsrAcknowledgeRcvCb_Last */
  return;
}
 8020e68:	bd10      	pop	{r4, pc}
 8020e6a:	46c0      	nop			@ (mov r8, r8)
 8020e6c:	2000a158 	.word	0x2000a158
 8020e70:	2000a128 	.word	0x2000a128

08020e74 <MBMUX_GetFeatureChIdx>:
static uint8_t MBMUX_GetFeatureChIdx(FEAT_INFO_IdTypeDef e_featID, MBMUX_ComType_t ComType)
{
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_1 */

  /* USER CODE END MBMUX_GetFeatureChIdx_1 */
  return p_MBMUX_ComTable->MBMUXMapping[e_featID][ComType];
 8020e74:	4b04      	ldr	r3, [pc, #16]	@ (8020e88 <MBMUX_GetFeatureChIdx+0x14>)
 8020e76:	681b      	ldr	r3, [r3, #0]
 8020e78:	0040      	lsls	r0, r0, #1
 8020e7a:	181b      	adds	r3, r3, r0
 8020e7c:	185b      	adds	r3, r3, r1
 8020e7e:	3321      	adds	r3, #33	@ 0x21
 8020e80:	33ff      	adds	r3, #255	@ 0xff
 8020e82:	7818      	ldrb	r0, [r3, #0]
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_Last */

  /* USER CODE END MBMUX_GetFeatureChIdx_Last */
}
 8020e84:	4770      	bx	lr
 8020e86:	46c0      	nop			@ (mov r8, r8)
 8020e88:	2000a158 	.word	0x2000a158

08020e8c <MBMUX_IsrNotRegistered>:

static void MBMUX_IsrNotRegistered(void *ComObj)
{
 8020e8c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_1 */

  /* USER CODE END MBMUX_IsrNotRegistered_1 */
  Error_Handler();
 8020e8e:	f7ff fcd1 	bl	8020834 <Error_Handler>
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_Last */

  /* USER CODE END MBMUX_IsrNotRegistered_Last */
}
 8020e92:	bd10      	pop	{r4, pc}

08020e94 <MBMUX_SEC_VerifySramBuffer>:
{
 8020e94:	b510      	push	{r4, lr}
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SYSTEM_AND_FLASH_ENABLE) != 0)
 8020e96:	4b13      	ldr	r3, [pc, #76]	@ (8020ee4 <MBMUX_SEC_VerifySramBuffer+0x50>)
 8020e98:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8020e9a:	07db      	lsls	r3, r3, #31
 8020e9c:	d519      	bpl.n	8020ed2 <MBMUX_SEC_VerifySramBuffer+0x3e>
    if (((((uint32_t)(pBufferAddress)) >= SRAM1_BASE)
 8020e9e:	0003      	movs	r3, r0
 8020ea0:	2280      	movs	r2, #128	@ 0x80
 8020ea2:	0592      	lsls	r2, r2, #22
 8020ea4:	4290      	cmp	r0, r2
 8020ea6:	d304      	bcc.n	8020eb2 <MBMUX_SEC_VerifySramBuffer+0x1e>
         && ((((uint32_t)(pBufferAddress)) + bufferSize) <= unsecure_sram1_end)) ||
 8020ea8:	1842      	adds	r2, r0, r1
 8020eaa:	4c0f      	ldr	r4, [pc, #60]	@ (8020ee8 <MBMUX_SEC_VerifySramBuffer+0x54>)
 8020eac:	6824      	ldr	r4, [r4, #0]
 8020eae:	42a2      	cmp	r2, r4
 8020eb0:	d907      	bls.n	8020ec2 <MBMUX_SEC_VerifySramBuffer+0x2e>
 8020eb2:	4a0e      	ldr	r2, [pc, #56]	@ (8020eec <MBMUX_SEC_VerifySramBuffer+0x58>)
 8020eb4:	4293      	cmp	r3, r2
 8020eb6:	d911      	bls.n	8020edc <MBMUX_SEC_VerifySramBuffer+0x48>
        ((((uint32_t)(pBufferAddress)) >= SRAM2_BASE) && ((((uint32_t)(pBufferAddress)) + bufferSize) <= unsecure_sram2_end))
 8020eb8:	185a      	adds	r2, r3, r1
 8020eba:	4c0d      	ldr	r4, [pc, #52]	@ (8020ef0 <MBMUX_SEC_VerifySramBuffer+0x5c>)
 8020ebc:	6824      	ldr	r4, [r4, #0]
 8020ebe:	42a2      	cmp	r2, r4
 8020ec0:	d80c      	bhi.n	8020edc <MBMUX_SEC_VerifySramBuffer+0x48>
      if (((uint32_t)pBufferAddress <= unsecure_sram2_end) && (bufferSize < (SRAM1_SIZE + SRAM2_SIZE)))
 8020ec2:	4a0b      	ldr	r2, [pc, #44]	@ (8020ef0 <MBMUX_SEC_VerifySramBuffer+0x5c>)
 8020ec4:	6812      	ldr	r2, [r2, #0]
 8020ec6:	4293      	cmp	r3, r2
 8020ec8:	d804      	bhi.n	8020ed4 <MBMUX_SEC_VerifySramBuffer+0x40>
 8020eca:	2380      	movs	r3, #128	@ 0x80
 8020ecc:	025b      	lsls	r3, r3, #9
 8020ece:	4299      	cmp	r1, r3
 8020ed0:	d200      	bcs.n	8020ed4 <MBMUX_SEC_VerifySramBuffer+0x40>
}
 8020ed2:	bd10      	pop	{r4, pc}
        Error_Handler();
 8020ed4:	f7ff fcae 	bl	8020834 <Error_Handler>
  uint32_t *p_validated_address = NULL;
 8020ed8:	2000      	movs	r0, #0
 8020eda:	e7fa      	b.n	8020ed2 <MBMUX_SEC_VerifySramBuffer+0x3e>
      Error_Handler();
 8020edc:	f7ff fcaa 	bl	8020834 <Error_Handler>
  uint32_t *p_validated_address = NULL;
 8020ee0:	2000      	movs	r0, #0
 8020ee2:	e7f6      	b.n	8020ed2 <MBMUX_SEC_VerifySramBuffer+0x3e>
 8020ee4:	2000a0d0 	.word	0x2000a0d0
 8020ee8:	2000a0cc 	.word	0x2000a0cc
 8020eec:	20007fff 	.word	0x20007fff
 8020ef0:	2000a0c8 	.word	0x2000a0c8

08020ef4 <MBMUX_RetrieveSecureSramConfig>:
{
 8020ef4:	b510      	push	{r4, lr}
  HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
 8020ef6:	4c0d      	ldr	r4, [pc, #52]	@ (8020f2c <MBMUX_RetrieveSecureSramConfig+0x38>)
 8020ef8:	0020      	movs	r0, r4
 8020efa:	f000 ff43 	bl	8021d84 <HAL_FLASHEx_OBGetConfig>
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SRAM1_DISABLE) != 0)
 8020efe:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8020f00:	065a      	lsls	r2, r3, #25
 8020f02:	d508      	bpl.n	8020f16 <MBMUX_RetrieveSecureSramConfig+0x22>
    unsecure_sram1_end = SRAM1_BASE + SRAM1_SIZE;
 8020f04:	4a0a      	ldr	r2, [pc, #40]	@ (8020f30 <MBMUX_RetrieveSecureSramConfig+0x3c>)
 8020f06:	490b      	ldr	r1, [pc, #44]	@ (8020f34 <MBMUX_RetrieveSecureSramConfig+0x40>)
 8020f08:	6011      	str	r1, [r2, #0]
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SRAM2_DISABLE) != 0)
 8020f0a:	061b      	lsls	r3, r3, #24
 8020f0c:	d508      	bpl.n	8020f20 <MBMUX_RetrieveSecureSramConfig+0x2c>
    unsecure_sram2_end = SRAM2_BASE + SRAM2_SIZE;
 8020f0e:	4b0a      	ldr	r3, [pc, #40]	@ (8020f38 <MBMUX_RetrieveSecureSramConfig+0x44>)
 8020f10:	4a0a      	ldr	r2, [pc, #40]	@ (8020f3c <MBMUX_RetrieveSecureSramConfig+0x48>)
 8020f12:	601a      	str	r2, [r3, #0]
}
 8020f14:	bd10      	pop	{r4, pc}
    unsecure_sram1_end = OptionsBytesStruct.SecureSRAM1StartAddr;
 8020f16:	4a05      	ldr	r2, [pc, #20]	@ (8020f2c <MBMUX_RetrieveSecureSramConfig+0x38>)
 8020f18:	6b91      	ldr	r1, [r2, #56]	@ 0x38
 8020f1a:	4a05      	ldr	r2, [pc, #20]	@ (8020f30 <MBMUX_RetrieveSecureSramConfig+0x3c>)
 8020f1c:	6011      	str	r1, [r2, #0]
 8020f1e:	e7f4      	b.n	8020f0a <MBMUX_RetrieveSecureSramConfig+0x16>
    unsecure_sram2_end = OptionsBytesStruct.SecureSRAM2StartAddr;
 8020f20:	4b02      	ldr	r3, [pc, #8]	@ (8020f2c <MBMUX_RetrieveSecureSramConfig+0x38>)
 8020f22:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8020f24:	4b04      	ldr	r3, [pc, #16]	@ (8020f38 <MBMUX_RetrieveSecureSramConfig+0x44>)
 8020f26:	601a      	str	r2, [r3, #0]
}
 8020f28:	e7f4      	b.n	8020f14 <MBMUX_RetrieveSecureSramConfig+0x20>
 8020f2a:	46c0      	nop			@ (mov r8, r8)
 8020f2c:	2000a0d0 	.word	0x2000a0d0
 8020f30:	2000a0cc 	.word	0x2000a0cc
 8020f34:	20008000 	.word	0x20008000
 8020f38:	2000a0c8 	.word	0x2000a0c8
 8020f3c:	20010000 	.word	0x20010000

08020f40 <MBMUX_RegisterFeatureCallback>:
{
 8020f40:	b570      	push	{r4, r5, r6, lr}
 8020f42:	000c      	movs	r4, r1
 8020f44:	0015      	movs	r5, r2
  check_existing_feature_registration = MBMUX_GetFeatureChIdx(e_featID, ComType);
 8020f46:	f7ff ff95 	bl	8020e74 <MBMUX_GetFeatureChIdx>
  if (check_existing_feature_registration != MB_CHANNEL_NOT_REGISTERED)
 8020f4a:	28ff      	cmp	r0, #255	@ 0xff
 8020f4c:	d00b      	beq.n	8020f66 <MBMUX_RegisterFeatureCallback+0x26>
      if (ComType == MBMUX_CMD_RESP)
 8020f4e:	2c00      	cmp	r4, #0
 8020f50:	d104      	bne.n	8020f5c <MBMUX_RegisterFeatureCallback+0x1c>
        MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[channel_idx].MsgCm0plusCb = MsgCb;
 8020f52:	4b06      	ldr	r3, [pc, #24]	@ (8020f6c <MBMUX_RegisterFeatureCallback+0x2c>)
 8020f54:	0082      	lsls	r2, r0, #2
 8020f56:	50d5      	str	r5, [r2, r3]
      ret = channel_idx;
 8020f58:	b240      	sxtb	r0, r0
}
 8020f5a:	bd70      	pop	{r4, r5, r6, pc}
        MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[channel_idx].MsgCm0plusCb = MsgCb;
 8020f5c:	4b03      	ldr	r3, [pc, #12]	@ (8020f6c <MBMUX_RegisterFeatureCallback+0x2c>)
 8020f5e:	1d82      	adds	r2, r0, #6
 8020f60:	0092      	lsls	r2, r2, #2
 8020f62:	50d5      	str	r5, [r2, r3]
 8020f64:	e7f8      	b.n	8020f58 <MBMUX_RegisterFeatureCallback+0x18>
  int8_t ret = -1;
 8020f66:	2001      	movs	r0, #1
 8020f68:	4240      	negs	r0, r0
 8020f6a:	e7f6      	b.n	8020f5a <MBMUX_RegisterFeatureCallback+0x1a>
 8020f6c:	2000a128 	.word	0x2000a128

08020f70 <MBMUX_GetFeatureComPtr>:
{
 8020f70:	b510      	push	{r4, lr}
 8020f72:	000c      	movs	r4, r1
  channel_idx = MBMUX_GetFeatureChIdx(e_featID, ComType);
 8020f74:	f7ff ff7e 	bl	8020e74 <MBMUX_GetFeatureChIdx>
  if (channel_idx < MBMUX_CHANNEL_NUMBER)
 8020f78:	2805      	cmp	r0, #5
 8020f7a:	d810      	bhi.n	8020f9e <MBMUX_GetFeatureComPtr+0x2e>
    if (ComType == MBMUX_CMD_RESP)  /* TX */
 8020f7c:	2c00      	cmp	r4, #0
 8020f7e:	d106      	bne.n	8020f8e <MBMUX_GetFeatureComPtr+0x1e>
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBCmdRespParam[channel_idx];
 8020f80:	4b08      	ldr	r3, [pc, #32]	@ (8020fa4 <MBMUX_GetFeatureComPtr+0x34>)
 8020f82:	681b      	ldr	r3, [r3, #0]
 8020f84:	0042      	lsls	r2, r0, #1
 8020f86:	1812      	adds	r2, r2, r0
 8020f88:	00d2      	lsls	r2, r2, #3
 8020f8a:	1898      	adds	r0, r3, r2
}
 8020f8c:	bd10      	pop	{r4, pc}
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBNotifAckParam[channel_idx];
 8020f8e:	4b05      	ldr	r3, [pc, #20]	@ (8020fa4 <MBMUX_GetFeatureComPtr+0x34>)
 8020f90:	681b      	ldr	r3, [r3, #0]
 8020f92:	0042      	lsls	r2, r0, #1
 8020f94:	1812      	adds	r2, r2, r0
 8020f96:	00d2      	lsls	r2, r2, #3
 8020f98:	3290      	adds	r2, #144	@ 0x90
 8020f9a:	1898      	adds	r0, r3, r2
 8020f9c:	e7f6      	b.n	8020f8c <MBMUX_GetFeatureComPtr+0x1c>
  MBMUX_ComParam_t *com_param_ptr = NULL;
 8020f9e:	2000      	movs	r0, #0
  return com_param_ptr;
 8020fa0:	e7f4      	b.n	8020f8c <MBMUX_GetFeatureComPtr+0x1c>
 8020fa2:	46c0      	nop			@ (mov r8, r8)
 8020fa4:	2000a158 	.word	0x2000a158

08020fa8 <MBMUX_NotificationSnd>:
{
 8020fa8:	b510      	push	{r4, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_NOTIF_ACK);
 8020faa:	2101      	movs	r1, #1
 8020fac:	f7ff ff62 	bl	8020e74 <MBMUX_GetFeatureChIdx>
 8020fb0:	0004      	movs	r4, r0
  if (p_MBMUX_ComTable->MBNotifAckParam[mb_ch].ParamCnt > p_MBMUX_ComTable->MBNotifAckParam[mb_ch].BufSize)
 8020fb2:	4b0a      	ldr	r3, [pc, #40]	@ (8020fdc <MBMUX_NotificationSnd+0x34>)
 8020fb4:	681b      	ldr	r3, [r3, #0]
 8020fb6:	0042      	lsls	r2, r0, #1
 8020fb8:	1812      	adds	r2, r2, r0
 8020fba:	00d2      	lsls	r2, r2, #3
 8020fbc:	189b      	adds	r3, r3, r2
 8020fbe:	001a      	movs	r2, r3
 8020fc0:	329e      	adds	r2, #158	@ 0x9e
 8020fc2:	8812      	ldrh	r2, [r2, #0]
 8020fc4:	339c      	adds	r3, #156	@ 0x9c
 8020fc6:	881b      	ldrh	r3, [r3, #0]
 8020fc8:	429a      	cmp	r2, r3
 8020fca:	d803      	bhi.n	8020fd4 <MBMUX_NotificationSnd+0x2c>
  return IPCC_IF_NotificationSnd(mb_ch);
 8020fcc:	0020      	movs	r0, r4
 8020fce:	f7ff fc07 	bl	80207e0 <IPCC_IF_NotificationSnd>
}
 8020fd2:	bd10      	pop	{r4, pc}
    Error_Handler();
 8020fd4:	f7ff fc2e 	bl	8020834 <Error_Handler>
 8020fd8:	e7f8      	b.n	8020fcc <MBMUX_NotificationSnd+0x24>
 8020fda:	46c0      	nop			@ (mov r8, r8)
 8020fdc:	2000a158 	.word	0x2000a158

08020fe0 <MBMUX_ResponseSnd>:
{
 8020fe0:	b510      	push	{r4, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_CMD_RESP);
 8020fe2:	2100      	movs	r1, #0
 8020fe4:	f7ff ff46 	bl	8020e74 <MBMUX_GetFeatureChIdx>
  return IPCC_IF_ResponseSnd(mb_ch);
 8020fe8:	f7ff fc0a 	bl	8020800 <IPCC_IF_ResponseSnd>
}
 8020fec:	bd10      	pop	{r4, pc}

08020fee <MBMUX_SEC_VerifySramBufferPtr>:
{
 8020fee:	b510      	push	{r4, lr}
  pbuf_validated = MBMUX_SEC_VerifySramBuffer(pBufferAddress, bufferSize);
 8020ff0:	f7ff ff50 	bl	8020e94 <MBMUX_SEC_VerifySramBuffer>
}
 8020ff4:	bd10      	pop	{r4, pc}
	...

08020ff8 <MBMUX_Init>:
{
 8020ff8:	b510      	push	{r4, lr}
 8020ffa:	0004      	movs	r4, r0
  IPCC_IF_Init(MBMUX_IsrCommandRcvCb, MBMUX_IsrAcknowledgeRcvCb);
 8020ffc:	4911      	ldr	r1, [pc, #68]	@ (8021044 <MBMUX_Init+0x4c>)
 8020ffe:	4812      	ldr	r0, [pc, #72]	@ (8021048 <MBMUX_Init+0x50>)
 8021000:	f7ff fbae 	bl	8020760 <IPCC_IF_Init>
  MBMUX_RetrieveSecureSramConfig();
 8021004:	f7ff ff76 	bl	8020ef4 <MBMUX_RetrieveSecureSramConfig>
  p_MBMUX_ComTable = (MBMUX_ComTable_t *) MBMUX_SEC_VerifySramBufferPtr((uint32_t *) pMBMUX_ComTable, sizeof(MBMUX_ComTable_t));
 8021008:	219e      	movs	r1, #158	@ 0x9e
 802100a:	0049      	lsls	r1, r1, #1
 802100c:	0020      	movs	r0, r4
 802100e:	f7ff ffee 	bl	8020fee <MBMUX_SEC_VerifySramBufferPtr>
 8021012:	4b0e      	ldr	r3, [pc, #56]	@ (802104c <MBMUX_Init+0x54>)
 8021014:	6018      	str	r0, [r3, #0]
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 8021016:	2200      	movs	r2, #0
 8021018:	e010      	b.n	802103c <MBMUX_Init+0x44>
    MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[i].MsgCm0plusCb = MBMUX_IsrNotRegistered;
 802101a:	4b0d      	ldr	r3, [pc, #52]	@ (8021050 <MBMUX_Init+0x58>)
 802101c:	0091      	lsls	r1, r2, #2
 802101e:	4c0d      	ldr	r4, [pc, #52]	@ (8021054 <MBMUX_Init+0x5c>)
 8021020:	50cc      	str	r4, [r1, r3]
    MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[i].MsgCm0plusCb = MBMUX_IsrNotRegistered;
 8021022:	1d91      	adds	r1, r2, #6
 8021024:	0089      	lsls	r1, r1, #2
 8021026:	50cc      	str	r4, [r1, r3]
    p_MBMUX_ComTable->MBCmdRespParam[i].MsgCm0plusCb = MBMUX_IsrNotRegistered; /* not used anymore */
 8021028:	0053      	lsls	r3, r2, #1
 802102a:	1899      	adds	r1, r3, r2
 802102c:	00c9      	lsls	r1, r1, #3
 802102e:	1841      	adds	r1, r0, r1
 8021030:	608c      	str	r4, [r1, #8]
    p_MBMUX_ComTable->MBNotifAckParam[i].MsgCm0plusCb = MBMUX_IsrNotRegistered; /* not used anymore */
 8021032:	000b      	movs	r3, r1
 8021034:	3398      	adds	r3, #152	@ 0x98
 8021036:	601c      	str	r4, [r3, #0]
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 8021038:	3201      	adds	r2, #1
 802103a:	b2d2      	uxtb	r2, r2
 802103c:	2a05      	cmp	r2, #5
 802103e:	d9ec      	bls.n	802101a <MBMUX_Init+0x22>
}
 8021040:	bd10      	pop	{r4, pc}
 8021042:	46c0      	nop			@ (mov r8, r8)
 8021044:	08020e4d 	.word	0x08020e4d
 8021048:	08020e29 	.word	0x08020e29
 802104c:	2000a158 	.word	0x2000a158
 8021050:	2000a128 	.word	0x2000a128
 8021054:	08020e8d 	.word	0x08020e8d

08021058 <MBMUXIF_TaskRadioNotifSnd>:

  /* USER CODE END MBMUXIF_TaskRadioCmdRcv_Last */
}

static void MBMUXIF_TaskRadioNotifSnd(void)
{
 8021058:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifSnd_1 */

  /* USER CODE END MBMUXIF_TaskRadioNotifSnd_1 */
  if (MBMUX_NotificationSnd(FEAT_INFO_RADIO_ID) == 0)
 802105a:	2007      	movs	r0, #7
 802105c:	f7ff ffa4 	bl	8020fa8 <MBMUX_NotificationSnd>
 8021060:	2800      	cmp	r0, #0
 8021062:	d103      	bne.n	802106c <MBMUXIF_TaskRadioNotifSnd+0x14>
  {
    UTIL_SEQ_WaitEvt(1 << CFG_SEQ_Evt_MbRadioAckRcv);
 8021064:	3004      	adds	r0, #4
 8021066:	f004 fd93 	bl	8025b90 <UTIL_SEQ_WaitEvt>
    Error_Handler();
  }
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifSnd_Last */

  /* USER CODE END MBMUXIF_TaskRadioNotifSnd_Last */
}
 802106a:	bd10      	pop	{r4, pc}
    Error_Handler();
 802106c:	f7ff fbe2 	bl	8020834 <Error_Handler>
}
 8021070:	e7fb      	b.n	802106a <MBMUXIF_TaskRadioNotifSnd+0x12>
	...

08021074 <MBMUXIF_TaskRadioCmdRcv>:
{
 8021074:	b510      	push	{r4, lr}
  Process_Radio_Cmd(RadioComObj);
 8021076:	4b02      	ldr	r3, [pc, #8]	@ (8021080 <MBMUXIF_TaskRadioCmdRcv+0xc>)
 8021078:	6818      	ldr	r0, [r3, #0]
 802107a:	f000 f9fb 	bl	8021474 <Process_Radio_Cmd>
}
 802107e:	bd10      	pop	{r4, pc}
 8021080:	2000a15c 	.word	0x2000a15c

08021084 <MBMUXIF_IsrRadioCmdRcvCb>:
{
 8021084:	b510      	push	{r4, lr}
  RadioComObj = (MBMUX_ComParam_t *) ComObj;
 8021086:	4b03      	ldr	r3, [pc, #12]	@ (8021094 <MBMUXIF_IsrRadioCmdRcvCb+0x10>)
 8021088:	6018      	str	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbRadioCmdRcv), CFG_SEQ_Prio_0);
 802108a:	2100      	movs	r1, #0
 802108c:	2004      	movs	r0, #4
 802108e:	f004 fca5 	bl	80259dc <UTIL_SEQ_SetTask>
}
 8021092:	bd10      	pop	{r4, pc}
 8021094:	2000a15c 	.word	0x2000a15c

08021098 <MBMUXIF_IsrRadioAckRcvCb>:
{
 8021098:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbRadioAckRcv);
 802109a:	2004      	movs	r0, #4
 802109c:	f004 fcb2 	bl	8025a04 <UTIL_SEQ_SetEvt>
}
 80210a0:	bd10      	pop	{r4, pc}
	...

080210a4 <MBMUXIF_RadioInit>:
{
 80210a4:	b510      	push	{r4, lr}
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_RADIO_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrRadioAckRcvCb);
 80210a6:	4a0d      	ldr	r2, [pc, #52]	@ (80210dc <MBMUXIF_RadioInit+0x38>)
 80210a8:	2101      	movs	r1, #1
 80210aa:	2007      	movs	r0, #7
 80210ac:	f7ff ff48 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 80210b0:	2800      	cmp	r0, #0
 80210b2:	da00      	bge.n	80210b6 <MBMUXIF_RadioInit+0x12>
}
 80210b4:	bd10      	pop	{r4, pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_RADIO_ID, MBMUX_CMD_RESP, MBMUXIF_IsrRadioCmdRcvCb);
 80210b6:	4a0a      	ldr	r2, [pc, #40]	@ (80210e0 <MBMUXIF_RadioInit+0x3c>)
 80210b8:	2100      	movs	r1, #0
 80210ba:	2007      	movs	r0, #7
 80210bc:	f7ff ff40 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 80210c0:	2800      	cmp	r0, #0
 80210c2:	dbf7      	blt.n	80210b4 <MBMUXIF_RadioInit+0x10>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbRadioCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskRadioCmdRcv);
 80210c4:	4a07      	ldr	r2, [pc, #28]	@ (80210e4 <MBMUXIF_RadioInit+0x40>)
 80210c6:	2100      	movs	r1, #0
 80210c8:	2004      	movs	r0, #4
 80210ca:	f004 fd8b 	bl	8025be4 <UTIL_SEQ_RegTask>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbRadioNotifSnd), UTIL_SEQ_RFU, MBMUXIF_TaskRadioNotifSnd);
 80210ce:	4a06      	ldr	r2, [pc, #24]	@ (80210e8 <MBMUXIF_RadioInit+0x44>)
 80210d0:	2100      	movs	r1, #0
 80210d2:	2008      	movs	r0, #8
 80210d4:	f004 fd86 	bl	8025be4 <UTIL_SEQ_RegTask>
    ret = 0;
 80210d8:	2000      	movs	r0, #0
 80210da:	e7eb      	b.n	80210b4 <MBMUXIF_RadioInit+0x10>
 80210dc:	08021099 	.word	0x08021099
 80210e0:	08021085 	.word	0x08021085
 80210e4:	08021075 	.word	0x08021075
 80210e8:	08021059 	.word	0x08021059

080210ec <MBMUXIF_GetRadioFeatureNotifComPtr>:
{
 80210ec:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_RADIO_ID, MBMUX_NOTIF_ACK);
 80210ee:	2101      	movs	r1, #1
 80210f0:	2007      	movs	r0, #7
 80210f2:	f7ff ff3d 	bl	8020f70 <MBMUX_GetFeatureComPtr>
 80210f6:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 80210f8:	d001      	beq.n	80210fe <MBMUXIF_GetRadioFeatureNotifComPtr+0x12>
}
 80210fa:	0020      	movs	r0, r4
 80210fc:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 80210fe:	f7ff fb99 	bl	8020834 <Error_Handler>
  return com_param_ptr;
 8021102:	e7fa      	b.n	80210fa <MBMUXIF_GetRadioFeatureNotifComPtr+0xe>

08021104 <MBMUXIF_RadioSendNotif>:
{
 8021104:	b510      	push	{r4, lr}
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbRadioNotifSnd), CFG_SEQ_Prio_0);
 8021106:	2100      	movs	r1, #0
 8021108:	2008      	movs	r0, #8
 802110a:	f004 fc67 	bl	80259dc <UTIL_SEQ_SetTask>
}
 802110e:	bd10      	pop	{r4, pc}

08021110 <MBMUXIF_IsrSystemPrioAAckRcvCb>:
static void MBMUXIF_IsrSystemPrioAAckRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioAAckRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioAAckRcvCb */
}
 8021110:	4770      	bx	lr

08021112 <MBMUXIF_IsrSystemPrioACmdRcvCb>:
static void MBMUXIF_IsrSystemPrioACmdRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioACmdRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioACmdRcvCb */
}
 8021112:	4770      	bx	lr

08021114 <MBMUXIF_IsrSystemPrioBAckRcvCb>:
static void MBMUXIF_IsrSystemPrioBAckRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBAckRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBAckRcvCb */
}
 8021114:	4770      	bx	lr

08021116 <MBMUXIF_IsrSystemPrioBCmdRcvCb>:
static void MBMUXIF_IsrSystemPrioBCmdRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBCmdRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBCmdRcvCb */
}
 8021116:	4770      	bx	lr

08021118 <MBMUXIF_FeatureCm0plusRegistrationCmd>:

static int8_t MBMUXIF_FeatureCm0plusRegistrationCmd(uint32_t *pBuf)
{
 8021118:	b510      	push	{r4, lr}

  /* USER CODE BEGIN MBMUXIF_FeatureCm0plusRegistrationCmd_1 */

  /* USER CODE END MBMUXIF_FeatureCm0plusRegistrationCmd_1 */

  switch (pBuf[0])
 802111a:	6803      	ldr	r3, [r0, #0]
 802111c:	2b09      	cmp	r3, #9
 802111e:	d841      	bhi.n	80211a4 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x8c>
 8021120:	009b      	lsls	r3, r3, #2
 8021122:	4a22      	ldr	r2, [pc, #136]	@ (80211ac <MBMUXIF_FeatureCm0plusRegistrationCmd+0x94>)
 8021124:	58d3      	ldr	r3, [r2, r3]
 8021126:	469f      	mov	pc, r3
  {
    case FEAT_INFO_SYSTEM_CMD_PRIO_A_ID:
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_CMD_PRIO_A_ID, MBMUX_CMD_RESP,
 8021128:	4a21      	ldr	r2, [pc, #132]	@ (80211b0 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x98>)
 802112a:	2100      	movs	r1, #0
 802112c:	2001      	movs	r0, #1
 802112e:	f7ff ff07 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
 8021132:	0004      	movs	r4, r0
  /* USER CODE BEGIN MBMUXIF_FeatureCm0plusRegistrationCmd_Last */

  /* USER CODE END MBMUXIF_FeatureCm0plusRegistrationCmd_Last */

  return ret;
}
 8021134:	0020      	movs	r0, r4
 8021136:	bd10      	pop	{r4, pc}
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID, MBMUX_NOTIF_ACK,
 8021138:	4a1e      	ldr	r2, [pc, #120]	@ (80211b4 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x9c>)
 802113a:	2101      	movs	r1, #1
 802113c:	2002      	movs	r0, #2
 802113e:	f7ff feff 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
 8021142:	0004      	movs	r4, r0
      break;
 8021144:	e7f6      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_CMD_PRIO_B_ID, MBMUX_CMD_RESP,
 8021146:	4a1c      	ldr	r2, [pc, #112]	@ (80211b8 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa0>)
 8021148:	2100      	movs	r1, #0
 802114a:	2003      	movs	r0, #3
 802114c:	f7ff fef8 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
 8021150:	0004      	movs	r4, r0
      break;
 8021152:	e7ef      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_NOTIF_PRIO_B_ID, MBMUX_NOTIF_ACK,
 8021154:	4a19      	ldr	r2, [pc, #100]	@ (80211bc <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa4>)
 8021156:	2101      	movs	r1, #1
 8021158:	2004      	movs	r0, #4
 802115a:	f7ff fef1 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
 802115e:	0004      	movs	r4, r0
      break;
 8021160:	e7e8      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_TraceInit(VERBOSE_LEVEL);
 8021162:	2002      	movs	r0, #2
 8021164:	f000 f8e6 	bl	8021334 <MBMUXIF_TraceInit>
 8021168:	0004      	movs	r4, r0
      break;
 802116a:	e7e3      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_RadioInit();
 802116c:	f7ff ff9a 	bl	80210a4 <MBMUXIF_RadioInit>
 8021170:	0004      	movs	r4, r0
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Radio registration done\r\n");
 8021172:	4b13      	ldr	r3, [pc, #76]	@ (80211c0 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa8>)
 8021174:	2200      	movs	r2, #0
 8021176:	2100      	movs	r1, #0
 8021178:	2001      	movs	r0, #1
 802117a:	f004 fb03 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
      break;
 802117e:	e7d9      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Lora not supported\r\n");
 8021180:	4b10      	ldr	r3, [pc, #64]	@ (80211c4 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xac>)
 8021182:	2200      	movs	r2, #0
 8021184:	2100      	movs	r1, #0
 8021186:	2001      	movs	r0, #1
 8021188:	f004 fafc 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
  int8_t ret = -2; /* feature not supported */
 802118c:	2402      	movs	r4, #2
 802118e:	4264      	negs	r4, r4
      break;
 8021190:	e7d0      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Sigfox not supported\r\n");
 8021192:	4b0d      	ldr	r3, [pc, #52]	@ (80211c8 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xb0>)
 8021194:	2200      	movs	r2, #0
 8021196:	2100      	movs	r1, #0
 8021198:	2001      	movs	r0, #1
 802119a:	f004 faf3 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
  int8_t ret = -2; /* feature not supported */
 802119e:	2402      	movs	r4, #2
 80211a0:	4264      	negs	r4, r4
      break;
 80211a2:	e7c7      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
  switch (pBuf[0])
 80211a4:	2402      	movs	r4, #2
 80211a6:	4264      	negs	r4, r4
 80211a8:	e7c4      	b.n	8021134 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
 80211aa:	46c0      	nop			@ (mov r8, r8)
 80211ac:	08026420 	.word	0x08026420
 80211b0:	08021113 	.word	0x08021113
 80211b4:	08021111 	.word	0x08021111
 80211b8:	08021117 	.word	0x08021117
 80211bc:	08021115 	.word	0x08021115
 80211c0:	080263b8 	.word	0x080263b8
 80211c4:	080263dc 	.word	0x080263dc
 80211c8:	080263fc 	.word	0x080263fc

080211cc <MBMUXIF_TaskSystemCmdRcv>:
{
 80211cc:	b510      	push	{r4, lr}
  uint32_t *com_buffer = MBMUX_SEC_VerifySramBufferPtr(SystemComObj->ParamBuf, SystemComObj->BufSize);
 80211ce:	4c0c      	ldr	r4, [pc, #48]	@ (8021200 <MBMUXIF_TaskSystemCmdRcv+0x34>)
 80211d0:	6823      	ldr	r3, [r4, #0]
 80211d2:	8999      	ldrh	r1, [r3, #12]
 80211d4:	6918      	ldr	r0, [r3, #16]
 80211d6:	f7ff ff0a 	bl	8020fee <MBMUX_SEC_VerifySramBufferPtr>
 80211da:	0003      	movs	r3, r0
  if (SystemComObj->MsgId == SYS_REGISTER_FEATURE_MSG_ID)
 80211dc:	6820      	ldr	r0, [r4, #0]
 80211de:	6802      	ldr	r2, [r0, #0]
 80211e0:	2a01      	cmp	r2, #1
 80211e2:	d002      	beq.n	80211ea <MBMUXIF_TaskSystemCmdRcv+0x1e>
    Process_Sys_Cmd(SystemComObj);
 80211e4:	f7ff fc84 	bl	8020af0 <Process_Sys_Cmd>
}
 80211e8:	bd10      	pop	{r4, pc}
    SystemComObj->ReturnVal = (uint32_t) MBMUXIF_FeatureCm0plusRegistrationCmd(com_buffer);
 80211ea:	0018      	movs	r0, r3
 80211ec:	f7ff ff94 	bl	8021118 <MBMUXIF_FeatureCm0plusRegistrationCmd>
 80211f0:	4b03      	ldr	r3, [pc, #12]	@ (8021200 <MBMUXIF_TaskSystemCmdRcv+0x34>)
 80211f2:	681b      	ldr	r3, [r3, #0]
 80211f4:	6158      	str	r0, [r3, #20]
    MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 80211f6:	2000      	movs	r0, #0
 80211f8:	f7ff fef2 	bl	8020fe0 <MBMUX_ResponseSnd>
 80211fc:	e7f4      	b.n	80211e8 <MBMUXIF_TaskSystemCmdRcv+0x1c>
 80211fe:	46c0      	nop			@ (mov r8, r8)
 8021200:	2000a160 	.word	0x2000a160

08021204 <MBMUXIF_IsrSystemCmdRcvCb>:
{
 8021204:	b510      	push	{r4, lr}
  SystemComObj = (MBMUX_ComParam_t *) ComObj;
 8021206:	4b09      	ldr	r3, [pc, #36]	@ (802122c <MBMUXIF_IsrSystemCmdRcvCb+0x28>)
 8021208:	6018      	str	r0, [r3, #0]
  switch (SystemComObj->MsgId)
 802120a:	6803      	ldr	r3, [r0, #0]
 802120c:	2b00      	cmp	r3, #0
 802120e:	d108      	bne.n	8021222 <MBMUXIF_IsrSystemCmdRcvCb+0x1e>
      SystemComObj->ReturnVal = (uint32_t) FEAT_INFO_GetListPtr();
 8021210:	f7ff fe06 	bl	8020e20 <FEAT_INFO_GetListPtr>
 8021214:	4b05      	ldr	r3, [pc, #20]	@ (802122c <MBMUXIF_IsrSystemCmdRcvCb+0x28>)
 8021216:	681b      	ldr	r3, [r3, #0]
 8021218:	6158      	str	r0, [r3, #20]
      MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 802121a:	2000      	movs	r0, #0
 802121c:	f7ff fee0 	bl	8020fe0 <MBMUX_ResponseSnd>
}
 8021220:	bd10      	pop	{r4, pc}
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbSystemCmdRcv), CFG_SEQ_Prio_0);
 8021222:	2100      	movs	r1, #0
 8021224:	2001      	movs	r0, #1
 8021226:	f004 fbd9 	bl	80259dc <UTIL_SEQ_SetTask>
}
 802122a:	e7f9      	b.n	8021220 <MBMUXIF_IsrSystemCmdRcvCb+0x1c>
 802122c:	2000a160 	.word	0x2000a160

08021230 <MBMUXIF_IsrSystemAckRcvCb>:
{
 8021230:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbSystemAckRcv);
 8021232:	2001      	movs	r0, #1
 8021234:	f004 fbe6 	bl	8025a04 <UTIL_SEQ_SetEvt>
}
 8021238:	bd10      	pop	{r4, pc}
	...

0802123c <MBMUXIF_SystemInit>:
{
 802123c:	b500      	push	{lr}
 802123e:	b097      	sub	sp, #92	@ 0x5c
  HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
 8021240:	4668      	mov	r0, sp
 8021242:	f000 fd9f 	bl	8021d84 <HAL_FLASHEx_OBGetConfig>
  pMb_RefTable = (MBMUX_ComTable_t *) OptionsBytesStruct.IPCCdataBufAddr;
 8021246:	9815      	ldr	r0, [sp, #84]	@ 0x54
 8021248:	4b18      	ldr	r3, [pc, #96]	@ (80212ac <MBMUXIF_SystemInit+0x70>)
 802124a:	6018      	str	r0, [r3, #0]
  while (pMb_RefTable->SynchronizeCpusAtBoot == CPUS_BOOT_SYNC_PREVENT_CPU2_TO_START);
 802124c:	239b      	movs	r3, #155	@ 0x9b
 802124e:	005b      	lsls	r3, r3, #1
 8021250:	5ac3      	ldrh	r3, [r0, r3]
 8021252:	b29b      	uxth	r3, r3
 8021254:	4a16      	ldr	r2, [pc, #88]	@ (80212b0 <MBMUXIF_SystemInit+0x74>)
 8021256:	4293      	cmp	r3, r2
 8021258:	d0f8      	beq.n	802124c <MBMUXIF_SystemInit+0x10>
  MBMUX_Init(pMb_RefTable);
 802125a:	f7ff fecd 	bl	8020ff8 <MBMUX_Init>
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrSystemAckRcvCb);
 802125e:	4a15      	ldr	r2, [pc, #84]	@ (80212b4 <MBMUXIF_SystemInit+0x78>)
 8021260:	2101      	movs	r1, #1
 8021262:	2000      	movs	r0, #0
 8021264:	f7ff fe6c 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8021268:	2800      	cmp	r0, #0
 802126a:	da10      	bge.n	802128e <MBMUXIF_SystemInit+0x52>
  if (ret >= 0)
 802126c:	2800      	cmp	r0, #0
 802126e:	db0c      	blt.n	802128a <MBMUXIF_SystemInit+0x4e>
    while (pMb_RefTable->SynchronizeCpusAtBoot != CPUS_BOOT_SYNC_ALLOW_CPU2_TO_START);
 8021270:	4b0e      	ldr	r3, [pc, #56]	@ (80212ac <MBMUXIF_SystemInit+0x70>)
 8021272:	681a      	ldr	r2, [r3, #0]
 8021274:	239b      	movs	r3, #155	@ 0x9b
 8021276:	005b      	lsls	r3, r3, #1
 8021278:	5ad3      	ldrh	r3, [r2, r3]
 802127a:	b29b      	uxth	r3, r3
 802127c:	490e      	ldr	r1, [pc, #56]	@ (80212b8 <MBMUXIF_SystemInit+0x7c>)
 802127e:	428b      	cmp	r3, r1
 8021280:	d1f6      	bne.n	8021270 <MBMUXIF_SystemInit+0x34>
    pMb_RefTable->SynchronizeCpusAtBoot = CPUS_BOOT_SYNC_CPU2_INIT_COMPLETED;
 8021282:	239b      	movs	r3, #155	@ 0x9b
 8021284:	005b      	lsls	r3, r3, #1
 8021286:	490d      	ldr	r1, [pc, #52]	@ (80212bc <MBMUXIF_SystemInit+0x80>)
 8021288:	52d1      	strh	r1, [r2, r3]
}
 802128a:	b017      	add	sp, #92	@ 0x5c
 802128c:	bd00      	pop	{pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_ID, MBMUX_CMD_RESP, MBMUXIF_IsrSystemCmdRcvCb);
 802128e:	4a0c      	ldr	r2, [pc, #48]	@ (80212c0 <MBMUXIF_SystemInit+0x84>)
 8021290:	2100      	movs	r1, #0
 8021292:	2000      	movs	r0, #0
 8021294:	f7ff fe54 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8021298:	2800      	cmp	r0, #0
 802129a:	dbf6      	blt.n	802128a <MBMUXIF_SystemInit+0x4e>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbSystemCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskSystemCmdRcv);
 802129c:	4a09      	ldr	r2, [pc, #36]	@ (80212c4 <MBMUXIF_SystemInit+0x88>)
 802129e:	2100      	movs	r1, #0
 80212a0:	2001      	movs	r0, #1
 80212a2:	f004 fc9f 	bl	8025be4 <UTIL_SEQ_RegTask>
    ret = 0;
 80212a6:	2000      	movs	r0, #0
 80212a8:	e7e0      	b.n	802126c <MBMUXIF_SystemInit+0x30>
 80212aa:	46c0      	nop			@ (mov r8, r8)
 80212ac:	2000a164 	.word	0x2000a164
 80212b0:	0000ffff 	.word	0x0000ffff
 80212b4:	08021231 	.word	0x08021231
 80212b8:	00005555 	.word	0x00005555
 80212bc:	ffffaaaa 	.word	0xffffaaaa
 80212c0:	08021205 	.word	0x08021205
 80212c4:	080211cd 	.word	0x080211cd

080212c8 <MBMUXIF_GetCpusSynchroFlag>:
  return pMb_RefTable->SynchronizeCpusAtBoot;
 80212c8:	4b03      	ldr	r3, [pc, #12]	@ (80212d8 <MBMUXIF_GetCpusSynchroFlag+0x10>)
 80212ca:	681a      	ldr	r2, [r3, #0]
 80212cc:	239b      	movs	r3, #155	@ 0x9b
 80212ce:	005b      	lsls	r3, r3, #1
 80212d0:	5ad0      	ldrh	r0, [r2, r3]
 80212d2:	b280      	uxth	r0, r0
}
 80212d4:	4770      	bx	lr
 80212d6:	46c0      	nop			@ (mov r8, r8)
 80212d8:	2000a164 	.word	0x2000a164

080212dc <MBMUXIF_GetSystemFeatureNotifComPtr>:
{
 80212dc:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(SystemPrioFeat, MBMUX_NOTIF_ACK);
 80212de:	2101      	movs	r1, #1
 80212e0:	f7ff fe46 	bl	8020f70 <MBMUX_GetFeatureComPtr>
 80212e4:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 80212e6:	d001      	beq.n	80212ec <MBMUXIF_GetSystemFeatureNotifComPtr+0x10>
}
 80212e8:	0020      	movs	r0, r4
 80212ea:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 80212ec:	f7ff faa2 	bl	8020834 <Error_Handler>
  return com_param_ptr;
 80212f0:	e7fa      	b.n	80212e8 <MBMUXIF_GetSystemFeatureNotifComPtr+0xc>

080212f2 <MBMUXIF_SystemSendNotif_NoWait>:
{
 80212f2:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(SystemPrioFeat) != 0)
 80212f4:	f7ff fe58 	bl	8020fa8 <MBMUX_NotificationSnd>
 80212f8:	2800      	cmp	r0, #0
 80212fa:	d100      	bne.n	80212fe <MBMUXIF_SystemSendNotif_NoWait+0xc>
}
 80212fc:	bd10      	pop	{r4, pc}
    Error_Handler();
 80212fe:	f7ff fa99 	bl	8020834 <Error_Handler>
}
 8021302:	e7fb      	b.n	80212fc <MBMUXIF_SystemSendNotif_NoWait+0xa>

08021304 <MBMUXIF_TraceBufferInit>:
static UTIL_ADV_TRACE_Status_t MBMUXIF_TraceBufferInit(void (*cb)(void *))
{
  /* USER CODE BEGIN MBMUXIF_TraceBufferInit_1 */

  /* USER CODE END MBMUXIF_TraceBufferInit_1 */
  TraceUtilCpltCallback = cb;
 8021304:	4b01      	ldr	r3, [pc, #4]	@ (802130c <MBMUXIF_TraceBufferInit+0x8>)
 8021306:	6018      	str	r0, [r3, #0]
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN MBMUXIF_TraceBufferInit_Last */

  /* USER CODE END MBMUXIF_TraceBufferInit_Last */
}
 8021308:	2000      	movs	r0, #0
 802130a:	4770      	bx	lr
 802130c:	2000a168 	.word	0x2000a168

08021310 <MBMUXIF_TaskTraceAckRcv>:

  /* USER CODE END MBMUXIF_IsrTraceAckRcvCb_Last */
}

static void MBMUXIF_TaskTraceAckRcv(void)
{
 8021310:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskTraceAckRcv_1 */

  /* USER CODE END MBMUXIF_TaskTraceAckRcv_1 */
  TraceUtilCpltCallback(NULL);
 8021312:	4b02      	ldr	r3, [pc, #8]	@ (802131c <MBMUXIF_TaskTraceAckRcv+0xc>)
 8021314:	681b      	ldr	r3, [r3, #0]
 8021316:	2000      	movs	r0, #0
 8021318:	4798      	blx	r3
  /* USER CODE BEGIN MBMUXIF_TaskTraceAckRcv_Last */

  /* USER CODE END MBMUXIF_TaskTraceAckRcv_Last */
}
 802131a:	bd10      	pop	{r4, pc}
 802131c:	2000a168 	.word	0x2000a168

08021320 <MBMUXIF_IsrTraceAckRcvCb>:
{
 8021320:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbTraceAckRcv); /* not necessary */
 8021322:	2002      	movs	r0, #2
 8021324:	f004 fb6e 	bl	8025a04 <UTIL_SEQ_SetEvt>
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbTraceAckRcv), CFG_SEQ_Prio_0);
 8021328:	2100      	movs	r1, #0
 802132a:	2002      	movs	r0, #2
 802132c:	f004 fb56 	bl	80259dc <UTIL_SEQ_SetTask>
}
 8021330:	bd10      	pop	{r4, pc}
	...

08021334 <MBMUXIF_TraceInit>:
{
 8021334:	b510      	push	{r4, lr}
 8021336:	0004      	movs	r4, r0
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_TRACE_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrTraceAckRcvCb);
 8021338:	4a0b      	ldr	r2, [pc, #44]	@ (8021368 <MBMUXIF_TraceInit+0x34>)
 802133a:	2101      	movs	r1, #1
 802133c:	2006      	movs	r0, #6
 802133e:	f7ff fdff 	bl	8020f40 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8021342:	2800      	cmp	r0, #0
 8021344:	da00      	bge.n	8021348 <MBMUXIF_TraceInit+0x14>
}
 8021346:	bd10      	pop	{r4, pc}
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbTraceAckRcv), UTIL_SEQ_RFU, MBMUXIF_TaskTraceAckRcv);
 8021348:	4a08      	ldr	r2, [pc, #32]	@ (802136c <MBMUXIF_TraceInit+0x38>)
 802134a:	2100      	movs	r1, #0
 802134c:	2002      	movs	r0, #2
 802134e:	f004 fc49 	bl	8025be4 <UTIL_SEQ_RegTask>
    UTIL_ADV_TRACE_Init();
 8021352:	f004 f9a1 	bl	8025698 <UTIL_ADV_TRACE_Init>
    UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 8021356:	4806      	ldr	r0, [pc, #24]	@ (8021370 <MBMUXIF_TraceInit+0x3c>)
 8021358:	f004 f9b8 	bl	80256cc <UTIL_ADV_TRACE_RegisterTimeStampFunction>
    UTIL_ADV_TRACE_SetVerboseLevel(verboseLevel);
 802135c:	0020      	movs	r0, r4
 802135e:	f004 f9bb 	bl	80256d8 <UTIL_ADV_TRACE_SetVerboseLevel>
    ret = 0;
 8021362:	2000      	movs	r0, #0
 8021364:	e7ef      	b.n	8021346 <MBMUXIF_TraceInit+0x12>
 8021366:	46c0      	nop			@ (mov r8, r8)
 8021368:	08021321 	.word	0x08021321
 802136c:	08021311 	.word	0x08021311
 8021370:	08020abd 	.word	0x08020abd

08021374 <MBMUXIF_GetTraceFeatureNotifComPtr>:
{
 8021374:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_TRACE_ID, MBMUX_NOTIF_ACK);
 8021376:	2101      	movs	r1, #1
 8021378:	2006      	movs	r0, #6
 802137a:	f7ff fdf9 	bl	8020f70 <MBMUX_GetFeatureComPtr>
 802137e:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 8021380:	d001      	beq.n	8021386 <MBMUXIF_GetTraceFeatureNotifComPtr+0x12>
}
 8021382:	0020      	movs	r0, r4
 8021384:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 8021386:	f7ff fa55 	bl	8020834 <Error_Handler>
  return com_param_ptr;
 802138a:	e7fa      	b.n	8021382 <MBMUXIF_GetTraceFeatureNotifComPtr+0xe>

0802138c <MBMUXIF_TraceSendNotif_NoWait>:
{
 802138c:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(FEAT_INFO_TRACE_ID) != 0)
 802138e:	2006      	movs	r0, #6
 8021390:	f7ff fe0a 	bl	8020fa8 <MBMUX_NotificationSnd>
 8021394:	2800      	cmp	r0, #0
 8021396:	d100      	bne.n	802139a <MBMUXIF_TraceSendNotif_NoWait+0xe>
}
 8021398:	bd10      	pop	{r4, pc}
    Error_Handler();
 802139a:	f7ff fa4b 	bl	8020834 <Error_Handler>
}
 802139e:	e7fb      	b.n	8021398 <MBMUXIF_TraceSendNotif_NoWait+0xc>

080213a0 <MBMUXIF_TraceBufferSend>:
{
 80213a0:	b570      	push	{r4, r5, r6, lr}
 80213a2:	0006      	movs	r6, r0
 80213a4:	000d      	movs	r5, r1
  com_obj = MBMUXIF_GetTraceFeatureNotifComPtr();
 80213a6:	f7ff ffe5 	bl	8021374 <MBMUXIF_GetTraceFeatureNotifComPtr>
 80213aa:	1e04      	subs	r4, r0, #0
  if (com_obj != NULL)
 80213ac:	d00b      	beq.n	80213c6 <MBMUXIF_TraceBufferSend+0x26>
    pbuf_validated = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 80213ae:	8981      	ldrh	r1, [r0, #12]
 80213b0:	6900      	ldr	r0, [r0, #16]
 80213b2:	f7ff fe1c 	bl	8020fee <MBMUX_SEC_VerifySramBufferPtr>
    com_obj->MsgId = TRACE_SEND_MSG_ID;
 80213b6:	2300      	movs	r3, #0
 80213b8:	6023      	str	r3, [r4, #0]
    pbuf_validated[0] = (uint32_t) buf;
 80213ba:	6006      	str	r6, [r0, #0]
    pbuf_validated[1] = (uint32_t) bufSize;
 80213bc:	6045      	str	r5, [r0, #4]
    com_obj->ParamCnt = 2;
 80213be:	3302      	adds	r3, #2
 80213c0:	81e3      	strh	r3, [r4, #14]
    MBMUXIF_TraceSendNotif_NoWait();
 80213c2:	f7ff ffe3 	bl	802138c <MBMUXIF_TraceSendNotif_NoWait>
}
 80213c6:	2000      	movs	r0, #0
 80213c8:	bd70      	pop	{r4, r5, r6, pc}

080213ca <RadioRxError_mbwrapper>:

  /* USER CODE END RadioRxTimeout_mbwrapper_2 */
}

static void RadioRxError_mbwrapper(void)
{
 80213ca:	b510      	push	{r4, lr}
  /* USER CODE BEGIN RadioRxError_mbwrapper_1 */

  /* USER CODE END RadioRxError_mbwrapper_1 */
  MBMUX_ComParam_t *com_obj;

  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 80213cc:	f7ff fe8e 	bl	80210ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_RX_ERROR_CB_ID;
 80213d0:	2323      	movs	r3, #35	@ 0x23
 80213d2:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 80213d4:	2300      	movs	r3, #0
 80213d6:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 80213d8:	f7ff fe94 	bl	8021104 <MBMUXIF_RadioSendNotif>
  /* once event is received and semaphore released: */
  return;
  /* USER CODE BEGIN RadioRxError_mbwrapper_2 */

  /* USER CODE END RadioRxError_mbwrapper_2 */
}
 80213dc:	bd10      	pop	{r4, pc}

080213de <RadioRxTimeout_mbwrapper>:
{
 80213de:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 80213e0:	f7ff fe84 	bl	80210ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_RX_TIMEOUT_CB_ID;
 80213e4:	2322      	movs	r3, #34	@ 0x22
 80213e6:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 80213e8:	2300      	movs	r3, #0
 80213ea:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 80213ec:	f7ff fe8a 	bl	8021104 <MBMUXIF_RadioSendNotif>
}
 80213f0:	bd10      	pop	{r4, pc}

080213f2 <RadioTxTimeout_mbwrapper>:
{
 80213f2:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 80213f4:	f7ff fe7a 	bl	80210ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_TX_TIMEOUT_CB_ID;
 80213f8:	2320      	movs	r3, #32
 80213fa:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 80213fc:	2300      	movs	r3, #0
 80213fe:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8021400:	f7ff fe80 	bl	8021104 <MBMUXIF_RadioSendNotif>
}
 8021404:	bd10      	pop	{r4, pc}

08021406 <RadioTxDone_mbwrapper>:
{
 8021406:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8021408:	f7ff fe70 	bl	80210ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_TX_DONE_CB_ID;
 802140c:	231f      	movs	r3, #31
 802140e:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8021410:	2300      	movs	r3, #0
 8021412:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8021414:	f7ff fe76 	bl	8021104 <MBMUXIF_RadioSendNotif>
}
 8021418:	bd10      	pop	{r4, pc}
	...

0802141c <RadioRxDone_mbwrapper>:
{
 802141c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802141e:	46c6      	mov	lr, r8
 8021420:	b500      	push	{lr}
 8021422:	0005      	movs	r5, r0
 8021424:	000e      	movs	r6, r1
 8021426:	4690      	mov	r8, r2
 8021428:	001f      	movs	r7, r3
  if (payload != NULL)
 802142a:	2800      	cmp	r0, #0
 802142c:	d004      	beq.n	8021438 <RadioRxDone_mbwrapper+0x1c>
    UTIL_MEM_cpy_8(aRadioMbWrapRxBuffer, payload, size);
 802142e:	4810      	ldr	r0, [pc, #64]	@ (8021470 <RadioRxDone_mbwrapper+0x54>)
 8021430:	000a      	movs	r2, r1
 8021432:	0029      	movs	r1, r5
 8021434:	f004 fabe 	bl	80259b4 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8021438:	f7ff fe58 	bl	80210ec <MBMUXIF_GetRadioFeatureNotifComPtr>
 802143c:	0004      	movs	r4, r0
  com_obj->MsgId = RADIO_RX_DONE_CB_ID;
 802143e:	2321      	movs	r3, #33	@ 0x21
 8021440:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021442:	8981      	ldrh	r1, [r0, #12]
 8021444:	6900      	ldr	r0, [r0, #16]
 8021446:	f7ff fdd2 	bl	8020fee <MBMUX_SEC_VerifySramBufferPtr>
  if (payload == NULL)
 802144a:	2d00      	cmp	r5, #0
 802144c:	d00c      	beq.n	8021468 <RadioRxDone_mbwrapper+0x4c>
    com_buffer[i++] = (uint32_t) aRadioMbWrapRxBuffer;
 802144e:	4b08      	ldr	r3, [pc, #32]	@ (8021470 <RadioRxDone_mbwrapper+0x54>)
 8021450:	6003      	str	r3, [r0, #0]
  com_buffer[i++] = (uint32_t) size;
 8021452:	6046      	str	r6, [r0, #4]
  com_buffer[i++] = (uint32_t) rssi;
 8021454:	4643      	mov	r3, r8
 8021456:	6083      	str	r3, [r0, #8]
  com_buffer[i++] = (uint32_t) snr;
 8021458:	60c7      	str	r7, [r0, #12]
  com_obj->ParamCnt = i;
 802145a:	2304      	movs	r3, #4
 802145c:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_RadioSendNotif();
 802145e:	f7ff fe51 	bl	8021104 <MBMUXIF_RadioSendNotif>
}
 8021462:	bc80      	pop	{r7}
 8021464:	46b8      	mov	r8, r7
 8021466:	bdf0      	pop	{r4, r5, r6, r7, pc}
    com_buffer[i++] = (uint32_t)NULL;
 8021468:	2300      	movs	r3, #0
 802146a:	6003      	str	r3, [r0, #0]
 802146c:	e7f1      	b.n	8021452 <RadioRxDone_mbwrapper+0x36>
 802146e:	46c0      	nop			@ (mov r8, r8)
 8021470:	20009048 	.word	0x20009048

08021474 <Process_Radio_Cmd>:
{
 8021474:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021476:	46de      	mov	lr, fp
 8021478:	4657      	mov	r7, sl
 802147a:	464e      	mov	r6, r9
 802147c:	4645      	mov	r5, r8
 802147e:	b5e0      	push	{r5, r6, r7, lr}
 8021480:	b08f      	sub	sp, #60	@ 0x3c
 8021482:	0004      	movs	r4, r0
  APP_LOG(TS_ON, VLEVEL_H, ">CM0PLUS(Radio)\r\n");
 8021484:	4bdb      	ldr	r3, [pc, #876]	@ (80217f4 <Process_Radio_Cmd+0x380>)
 8021486:	2201      	movs	r2, #1
 8021488:	2100      	movs	r1, #0
 802148a:	2003      	movs	r0, #3
 802148c:	f004 f97a 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(ComObj->ParamBuf, ComObj->BufSize);
 8021490:	89a1      	ldrh	r1, [r4, #12]
 8021492:	6920      	ldr	r0, [r4, #16]
 8021494:	f7ff fdab 	bl	8020fee <MBMUX_SEC_VerifySramBufferPtr>
  switch (ComObj->MsgId)
 8021498:	6823      	ldr	r3, [r4, #0]
 802149a:	2b1e      	cmp	r3, #30
 802149c:	d814      	bhi.n	80214c8 <Process_Radio_Cmd+0x54>
 802149e:	009b      	lsls	r3, r3, #2
 80214a0:	4ad5      	ldr	r2, [pc, #852]	@ (80217f8 <Process_Radio_Cmd+0x384>)
 80214a2:	58d3      	ldr	r3, [r2, r3]
 80214a4:	469f      	mov	pc, r3
      radioevents_mbwrapper.TxDone = &RadioTxDone_mbwrapper;
 80214a6:	48d5      	ldr	r0, [pc, #852]	@ (80217fc <Process_Radio_Cmd+0x388>)
 80214a8:	4bd5      	ldr	r3, [pc, #852]	@ (8021800 <Process_Radio_Cmd+0x38c>)
 80214aa:	6003      	str	r3, [r0, #0]
      radioevents_mbwrapper.TxTimeout = &RadioTxTimeout_mbwrapper;
 80214ac:	4bd5      	ldr	r3, [pc, #852]	@ (8021804 <Process_Radio_Cmd+0x390>)
 80214ae:	6043      	str	r3, [r0, #4]
      radioevents_mbwrapper.RxDone = &RadioRxDone_mbwrapper;
 80214b0:	4bd5      	ldr	r3, [pc, #852]	@ (8021808 <Process_Radio_Cmd+0x394>)
 80214b2:	6083      	str	r3, [r0, #8]
      radioevents_mbwrapper.RxTimeout = &RadioRxTimeout_mbwrapper;
 80214b4:	4bd5      	ldr	r3, [pc, #852]	@ (802180c <Process_Radio_Cmd+0x398>)
 80214b6:	60c3      	str	r3, [r0, #12]
      radioevents_mbwrapper.RxError = &RadioRxError_mbwrapper;
 80214b8:	4bd5      	ldr	r3, [pc, #852]	@ (8021810 <Process_Radio_Cmd+0x39c>)
 80214ba:	6103      	str	r3, [r0, #16]
      Radio.Init(&radioevents_mbwrapper);
 80214bc:	4bd5      	ldr	r3, [pc, #852]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80214be:	681b      	ldr	r3, [r3, #0]
 80214c0:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80214c2:	2300      	movs	r3, #0
 80214c4:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80214c6:	6163      	str	r3, [r4, #20]
  APP_LOG(TS_ON, VLEVEL_H, "<CM0PLUS(Radio)\r\n");
 80214c8:	4bd3      	ldr	r3, [pc, #844]	@ (8021818 <Process_Radio_Cmd+0x3a4>)
 80214ca:	2201      	movs	r2, #1
 80214cc:	2100      	movs	r1, #0
 80214ce:	2003      	movs	r0, #3
 80214d0:	f004 f958 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_RADIO_ID);
 80214d4:	2007      	movs	r0, #7
 80214d6:	f7ff fd83 	bl	8020fe0 <MBMUX_ResponseSnd>
}
 80214da:	b00f      	add	sp, #60	@ 0x3c
 80214dc:	bcf0      	pop	{r4, r5, r6, r7}
 80214de:	46bb      	mov	fp, r7
 80214e0:	46b2      	mov	sl, r6
 80214e2:	46a9      	mov	r9, r5
 80214e4:	46a0      	mov	r8, r4
 80214e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      state = Radio.GetStatus();
 80214e8:	4bca      	ldr	r3, [pc, #808]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80214ea:	685b      	ldr	r3, [r3, #4]
 80214ec:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80214ee:	2300      	movs	r3, #0
 80214f0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) state; /* */
 80214f2:	6160      	str	r0, [r4, #20]
      break;
 80214f4:	e7e8      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetModem((RadioModems_t) com_buffer[0]);
 80214f6:	4bc7      	ldr	r3, [pc, #796]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80214f8:	689b      	ldr	r3, [r3, #8]
 80214fa:	7800      	ldrb	r0, [r0, #0]
 80214fc:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80214fe:	2300      	movs	r3, #0
 8021500:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8021502:	6163      	str	r3, [r4, #20]
      break;
 8021504:	e7e0      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetChannel((uint32_t) com_buffer[0]);
 8021506:	4bc3      	ldr	r3, [pc, #780]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021508:	68db      	ldr	r3, [r3, #12]
 802150a:	6800      	ldr	r0, [r0, #0]
 802150c:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802150e:	2300      	movs	r3, #0
 8021510:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8021512:	6163      	str	r3, [r4, #20]
      break;
 8021514:	e7d8      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.IsChannelFree(com_buffer[0], com_buffer[1], (int16_t) com_buffer[2], com_buffer[3]);
 8021516:	4bbf      	ldr	r3, [pc, #764]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021518:	691d      	ldr	r5, [r3, #16]
 802151a:	68c3      	ldr	r3, [r0, #12]
 802151c:	2108      	movs	r1, #8
 802151e:	5e42      	ldrsh	r2, [r0, r1]
 8021520:	6841      	ldr	r1, [r0, #4]
 8021522:	6800      	ldr	r0, [r0, #0]
 8021524:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021526:	2300      	movs	r3, #0
 8021528:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 802152a:	6160      	str	r0, [r4, #20]
      break;
 802152c:	e7cc      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.Random();
 802152e:	4bb9      	ldr	r3, [pc, #740]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021530:	695b      	ldr	r3, [r3, #20]
 8021532:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021534:	2300      	movs	r3, #0
 8021536:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8021538:	6160      	str	r0, [r4, #20]
      break;
 802153a:	e7c5      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetRxConfig((RadioModems_t) com_buffer[0],  com_buffer[1],
 802153c:	4bb5      	ldr	r3, [pc, #724]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 802153e:	699b      	ldr	r3, [r3, #24]
 8021540:	4698      	mov	r8, r3
                        com_buffer[4], (uint16_t) com_buffer[5],
 8021542:	6943      	ldr	r3, [r0, #20]
 8021544:	930a      	str	r3, [sp, #40]	@ 0x28
                        (uint16_t) com_buffer[6], (bool) com_buffer[7],
 8021546:	6982      	ldr	r2, [r0, #24]
 8021548:	920b      	str	r2, [sp, #44]	@ 0x2c
 802154a:	69c3      	ldr	r3, [r0, #28]
 802154c:	469b      	mov	fp, r3
                        (uint8_t) com_buffer[8],
 802154e:	6a01      	ldr	r1, [r0, #32]
 8021550:	910c      	str	r1, [sp, #48]	@ 0x30
                        (bool) com_buffer[9], (bool) com_buffer[10], (uint8_t) com_buffer[11],
 8021552:	6a46      	ldr	r6, [r0, #36]	@ 0x24
 8021554:	6a87      	ldr	r7, [r0, #40]	@ 0x28
 8021556:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 8021558:	930d      	str	r3, [sp, #52]	@ 0x34
                        (bool) com_buffer[12], (bool) com_buffer[13]);
 802155a:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 802155c:	6b42      	ldr	r2, [r0, #52]	@ 0x34
      Radio.SetRxConfig((RadioModems_t) com_buffer[0],  com_buffer[1],
 802155e:	7b01      	ldrb	r1, [r0, #12]
 8021560:	468a      	mov	sl, r1
 8021562:	6881      	ldr	r1, [r0, #8]
 8021564:	4689      	mov	r9, r1
 8021566:	6841      	ldr	r1, [r0, #4]
 8021568:	7805      	ldrb	r5, [r0, #0]
 802156a:	46ac      	mov	ip, r5
 802156c:	1e55      	subs	r5, r2, #1
 802156e:	41aa      	sbcs	r2, r5
 8021570:	9209      	str	r2, [sp, #36]	@ 0x24
 8021572:	1e5a      	subs	r2, r3, #1
 8021574:	4193      	sbcs	r3, r2
 8021576:	9308      	str	r3, [sp, #32]
 8021578:	466b      	mov	r3, sp
 802157a:	2234      	movs	r2, #52	@ 0x34
 802157c:	189b      	adds	r3, r3, r2
 802157e:	781b      	ldrb	r3, [r3, #0]
 8021580:	9307      	str	r3, [sp, #28]
 8021582:	1e7b      	subs	r3, r7, #1
 8021584:	419f      	sbcs	r7, r3
 8021586:	9706      	str	r7, [sp, #24]
 8021588:	1e73      	subs	r3, r6, #1
 802158a:	419e      	sbcs	r6, r3
 802158c:	9605      	str	r6, [sp, #20]
 802158e:	466b      	mov	r3, sp
 8021590:	3a04      	subs	r2, #4
 8021592:	189b      	adds	r3, r3, r2
 8021594:	781b      	ldrb	r3, [r3, #0]
 8021596:	9304      	str	r3, [sp, #16]
 8021598:	465d      	mov	r5, fp
 802159a:	1e6b      	subs	r3, r5, #1
 802159c:	419d      	sbcs	r5, r3
 802159e:	9503      	str	r5, [sp, #12]
 80215a0:	466b      	mov	r3, sp
 80215a2:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 80215a4:	9302      	str	r3, [sp, #8]
 80215a6:	466b      	mov	r3, sp
 80215a8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80215aa:	9301      	str	r3, [sp, #4]
 80215ac:	6903      	ldr	r3, [r0, #16]
 80215ae:	9300      	str	r3, [sp, #0]
 80215b0:	4653      	mov	r3, sl
 80215b2:	464a      	mov	r2, r9
 80215b4:	4660      	mov	r0, ip
 80215b6:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80215b8:	2300      	movs	r3, #0
 80215ba:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80215bc:	6163      	str	r3, [r4, #20]
      break;
 80215be:	e783      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetTxConfig((RadioModems_t) com_buffer[0], (int8_t) com_buffer[1],
 80215c0:	4b94      	ldr	r3, [pc, #592]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80215c2:	69db      	ldr	r3, [r3, #28]
 80215c4:	4698      	mov	r8, r3
                        (uint8_t) com_buffer[5], (uint16_t) com_buffer[6],
 80215c6:	6943      	ldr	r3, [r0, #20]
 80215c8:	930a      	str	r3, [sp, #40]	@ 0x28
 80215ca:	6982      	ldr	r2, [r0, #24]
 80215cc:	920b      	str	r2, [sp, #44]	@ 0x2c
                        (bool) com_buffer[7], (bool) com_buffer[8], (bool) com_buffer[9],
 80215ce:	69c5      	ldr	r5, [r0, #28]
 80215d0:	6a06      	ldr	r6, [r0, #32]
 80215d2:	6a47      	ldr	r7, [r0, #36]	@ 0x24
                        (uint8_t) com_buffer[10], (bool) com_buffer[11],  com_buffer[12]);
 80215d4:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80215d6:	6ac2      	ldr	r2, [r0, #44]	@ 0x2c
      Radio.SetTxConfig((RadioModems_t) com_buffer[0], (int8_t) com_buffer[1],
 80215d8:	68c1      	ldr	r1, [r0, #12]
 80215da:	468a      	mov	sl, r1
 80215dc:	6881      	ldr	r1, [r0, #8]
 80215de:	4689      	mov	r9, r1
 80215e0:	2104      	movs	r1, #4
 80215e2:	5641      	ldrsb	r1, [r0, r1]
 80215e4:	910c      	str	r1, [sp, #48]	@ 0x30
 80215e6:	7801      	ldrb	r1, [r0, #0]
 80215e8:	468c      	mov	ip, r1
 80215ea:	6b01      	ldr	r1, [r0, #48]	@ 0x30
 80215ec:	9108      	str	r1, [sp, #32]
 80215ee:	1e51      	subs	r1, r2, #1
 80215f0:	418a      	sbcs	r2, r1
 80215f2:	9207      	str	r2, [sp, #28]
 80215f4:	b2db      	uxtb	r3, r3
 80215f6:	9306      	str	r3, [sp, #24]
 80215f8:	1e7b      	subs	r3, r7, #1
 80215fa:	419f      	sbcs	r7, r3
 80215fc:	9705      	str	r7, [sp, #20]
 80215fe:	1e73      	subs	r3, r6, #1
 8021600:	419e      	sbcs	r6, r3
 8021602:	9604      	str	r6, [sp, #16]
 8021604:	1e6b      	subs	r3, r5, #1
 8021606:	419d      	sbcs	r5, r3
 8021608:	9503      	str	r5, [sp, #12]
 802160a:	466b      	mov	r3, sp
 802160c:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 802160e:	9302      	str	r3, [sp, #8]
 8021610:	466b      	mov	r3, sp
 8021612:	2228      	movs	r2, #40	@ 0x28
 8021614:	189b      	adds	r3, r3, r2
 8021616:	781b      	ldrb	r3, [r3, #0]
 8021618:	9301      	str	r3, [sp, #4]
 802161a:	6903      	ldr	r3, [r0, #16]
 802161c:	9300      	str	r3, [sp, #0]
 802161e:	4653      	mov	r3, sl
 8021620:	464a      	mov	r2, r9
 8021622:	990c      	ldr	r1, [sp, #48]	@ 0x30
 8021624:	4660      	mov	r0, ip
 8021626:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021628:	2300      	movs	r3, #0
 802162a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 802162c:	6163      	str	r3, [r4, #20]
      break;
 802162e:	e74b      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.CheckRfFrequency(com_buffer[0]);
 8021630:	4b78      	ldr	r3, [pc, #480]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021632:	6a1b      	ldr	r3, [r3, #32]
 8021634:	6800      	ldr	r0, [r0, #0]
 8021636:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021638:	2300      	movs	r3, #0
 802163a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 802163c:	6160      	str	r0, [r4, #20]
      break;
 802163e:	e743      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.TimeOnAir((RadioModems_t) com_buffer[0], (uint32_t) com_buffer[1],
 8021640:	4b74      	ldr	r3, [pc, #464]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021642:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8021644:	4698      	mov	r8, r3
                                 (uint16_t) com_buffer[4], (bool) com_buffer[5],
 8021646:	6905      	ldr	r5, [r0, #16]
 8021648:	6946      	ldr	r6, [r0, #20]
                                 (uint8_t) com_buffer[6], (bool) com_buffer[7]);
 802164a:	6987      	ldr	r7, [r0, #24]
 802164c:	69c3      	ldr	r3, [r0, #28]
 802164e:	469c      	mov	ip, r3
      ret_uint = Radio.TimeOnAir((RadioModems_t) com_buffer[0], (uint32_t) com_buffer[1],
 8021650:	7b03      	ldrb	r3, [r0, #12]
 8021652:	4699      	mov	r9, r3
 8021654:	6883      	ldr	r3, [r0, #8]
 8021656:	469a      	mov	sl, r3
 8021658:	6841      	ldr	r1, [r0, #4]
 802165a:	7800      	ldrb	r0, [r0, #0]
 802165c:	4663      	mov	r3, ip
 802165e:	1e5a      	subs	r2, r3, #1
 8021660:	4193      	sbcs	r3, r2
 8021662:	9303      	str	r3, [sp, #12]
 8021664:	b2ff      	uxtb	r7, r7
 8021666:	9702      	str	r7, [sp, #8]
 8021668:	1e77      	subs	r7, r6, #1
 802166a:	41be      	sbcs	r6, r7
 802166c:	9601      	str	r6, [sp, #4]
 802166e:	b2ad      	uxth	r5, r5
 8021670:	9500      	str	r5, [sp, #0]
 8021672:	464b      	mov	r3, r9
 8021674:	4652      	mov	r2, sl
 8021676:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021678:	2300      	movs	r3, #0
 802167a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 802167c:	6160      	str	r0, [r4, #20]
      break;
 802167e:	e723      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_status = Radio.Send((uint8_t *) com_buffer[0], (uint8_t) com_buffer[1]);
 8021680:	4b64      	ldr	r3, [pc, #400]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021682:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8021684:	6802      	ldr	r2, [r0, #0]
 8021686:	7901      	ldrb	r1, [r0, #4]
 8021688:	0010      	movs	r0, r2
 802168a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802168c:	2300      	movs	r3, #0
 802168e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_status; /* */
 8021690:	6160      	str	r0, [r4, #20]
      break;
 8021692:	e719      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.Sleep();
 8021694:	4b5f      	ldr	r3, [pc, #380]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021696:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8021698:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802169a:	2300      	movs	r3, #0
 802169c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 802169e:	6163      	str	r3, [r4, #20]
      break;
 80216a0:	e712      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.Standby();
 80216a2:	4b5c      	ldr	r3, [pc, #368]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80216a4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80216a6:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80216a8:	2300      	movs	r3, #0
 80216aa:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80216ac:	6163      	str	r3, [r4, #20]
      break;
 80216ae:	e70b      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.Rx(com_buffer[0]);
 80216b0:	4b58      	ldr	r3, [pc, #352]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80216b2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80216b4:	6800      	ldr	r0, [r0, #0]
 80216b6:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80216b8:	2300      	movs	r3, #0
 80216ba:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80216bc:	6163      	str	r3, [r4, #20]
      break;
 80216be:	e703      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.StartCad();
 80216c0:	4b54      	ldr	r3, [pc, #336]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80216c2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80216c4:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80216c6:	2300      	movs	r3, #0
 80216c8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80216ca:	6163      	str	r3, [r4, #20]
      break;
 80216cc:	e6fc      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetTxContinuousWave(com_buffer[0], (int8_t) com_buffer[1], (uint16_t) com_buffer[2]);
 80216ce:	4b51      	ldr	r3, [pc, #324]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80216d0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80216d2:	8902      	ldrh	r2, [r0, #8]
 80216d4:	2104      	movs	r1, #4
 80216d6:	5641      	ldrsb	r1, [r0, r1]
 80216d8:	6800      	ldr	r0, [r0, #0]
 80216da:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80216dc:	2300      	movs	r3, #0
 80216de:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80216e0:	6163      	str	r3, [r4, #20]
      break;
 80216e2:	e6f1      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_int =  Radio.Rssi((RadioModems_t) com_buffer[0]);
 80216e4:	4b4b      	ldr	r3, [pc, #300]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80216e6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80216e8:	7800      	ldrb	r0, [r0, #0]
 80216ea:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80216ec:	2300      	movs	r3, #0
 80216ee:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_int; /* */
 80216f0:	6160      	str	r0, [r4, #20]
      break;
 80216f2:	e6e9      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.Write((uint16_t) com_buffer[0], (uint8_t) com_buffer[1]);
 80216f4:	4b47      	ldr	r3, [pc, #284]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80216f6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80216f8:	7901      	ldrb	r1, [r0, #4]
 80216fa:	8800      	ldrh	r0, [r0, #0]
 80216fc:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80216fe:	2300      	movs	r3, #0
 8021700:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8021702:	6163      	str	r3, [r4, #20]
      break;
 8021704:	e6e0      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.Read((uint16_t) com_buffer[0]);
 8021706:	4b43      	ldr	r3, [pc, #268]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021708:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 802170a:	8800      	ldrh	r0, [r0, #0]
 802170c:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802170e:	2300      	movs	r3, #0
 8021710:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8021712:	6160      	str	r0, [r4, #20]
      break;
 8021714:	e6d8      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.WriteRegisters((uint16_t) com_buffer[0], (uint8_t *) com_buffer[1], (uint8_t) com_buffer[2]);
 8021716:	4b3f      	ldr	r3, [pc, #252]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021718:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802171a:	6841      	ldr	r1, [r0, #4]
 802171c:	7a02      	ldrb	r2, [r0, #8]
 802171e:	8800      	ldrh	r0, [r0, #0]
 8021720:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021722:	2300      	movs	r3, #0
 8021724:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8021726:	6163      	str	r3, [r4, #20]
      break;
 8021728:	e6ce      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.ReadRegisters((uint16_t) com_buffer[0], (uint8_t *) com_buffer[1], (uint8_t) com_buffer[2]);
 802172a:	4b3a      	ldr	r3, [pc, #232]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 802172c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 802172e:	6841      	ldr	r1, [r0, #4]
 8021730:	7a02      	ldrb	r2, [r0, #8]
 8021732:	8800      	ldrh	r0, [r0, #0]
 8021734:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021736:	2300      	movs	r3, #0
 8021738:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 802173a:	6163      	str	r3, [r4, #20]
      break;
 802173c:	e6c4      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetMaxPayloadLength((RadioModems_t) com_buffer[0], (uint8_t) com_buffer[1]);
 802173e:	4b35      	ldr	r3, [pc, #212]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021740:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8021742:	7901      	ldrb	r1, [r0, #4]
 8021744:	7800      	ldrb	r0, [r0, #0]
 8021746:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8021748:	2300      	movs	r3, #0
 802174a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 802174c:	6163      	str	r3, [r4, #20]
      break;
 802174e:	e6bb      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetPublicNetwork((bool) com_buffer[0]);
 8021750:	4b30      	ldr	r3, [pc, #192]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021752:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8021754:	6800      	ldr	r0, [r0, #0]
 8021756:	1e42      	subs	r2, r0, #1
 8021758:	4190      	sbcs	r0, r2
 802175a:	b2c0      	uxtb	r0, r0
 802175c:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802175e:	2300      	movs	r3, #0
 8021760:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8021762:	6163      	str	r3, [r4, #20]
      break;
 8021764:	e6b0      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.GetWakeupTime();
 8021766:	4b2b      	ldr	r3, [pc, #172]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021768:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 802176a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802176c:	2300      	movs	r3, #0
 802176e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8021770:	6160      	str	r0, [r4, #20]
      break;
 8021772:	e6a9      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.IrqProcess();
 8021774:	4b27      	ldr	r3, [pc, #156]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021776:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021778:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802177a:	2300      	movs	r3, #0
 802177c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 802177e:	6163      	str	r3, [r4, #20]
      break;
 8021780:	e6a2      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.RxBoosted(com_buffer[0]);
 8021782:	4b24      	ldr	r3, [pc, #144]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021784:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021786:	6800      	ldr	r0, [r0, #0]
 8021788:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802178a:	2300      	movs	r3, #0
 802178c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 802178e:	6163      	str	r3, [r4, #20]
      break;
 8021790:	e69a      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.SetRxDutyCycle(com_buffer[0], com_buffer[1]);
 8021792:	4b20      	ldr	r3, [pc, #128]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 8021794:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8021796:	6841      	ldr	r1, [r0, #4]
 8021798:	6800      	ldr	r0, [r0, #0]
 802179a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802179c:	2300      	movs	r3, #0
 802179e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80217a0:	6163      	str	r3, [r4, #20]
      break;
 80217a2:	e691      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.TxCw((int8_t)com_buffer[0]);
 80217a4:	4b1b      	ldr	r3, [pc, #108]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80217a6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80217a8:	7800      	ldrb	r0, [r0, #0]
 80217aa:	b240      	sxtb	r0, r0
 80217ac:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80217ae:	2300      	movs	r3, #0
 80217b0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80217b2:	6163      	str	r3, [r4, #20]
      break;
 80217b4:	e688      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      Radio.TxPrbs();
 80217b6:	4b17      	ldr	r3, [pc, #92]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80217b8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80217ba:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80217bc:	2300      	movs	r3, #0
 80217be:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80217c0:	6163      	str	r3, [r4, #20]
      break;
 80217c2:	e681      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.RadioSetRxGenericConfig((GenericModems_t) com_buffer[0], (RxConfigGeneric_t *)com_buffer[1], com_buffer[2], com_buffer[3]);
 80217c4:	4b13      	ldr	r3, [pc, #76]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80217c6:	6f5d      	ldr	r5, [r3, #116]	@ 0x74
 80217c8:	6841      	ldr	r1, [r0, #4]
 80217ca:	68c3      	ldr	r3, [r0, #12]
 80217cc:	6882      	ldr	r2, [r0, #8]
 80217ce:	7800      	ldrb	r0, [r0, #0]
 80217d0:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80217d2:	2300      	movs	r3, #0
 80217d4:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 80217d6:	6160      	str	r0, [r4, #20]
      break;
 80217d8:	e676      	b.n	80214c8 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.RadioSetTxGenericConfig((GenericModems_t) com_buffer[0], (TxConfigGeneric_t *)com_buffer[1], (int8_t) com_buffer[2], (uint32_t) com_buffer[3]);
 80217da:	4b0e      	ldr	r3, [pc, #56]	@ (8021814 <Process_Radio_Cmd+0x3a0>)
 80217dc:	6f9d      	ldr	r5, [r3, #120]	@ 0x78
 80217de:	6841      	ldr	r1, [r0, #4]
 80217e0:	68c3      	ldr	r3, [r0, #12]
 80217e2:	2208      	movs	r2, #8
 80217e4:	5682      	ldrsb	r2, [r0, r2]
 80217e6:	7800      	ldrb	r0, [r0, #0]
 80217e8:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80217ea:	2300      	movs	r3, #0
 80217ec:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 80217ee:	6160      	str	r0, [r4, #20]
      break;
 80217f0:	e66a      	b.n	80214c8 <Process_Radio_Cmd+0x54>
 80217f2:	46c0      	nop			@ (mov r8, r8)
 80217f4:	08026458 	.word	0x08026458
 80217f8:	08026480 	.word	0x08026480
 80217fc:	2000a16c 	.word	0x2000a16c
 8021800:	08021407 	.word	0x08021407
 8021804:	080213f3 	.word	0x080213f3
 8021808:	0802141d 	.word	0x0802141d
 802180c:	080213df 	.word	0x080213df
 8021810:	080213cb 	.word	0x080213cb
 8021814:	080266c8 	.word	0x080266c8
 8021818:	0802646c 	.word	0x0802646c

0802181c <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 802181c:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 802181e:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8021820:	3304      	adds	r3, #4

08021822 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8021822:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8021824:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 8021826:	d3f9      	bcc.n	802181c <CopyDataInit>
  bx lr
 8021828:	4770      	bx	lr

0802182a <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 802182a:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 802182c:	3004      	adds	r0, #4

0802182e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 802182e:	4288      	cmp	r0, r1
  bcc FillZerobss
 8021830:	d3fb      	bcc.n	802182a <FillZerobss>
  bx lr
 8021832:	4770      	bx	lr

08021834 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8021834:	4811      	ldr	r0, [pc, #68]	@ (802187c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8021836:	4685      	mov	sp, r0

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 8021838:	4811      	ldr	r0, [pc, #68]	@ (8021880 <LoopForever+0x6>)
 802183a:	4912      	ldr	r1, [pc, #72]	@ (8021884 <LoopForever+0xa>)
 802183c:	2300      	movs	r3, #0
 802183e:	f7ff fff6 	bl	802182e <LoopFillZerobss>

/* Zero fill the MB_MEM2 segments. */
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 8021842:	4811      	ldr	r0, [pc, #68]	@ (8021888 <LoopForever+0xe>)
 8021844:	4911      	ldr	r1, [pc, #68]	@ (802188c <LoopForever+0x12>)
 8021846:	2300      	movs	r3, #0
 8021848:	f7ff fff1 	bl	802182e <LoopFillZerobss>

/* Zero fill the MB_MEM2 segments. */
  INIT_BSS _sMB_MEM3, _eMB_MEM3
 802184c:	4810      	ldr	r0, [pc, #64]	@ (8021890 <LoopForever+0x16>)
 802184e:	4911      	ldr	r1, [pc, #68]	@ (8021894 <LoopForever+0x1a>)
 8021850:	2300      	movs	r3, #0
 8021852:	f7ff ffec 	bl	802182e <LoopFillZerobss>

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 8021856:	4810      	ldr	r0, [pc, #64]	@ (8021898 <LoopForever+0x1e>)
 8021858:	4910      	ldr	r1, [pc, #64]	@ (802189c <LoopForever+0x22>)
 802185a:	4a11      	ldr	r2, [pc, #68]	@ (80218a0 <LoopForever+0x26>)
 802185c:	2300      	movs	r3, #0
 802185e:	f7ff ffe0 	bl	8021822 <LoopCopyDataInit>

/* Copy the MB_MEM2 segment initializers from flash to SRAM */
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 8021862:	4809      	ldr	r0, [pc, #36]	@ (8021888 <LoopForever+0xe>)
 8021864:	4909      	ldr	r1, [pc, #36]	@ (802188c <LoopForever+0x12>)
 8021866:	4a0f      	ldr	r2, [pc, #60]	@ (80218a4 <LoopForever+0x2a>)
 8021868:	2300      	movs	r3, #0
 802186a:	f7ff ffda 	bl	8021822 <LoopCopyDataInit>

/* Call the clock system initialization function.*/
  bl  SystemInit
 802186e:	f000 f8db 	bl	8021a28 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8021872:	f004 fd17 	bl	80262a4 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8021876:	f7fe ffd3 	bl	8020820 <main>

0802187a <LoopForever>:

LoopForever:
    b LoopForever
 802187a:	e7fe      	b.n	802187a <LoopForever>
  ldr   r0, =_estack
 802187c:	20010000 	.word	0x20010000
  INIT_BSS _sbss, _ebss
 8021880:	2000a018 	.word	0x2000a018
 8021884:	2000a478 	.word	0x2000a478
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 8021888:	20009000 	.word	0x20009000
 802188c:	20009048 	.word	0x20009048
  INIT_BSS _sMB_MEM3, _eMB_MEM3
 8021890:	20009048 	.word	0x20009048
 8021894:	20009348 	.word	0x20009348
  INIT_DATA _sdata, _edata, _sidata
 8021898:	2000a000 	.word	0x2000a000
 802189c:	2000a018 	.word	0x2000a018
 80218a0:	08026908 	.word	0x08026908
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 80218a4:	08026920 	.word	0x08026920

080218a8 <ADC_COMP_DAC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80218a8:	e7fe      	b.n	80218a8 <ADC_COMP_DAC_IRQHandler>

080218aa <MX_SubGHz_Phy_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_SubGHz_Phy_Init(void)
{
 80218aa:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MX_SubGHz_Phy_Init_1 */

  /* USER CODE END MX_SubGHz_Phy_Init_1 */
  SystemApp_Init();
 80218ac:	f7ff f8ec 	bl	8020a88 <SystemApp_Init>

  /* USER CODE END MX_SubGHz_Phy_Init_1_1 */
  /* USER CODE BEGIN MX_SubGHz_Phy_Init_2 */

  /* USER CODE END MX_SubGHz_Phy_Init_2 */
}
 80218b0:	bd10      	pop	{r4, pc}

080218b2 <MX_SubGHz_Phy_Process>:

void MX_SubGHz_Phy_Process(void)
{
 80218b2:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MX_SubGHz_Phy_Process_1 */

  /* USER CODE END MX_SubGHz_Phy_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 80218b4:	2001      	movs	r0, #1
 80218b6:	4240      	negs	r0, r0
 80218b8:	f004 f8d6 	bl	8025a68 <UTIL_SEQ_Run>
  /* USER CODE BEGIN MX_SubGHz_Phy_Process_2 */

  /* USER CODE END MX_SubGHz_Phy_Process_2 */
}
 80218bc:	bd10      	pop	{r4, pc}

080218be <RBI_Init>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t RBI_Init(void)
{
 80218be:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_Init();
 80218c0:	f000 f816 	bl	80218f0 <BSP_RADIO_Init>
  /* USER CODE BEGIN RBI_Init_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_Init_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 80218c4:	bd10      	pop	{r4, pc}

080218c6 <RBI_ConfigRFSwitch>:
  return retcode;
#endif  /* USE_BSP_DRIVER */
}

int32_t RBI_ConfigRFSwitch(RBI_Switch_TypeDef Config)
{
 80218c6:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 80218c8:	f000 f850 	bl	802196c <BSP_RADIO_ConfigRFSwitch>
  /* USER CODE BEGIN RBI_ConfigRFSwitch_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_ConfigRFSwitch_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 80218cc:	bd10      	pop	{r4, pc}

080218ce <RBI_GetTxConfig>:

int32_t RBI_GetTxConfig(void)
{
 80218ce:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_GetTxConfig();
 80218d0:	f000 f89e 	bl	8021a10 <BSP_RADIO_GetTxConfig>
  /* USER CODE BEGIN RBI_GetTxConfig_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_GetTxConfig_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 80218d4:	bd10      	pop	{r4, pc}

080218d6 <RBI_IsTCXO>:

int32_t RBI_IsTCXO(void)
{
 80218d6:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_IsTCXO();
 80218d8:	f000 f89c 	bl	8021a14 <BSP_RADIO_IsTCXO>
  /* USER CODE BEGIN RBI_IsTCXO_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_IsTCXO_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 80218dc:	bd10      	pop	{r4, pc}

080218de <RBI_IsDCDC>:

int32_t RBI_IsDCDC(void)
{
 80218de:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_IsDCDC();
 80218e0:	f000 f89a 	bl	8021a18 <BSP_RADIO_IsDCDC>
  /* USER CODE BEGIN RBI_IsDCDC_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_IsDCDC_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 80218e4:	bd10      	pop	{r4, pc}

080218e6 <RBI_GetRFOMaxPowerConfig>:

int32_t RBI_GetRFOMaxPowerConfig(RBI_RFOMaxPowerConfig_TypeDef Config)
{
 80218e6:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_GetRFOMaxPowerConfig((BSP_RADIO_RFOMaxPowerConfig_TypeDef) Config);
 80218e8:	f000 f898 	bl	8021a1c <BSP_RADIO_GetRFOMaxPowerConfig>
    ret = 22; /*dBm*/
  }
  /* USER CODE END RBI_GetRFOMaxPowerConfig_2 */
  return ret;
#endif  /* USE_BSP_DRIVER  */
}
 80218ec:	bd10      	pop	{r4, pc}
	...

080218f0 <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 80218f0:	b510      	push	{r4, lr}
 80218f2:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 80218f4:	2214      	movs	r2, #20
 80218f6:	2100      	movs	r1, #0
 80218f8:	a801      	add	r0, sp, #4
 80218fa:	f004 fccb 	bl	8026294 <memset>
  SET_BIT(RCC->C2AHB2ENR, Periphs);
 80218fe:	21b0      	movs	r1, #176	@ 0xb0
 8021900:	05c9      	lsls	r1, r1, #23
 8021902:	22a6      	movs	r2, #166	@ 0xa6
 8021904:	0052      	lsls	r2, r2, #1
 8021906:	5888      	ldr	r0, [r1, r2]
 8021908:	2304      	movs	r3, #4
 802190a:	4318      	orrs	r0, r3
 802190c:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB2ENR, Periphs);
 802190e:	588a      	ldr	r2, [r1, r2]
 8021910:	4013      	ands	r3, r2
 8021912:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 8021914:	9b00      	ldr	r3, [sp, #0]
  
  /* Enable the Radio Switch Clock */
  RF_SW_CTRL3_GPIO_CLK_ENABLE();
  
  /* Configure the Radio Switch pin */
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
 8021916:	2310      	movs	r3, #16
 8021918:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 802191a:	3b0f      	subs	r3, #15
 802191c:	9302      	str	r3, [sp, #8]
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802191e:	3302      	adds	r3, #2
 8021920:	9304      	str	r3, [sp, #16]
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 8021922:	4c11      	ldr	r4, [pc, #68]	@ (8021968 <BSP_RADIO_Init+0x78>)
 8021924:	a901      	add	r1, sp, #4
 8021926:	0020      	movs	r0, r4
 8021928:	f000 fa76 	bl	8021e18 <HAL_GPIO_Init>
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802192c:	2320      	movs	r3, #32
 802192e:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 8021930:	a901      	add	r1, sp, #4
 8021932:	0020      	movs	r0, r4
 8021934:	f000 fa70 	bl	8021e18 <HAL_GPIO_Init>
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 8021938:	2308      	movs	r3, #8
 802193a:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802193c:	a901      	add	r1, sp, #4
 802193e:	0020      	movs	r0, r4
 8021940:	f000 fa6a 	bl	8021e18 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 8021944:	2200      	movs	r2, #0
 8021946:	2120      	movs	r1, #32
 8021948:	0020      	movs	r0, r4
 802194a:	f000 fb19 	bl	8021f80 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802194e:	2200      	movs	r2, #0
 8021950:	2110      	movs	r1, #16
 8021952:	0020      	movs	r0, r4
 8021954:	f000 fb14 	bl	8021f80 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 8021958:	2200      	movs	r2, #0
 802195a:	2108      	movs	r1, #8
 802195c:	0020      	movs	r0, r4
 802195e:	f000 fb0f 	bl	8021f80 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 8021962:	2000      	movs	r0, #0
 8021964:	b006      	add	sp, #24
 8021966:	bd10      	pop	{r4, pc}
 8021968:	48000800 	.word	0x48000800

0802196c <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 802196c:	b510      	push	{r4, lr}
  switch (Config)
 802196e:	2802      	cmp	r0, #2
 8021970:	d03a      	beq.n	80219e8 <BSP_RADIO_ConfigRFSwitch+0x7c>
 8021972:	d814      	bhi.n	802199e <BSP_RADIO_ConfigRFSwitch+0x32>
 8021974:	2800      	cmp	r0, #0
 8021976:	d025      	beq.n	80219c4 <BSP_RADIO_ConfigRFSwitch+0x58>
 8021978:	2801      	cmp	r0, #1
 802197a:	d133      	bne.n	80219e4 <BSP_RADIO_ConfigRFSwitch+0x78>
      break;      
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802197c:	4c23      	ldr	r4, [pc, #140]	@ (8021a0c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 802197e:	2201      	movs	r2, #1
 8021980:	2108      	movs	r1, #8
 8021982:	0020      	movs	r0, r4
 8021984:	f000 fafc 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 8021988:	2201      	movs	r2, #1
 802198a:	2110      	movs	r1, #16
 802198c:	0020      	movs	r0, r4
 802198e:	f000 faf7 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 8021992:	2200      	movs	r2, #0
 8021994:	2120      	movs	r1, #32
 8021996:	0020      	movs	r0, r4
 8021998:	f000 faf2 	bl	8021f80 <HAL_GPIO_WritePin>
      break;
 802199c:	e022      	b.n	80219e4 <BSP_RADIO_ConfigRFSwitch+0x78>
  switch (Config)
 802199e:	2803      	cmp	r0, #3
 80219a0:	d120      	bne.n	80219e4 <BSP_RADIO_ConfigRFSwitch+0x78>
      break;
    }
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 80219a2:	4c1a      	ldr	r4, [pc, #104]	@ (8021a0c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 80219a4:	2201      	movs	r2, #1
 80219a6:	2108      	movs	r1, #8
 80219a8:	0020      	movs	r0, r4
 80219aa:	f000 fae9 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 80219ae:	2200      	movs	r2, #0
 80219b0:	2110      	movs	r1, #16
 80219b2:	0020      	movs	r0, r4
 80219b4:	f000 fae4 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 80219b8:	2201      	movs	r2, #1
 80219ba:	2120      	movs	r1, #32
 80219bc:	0020      	movs	r0, r4
 80219be:	f000 fadf 	bl	8021f80 <HAL_GPIO_WritePin>
      break;
 80219c2:	e00f      	b.n	80219e4 <BSP_RADIO_ConfigRFSwitch+0x78>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 80219c4:	4c11      	ldr	r4, [pc, #68]	@ (8021a0c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 80219c6:	2200      	movs	r2, #0
 80219c8:	2108      	movs	r1, #8
 80219ca:	0020      	movs	r0, r4
 80219cc:	f000 fad8 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 80219d0:	2200      	movs	r2, #0
 80219d2:	2110      	movs	r1, #16
 80219d4:	0020      	movs	r0, r4
 80219d6:	f000 fad3 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET);
 80219da:	2200      	movs	r2, #0
 80219dc:	2120      	movs	r1, #32
 80219de:	0020      	movs	r0, r4
 80219e0:	f000 face 	bl	8021f80 <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 80219e4:	2000      	movs	r0, #0
 80219e6:	bd10      	pop	{r4, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 80219e8:	4c08      	ldr	r4, [pc, #32]	@ (8021a0c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 80219ea:	2201      	movs	r2, #1
 80219ec:	2108      	movs	r1, #8
 80219ee:	0020      	movs	r0, r4
 80219f0:	f000 fac6 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 80219f4:	2201      	movs	r2, #1
 80219f6:	2110      	movs	r1, #16
 80219f8:	0020      	movs	r0, r4
 80219fa:	f000 fac1 	bl	8021f80 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 80219fe:	2201      	movs	r2, #1
 8021a00:	2120      	movs	r1, #32
 8021a02:	0020      	movs	r0, r4
 8021a04:	f000 fabc 	bl	8021f80 <HAL_GPIO_WritePin>
      break;
 8021a08:	e7ec      	b.n	80219e4 <BSP_RADIO_ConfigRFSwitch+0x78>
 8021a0a:	46c0      	nop			@ (mov r8, r8)
 8021a0c:	48000800 	.word	0x48000800

08021a10 <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 8021a10:	2000      	movs	r0, #0
 8021a12:	4770      	bx	lr

08021a14 <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 8021a14:	2001      	movs	r0, #1
 8021a16:	4770      	bx	lr

08021a18 <BSP_RADIO_IsDCDC>:
  *  RADIO_CONF_DCDC_SUPPORTED  
  */
int32_t BSP_RADIO_IsDCDC(void)
{
  return RADIO_CONF_DCDC_SUPPORTED;
}
 8021a18:	2001      	movs	r0, #1
 8021a1a:	4770      	bx	lr

08021a1c <BSP_RADIO_GetRFOMaxPowerConfig>:
  */
int32_t BSP_RADIO_GetRFOMaxPowerConfig(BSP_RADIO_RFOMaxPowerConfig_TypeDef Config)
{
  int32_t ret;

  if(Config == RADIO_RFO_LP_MAXPOWER)
 8021a1c:	2800      	cmp	r0, #0
 8021a1e:	d101      	bne.n	8021a24 <BSP_RADIO_GetRFOMaxPowerConfig+0x8>
  {
    ret = RADIO_CONF_RFO_LP_MAX_15_dBm;
 8021a20:	300f      	adds	r0, #15
  {
    ret = RADIO_CONF_RFO_HP_MAX_22_dBm;
  }

  return ret;
}
 8021a22:	4770      	bx	lr
    ret = RADIO_CONF_RFO_HP_MAX_22_dBm;
 8021a24:	2016      	movs	r0, #22
  return ret;
 8021a26:	e7fc      	b.n	8021a22 <BSP_RADIO_GetRFOMaxPowerConfig+0x6>

08021a28 <SystemInit>:

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 8021a28:	4770      	bx	lr
	...

08021a2c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8021a2c:	b570      	push	{r4, r5, r6, lr}
 8021a2e:	0004      	movs	r4, r0
  HAL_StatusTypeDef  status = HAL_OK;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 8021a30:	4b13      	ldr	r3, [pc, #76]	@ (8021a80 <HAL_InitTick+0x54>)
 8021a32:	781b      	ldrb	r3, [r3, #0]
 8021a34:	2b00      	cmp	r3, #0
 8021a36:	d101      	bne.n	8021a3c <HAL_InitTick+0x10>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 8021a38:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8021a3a:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLK2Freq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 8021a3c:	f000 fcba 	bl	80223b4 <HAL_RCC_GetHCLK2Freq>
 8021a40:	0005      	movs	r5, r0
 8021a42:	4b0f      	ldr	r3, [pc, #60]	@ (8021a80 <HAL_InitTick+0x54>)
 8021a44:	7819      	ldrb	r1, [r3, #0]
 8021a46:	20fa      	movs	r0, #250	@ 0xfa
 8021a48:	0080      	lsls	r0, r0, #2
 8021a4a:	f7fe fb65 	bl	8020118 <__udivsi3>
 8021a4e:	0001      	movs	r1, r0
 8021a50:	0028      	movs	r0, r5
 8021a52:	f7fe fb61 	bl	8020118 <__udivsi3>
 8021a56:	f000 f8a1 	bl	8021b9c <HAL_SYSTICK_Config>
 8021a5a:	2800      	cmp	r0, #0
 8021a5c:	d10d      	bne.n	8021a7a <HAL_InitTick+0x4e>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8021a5e:	2c03      	cmp	r4, #3
 8021a60:	d901      	bls.n	8021a66 <HAL_InitTick+0x3a>
        status = HAL_ERROR;
 8021a62:	2001      	movs	r0, #1
 8021a64:	e7e9      	b.n	8021a3a <HAL_InitTick+0xe>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8021a66:	3001      	adds	r0, #1
 8021a68:	2200      	movs	r2, #0
 8021a6a:	0021      	movs	r1, r4
 8021a6c:	4240      	negs	r0, r0
 8021a6e:	f000 f885 	bl	8021b7c <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8021a72:	4b04      	ldr	r3, [pc, #16]	@ (8021a84 <HAL_InitTick+0x58>)
 8021a74:	601c      	str	r4, [r3, #0]
  HAL_StatusTypeDef  status = HAL_OK;
 8021a76:	2000      	movs	r0, #0
 8021a78:	e7df      	b.n	8021a3a <HAL_InitTick+0xe>
      status = HAL_ERROR;
 8021a7a:	2001      	movs	r0, #1
 8021a7c:	e7dd      	b.n	8021a3a <HAL_InitTick+0xe>
 8021a7e:	46c0      	nop			@ (mov r8, r8)
 8021a80:	2000a004 	.word	0x2000a004
 8021a84:	2000a008 	.word	0x2000a008

08021a88 <HAL_Init>:
{
 8021a88:	b510      	push	{r4, lr}
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
 8021a8a:	f000 fc93 	bl	80223b4 <HAL_RCC_GetHCLK2Freq>
 8021a8e:	4b06      	ldr	r3, [pc, #24]	@ (8021aa8 <HAL_Init+0x20>)
 8021a90:	6018      	str	r0, [r3, #0]
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8021a92:	2003      	movs	r0, #3
 8021a94:	f7ff ffca 	bl	8021a2c <HAL_InitTick>
 8021a98:	1e04      	subs	r4, r0, #0
 8021a9a:	d002      	beq.n	8021aa2 <HAL_Init+0x1a>
    status = HAL_ERROR;
 8021a9c:	2401      	movs	r4, #1
}
 8021a9e:	0020      	movs	r0, r4
 8021aa0:	bd10      	pop	{r4, pc}
    HAL_MspInit();
 8021aa2:	f7fe ff63 	bl	802096c <HAL_MspInit>
 8021aa6:	e7fa      	b.n	8021a9e <HAL_Init+0x16>
 8021aa8:	2000a000 	.word	0x2000a000

08021aac <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8021aac:	4b03      	ldr	r3, [pc, #12]	@ (8021abc <HAL_IncTick+0x10>)
 8021aae:	781b      	ldrb	r3, [r3, #0]
 8021ab0:	4a03      	ldr	r2, [pc, #12]	@ (8021ac0 <HAL_IncTick+0x14>)
 8021ab2:	6811      	ldr	r1, [r2, #0]
 8021ab4:	185b      	adds	r3, r3, r1
 8021ab6:	6013      	str	r3, [r2, #0]
}
 8021ab8:	4770      	bx	lr
 8021aba:	46c0      	nop			@ (mov r8, r8)
 8021abc:	2000a004 	.word	0x2000a004
 8021ac0:	2000a188 	.word	0x2000a188

08021ac4 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8021ac4:	4a02      	ldr	r2, [pc, #8]	@ (8021ad0 <HAL_SuspendTick+0xc>)
 8021ac6:	6813      	ldr	r3, [r2, #0]
 8021ac8:	2102      	movs	r1, #2
 8021aca:	438b      	bics	r3, r1
 8021acc:	6013      	str	r3, [r2, #0]
}
 8021ace:	4770      	bx	lr
 8021ad0:	e000e010 	.word	0xe000e010

08021ad4 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8021ad4:	4a02      	ldr	r2, [pc, #8]	@ (8021ae0 <HAL_ResumeTick+0xc>)
 8021ad6:	6813      	ldr	r3, [r2, #0]
 8021ad8:	2102      	movs	r1, #2
 8021ada:	430b      	orrs	r3, r1
 8021adc:	6013      	str	r3, [r2, #0]
}
 8021ade:	4770      	bx	lr
 8021ae0:	e000e010 	.word	0xe000e010

08021ae4 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8021ae4:	b570      	push	{r4, r5, r6, lr}
  if ((int32_t)(IRQn) >= 0)
 8021ae6:	2800      	cmp	r0, #0
 8021ae8:	db11      	blt.n	8021b0e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8021aea:	0883      	lsrs	r3, r0, #2
 8021aec:	4d13      	ldr	r5, [pc, #76]	@ (8021b3c <__NVIC_SetPriority+0x58>)
 8021aee:	33c0      	adds	r3, #192	@ 0xc0
 8021af0:	009b      	lsls	r3, r3, #2
 8021af2:	595c      	ldr	r4, [r3, r5]
 8021af4:	2203      	movs	r2, #3
 8021af6:	4010      	ands	r0, r2
 8021af8:	00c0      	lsls	r0, r0, #3
 8021afa:	32fc      	adds	r2, #252	@ 0xfc
 8021afc:	0016      	movs	r6, r2
 8021afe:	4086      	lsls	r6, r0
 8021b00:	43b4      	bics	r4, r6
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8021b02:	0189      	lsls	r1, r1, #6
 8021b04:	400a      	ands	r2, r1
 8021b06:	4082      	lsls	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8021b08:	4322      	orrs	r2, r4
 8021b0a:	515a      	str	r2, [r3, r5]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8021b0c:	bd70      	pop	{r4, r5, r6, pc}
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8021b0e:	230f      	movs	r3, #15
 8021b10:	4003      	ands	r3, r0
 8021b12:	3b08      	subs	r3, #8
 8021b14:	089b      	lsrs	r3, r3, #2
 8021b16:	3306      	adds	r3, #6
 8021b18:	009b      	lsls	r3, r3, #2
 8021b1a:	4a09      	ldr	r2, [pc, #36]	@ (8021b40 <__NVIC_SetPriority+0x5c>)
 8021b1c:	4694      	mov	ip, r2
 8021b1e:	4463      	add	r3, ip
 8021b20:	685c      	ldr	r4, [r3, #4]
 8021b22:	2203      	movs	r2, #3
 8021b24:	4010      	ands	r0, r2
 8021b26:	00c0      	lsls	r0, r0, #3
 8021b28:	32fc      	adds	r2, #252	@ 0xfc
 8021b2a:	0015      	movs	r5, r2
 8021b2c:	4085      	lsls	r5, r0
 8021b2e:	43ac      	bics	r4, r5
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8021b30:	0189      	lsls	r1, r1, #6
 8021b32:	400a      	ands	r2, r1
 8021b34:	4082      	lsls	r2, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8021b36:	4322      	orrs	r2, r4
 8021b38:	605a      	str	r2, [r3, #4]
}
 8021b3a:	e7e7      	b.n	8021b0c <__NVIC_SetPriority+0x28>
 8021b3c:	e000e100 	.word	0xe000e100
 8021b40:	e000ed00 	.word	0xe000ed00

08021b44 <SysTick_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8021b44:	3801      	subs	r0, #1
 8021b46:	2380      	movs	r3, #128	@ 0x80
 8021b48:	045b      	lsls	r3, r3, #17
 8021b4a:	4298      	cmp	r0, r3
 8021b4c:	d20f      	bcs.n	8021b6e <SysTick_Config+0x2a>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8021b4e:	4a09      	ldr	r2, [pc, #36]	@ (8021b74 <SysTick_Config+0x30>)
 8021b50:	6050      	str	r0, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8021b52:	4809      	ldr	r0, [pc, #36]	@ (8021b78 <SysTick_Config+0x34>)
 8021b54:	6a03      	ldr	r3, [r0, #32]
 8021b56:	021b      	lsls	r3, r3, #8
 8021b58:	0a1b      	lsrs	r3, r3, #8
 8021b5a:	21c0      	movs	r1, #192	@ 0xc0
 8021b5c:	0609      	lsls	r1, r1, #24
 8021b5e:	430b      	orrs	r3, r1
 8021b60:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8021b62:	2300      	movs	r3, #0
 8021b64:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8021b66:	3307      	adds	r3, #7
 8021b68:	6013      	str	r3, [r2, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8021b6a:	2000      	movs	r0, #0
}
 8021b6c:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8021b6e:	2001      	movs	r0, #1
 8021b70:	e7fc      	b.n	8021b6c <SysTick_Config+0x28>
 8021b72:	46c0      	nop			@ (mov r8, r8)
 8021b74:	e000e010 	.word	0xe000e010
 8021b78:	e000ed00 	.word	0xe000ed00

08021b7c <HAL_NVIC_SetPriority>:
  *         with stm32wlxx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8021b7c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
 8021b7e:	f7ff ffb1 	bl	8021ae4 <__NVIC_SetPriority>
}
 8021b82:	bd10      	pop	{r4, pc}

08021b84 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8021b84:	2800      	cmp	r0, #0
 8021b86:	db05      	blt.n	8021b94 <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8021b88:	221f      	movs	r2, #31
 8021b8a:	4002      	ands	r2, r0
 8021b8c:	2301      	movs	r3, #1
 8021b8e:	4093      	lsls	r3, r2
 8021b90:	4a01      	ldr	r2, [pc, #4]	@ (8021b98 <HAL_NVIC_EnableIRQ+0x14>)
 8021b92:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8021b94:	4770      	bx	lr
 8021b96:	46c0      	nop			@ (mov r8, r8)
 8021b98:	e000e100 	.word	0xe000e100

08021b9c <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8021b9c:	b510      	push	{r4, lr}
  return SysTick_Config(TicksNumb);
 8021b9e:	f7ff ffd1 	bl	8021b44 <SysTick_Config>
}
 8021ba2:	bd10      	pop	{r4, pc}

08021ba4 <FLASH_OB_GetWRP>:
  * @param[out]  WRDPEndOffset Specifies the address where to copied the end page of
  *                            the write protected area
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t *WRPStartOffset, uint32_t *WRDPEndOffset)
{
 8021ba4:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_OB_WRPAREA(WRPArea));

  /* Get the configuration of the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 8021ba6:	2800      	cmp	r0, #0
 8021ba8:	d109      	bne.n	8021bbe <FLASH_OB_GetWRP+0x1a>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_STRT);
 8021baa:	4c0a      	ldr	r4, [pc, #40]	@ (8021bd4 <FLASH_OB_GetWRP+0x30>)
 8021bac:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8021bae:	237f      	movs	r3, #127	@ 0x7f
 8021bb0:	4018      	ands	r0, r3
 8021bb2:	6008      	str	r0, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_END) >> FLASH_WRP1AR_WRP1A_END_Pos);
 8021bb4:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8021bb6:	0c09      	lsrs	r1, r1, #16
 8021bb8:	400b      	ands	r3, r1
 8021bba:	6013      	str	r3, [r2, #0]
  else /* OB_WRPAREA_BANK1_AREAB */
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
  }
}
 8021bbc:	bd10      	pop	{r4, pc}
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
 8021bbe:	4c05      	ldr	r4, [pc, #20]	@ (8021bd4 <FLASH_OB_GetWRP+0x30>)
 8021bc0:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8021bc2:	237f      	movs	r3, #127	@ 0x7f
 8021bc4:	4018      	ands	r0, r3
 8021bc6:	6008      	str	r0, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
 8021bc8:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 8021bca:	0c09      	lsrs	r1, r1, #16
 8021bcc:	400b      	ands	r3, r1
 8021bce:	6013      	str	r3, [r2, #0]
}
 8021bd0:	e7f4      	b.n	8021bbc <FLASH_OB_GetWRP+0x18>
 8021bd2:	46c0      	nop			@ (mov r8, r8)
 8021bd4:	58004000 	.word	0x58004000

08021bd8 <FLASH_OB_GetRDP>:
  *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
  *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
  uint32_t rdplvl = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 8021bd8:	4b04      	ldr	r3, [pc, #16]	@ (8021bec <FLASH_OB_GetRDP+0x14>)
 8021bda:	6a1b      	ldr	r3, [r3, #32]
 8021bdc:	20ff      	movs	r0, #255	@ 0xff
 8021bde:	4018      	ands	r0, r3

  if ((rdplvl != OB_RDP_LEVEL_0) && (rdplvl != OB_RDP_LEVEL_2))
 8021be0:	28aa      	cmp	r0, #170	@ 0xaa
 8021be2:	d002      	beq.n	8021bea <FLASH_OB_GetRDP+0x12>
 8021be4:	28cc      	cmp	r0, #204	@ 0xcc
 8021be6:	d000      	beq.n	8021bea <FLASH_OB_GetRDP+0x12>
  {
    return (OB_RDP_LEVEL_1);
 8021be8:	20bb      	movs	r0, #187	@ 0xbb
  }
  else
  {
    return rdplvl;
  }
}
 8021bea:	4770      	bx	lr
 8021bec:	58004000 	.word	0x58004000

08021bf0 <FLASH_OB_GetUser>:
  *         @arg @ref OB_BOOT_LOCK_DISABLE or @ref OB_BOOT_LOCK_ENABLE
  */
#endif
static uint32_t FLASH_OB_GetUser(void)
{
  uint32_t user_config = (READ_REG(FLASH->OPTR) & OB_USER_ALL);
 8021bf0:	4b02      	ldr	r3, [pc, #8]	@ (8021bfc <FLASH_OB_GetUser+0xc>)
 8021bf2:	6a18      	ldr	r0, [r3, #32]
 8021bf4:	4b02      	ldr	r3, [pc, #8]	@ (8021c00 <FLASH_OB_GetUser+0x10>)
 8021bf6:	4018      	ands	r0, r3
  CLEAR_BIT(user_config, (FLASH_OPTR_RDP | FLASH_OPTR_ESE));

  return user_config;
}
 8021bf8:	4770      	bx	lr
 8021bfa:	46c0      	nop			@ (mov r8, r8)
 8021bfc:	58004000 	.word	0x58004000
 8021c00:	cf8f7e00 	.word	0xcf8f7e00

08021c04 <FLASH_OB_GetPCROP>:
  * @param PCROP1BEndAddr [out] Specifies the address where to copied the end address of
  *                       the Zone 1B Proprietary code readout protection
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROP1AStartAddr, uint32_t *PCROP1AEndAddr, uint32_t *PCROP1BStartAddr, uint32_t *PCROP1BEndAddr)
{
 8021c04:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t pcrop;

  pcrop             = (READ_BIT(FLASH->PCROP1BSR, FLASH_PCROP1BSR_PCROP1B_STRT));
 8021c06:	4c10      	ldr	r4, [pc, #64]	@ (8021c48 <FLASH_OB_GetPCROP+0x44>)
 8021c08:	6b66      	ldr	r6, [r4, #52]	@ 0x34
  *PCROP1BStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 8021c0a:	02b6      	lsls	r6, r6, #10
 8021c0c:	25ff      	movs	r5, #255	@ 0xff
 8021c0e:	02ad      	lsls	r5, r5, #10
 8021c10:	402e      	ands	r6, r5
 8021c12:	2780      	movs	r7, #128	@ 0x80
 8021c14:	053f      	lsls	r7, r7, #20
 8021c16:	46bc      	mov	ip, r7
 8021c18:	4466      	add	r6, ip
 8021c1a:	601e      	str	r6, [r3, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1BER, FLASH_PCROP1BER_PCROP1B_END));
 8021c1c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
  *PCROP1BEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 8021c1e:	029b      	lsls	r3, r3, #10
 8021c20:	402b      	ands	r3, r5
 8021c22:	4463      	add	r3, ip
 8021c24:	9e05      	ldr	r6, [sp, #20]
 8021c26:	6033      	str	r3, [r6, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1ASR, FLASH_PCROP1ASR_PCROP1A_STRT));
 8021c28:	6a63      	ldr	r3, [r4, #36]	@ 0x24
  *PCROP1AStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 8021c2a:	029b      	lsls	r3, r3, #10
 8021c2c:	402b      	ands	r3, r5
 8021c2e:	4463      	add	r3, ip
 8021c30:	600b      	str	r3, [r1, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1AER, FLASH_PCROP1AER_PCROP1A_END));
 8021c32:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
  *PCROP1AEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 8021c34:	029b      	lsls	r3, r3, #10
 8021c36:	402b      	ands	r3, r5
 8021c38:	4463      	add	r3, ip
 8021c3a:	6013      	str	r3, [r2, #0]

  *PCROPConfig      = (READ_REG(FLASH->PCROP1AER) & FLASH_PCROP1AER_PCROP_RDP);
 8021c3c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8021c3e:	0fdb      	lsrs	r3, r3, #31
 8021c40:	07db      	lsls	r3, r3, #31
 8021c42:	6003      	str	r3, [r0, #0]
}
 8021c44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021c46:	46c0      	nop			@ (mov r8, r8)
 8021c48:	58004000 	.word	0x58004000

08021c4c <FLASH_OB_GetIPCCBufferAddr>:
  *           This value correspond to the first double-word of the IPCC mailbox data buffer area
  *           in SRAM starting from 0x20000000 (SRAM1 start address to SRAM2 end address).
  */
static uint32_t FLASH_OB_GetIPCCBufferAddr(void)
{
  return (uint32_t)((READ_BIT(FLASH->IPCCBR, FLASH_IPCCBR_IPCCDBA) << 4) + SRAM1_BASE);
 8021c4c:	4b04      	ldr	r3, [pc, #16]	@ (8021c60 <FLASH_OB_GetIPCCBufferAddr+0x14>)
 8021c4e:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8021c50:	0100      	lsls	r0, r0, #4
 8021c52:	4b04      	ldr	r3, [pc, #16]	@ (8021c64 <FLASH_OB_GetIPCCBufferAddr+0x18>)
 8021c54:	4018      	ands	r0, r3
 8021c56:	2380      	movs	r3, #128	@ 0x80
 8021c58:	059b      	lsls	r3, r3, #22
 8021c5a:	469c      	mov	ip, r3
 8021c5c:	4460      	add	r0, ip
}
 8021c5e:	4770      	bx	lr
 8021c60:	58004000 	.word	0x58004000
 8021c64:	0003fff0 	.word	0x0003fff0

08021c68 <FLASH_OB_GetC2BootResetConfig>:
  * @param  C2BootResetRegion   Specifies the Secure Boot reset memory region
  * @retval None
  */
static void FLASH_OB_GetC2BootResetConfig(uint32_t *C2BootResetVectAddr, uint32_t *C2BootResetRegion)
{
  *C2BootResetRegion = (READ_BIT(FLASH->SRRVR, FLASH_SRRVR_C2OPT));
 8021c68:	4a0f      	ldr	r2, [pc, #60]	@ (8021ca8 <FLASH_OB_GetC2BootResetConfig+0x40>)
 8021c6a:	2384      	movs	r3, #132	@ 0x84
 8021c6c:	58d2      	ldr	r2, [r2, r3]
 8021c6e:	0fd3      	lsrs	r3, r2, #31
 8021c70:	07db      	lsls	r3, r3, #31
 8021c72:	600b      	str	r3, [r1, #0]

  if (*C2BootResetRegion == OB_C2_BOOT_FROM_FLASH)
 8021c74:	2a00      	cmp	r2, #0
 8021c76:	db0b      	blt.n	8021c90 <FLASH_OB_GetC2BootResetConfig+0x28>
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
  }
  else
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + SRAM1_BASE);
 8021c78:	4a0b      	ldr	r2, [pc, #44]	@ (8021ca8 <FLASH_OB_GetC2BootResetConfig+0x40>)
 8021c7a:	2384      	movs	r3, #132	@ 0x84
 8021c7c:	58d3      	ldr	r3, [r2, r3]
 8021c7e:	009b      	lsls	r3, r3, #2
 8021c80:	4a0a      	ldr	r2, [pc, #40]	@ (8021cac <FLASH_OB_GetC2BootResetConfig+0x44>)
 8021c82:	4013      	ands	r3, r2
 8021c84:	2280      	movs	r2, #128	@ 0x80
 8021c86:	0592      	lsls	r2, r2, #22
 8021c88:	4694      	mov	ip, r2
 8021c8a:	4463      	add	r3, ip
 8021c8c:	6003      	str	r3, [r0, #0]
  }
}
 8021c8e:	4770      	bx	lr
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
 8021c90:	4a05      	ldr	r2, [pc, #20]	@ (8021ca8 <FLASH_OB_GetC2BootResetConfig+0x40>)
 8021c92:	2384      	movs	r3, #132	@ 0x84
 8021c94:	58d3      	ldr	r3, [r2, r3]
 8021c96:	009b      	lsls	r3, r3, #2
 8021c98:	4a04      	ldr	r2, [pc, #16]	@ (8021cac <FLASH_OB_GetC2BootResetConfig+0x44>)
 8021c9a:	4013      	ands	r3, r2
 8021c9c:	2280      	movs	r2, #128	@ 0x80
 8021c9e:	0512      	lsls	r2, r2, #20
 8021ca0:	4694      	mov	ip, r2
 8021ca2:	4463      	add	r3, ip
 8021ca4:	6003      	str	r3, [r0, #0]
 8021ca6:	e7f2      	b.n	8021c8e <FLASH_OB_GetC2BootResetConfig+0x26>
 8021ca8:	58004000 	.word	0x58004000
 8021cac:	0003fffc 	.word	0x0003fffc

08021cb0 <FLASH_OB_GetSUBGHZSPISecureAccess>:
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_DISABLE : Sub-GHz radio SPI Secure access disabled
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_ENABLE : Sub-GHz radio SPI Secure access enabled
  */
static uint32_t FLASH_OB_GetSUBGHZSPISecureAccess(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_SUBGHZSPISD));
 8021cb0:	4a02      	ldr	r2, [pc, #8]	@ (8021cbc <FLASH_OB_GetSUBGHZSPISecureAccess+0xc>)
 8021cb2:	2380      	movs	r3, #128	@ 0x80
 8021cb4:	58d0      	ldr	r0, [r2, r3]
 8021cb6:	0fc0      	lsrs	r0, r0, #31
 8021cb8:	07c0      	lsls	r0, r0, #31
}
 8021cba:	4770      	bx	lr
 8021cbc:	58004000 	.word	0x58004000

08021cc0 <FLASH_OB_GetC2DebugAccessMode>:
  *           @arg @ref OB_C2_DEBUG_ACCESS_DISABLE : CPU2 debug access disabled
  *           @arg @ref OB_C2_DEBUG_ACCESS_ENABLE : CPU2 debug access enabled
  */
static uint32_t FLASH_OB_GetC2DebugAccessMode(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_DDS));
 8021cc0:	4a03      	ldr	r2, [pc, #12]	@ (8021cd0 <FLASH_OB_GetC2DebugAccessMode+0x10>)
 8021cc2:	2380      	movs	r3, #128	@ 0x80
 8021cc4:	58d0      	ldr	r0, [r2, r3]
 8021cc6:	2380      	movs	r3, #128	@ 0x80
 8021cc8:	015b      	lsls	r3, r3, #5
 8021cca:	4018      	ands	r0, r3
}
 8021ccc:	4770      	bx	lr
 8021cce:	46c0      	nop			@ (mov r8, r8)
 8021cd0:	58004000 	.word	0x58004000

08021cd4 <FLASH_OB_GetSecureMode>:
  *                               Null
  */
static uint32_t FLASH_OB_GetSecureMode(uint32_t Reg, uint32_t Bit, uint32_t ValueEnable, uint32_t ValueDisable)
{
  /* Return status of bit (set as enable, set as disable) */
  if (READ_BIT(Reg, Bit) == 0U)
 8021cd4:	4201      	tst	r1, r0
 8021cd6:	d100      	bne.n	8021cda <FLASH_OB_GetSecureMode+0x6>
  {
    return ValueEnable;
 8021cd8:	0013      	movs	r3, r2
  }
  else
  {
    return ValueDisable;
  }
}
 8021cda:	0018      	movs	r0, r3
 8021cdc:	4770      	bx	lr
	...

08021ce0 <FLASH_OB_GetSecureMemoryConfig>:
{
 8021ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021ce2:	46c6      	mov	lr, r8
 8021ce4:	b500      	push	{lr}
 8021ce6:	4698      	mov	r8, r3
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 8021ce8:	4c24      	ldr	r4, [pc, #144]	@ (8021d7c <FLASH_OB_GetSecureMemoryConfig+0x9c>)
 8021cea:	2580      	movs	r5, #128	@ 0x80
 8021cec:	5966      	ldr	r6, [r4, r5]
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);
 8021cee:	3504      	adds	r5, #4
 8021cf0:	5965      	ldr	r5, [r4, r5]
  uint32_t user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_SFSA) >> FLASH_SFR_SFSA_Pos);
 8021cf2:	247f      	movs	r4, #127	@ 0x7f
 8021cf4:	0027      	movs	r7, r4
 8021cf6:	4037      	ands	r7, r6
  *SecureFlashStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 8021cf8:	2380      	movs	r3, #128	@ 0x80
 8021cfa:	025b      	lsls	r3, r3, #9
 8021cfc:	469c      	mov	ip, r3
 8021cfe:	4467      	add	r7, ip
 8021d00:	02ff      	lsls	r7, r7, #11
 8021d02:	6007      	str	r7, [r0, #0]
  user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_HDPSA) >> FLASH_SFR_HDPSA_Pos);
 8021d04:	0c30      	lsrs	r0, r6, #16
 8021d06:	4004      	ands	r4, r0
  *HideProtectionStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 8021d08:	4464      	add	r4, ip
 8021d0a:	02e4      	lsls	r4, r4, #11
 8021d0c:	600c      	str	r4, [r1, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SBRSA) >> FLASH_SRRVR_SBRSA_Pos);
 8021d0e:	0ca9      	lsrs	r1, r5, #18
  *SecureSRAM2StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM2_BASE);
 8021d10:	0289      	lsls	r1, r1, #10
 8021d12:	20f8      	movs	r0, #248	@ 0xf8
 8021d14:	01c0      	lsls	r0, r0, #7
 8021d16:	4001      	ands	r1, r0
 8021d18:	4b19      	ldr	r3, [pc, #100]	@ (8021d80 <FLASH_OB_GetSecureMemoryConfig+0xa0>)
 8021d1a:	469c      	mov	ip, r3
 8021d1c:	4461      	add	r1, ip
 8021d1e:	6011      	str	r1, [r2, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SNBRSA) >> FLASH_SRRVR_SNBRSA_Pos);
 8021d20:	0e6a      	lsrs	r2, r5, #25
  *SecureSRAM1StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM1_BASE);
 8021d22:	0292      	lsls	r2, r2, #10
 8021d24:	4002      	ands	r2, r0
 8021d26:	2380      	movs	r3, #128	@ 0x80
 8021d28:	059b      	lsls	r3, r3, #22
 8021d2a:	469c      	mov	ip, r3
 8021d2c:	4462      	add	r2, ip
 8021d2e:	4643      	mov	r3, r8
 8021d30:	601a      	str	r2, [r3, #0]
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8021d32:	2310      	movs	r3, #16
 8021d34:	2201      	movs	r2, #1
 8021d36:	2180      	movs	r1, #128	@ 0x80
 8021d38:	0030      	movs	r0, r6
 8021d3a:	f7ff ffcb 	bl	8021cd4 <FLASH_OB_GetSecureMode>
 8021d3e:	0004      	movs	r4, r0
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 8021d40:	2780      	movs	r7, #128	@ 0x80
 8021d42:	043f      	lsls	r7, r7, #16
 8021d44:	2320      	movs	r3, #32
 8021d46:	2202      	movs	r2, #2
 8021d48:	0039      	movs	r1, r7
 8021d4a:	0030      	movs	r0, r6
 8021d4c:	f7ff ffc2 	bl	8021cd4 <FLASH_OB_GetSecureMode>
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8021d50:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 8021d52:	2180      	movs	r1, #128	@ 0x80
 8021d54:	2340      	movs	r3, #64	@ 0x40
 8021d56:	2204      	movs	r2, #4
 8021d58:	05c9      	lsls	r1, r1, #23
 8021d5a:	0028      	movs	r0, r5
 8021d5c:	f7ff ffba 	bl	8021cd4 <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 8021d60:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_BRSD, OB_SECURE_SRAM2_ENABLE, OB_SECURE_SRAM2_DISABLE));
 8021d62:	2380      	movs	r3, #128	@ 0x80
 8021d64:	2208      	movs	r2, #8
 8021d66:	0039      	movs	r1, r7
 8021d68:	0028      	movs	r0, r5
 8021d6a:	f7ff ffb3 	bl	8021cd4 <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 8021d6e:	4304      	orrs	r4, r0
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8021d70:	9b06      	ldr	r3, [sp, #24]
 8021d72:	601c      	str	r4, [r3, #0]
}
 8021d74:	bc80      	pop	{r7}
 8021d76:	46b8      	mov	r8, r7
 8021d78:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021d7a:	46c0      	nop			@ (mov r8, r8)
 8021d7c:	58004000 	.word	0x58004000
 8021d80:	20008000 	.word	0x20008000

08021d84 <HAL_FLASHEx_OBGetConfig>:
{
 8021d84:	b530      	push	{r4, r5, lr}
 8021d86:	b083      	sub	sp, #12
 8021d88:	0004      	movs	r4, r0
  pOBInit->OptionType = OPTIONBYTE_ALL;
 8021d8a:	4b21      	ldr	r3, [pc, #132]	@ (8021e10 <HAL_FLASHEx_OBGetConfig+0x8c>)
 8021d8c:	6003      	str	r3, [r0, #0]
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
 8021d8e:	6840      	ldr	r0, [r0, #4]
 8021d90:	2801      	cmp	r0, #1
 8021d92:	d935      	bls.n	8021e00 <HAL_FLASHEx_OBGetConfig+0x7c>
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 8021d94:	f7ff ff20 	bl	8021bd8 <FLASH_OB_GetRDP>
 8021d98:	6120      	str	r0, [r4, #16]
  pOBInit->UserConfig = FLASH_OB_GetUser();
 8021d9a:	f7ff ff29 	bl	8021bf0 <FLASH_OB_GetUser>
 8021d9e:	61a0      	str	r0, [r4, #24]
  pOBInit->UserType = OB_USER_ALL;
 8021da0:	4b1c      	ldr	r3, [pc, #112]	@ (8021e14 <HAL_FLASHEx_OBGetConfig+0x90>)
 8021da2:	6163      	str	r3, [r4, #20]
  FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROP1AStartAddr), &(pOBInit->PCROP1AEndAddr), &(pOBInit->PCROP1BStartAddr), &(pOBInit->PCROP1BEndAddr));
 8021da4:	0023      	movs	r3, r4
 8021da6:	3328      	adds	r3, #40	@ 0x28
 8021da8:	0022      	movs	r2, r4
 8021daa:	3224      	adds	r2, #36	@ 0x24
 8021dac:	0021      	movs	r1, r4
 8021dae:	3120      	adds	r1, #32
 8021db0:	0020      	movs	r0, r4
 8021db2:	301c      	adds	r0, #28
 8021db4:	0025      	movs	r5, r4
 8021db6:	352c      	adds	r5, #44	@ 0x2c
 8021db8:	9500      	str	r5, [sp, #0]
 8021dba:	f7ff ff23 	bl	8021c04 <FLASH_OB_GetPCROP>
  pOBInit->PCROPConfig |= (OB_PCROP_ZONE_A | OB_PCROP_ZONE_B);
 8021dbe:	69e3      	ldr	r3, [r4, #28]
 8021dc0:	2203      	movs	r2, #3
 8021dc2:	4313      	orrs	r3, r2
 8021dc4:	61e3      	str	r3, [r4, #28]
  pOBInit->IPCCdataBufAddr = FLASH_OB_GetIPCCBufferAddr();
 8021dc6:	f7ff ff41 	bl	8021c4c <FLASH_OB_GetIPCCBufferAddr>
 8021dca:	6560      	str	r0, [r4, #84]	@ 0x54
  FLASH_OB_GetSecureMemoryConfig(&(pOBInit->SecureFlashStartAddr), &(pOBInit->HideProtectionStartAddr), &(pOBInit->SecureSRAM2StartAddr), &(pOBInit->SecureSRAM1StartAddr), &(pOBInit->SecureMode));
 8021dcc:	0023      	movs	r3, r4
 8021dce:	3338      	adds	r3, #56	@ 0x38
 8021dd0:	0022      	movs	r2, r4
 8021dd2:	3234      	adds	r2, #52	@ 0x34
 8021dd4:	0021      	movs	r1, r4
 8021dd6:	313c      	adds	r1, #60	@ 0x3c
 8021dd8:	0020      	movs	r0, r4
 8021dda:	3030      	adds	r0, #48	@ 0x30
 8021ddc:	3514      	adds	r5, #20
 8021dde:	9500      	str	r5, [sp, #0]
 8021de0:	f7ff ff7e 	bl	8021ce0 <FLASH_OB_GetSecureMemoryConfig>
  FLASH_OB_GetC2BootResetConfig(&(pOBInit->C2SecureBootVectAddr), &(pOBInit->C2BootRegion));
 8021de4:	0021      	movs	r1, r4
 8021de6:	314c      	adds	r1, #76	@ 0x4c
 8021de8:	0020      	movs	r0, r4
 8021dea:	3050      	adds	r0, #80	@ 0x50
 8021dec:	f7ff ff3c 	bl	8021c68 <FLASH_OB_GetC2BootResetConfig>
  pOBInit->SUBGHZSPISecureAccess = FLASH_OB_GetSUBGHZSPISecureAccess();
 8021df0:	f7ff ff5e 	bl	8021cb0 <FLASH_OB_GetSUBGHZSPISecureAccess>
 8021df4:	6460      	str	r0, [r4, #68]	@ 0x44
  pOBInit->C2DebugAccessMode = FLASH_OB_GetC2DebugAccessMode();
 8021df6:	f7ff ff63 	bl	8021cc0 <FLASH_OB_GetC2DebugAccessMode>
 8021dfa:	64a0      	str	r0, [r4, #72]	@ 0x48
}
 8021dfc:	b003      	add	sp, #12
 8021dfe:	bd30      	pop	{r4, r5, pc}
    FLASH_OB_GetWRP(pOBInit->WRPArea, &(pOBInit->WRPStartOffset), &(pOBInit->WRPEndOffset));
 8021e00:	0022      	movs	r2, r4
 8021e02:	320c      	adds	r2, #12
 8021e04:	0021      	movs	r1, r4
 8021e06:	3108      	adds	r1, #8
 8021e08:	f7ff fecc 	bl	8021ba4 <FLASH_OB_GetWRP>
 8021e0c:	e7c2      	b.n	8021d94 <HAL_FLASHEx_OBGetConfig+0x10>
 8021e0e:	46c0      	nop			@ (mov r8, r8)
 8021e10:	00000f1f 	.word	0x00000f1f
 8021e14:	cf8f7e00 	.word	0xcf8f7e00

08021e18 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8021e18:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t position = 0x00u;
 8021e1a:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8021e1c:	e05a      	b.n	8021ed4 <HAL_GPIO_Init+0xbc>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8021e1e:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8021e20:	005f      	lsls	r7, r3, #1
 8021e22:	2403      	movs	r4, #3
 8021e24:	40bc      	lsls	r4, r7
 8021e26:	43a6      	bics	r6, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8021e28:	68cc      	ldr	r4, [r1, #12]
 8021e2a:	40bc      	lsls	r4, r7
 8021e2c:	4334      	orrs	r4, r6
        GPIOx->OSPEEDR = temp;
 8021e2e:	6084      	str	r4, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8021e30:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8021e32:	4394      	bics	r4, r2
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8021e34:	684e      	ldr	r6, [r1, #4]
 8021e36:	0936      	lsrs	r6, r6, #4
 8021e38:	2201      	movs	r2, #1
 8021e3a:	4032      	ands	r2, r6
 8021e3c:	409a      	lsls	r2, r3
 8021e3e:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 8021e40:	6042      	str	r2, [r0, #4]
 8021e42:	e057      	b.n	8021ef4 <HAL_GPIO_Init+0xdc>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8021e44:	08de      	lsrs	r6, r3, #3
 8021e46:	3608      	adds	r6, #8
 8021e48:	00b6      	lsls	r6, r6, #2
 8021e4a:	5837      	ldr	r7, [r6, r0]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8021e4c:	3205      	adds	r2, #5
 8021e4e:	401a      	ands	r2, r3
 8021e50:	0092      	lsls	r2, r2, #2
 8021e52:	240f      	movs	r4, #15
 8021e54:	4094      	lsls	r4, r2
 8021e56:	43a7      	bics	r7, r4
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8021e58:	690c      	ldr	r4, [r1, #16]
 8021e5a:	4094      	lsls	r4, r2
 8021e5c:	0022      	movs	r2, r4
 8021e5e:	433a      	orrs	r2, r7
        GPIOx->AFR[position >> 3u] = temp;
 8021e60:	5032      	str	r2, [r6, r0]
 8021e62:	e05a      	b.n	8021f1a <HAL_GPIO_Init+0x102>
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = SYSCFG->EXTICR[position >> 2u];
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8021e64:	2602      	movs	r6, #2
 8021e66:	e000      	b.n	8021e6a <HAL_GPIO_Init+0x52>
 8021e68:	2600      	movs	r6, #0
 8021e6a:	40a6      	lsls	r6, r4
 8021e6c:	0034      	movs	r4, r6
 8021e6e:	433c      	orrs	r4, r7
        SYSCFG->EXTICR[position >> 2u] = temp;
 8021e70:	3202      	adds	r2, #2
 8021e72:	0092      	lsls	r2, r2, #2
 8021e74:	4e3e      	ldr	r6, [pc, #248]	@ (8021f70 <HAL_GPIO_Init+0x158>)
 8021e76:	5194      	str	r4, [r2, r6]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8021e78:	4a3e      	ldr	r2, [pc, #248]	@ (8021f74 <HAL_GPIO_Init+0x15c>)
 8021e7a:	6817      	ldr	r7, [r2, #0]
        temp &= ~(iocurrent);
 8021e7c:	43ea      	mvns	r2, r5
 8021e7e:	003e      	movs	r6, r7
 8021e80:	43ae      	bics	r6, r5
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8021e82:	684c      	ldr	r4, [r1, #4]
 8021e84:	02e4      	lsls	r4, r4, #11
 8021e86:	d501      	bpl.n	8021e8c <HAL_GPIO_Init+0x74>
        {
          temp |= iocurrent;
 8021e88:	003e      	movs	r6, r7
 8021e8a:	432e      	orrs	r6, r5
        }
        EXTI->RTSR1 = temp;
 8021e8c:	4c39      	ldr	r4, [pc, #228]	@ (8021f74 <HAL_GPIO_Init+0x15c>)
 8021e8e:	6026      	str	r6, [r4, #0]

        temp = EXTI->FTSR1;
 8021e90:	6867      	ldr	r7, [r4, #4]
        temp &= ~(iocurrent);
 8021e92:	003e      	movs	r6, r7
 8021e94:	4016      	ands	r6, r2
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8021e96:	684c      	ldr	r4, [r1, #4]
 8021e98:	02a4      	lsls	r4, r4, #10
 8021e9a:	d501      	bpl.n	8021ea0 <HAL_GPIO_Init+0x88>
        {
          temp |= iocurrent;
 8021e9c:	003e      	movs	r6, r7
 8021e9e:	432e      	orrs	r6, r5
        }
        EXTI->FTSR1 = temp;
 8021ea0:	4c34      	ldr	r4, [pc, #208]	@ (8021f74 <HAL_GPIO_Init+0x15c>)
 8021ea2:	6066      	str	r6, [r4, #4]

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
 8021ea4:	26c0      	movs	r6, #192	@ 0xc0
 8021ea6:	59a7      	ldr	r7, [r4, r6]
#else
        temp = EXTI->IMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8021ea8:	003e      	movs	r6, r7
 8021eaa:	4016      	ands	r6, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8021eac:	684c      	ldr	r4, [r1, #4]
 8021eae:	03e4      	lsls	r4, r4, #15
 8021eb0:	d501      	bpl.n	8021eb6 <HAL_GPIO_Init+0x9e>
        {
          temp |= iocurrent;
 8021eb2:	003e      	movs	r6, r7
 8021eb4:	432e      	orrs	r6, r5
        }
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 = temp;
 8021eb6:	4c2f      	ldr	r4, [pc, #188]	@ (8021f74 <HAL_GPIO_Init+0x15c>)
 8021eb8:	27c0      	movs	r7, #192	@ 0xc0
 8021eba:	51e6      	str	r6, [r4, r7]
#else
        EXTI->IMR1 = temp;
#endif /* CORE_CM0PLUS */

#ifdef CORE_CM0PLUS
        temp = EXTI->C2EMR1;
 8021ebc:	26c4      	movs	r6, #196	@ 0xc4
 8021ebe:	59a6      	ldr	r6, [r4, r6]
#else
        temp = EXTI->EMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8021ec0:	4032      	ands	r2, r6
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8021ec2:	684c      	ldr	r4, [r1, #4]
 8021ec4:	03a4      	lsls	r4, r4, #14
 8021ec6:	d501      	bpl.n	8021ecc <HAL_GPIO_Init+0xb4>
        {
          temp |= iocurrent;
 8021ec8:	002a      	movs	r2, r5
 8021eca:	4332      	orrs	r2, r6
        }
#ifdef CORE_CM0PLUS
        EXTI->C2EMR1 = temp;
 8021ecc:	4d29      	ldr	r5, [pc, #164]	@ (8021f74 <HAL_GPIO_Init+0x15c>)
 8021ece:	24c4      	movs	r4, #196	@ 0xc4
 8021ed0:	512a      	str	r2, [r5, r4]
        EXTI->EMR1 = temp;
#endif /* CORE_CM0PLUS */
      }
    }

    position++;
 8021ed2:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8021ed4:	680c      	ldr	r4, [r1, #0]
 8021ed6:	0022      	movs	r2, r4
 8021ed8:	40da      	lsrs	r2, r3
 8021eda:	d048      	beq.n	8021f6e <HAL_GPIO_Init+0x156>
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8021edc:	2201      	movs	r2, #1
 8021ede:	409a      	lsls	r2, r3
 8021ee0:	0025      	movs	r5, r4
 8021ee2:	4015      	ands	r5, r2
    if (iocurrent != 0x00u)
 8021ee4:	4214      	tst	r4, r2
 8021ee6:	d0f4      	beq.n	8021ed2 <HAL_GPIO_Init+0xba>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8021ee8:	684e      	ldr	r6, [r1, #4]
 8021eea:	2403      	movs	r4, #3
 8021eec:	4034      	ands	r4, r6
 8021eee:	3c01      	subs	r4, #1
 8021ef0:	2c01      	cmp	r4, #1
 8021ef2:	d994      	bls.n	8021e1e <HAL_GPIO_Init+0x6>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8021ef4:	684c      	ldr	r4, [r1, #4]
 8021ef6:	2203      	movs	r2, #3
 8021ef8:	4022      	ands	r2, r4
 8021efa:	2a03      	cmp	r2, #3
 8021efc:	d008      	beq.n	8021f10 <HAL_GPIO_Init+0xf8>
        temp = GPIOx->PUPDR;
 8021efe:	68c4      	ldr	r4, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8021f00:	005e      	lsls	r6, r3, #1
 8021f02:	2203      	movs	r2, #3
 8021f04:	40b2      	lsls	r2, r6
 8021f06:	4394      	bics	r4, r2
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8021f08:	688a      	ldr	r2, [r1, #8]
 8021f0a:	40b2      	lsls	r2, r6
 8021f0c:	4322      	orrs	r2, r4
        GPIOx->PUPDR = temp;
 8021f0e:	60c2      	str	r2, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8021f10:	684c      	ldr	r4, [r1, #4]
 8021f12:	2203      	movs	r2, #3
 8021f14:	4022      	ands	r2, r4
 8021f16:	2a02      	cmp	r2, #2
 8021f18:	d094      	beq.n	8021e44 <HAL_GPIO_Init+0x2c>
      temp = GPIOx->MODER;
 8021f1a:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8021f1c:	005e      	lsls	r6, r3, #1
 8021f1e:	2203      	movs	r2, #3
 8021f20:	0017      	movs	r7, r2
 8021f22:	40b7      	lsls	r7, r6
 8021f24:	43bc      	bics	r4, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021f26:	684f      	ldr	r7, [r1, #4]
 8021f28:	403a      	ands	r2, r7
 8021f2a:	40b2      	lsls	r2, r6
 8021f2c:	4322      	orrs	r2, r4
      GPIOx->MODER = temp;
 8021f2e:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8021f30:	684c      	ldr	r4, [r1, #4]
 8021f32:	22c0      	movs	r2, #192	@ 0xc0
 8021f34:	0292      	lsls	r2, r2, #10
 8021f36:	4214      	tst	r4, r2
 8021f38:	d0cb      	beq.n	8021ed2 <HAL_GPIO_Init+0xba>
        temp = SYSCFG->EXTICR[position >> 2u];
 8021f3a:	089a      	lsrs	r2, r3, #2
 8021f3c:	1c94      	adds	r4, r2, #2
 8021f3e:	00a4      	lsls	r4, r4, #2
 8021f40:	4e0b      	ldr	r6, [pc, #44]	@ (8021f70 <HAL_GPIO_Init+0x158>)
 8021f42:	59a7      	ldr	r7, [r4, r6]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 8021f44:	2403      	movs	r4, #3
 8021f46:	401c      	ands	r4, r3
 8021f48:	00a4      	lsls	r4, r4, #2
 8021f4a:	2607      	movs	r6, #7
 8021f4c:	40a6      	lsls	r6, r4
 8021f4e:	43b7      	bics	r7, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8021f50:	2690      	movs	r6, #144	@ 0x90
 8021f52:	05f6      	lsls	r6, r6, #23
 8021f54:	42b0      	cmp	r0, r6
 8021f56:	d087      	beq.n	8021e68 <HAL_GPIO_Init+0x50>
 8021f58:	4e07      	ldr	r6, [pc, #28]	@ (8021f78 <HAL_GPIO_Init+0x160>)
 8021f5a:	42b0      	cmp	r0, r6
 8021f5c:	d005      	beq.n	8021f6a <HAL_GPIO_Init+0x152>
 8021f5e:	4e07      	ldr	r6, [pc, #28]	@ (8021f7c <HAL_GPIO_Init+0x164>)
 8021f60:	42b0      	cmp	r0, r6
 8021f62:	d100      	bne.n	8021f66 <HAL_GPIO_Init+0x14e>
 8021f64:	e77e      	b.n	8021e64 <HAL_GPIO_Init+0x4c>
 8021f66:	2607      	movs	r6, #7
 8021f68:	e77f      	b.n	8021e6a <HAL_GPIO_Init+0x52>
 8021f6a:	2601      	movs	r6, #1
 8021f6c:	e77d      	b.n	8021e6a <HAL_GPIO_Init+0x52>
  }
}
 8021f6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021f70:	40010000 	.word	0x40010000
 8021f74:	58000800 	.word	0x58000800
 8021f78:	48000400 	.word	0x48000400
 8021f7c:	48000800 	.word	0x48000800

08021f80 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8021f80:	2a00      	cmp	r2, #0
 8021f82:	d001      	beq.n	8021f88 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8021f84:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8021f86:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8021f88:	6281      	str	r1, [r0, #40]	@ 0x28
}
 8021f8a:	e7fc      	b.n	8021f86 <HAL_GPIO_WritePin+0x6>

08021f8c <HAL_IPCC_RxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_RxCallback can be implemented in the user file
   */
}
 8021f8c:	4770      	bx	lr

08021f8e <HAL_IPCC_TxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_TxCallback can be implemented in the user file
   */
}
 8021f8e:	4770      	bx	lr

08021f90 <HAL_IPCC_TX_IRQHandler>:
{
 8021f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021f92:	0007      	movs	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_TX_BUF;
 8021f94:	4b12      	ldr	r3, [pc, #72]	@ (8021fe0 <HAL_IPCC_TX_IRQHandler+0x50>)
 8021f96:	685a      	ldr	r2, [r3, #4]
 8021f98:	26fc      	movs	r6, #252	@ 0xfc
 8021f9a:	03b6      	lsls	r6, r6, #14
 8021f9c:	4396      	bics	r6, r2
  irqmask = irqmask & ~(currentInstance->SR << IPCC_MR_CH1FM_Pos);
 8021f9e:	68db      	ldr	r3, [r3, #12]
 8021fa0:	041b      	lsls	r3, r3, #16
 8021fa2:	439e      	bics	r6, r3
  uint32_t ch_count = 0U;
 8021fa4:	2500      	movs	r5, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8021fa6:	e005      	b.n	8021fb4 <HAL_IPCC_TX_IRQHandler+0x24>
        hipcc->ChannelCallbackTx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_TX);
 8021fa8:	2200      	movs	r2, #0
 8021faa:	0029      	movs	r1, r5
 8021fac:	0038      	movs	r0, r7
 8021fae:	4798      	blx	r3
      irqmask =  irqmask & ~(bit_pos);
 8021fb0:	43a6      	bics	r6, r4
    ch_count++;
 8021fb2:	3501      	adds	r5, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8021fb4:	2e00      	cmp	r6, #0
 8021fb6:	d011      	beq.n	8021fdc <HAL_IPCC_TX_IRQHandler+0x4c>
    bit_pos = 1UL << (IPCC_MR_CH1FM_Pos + (ch_count & CHANNEL_INDEX_Msk));
 8021fb8:	230f      	movs	r3, #15
 8021fba:	402b      	ands	r3, r5
 8021fbc:	3310      	adds	r3, #16
 8021fbe:	2401      	movs	r4, #1
 8021fc0:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 8021fc2:	4234      	tst	r4, r6
 8021fc4:	d0f5      	beq.n	8021fb2 <HAL_IPCC_TX_IRQHandler+0x22>
      currentInstance->MR |= bit_pos;
 8021fc6:	4a06      	ldr	r2, [pc, #24]	@ (8021fe0 <HAL_IPCC_TX_IRQHandler+0x50>)
 8021fc8:	6853      	ldr	r3, [r2, #4]
 8021fca:	4323      	orrs	r3, r4
 8021fcc:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackTx[ch_count] != NULL)
 8021fce:	1dab      	adds	r3, r5, #6
 8021fd0:	009b      	lsls	r3, r3, #2
 8021fd2:	18fb      	adds	r3, r7, r3
 8021fd4:	685b      	ldr	r3, [r3, #4]
 8021fd6:	2b00      	cmp	r3, #0
 8021fd8:	d1e6      	bne.n	8021fa8 <HAL_IPCC_TX_IRQHandler+0x18>
 8021fda:	e7e9      	b.n	8021fb0 <HAL_IPCC_TX_IRQHandler+0x20>
}
 8021fdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021fde:	46c0      	nop			@ (mov r8, r8)
 8021fe0:	58000c10 	.word	0x58000c10

08021fe4 <HAL_IPCC_RX_IRQHandler>:
{
 8021fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021fe6:	0007      	movs	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_RX_BUF;
 8021fe8:	4b10      	ldr	r3, [pc, #64]	@ (802202c <HAL_IPCC_RX_IRQHandler+0x48>)
 8021fea:	685b      	ldr	r3, [r3, #4]
 8021fec:	263f      	movs	r6, #63	@ 0x3f
 8021fee:	439e      	bics	r6, r3
  irqmask = irqmask & otherInstance->SR;
 8021ff0:	4b0f      	ldr	r3, [pc, #60]	@ (8022030 <HAL_IPCC_RX_IRQHandler+0x4c>)
 8021ff2:	68db      	ldr	r3, [r3, #12]
 8021ff4:	401e      	ands	r6, r3
  uint32_t ch_count = 0U;
 8021ff6:	2500      	movs	r5, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8021ff8:	e005      	b.n	8022006 <HAL_IPCC_RX_IRQHandler+0x22>
        hipcc->ChannelCallbackRx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_RX);
 8021ffa:	2201      	movs	r2, #1
 8021ffc:	0029      	movs	r1, r5
 8021ffe:	0038      	movs	r0, r7
 8022000:	4798      	blx	r3
      irqmask = irqmask & ~(bit_pos);
 8022002:	43a6      	bics	r6, r4
    ch_count++;
 8022004:	3501      	adds	r5, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8022006:	2e00      	cmp	r6, #0
 8022008:	d00f      	beq.n	802202a <HAL_IPCC_RX_IRQHandler+0x46>
    bit_pos = 1UL << (ch_count & CHANNEL_INDEX_Msk);
 802200a:	230f      	movs	r3, #15
 802200c:	402b      	ands	r3, r5
 802200e:	2401      	movs	r4, #1
 8022010:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 8022012:	4234      	tst	r4, r6
 8022014:	d0f6      	beq.n	8022004 <HAL_IPCC_RX_IRQHandler+0x20>
      currentInstance->MR |= bit_pos;
 8022016:	4a05      	ldr	r2, [pc, #20]	@ (802202c <HAL_IPCC_RX_IRQHandler+0x48>)
 8022018:	6853      	ldr	r3, [r2, #4]
 802201a:	4323      	orrs	r3, r4
 802201c:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackRx[ch_count] != NULL)
 802201e:	00ab      	lsls	r3, r5, #2
 8022020:	18fb      	adds	r3, r7, r3
 8022022:	685b      	ldr	r3, [r3, #4]
 8022024:	2b00      	cmp	r3, #0
 8022026:	d1e8      	bne.n	8021ffa <HAL_IPCC_RX_IRQHandler+0x16>
 8022028:	e7eb      	b.n	8022002 <HAL_IPCC_RX_IRQHandler+0x1e>
}
 802202a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802202c:	58000c10 	.word	0x58000c10
 8022030:	58000c00 	.word	0x58000c00

08022034 <IPCC_UnmaskInterrupt>:
  *            @arg IPCC_CHANNEL_5: IPCC Channel 5
  *            @arg IPCC_CHANNEL_6: IPCC Channel 6
  * @param  ChannelDir Channel direction
  */
void IPCC_UnmaskInterrupt(uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 8022034:	b510      	push	{r4, lr}
#if defined(CORE_CM0PLUS)
  IPCC_CommonTypeDef *currentInstance = IPCC_C2;
#else
  IPCC_CommonTypeDef *currentInstance = IPCC_C1;
#endif
  if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 8022036:	2900      	cmp	r1, #0
 8022038:	d109      	bne.n	802204e <IPCC_UnmaskInterrupt+0x1a>
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 802203a:	4c09      	ldr	r4, [pc, #36]	@ (8022060 <IPCC_UnmaskInterrupt+0x2c>)
 802203c:	6863      	ldr	r3, [r4, #4]
 802203e:	310f      	adds	r1, #15
 8022040:	4001      	ands	r1, r0
 8022042:	2280      	movs	r2, #128	@ 0x80
 8022044:	0252      	lsls	r2, r2, #9
 8022046:	408a      	lsls	r2, r1
 8022048:	4393      	bics	r3, r2
 802204a:	6063      	str	r3, [r4, #4]
  else
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
  }
}
 802204c:	bd10      	pop	{r4, pc}
    currentInstance->MR &= ~(IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 802204e:	4c04      	ldr	r4, [pc, #16]	@ (8022060 <IPCC_UnmaskInterrupt+0x2c>)
 8022050:	6863      	ldr	r3, [r4, #4]
 8022052:	210f      	movs	r1, #15
 8022054:	4001      	ands	r1, r0
 8022056:	2201      	movs	r2, #1
 8022058:	408a      	lsls	r2, r1
 802205a:	4393      	bics	r3, r2
 802205c:	6063      	str	r3, [r4, #4]
}
 802205e:	e7f5      	b.n	802204c <IPCC_UnmaskInterrupt+0x18>
 8022060:	58000c10 	.word	0x58000c10

08022064 <HAL_IPCC_ActivateNotification>:
{
 8022064:	b570      	push	{r4, r5, r6, lr}
 8022066:	000c      	movs	r4, r1
  if (hipcc != NULL)
 8022068:	2800      	cmp	r0, #0
 802206a:	d028      	beq.n	80220be <HAL_IPCC_ActivateNotification+0x5a>
    if (hipcc->State == HAL_IPCC_STATE_READY)
 802206c:	2138      	movs	r1, #56	@ 0x38
 802206e:	5c41      	ldrb	r1, [r0, r1]
 8022070:	2901      	cmp	r1, #1
 8022072:	d001      	beq.n	8022078 <HAL_IPCC_ActivateNotification+0x14>
      err = HAL_ERROR;
 8022074:	2001      	movs	r0, #1
}
 8022076:	bd70      	pop	{r4, r5, r6, pc}
      if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 8022078:	2a00      	cmp	r2, #0
 802207a:	d10f      	bne.n	802209c <HAL_IPCC_ActivateNotification+0x38>
        hipcc->ChannelCallbackTx[ChannelIndex] = cb;
 802207c:	1da1      	adds	r1, r4, #6
 802207e:	0089      	lsls	r1, r1, #2
 8022080:	1841      	adds	r1, r0, r1
 8022082:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 8022084:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8022086:	250f      	movs	r5, #15
 8022088:	4025      	ands	r5, r4
 802208a:	2180      	movs	r1, #128	@ 0x80
 802208c:	0249      	lsls	r1, r1, #9
 802208e:	40a9      	lsls	r1, r5
 8022090:	430b      	orrs	r3, r1
 8022092:	6343      	str	r3, [r0, #52]	@ 0x34
      if (ChannelDir == IPCC_CHANNEL_DIR_RX)
 8022094:	2a01      	cmp	r2, #1
 8022096:	d00c      	beq.n	80220b2 <HAL_IPCC_ActivateNotification+0x4e>
  HAL_StatusTypeDef err = HAL_OK;
 8022098:	2000      	movs	r0, #0
 802209a:	e7ec      	b.n	8022076 <HAL_IPCC_ActivateNotification+0x12>
        hipcc->ChannelCallbackRx[ChannelIndex] = cb;
 802209c:	00a1      	lsls	r1, r4, #2
 802209e:	1841      	adds	r1, r0, r1
 80220a0:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80220a2:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80220a4:	250f      	movs	r5, #15
 80220a6:	4025      	ands	r5, r4
 80220a8:	2101      	movs	r1, #1
 80220aa:	40a9      	lsls	r1, r5
 80220ac:	430b      	orrs	r3, r1
 80220ae:	6343      	str	r3, [r0, #52]	@ 0x34
 80220b0:	e7f0      	b.n	8022094 <HAL_IPCC_ActivateNotification+0x30>
        IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 80220b2:	0011      	movs	r1, r2
 80220b4:	0020      	movs	r0, r4
 80220b6:	f7ff ffbd 	bl	8022034 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 80220ba:	2000      	movs	r0, #0
 80220bc:	e7db      	b.n	8022076 <HAL_IPCC_ActivateNotification+0x12>
    err = HAL_ERROR;
 80220be:	2001      	movs	r0, #1
 80220c0:	e7d9      	b.n	8022076 <HAL_IPCC_ActivateNotification+0x12>
	...

080220c4 <HAL_IPCC_NotifyCPU>:
{
 80220c4:	b570      	push	{r4, r5, r6, lr}
 80220c6:	000b      	movs	r3, r1
  if (hipcc->State == HAL_IPCC_STATE_READY)
 80220c8:	2438      	movs	r4, #56	@ 0x38
 80220ca:	5d04      	ldrb	r4, [r0, r4]
 80220cc:	2c01      	cmp	r4, #1
 80220ce:	d001      	beq.n	80220d4 <HAL_IPCC_NotifyCPU+0x10>
    err = HAL_ERROR;
 80220d0:	2001      	movs	r0, #1
}
 80220d2:	bd70      	pop	{r4, r5, r6, pc}
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 80220d4:	490c      	ldr	r1, [pc, #48]	@ (8022108 <HAL_IPCC_NotifyCPU+0x44>)
 80220d6:	6889      	ldr	r1, [r1, #8]
 80220d8:	2a00      	cmp	r2, #0
 80220da:	d10d      	bne.n	80220f8 <HAL_IPCC_NotifyCPU+0x34>
 80220dc:	2480      	movs	r4, #128	@ 0x80
 80220de:	0264      	lsls	r4, r4, #9
 80220e0:	250f      	movs	r5, #15
 80220e2:	401d      	ands	r5, r3
 80220e4:	40ac      	lsls	r4, r5
 80220e6:	4321      	orrs	r1, r4
 80220e8:	4d07      	ldr	r5, [pc, #28]	@ (8022108 <HAL_IPCC_NotifyCPU+0x44>)
 80220ea:	60a9      	str	r1, [r5, #8]
    if ((hipcc->callbackRequest & mask) == mask)
 80220ec:	6b41      	ldr	r1, [r0, #52]	@ 0x34
 80220ee:	4021      	ands	r1, r4
 80220f0:	428c      	cmp	r4, r1
 80220f2:	d003      	beq.n	80220fc <HAL_IPCC_NotifyCPU+0x38>
  HAL_StatusTypeDef err = HAL_OK;
 80220f4:	2000      	movs	r0, #0
 80220f6:	e7ec      	b.n	80220d2 <HAL_IPCC_NotifyCPU+0xe>
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 80220f8:	2401      	movs	r4, #1
 80220fa:	e7f1      	b.n	80220e0 <HAL_IPCC_NotifyCPU+0x1c>
      IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 80220fc:	0011      	movs	r1, r2
 80220fe:	0018      	movs	r0, r3
 8022100:	f7ff ff98 	bl	8022034 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 8022104:	2000      	movs	r0, #0
 8022106:	e7e4      	b.n	80220d2 <HAL_IPCC_NotifyCPU+0xe>
 8022108:	58000c10 	.word	0x58000c10

0802210c <IPCC_SetDefaultCallbacks>:
  */
void IPCC_SetDefaultCallbacks(IPCC_HandleTypeDef *hipcc)
{
  uint32_t i;
  /* Set all callbacks to default */
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 802210c:	2200      	movs	r2, #0
 802210e:	e009      	b.n	8022124 <IPCC_SetDefaultCallbacks+0x18>
  {
    hipcc->ChannelCallbackRx[i] = HAL_IPCC_RxCallback;
 8022110:	0093      	lsls	r3, r2, #2
 8022112:	18c3      	adds	r3, r0, r3
 8022114:	4905      	ldr	r1, [pc, #20]	@ (802212c <IPCC_SetDefaultCallbacks+0x20>)
 8022116:	6059      	str	r1, [r3, #4]
    hipcc->ChannelCallbackTx[i] = HAL_IPCC_TxCallback;
 8022118:	1d93      	adds	r3, r2, #6
 802211a:	009b      	lsls	r3, r3, #2
 802211c:	18c3      	adds	r3, r0, r3
 802211e:	4904      	ldr	r1, [pc, #16]	@ (8022130 <IPCC_SetDefaultCallbacks+0x24>)
 8022120:	6059      	str	r1, [r3, #4]
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8022122:	3201      	adds	r2, #1
 8022124:	2a05      	cmp	r2, #5
 8022126:	d9f3      	bls.n	8022110 <IPCC_SetDefaultCallbacks+0x4>
  }
}
 8022128:	4770      	bx	lr
 802212a:	46c0      	nop			@ (mov r8, r8)
 802212c:	08021f8d 	.word	0x08021f8d
 8022130:	08021f8f 	.word	0x08021f8f

08022134 <IPCC_Reset_Register>:
  * @param  Instance pointer to register
  */
void IPCC_Reset_Register(IPCC_CommonTypeDef *Instance)
{
  /* Disable RX and TX interrupts */
  Instance->CR  = 0x00000000U;
 8022134:	2300      	movs	r3, #0
 8022136:	6003      	str	r3, [r0, #0]

  /* Mask RX and TX interrupts */
  Instance->MR  = (IPCC_ALL_TX_BUF | IPCC_ALL_RX_BUF);
 8022138:	4b02      	ldr	r3, [pc, #8]	@ (8022144 <IPCC_Reset_Register+0x10>)
 802213a:	6043      	str	r3, [r0, #4]

  /* Clear RX status */
  Instance->SCR = IPCC_ALL_RX_BUF;
 802213c:	233f      	movs	r3, #63	@ 0x3f
 802213e:	6083      	str	r3, [r0, #8]
}
 8022140:	4770      	bx	lr
 8022142:	46c0      	nop			@ (mov r8, r8)
 8022144:	003f003f 	.word	0x003f003f

08022148 <HAL_IPCC_Init>:
{
 8022148:	b570      	push	{r4, r5, r6, lr}
 802214a:	1e04      	subs	r4, r0, #0
  if (hipcc != NULL)
 802214c:	d018      	beq.n	8022180 <HAL_IPCC_Init+0x38>
    if (hipcc->State == HAL_IPCC_STATE_RESET)
 802214e:	2338      	movs	r3, #56	@ 0x38
 8022150:	5cc3      	ldrb	r3, [r0, r3]
 8022152:	2b00      	cmp	r3, #0
 8022154:	d011      	beq.n	802217a <HAL_IPCC_Init+0x32>
    IPCC_Reset_Register(currentInstance);
 8022156:	4d0b      	ldr	r5, [pc, #44]	@ (8022184 <HAL_IPCC_Init+0x3c>)
 8022158:	0028      	movs	r0, r5
 802215a:	f7ff ffeb 	bl	8022134 <IPCC_Reset_Register>
    currentInstance->CR |= (IPCC_CR_RXOIE | IPCC_CR_TXFIE);
 802215e:	682a      	ldr	r2, [r5, #0]
 8022160:	4b09      	ldr	r3, [pc, #36]	@ (8022188 <HAL_IPCC_Init+0x40>)
 8022162:	4313      	orrs	r3, r2
 8022164:	602b      	str	r3, [r5, #0]
    IPCC_SetDefaultCallbacks(hipcc);
 8022166:	0020      	movs	r0, r4
 8022168:	f7ff ffd0 	bl	802210c <IPCC_SetDefaultCallbacks>
    hipcc->callbackRequest = 0;
 802216c:	2300      	movs	r3, #0
 802216e:	6363      	str	r3, [r4, #52]	@ 0x34
    hipcc->State = HAL_IPCC_STATE_READY;
 8022170:	3338      	adds	r3, #56	@ 0x38
 8022172:	2201      	movs	r2, #1
 8022174:	54e2      	strb	r2, [r4, r3]
  HAL_StatusTypeDef err = HAL_OK;
 8022176:	2000      	movs	r0, #0
}
 8022178:	bd70      	pop	{r4, r5, r6, pc}
      HAL_IPCC_MspInit(hipcc);
 802217a:	f7fe fac1 	bl	8020700 <HAL_IPCC_MspInit>
 802217e:	e7ea      	b.n	8022156 <HAL_IPCC_Init+0xe>
    err = HAL_ERROR;
 8022180:	2001      	movs	r0, #1
 8022182:	e7f9      	b.n	8022178 <HAL_IPCC_Init+0x30>
 8022184:	58000c10 	.word	0x58000c10
 8022188:	00010001 	.word	0x00010001

0802218c <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 802218c:	4a03      	ldr	r2, [pc, #12]	@ (802219c <HAL_PWR_EnableBkUpAccess+0x10>)
 802218e:	6811      	ldr	r1, [r2, #0]
 8022190:	2380      	movs	r3, #128	@ 0x80
 8022192:	005b      	lsls	r3, r3, #1
 8022194:	430b      	orrs	r3, r1
 8022196:	6013      	str	r3, [r2, #0]
}
 8022198:	4770      	bx	lr
 802219a:	46c0      	nop			@ (mov r8, r8)
 802219c:	58000400 	.word	0x58000400

080221a0 <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as
  *        the interrupt wake up source.
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 80221a0:	b510      	push	{r4, lr}
 80221a2:	000c      	movs	r4, r1
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 80221a4:	2800      	cmp	r0, #0
 80221a6:	d113      	bne.n	80221d0 <HAL_PWR_EnterSLEEPMode+0x30>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 80221a8:	4b0e      	ldr	r3, [pc, #56]	@ (80221e4 <HAL_PWR_EnterSLEEPMode+0x44>)
 80221aa:	695b      	ldr	r3, [r3, #20]
 80221ac:	059b      	lsls	r3, r3, #22
 80221ae:	d40a      	bmi.n	80221c6 <HAL_PWR_EnterSLEEPMode+0x26>
      HAL_PWREx_EnableLowPowerRunMode();
    }
  }

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80221b0:	4a0d      	ldr	r2, [pc, #52]	@ (80221e8 <HAL_PWR_EnterSLEEPMode+0x48>)
 80221b2:	6913      	ldr	r3, [r2, #16]
 80221b4:	2104      	movs	r1, #4
 80221b6:	438b      	bics	r3, r1
 80221b8:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry -------------------------------------------------*/
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 80221ba:	2c01      	cmp	r4, #1
 80221bc:	d00f      	beq.n	80221de <HAL_PWR_EnterSLEEPMode+0x3e>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 80221be:	bf40      	sev
    __WFE();
 80221c0:	bf20      	wfe
    __WFE();
 80221c2:	bf20      	wfe
  }
}
 80221c4:	bd10      	pop	{r4, pc}
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 80221c6:	f000 f81b 	bl	8022200 <HAL_PWREx_DisableLowPowerRunMode>
 80221ca:	2800      	cmp	r0, #0
 80221cc:	d0f0      	beq.n	80221b0 <HAL_PWR_EnterSLEEPMode+0x10>
 80221ce:	e7f9      	b.n	80221c4 <HAL_PWR_EnterSLEEPMode+0x24>
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 80221d0:	4b04      	ldr	r3, [pc, #16]	@ (80221e4 <HAL_PWR_EnterSLEEPMode+0x44>)
 80221d2:	695b      	ldr	r3, [r3, #20]
 80221d4:	059b      	lsls	r3, r3, #22
 80221d6:	d4eb      	bmi.n	80221b0 <HAL_PWR_EnterSLEEPMode+0x10>
      HAL_PWREx_EnableLowPowerRunMode();
 80221d8:	f000 f808 	bl	80221ec <HAL_PWREx_EnableLowPowerRunMode>
 80221dc:	e7e8      	b.n	80221b0 <HAL_PWR_EnterSLEEPMode+0x10>
    __WFI();
 80221de:	bf30      	wfi
 80221e0:	e7f0      	b.n	80221c4 <HAL_PWR_EnterSLEEPMode+0x24>
 80221e2:	46c0      	nop			@ (mov r8, r8)
 80221e4:	58000400 	.word	0x58000400
 80221e8:	e000ed00 	.word	0xe000ed00

080221ec <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 80221ec:	4a03      	ldr	r2, [pc, #12]	@ (80221fc <HAL_PWREx_EnableLowPowerRunMode+0x10>)
 80221ee:	6811      	ldr	r1, [r2, #0]
 80221f0:	2380      	movs	r3, #128	@ 0x80
 80221f2:	01db      	lsls	r3, r3, #7
 80221f4:	430b      	orrs	r3, r1
 80221f6:	6013      	str	r3, [r2, #0]
}
 80221f8:	4770      	bx	lr
 80221fa:	46c0      	nop			@ (mov r8, r8)
 80221fc:	58000400 	.word	0x58000400

08022200 <HAL_PWREx_DisableLowPowerRunMode>:
  *        returns HAL_TIMEOUT status). The system clock frequency can then be
  *        increased above 2 MHz.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
 8022200:	b510      	push	{r4, lr}
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 8022202:	4a0e      	ldr	r2, [pc, #56]	@ (802223c <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8022204:	6813      	ldr	r3, [r2, #0]
 8022206:	490e      	ldr	r1, [pc, #56]	@ (8022240 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 8022208:	400b      	ands	r3, r1
 802220a:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 802220c:	4b0d      	ldr	r3, [pc, #52]	@ (8022244 <HAL_PWREx_DisableLowPowerRunMode+0x44>)
 802220e:	6818      	ldr	r0, [r3, #0]
 8022210:	2332      	movs	r3, #50	@ 0x32
 8022212:	4358      	muls	r0, r3
 8022214:	490c      	ldr	r1, [pc, #48]	@ (8022248 <HAL_PWREx_DisableLowPowerRunMode+0x48>)
 8022216:	f7fd ff7f 	bl	8020118 <__udivsi3>
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 802221a:	e000      	b.n	802221e <HAL_PWREx_DisableLowPowerRunMode+0x1e>
  {
    wait_loop_index--;
 802221c:	3801      	subs	r0, #1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 802221e:	4b07      	ldr	r3, [pc, #28]	@ (802223c <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8022220:	695b      	ldr	r3, [r3, #20]
 8022222:	059b      	lsls	r3, r3, #22
 8022224:	d501      	bpl.n	802222a <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 8022226:	2800      	cmp	r0, #0
 8022228:	d1f8      	bne.n	802221c <HAL_PWREx_DisableLowPowerRunMode+0x1c>
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802222a:	4b04      	ldr	r3, [pc, #16]	@ (802223c <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 802222c:	695b      	ldr	r3, [r3, #20]
 802222e:	059b      	lsls	r3, r3, #22
 8022230:	d401      	bmi.n	8022236 <HAL_PWREx_DisableLowPowerRunMode+0x36>
  {
    return HAL_TIMEOUT;
  }

  return HAL_OK;
 8022232:	2000      	movs	r0, #0
}
 8022234:	bd10      	pop	{r4, pc}
    return HAL_TIMEOUT;
 8022236:	2003      	movs	r0, #3
 8022238:	e7fc      	b.n	8022234 <HAL_PWREx_DisableLowPowerRunMode+0x34>
 802223a:	46c0      	nop			@ (mov r8, r8)
 802223c:	58000400 	.word	0x58000400
 8022240:	ffffbfff 	.word	0xffffbfff
 8022244:	2000a000 	.word	0x2000a000
 8022248:	000f4240 	.word	0x000f4240

0802224c <HAL_PWREx_EnterSTOP2Mode>:
  *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop mode with WFI instruction
  *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop mode with WFE instruction
  * @retval None
  */
void HAL_PWREx_EnterSTOP2Mode(uint8_t STOPEntry)
{
 802224c:	b510      	push	{r4, lr}
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 802224e:	490d      	ldr	r1, [pc, #52]	@ (8022284 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 8022250:	2280      	movs	r2, #128	@ 0x80
 8022252:	588b      	ldr	r3, [r1, r2]
 8022254:	2407      	movs	r4, #7
 8022256:	43a3      	bics	r3, r4
 8022258:	3c05      	subs	r4, #5
 802225a:	4323      	orrs	r3, r4
 802225c:	508b      	str	r3, [r1, r2]
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802225e:	4a0a      	ldr	r2, [pc, #40]	@ (8022288 <HAL_PWREx_EnterSTOP2Mode+0x3c>)
 8022260:	6913      	ldr	r3, [r2, #16]
 8022262:	2104      	movs	r1, #4
 8022264:	430b      	orrs	r3, r1
 8022266:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 8022268:	2801      	cmp	r0, #1
 802226a:	d008      	beq.n	802227e <HAL_PWREx_EnterSTOP2Mode+0x32>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 802226c:	bf40      	sev
    __WFE();
 802226e:	bf20      	wfe
    __WFE();
 8022270:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8022272:	4a05      	ldr	r2, [pc, #20]	@ (8022288 <HAL_PWREx_EnterSTOP2Mode+0x3c>)
 8022274:	6913      	ldr	r3, [r2, #16]
 8022276:	2104      	movs	r1, #4
 8022278:	438b      	bics	r3, r1
 802227a:	6113      	str	r3, [r2, #16]
}
 802227c:	bd10      	pop	{r4, pc}
    __WFI();
 802227e:	bf30      	wfi
 8022280:	e7f7      	b.n	8022272 <HAL_PWREx_EnterSTOP2Mode+0x26>
 8022282:	46c0      	nop			@ (mov r8, r8)
 8022284:	58000400 	.word	0x58000400
 8022288:	e000ed00 	.word	0xe000ed00

0802228c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 802228c:	b510      	push	{r4, lr}
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802228e:	23b0      	movs	r3, #176	@ 0xb0
 8022290:	05db      	lsls	r3, r3, #23
 8022292:	689a      	ldr	r2, [r3, #8]
 8022294:	210c      	movs	r1, #12
 8022296:	000c      	movs	r4, r1
 8022298:	4014      	ands	r4, r2
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802229a:	68d8      	ldr	r0, [r3, #12]
 802229c:	2303      	movs	r3, #3
 802229e:	4003      	ands	r3, r0
  uint32_t pllinputfreq;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
  pllsource = __HAL_RCC_GET_PLL_OSCSOURCE();

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80222a0:	4211      	tst	r1, r2
 80222a2:	d00a      	beq.n	80222ba <HAL_RCC_GetSysClockFreq+0x2e>
 80222a4:	2c0c      	cmp	r4, #12
 80222a6:	d006      	beq.n	80222b6 <HAL_RCC_GetSysClockFreq+0x2a>
    {
      /* MSI used as system clock source */
      sysclockfreq = msifreq;
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80222a8:	2c04      	cmp	r4, #4
 80222aa:	d04f      	beq.n	802234c <HAL_RCC_GetSysClockFreq+0xc0>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 80222ac:	2c08      	cmp	r4, #8
 80222ae:	d040      	beq.n	8022332 <HAL_RCC_GetSysClockFreq+0xa6>
  uint32_t msifreq = 0U;
 80222b0:	2100      	movs	r1, #0
  uint32_t sysclockfreq = 0U;
 80222b2:	2000      	movs	r0, #0
 80222b4:	e02a      	b.n	802230c <HAL_RCC_GetSysClockFreq+0x80>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 80222b6:	2b01      	cmp	r3, #1
 80222b8:	d1f6      	bne.n	80222a8 <HAL_RCC_GetSysClockFreq+0x1c>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 80222ba:	23b0      	movs	r3, #176	@ 0xb0
 80222bc:	05db      	lsls	r3, r3, #23
 80222be:	681a      	ldr	r2, [r3, #0]
 80222c0:	2108      	movs	r1, #8
 80222c2:	000b      	movs	r3, r1
 80222c4:	4013      	ands	r3, r2
 80222c6:	4211      	tst	r1, r2
 80222c8:	d00e      	beq.n	80222e8 <HAL_RCC_GetSysClockFreq+0x5c>
 80222ca:	23b0      	movs	r3, #176	@ 0xb0
 80222cc:	05db      	lsls	r3, r3, #23
 80222ce:	681a      	ldr	r2, [r3, #0]
 80222d0:	000b      	movs	r3, r1
 80222d2:	4013      	ands	r3, r2
 80222d4:	4211      	tst	r1, r2
 80222d6:	d125      	bne.n	8022324 <HAL_RCC_GetSysClockFreq+0x98>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80222d8:	21b0      	movs	r1, #176	@ 0xb0
 80222da:	05c9      	lsls	r1, r1, #23
 80222dc:	2294      	movs	r2, #148	@ 0x94
 80222de:	588a      	ldr	r2, [r1, r2]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 80222e0:	4a31      	ldr	r2, [pc, #196]	@ (80223a8 <HAL_RCC_GetSysClockFreq+0x11c>)
 80222e2:	009b      	lsls	r3, r3, #2
 80222e4:	5899      	ldr	r1, [r3, r2]
 80222e6:	e00e      	b.n	8022306 <HAL_RCC_GetSysClockFreq+0x7a>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 80222e8:	22b0      	movs	r2, #176	@ 0xb0
 80222ea:	05d2      	lsls	r2, r2, #23
 80222ec:	6812      	ldr	r2, [r2, #0]
 80222ee:	0712      	lsls	r2, r2, #28
 80222f0:	d414      	bmi.n	802231c <HAL_RCC_GetSysClockFreq+0x90>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80222f2:	22b0      	movs	r2, #176	@ 0xb0
 80222f4:	05d2      	lsls	r2, r2, #23
 80222f6:	2394      	movs	r3, #148	@ 0x94
 80222f8:	58d2      	ldr	r2, [r2, r3]
 80222fa:	0a12      	lsrs	r2, r2, #8
 80222fc:	3b85      	subs	r3, #133	@ 0x85
 80222fe:	4013      	ands	r3, r2
 8022300:	4a29      	ldr	r2, [pc, #164]	@ (80223a8 <HAL_RCC_GetSysClockFreq+0x11c>)
 8022302:	009b      	lsls	r3, r3, #2
 8022304:	5899      	ldr	r1, [r3, r2]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8022306:	2c00      	cmp	r4, #0
 8022308:	d01e      	beq.n	8022348 <HAL_RCC_GetSysClockFreq+0xbc>
  uint32_t sysclockfreq = 0U;
 802230a:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802230c:	23b0      	movs	r3, #176	@ 0xb0
 802230e:	05db      	lsls	r3, r3, #23
 8022310:	689a      	ldr	r2, [r3, #8]
 8022312:	230c      	movs	r3, #12
 8022314:	4013      	ands	r3, r2
  else
  {
    /* Nothing to do */
  }

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8022316:	2b0c      	cmp	r3, #12
 8022318:	d01e      	beq.n	8022358 <HAL_RCC_GetSysClockFreq+0xcc>
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
                                             LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
}
 802231a:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802231c:	22b0      	movs	r2, #176	@ 0xb0
 802231e:	05d2      	lsls	r2, r2, #23
 8022320:	6812      	ldr	r2, [r2, #0]
 8022322:	e7ed      	b.n	8022300 <HAL_RCC_GetSysClockFreq+0x74>
 8022324:	23b0      	movs	r3, #176	@ 0xb0
 8022326:	05db      	lsls	r3, r3, #23
 8022328:	681a      	ldr	r2, [r3, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802232a:	0912      	lsrs	r2, r2, #4
 802232c:	230f      	movs	r3, #15
 802232e:	4013      	ands	r3, r2
 8022330:	e7d6      	b.n	80222e0 <HAL_RCC_GetSysClockFreq+0x54>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8022332:	23b0      	movs	r3, #176	@ 0xb0
 8022334:	05db      	lsls	r3, r3, #23
 8022336:	681a      	ldr	r2, [r3, #0]
 8022338:	2380      	movs	r3, #128	@ 0x80
 802233a:	035b      	lsls	r3, r3, #13
 802233c:	0011      	movs	r1, r2
 802233e:	4019      	ands	r1, r3
 8022340:	421a      	tst	r2, r3
 8022342:	d106      	bne.n	8022352 <HAL_RCC_GetSysClockFreq+0xc6>
      sysclockfreq = HSE_VALUE;
 8022344:	4819      	ldr	r0, [pc, #100]	@ (80223ac <HAL_RCC_GetSysClockFreq+0x120>)
 8022346:	e7e1      	b.n	802230c <HAL_RCC_GetSysClockFreq+0x80>
      sysclockfreq = msifreq;
 8022348:	0008      	movs	r0, r1
 802234a:	e7df      	b.n	802230c <HAL_RCC_GetSysClockFreq+0x80>
  uint32_t msifreq = 0U;
 802234c:	2100      	movs	r1, #0
    sysclockfreq = HSI_VALUE;
 802234e:	4818      	ldr	r0, [pc, #96]	@ (80223b0 <HAL_RCC_GetSysClockFreq+0x124>)
 8022350:	e7dc      	b.n	802230c <HAL_RCC_GetSysClockFreq+0x80>
  uint32_t msifreq = 0U;
 8022352:	2100      	movs	r1, #0
      sysclockfreq = HSE_VALUE / 2U;
 8022354:	4816      	ldr	r0, [pc, #88]	@ (80223b0 <HAL_RCC_GetSysClockFreq+0x124>)
 8022356:	e7d9      	b.n	802230c <HAL_RCC_GetSysClockFreq+0x80>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8022358:	23b0      	movs	r3, #176	@ 0xb0
 802235a:	05db      	lsls	r3, r3, #23
 802235c:	68da      	ldr	r2, [r3, #12]
 802235e:	2303      	movs	r3, #3
 8022360:	4013      	ands	r3, r2
    switch (pllsource)
 8022362:	2b02      	cmp	r3, #2
 8022364:	d008      	beq.n	8022378 <HAL_RCC_GetSysClockFreq+0xec>
 8022366:	2b03      	cmp	r3, #3
 8022368:	d107      	bne.n	802237a <HAL_RCC_GetSysClockFreq+0xee>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802236a:	23b0      	movs	r3, #176	@ 0xb0
 802236c:	05db      	lsls	r3, r3, #23
 802236e:	681b      	ldr	r3, [r3, #0]
 8022370:	02db      	lsls	r3, r3, #11
 8022372:	d416      	bmi.n	80223a2 <HAL_RCC_GetSysClockFreq+0x116>
          pllinputfreq = HSE_VALUE;
 8022374:	490d      	ldr	r1, [pc, #52]	@ (80223ac <HAL_RCC_GetSysClockFreq+0x120>)
 8022376:	e000      	b.n	802237a <HAL_RCC_GetSysClockFreq+0xee>
    switch (pllsource)
 8022378:	490d      	ldr	r1, [pc, #52]	@ (80223b0 <HAL_RCC_GetSysClockFreq+0x124>)
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802237a:	24b0      	movs	r4, #176	@ 0xb0
 802237c:	05e4      	lsls	r4, r4, #23
 802237e:	68e3      	ldr	r3, [r4, #12]
 8022380:	0a1b      	lsrs	r3, r3, #8
 8022382:	207f      	movs	r0, #127	@ 0x7f
 8022384:	4018      	ands	r0, r3
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8022386:	4348      	muls	r0, r1
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8022388:	68e3      	ldr	r3, [r4, #12]
 802238a:	091b      	lsrs	r3, r3, #4
 802238c:	2107      	movs	r1, #7
 802238e:	4019      	ands	r1, r3
 8022390:	3101      	adds	r1, #1
 8022392:	f7fd fec1 	bl	8020118 <__udivsi3>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 8022396:	68e1      	ldr	r1, [r4, #12]
 8022398:	0f49      	lsrs	r1, r1, #29
 802239a:	3101      	adds	r1, #1
 802239c:	f7fd febc 	bl	8020118 <__udivsi3>
  return sysclockfreq;
 80223a0:	e7bb      	b.n	802231a <HAL_RCC_GetSysClockFreq+0x8e>
          pllinputfreq = HSE_VALUE / 2U;
 80223a2:	4903      	ldr	r1, [pc, #12]	@ (80223b0 <HAL_RCC_GetSysClockFreq+0x124>)
 80223a4:	e7e9      	b.n	802237a <HAL_RCC_GetSysClockFreq+0xee>
 80223a6:	46c0      	nop			@ (mov r8, r8)
 80223a8:	080264fc 	.word	0x080264fc
 80223ac:	01e84800 	.word	0x01e84800
 80223b0:	00f42400 	.word	0x00f42400

080223b4 <HAL_RCC_GetHCLK2Freq>:
/**
  * @brief  Return the HCLK2 frequency.
  * @retval HCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetHCLK2Freq(void)
{
 80223b4:	b510      	push	{r4, lr}
  /* Get SysClock and Compute HCLK2 frequency --------------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK2_FREQ(HAL_RCC_GetSysClockFreq(), LL_C2_RCC_GetAHBPrescaler())));
 80223b6:	f7ff ff69 	bl	802228c <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 80223ba:	22b0      	movs	r2, #176	@ 0xb0
 80223bc:	05d2      	lsls	r2, r2, #23
 80223be:	2384      	movs	r3, #132	@ 0x84
 80223c0:	005b      	lsls	r3, r3, #1
 80223c2:	58d2      	ldr	r2, [r2, r3]
 80223c4:	0912      	lsrs	r2, r2, #4
 80223c6:	3bf9      	subs	r3, #249	@ 0xf9
 80223c8:	4013      	ands	r3, r2
 80223ca:	4a03      	ldr	r2, [pc, #12]	@ (80223d8 <HAL_RCC_GetHCLK2Freq+0x24>)
 80223cc:	009b      	lsls	r3, r3, #2
 80223ce:	5899      	ldr	r1, [r3, r2]
 80223d0:	f7fd fea2 	bl	8020118 <__udivsi3>
}
 80223d4:	bd10      	pop	{r4, pc}
 80223d6:	46c0      	nop			@ (mov r8, r8)
 80223d8:	0802653c 	.word	0x0802653c

080223dc <LL_RCC_SetI2CClockSource>:
{
 80223dc:	b530      	push	{r4, r5, lr}
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 80223de:	24b0      	movs	r4, #176	@ 0xb0
 80223e0:	05e4      	lsls	r4, r4, #23
 80223e2:	2188      	movs	r1, #136	@ 0x88
 80223e4:	5863      	ldr	r3, [r4, r1]
 80223e6:	0902      	lsrs	r2, r0, #4
 80223e8:	25ff      	movs	r5, #255	@ 0xff
 80223ea:	032d      	lsls	r5, r5, #12
 80223ec:	402a      	ands	r2, r5
 80223ee:	4393      	bics	r3, r2
 80223f0:	0100      	lsls	r0, r0, #4
 80223f2:	4028      	ands	r0, r5
 80223f4:	4303      	orrs	r3, r0
 80223f6:	5063      	str	r3, [r4, r1]
}
 80223f8:	bd30      	pop	{r4, r5, pc}
	...

080223fc <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80223fc:	b570      	push	{r4, r5, r6, lr}
 80223fe:	0004      	movs	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8022400:	6803      	ldr	r3, [r0, #0]
 8022402:	03db      	lsls	r3, r3, #15
 8022404:	d500      	bpl.n	8022408 <HAL_RCCEx_PeriphCLKConfig+0xc>
 8022406:	e097      	b.n	8022538 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8022408:	2500      	movs	r5, #0
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 802240a:	6823      	ldr	r3, [r4, #0]
 802240c:	07db      	lsls	r3, r3, #31
 802240e:	d50a      	bpl.n	8022426 <HAL_RCCEx_PeriphCLKConfig+0x2a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8022410:	6863      	ldr	r3, [r4, #4]
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 8022412:	20b0      	movs	r0, #176	@ 0xb0
 8022414:	05c0      	lsls	r0, r0, #23
 8022416:	2188      	movs	r1, #136	@ 0x88
 8022418:	5842      	ldr	r2, [r0, r1]
 802241a:	0c1e      	lsrs	r6, r3, #16
 802241c:	43b2      	bics	r2, r6
 802241e:	041b      	lsls	r3, r3, #16
 8022420:	0c1b      	lsrs	r3, r3, #16
 8022422:	4313      	orrs	r3, r2
 8022424:	5043      	str	r3, [r0, r1]
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8022426:	6823      	ldr	r3, [r4, #0]
 8022428:	079b      	lsls	r3, r3, #30
 802242a:	d50a      	bpl.n	8022442 <HAL_RCCEx_PeriphCLKConfig+0x46>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 802242c:	68a3      	ldr	r3, [r4, #8]
 802242e:	20b0      	movs	r0, #176	@ 0xb0
 8022430:	05c0      	lsls	r0, r0, #23
 8022432:	2188      	movs	r1, #136	@ 0x88
 8022434:	5842      	ldr	r2, [r0, r1]
 8022436:	0c1e      	lsrs	r6, r3, #16
 8022438:	43b2      	bics	r2, r6
 802243a:	041b      	lsls	r3, r3, #16
 802243c:	0c1b      	lsrs	r3, r3, #16
 802243e:	4313      	orrs	r3, r2
 8022440:	5043      	str	r3, [r0, r1]
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8022442:	6823      	ldr	r3, [r4, #0]
 8022444:	069b      	lsls	r3, r3, #26
 8022446:	d508      	bpl.n	802245a <HAL_RCCEx_PeriphCLKConfig+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8022448:	6923      	ldr	r3, [r4, #16]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 802244a:	20b0      	movs	r0, #176	@ 0xb0
 802244c:	05c0      	lsls	r0, r0, #23
 802244e:	2188      	movs	r1, #136	@ 0x88
 8022450:	5842      	ldr	r2, [r0, r1]
 8022452:	4e6d      	ldr	r6, [pc, #436]	@ (8022608 <HAL_RCCEx_PeriphCLKConfig+0x20c>)
 8022454:	4032      	ands	r2, r6
 8022456:	4313      	orrs	r3, r2
 8022458:	5043      	str	r3, [r0, r1]
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 802245a:	6823      	ldr	r3, [r4, #0]
 802245c:	059b      	lsls	r3, r3, #22
 802245e:	d50a      	bpl.n	8022476 <HAL_RCCEx_PeriphCLKConfig+0x7a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8022460:	6a22      	ldr	r2, [r4, #32]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8022462:	26b0      	movs	r6, #176	@ 0xb0
 8022464:	05f6      	lsls	r6, r6, #23
 8022466:	2088      	movs	r0, #136	@ 0x88
 8022468:	5833      	ldr	r3, [r6, r0]
 802246a:	0c11      	lsrs	r1, r2, #16
 802246c:	0409      	lsls	r1, r1, #16
 802246e:	438b      	bics	r3, r1
 8022470:	0412      	lsls	r2, r2, #16
 8022472:	4313      	orrs	r3, r2
 8022474:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8022476:	6823      	ldr	r3, [r4, #0]
 8022478:	055b      	lsls	r3, r3, #21
 802247a:	d50a      	bpl.n	8022492 <HAL_RCCEx_PeriphCLKConfig+0x96>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 802247c:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 802247e:	26b0      	movs	r6, #176	@ 0xb0
 8022480:	05f6      	lsls	r6, r6, #23
 8022482:	2088      	movs	r0, #136	@ 0x88
 8022484:	5833      	ldr	r3, [r6, r0]
 8022486:	0c11      	lsrs	r1, r2, #16
 8022488:	0409      	lsls	r1, r1, #16
 802248a:	438b      	bics	r3, r1
 802248c:	0412      	lsls	r2, r2, #16
 802248e:	4313      	orrs	r3, r2
 8022490:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 8022492:	6823      	ldr	r3, [r4, #0]
 8022494:	051b      	lsls	r3, r3, #20
 8022496:	d50a      	bpl.n	80224ae <HAL_RCCEx_PeriphCLKConfig+0xb2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 8022498:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 802249a:	26b0      	movs	r6, #176	@ 0xb0
 802249c:	05f6      	lsls	r6, r6, #23
 802249e:	2088      	movs	r0, #136	@ 0x88
 80224a0:	5833      	ldr	r3, [r6, r0]
 80224a2:	0c11      	lsrs	r1, r2, #16
 80224a4:	0409      	lsls	r1, r1, #16
 80224a6:	438b      	bics	r3, r1
 80224a8:	0412      	lsls	r2, r2, #16
 80224aa:	4313      	orrs	r3, r2
 80224ac:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80224ae:	6823      	ldr	r3, [r4, #0]
 80224b0:	065b      	lsls	r3, r3, #25
 80224b2:	d500      	bpl.n	80224b6 <HAL_RCCEx_PeriphCLKConfig+0xba>
 80224b4:	e090      	b.n	80225d8 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80224b6:	6823      	ldr	r3, [r4, #0]
 80224b8:	061b      	lsls	r3, r3, #24
 80224ba:	d500      	bpl.n	80224be <HAL_RCCEx_PeriphCLKConfig+0xc2>
 80224bc:	e090      	b.n	80225e0 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80224be:	6823      	ldr	r3, [r4, #0]
 80224c0:	05db      	lsls	r3, r3, #23
 80224c2:	d500      	bpl.n	80224c6 <HAL_RCCEx_PeriphCLKConfig+0xca>
 80224c4:	e090      	b.n	80225e8 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 80224c6:	6823      	ldr	r3, [r4, #0]
 80224c8:	06db      	lsls	r3, r3, #27
 80224ca:	d50e      	bpl.n	80224ea <HAL_RCCEx_PeriphCLKConfig+0xee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 80224cc:	68e3      	ldr	r3, [r4, #12]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 80224ce:	20b0      	movs	r0, #176	@ 0xb0
 80224d0:	05c0      	lsls	r0, r0, #23
 80224d2:	2188      	movs	r1, #136	@ 0x88
 80224d4:	5842      	ldr	r2, [r0, r1]
 80224d6:	4e4d      	ldr	r6, [pc, #308]	@ (802260c <HAL_RCCEx_PeriphCLKConfig+0x210>)
 80224d8:	4032      	ands	r2, r6
 80224da:	4313      	orrs	r3, r2
 80224dc:	5043      	str	r3, [r0, r1]

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 80224de:	68e2      	ldr	r2, [r4, #12]
 80224e0:	2380      	movs	r3, #128	@ 0x80
 80224e2:	005b      	lsls	r3, r3, #1
 80224e4:	429a      	cmp	r2, r3
 80224e6:	d100      	bne.n	80224ea <HAL_RCCEx_PeriphCLKConfig+0xee>
 80224e8:	e082      	b.n	80225f0 <HAL_RCCEx_PeriphCLKConfig+0x1f4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80224ea:	6823      	ldr	r3, [r4, #0]
 80224ec:	041b      	lsls	r3, r3, #16
 80224ee:	d510      	bpl.n	8022512 <HAL_RCCEx_PeriphCLKConfig+0x116>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80224f0:	6b22      	ldr	r2, [r4, #48]	@ 0x30
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 80224f2:	20b0      	movs	r0, #176	@ 0xb0
 80224f4:	05c0      	lsls	r0, r0, #23
 80224f6:	2188      	movs	r1, #136	@ 0x88
 80224f8:	5843      	ldr	r3, [r0, r1]
 80224fa:	009b      	lsls	r3, r3, #2
 80224fc:	089b      	lsrs	r3, r3, #2
 80224fe:	4313      	orrs	r3, r2
 8022500:	5043      	str	r3, [r0, r1]

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8022502:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8022504:	2b00      	cmp	r3, #0
 8022506:	d104      	bne.n	8022512 <HAL_RCCEx_PeriphCLKConfig+0x116>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 8022508:	68c1      	ldr	r1, [r0, #12]
 802250a:	2380      	movs	r3, #128	@ 0x80
 802250c:	045b      	lsls	r3, r3, #17
 802250e:	430b      	orrs	r3, r1
 8022510:	60c3      	str	r3, [r0, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8022512:	6823      	ldr	r3, [r4, #0]
 8022514:	045b      	lsls	r3, r3, #17
 8022516:	d50d      	bpl.n	8022534 <HAL_RCCEx_PeriphCLKConfig+0x138>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8022518:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 802251a:	20b0      	movs	r0, #176	@ 0xb0
 802251c:	05c0      	lsls	r0, r0, #23
 802251e:	2188      	movs	r1, #136	@ 0x88
 8022520:	5842      	ldr	r2, [r0, r1]
 8022522:	4e3b      	ldr	r6, [pc, #236]	@ (8022610 <HAL_RCCEx_PeriphCLKConfig+0x214>)
 8022524:	4032      	ands	r2, r6
 8022526:	4313      	orrs	r3, r2
 8022528:	5043      	str	r3, [r0, r1]

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 802252a:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 802252c:	2380      	movs	r3, #128	@ 0x80
 802252e:	059b      	lsls	r3, r3, #22
 8022530:	429a      	cmp	r2, r3
 8022532:	d063      	beq.n	80225fc <HAL_RCCEx_PeriphCLKConfig+0x200>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
    }
  }

  return status;
}
 8022534:	0028      	movs	r0, r5
 8022536:	bd70      	pop	{r4, r5, r6, pc}
    HAL_PWR_EnableBkUpAccess();
 8022538:	f7ff fe28 	bl	802218c <HAL_PWR_EnableBkUpAccess>
    tickstart = HAL_GetTick();
 802253c:	f7fe fb04 	bl	8020b48 <HAL_GetTick>
 8022540:	0005      	movs	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 8022542:	4b34      	ldr	r3, [pc, #208]	@ (8022614 <HAL_RCCEx_PeriphCLKConfig+0x218>)
 8022544:	681b      	ldr	r3, [r3, #0]
 8022546:	05db      	lsls	r3, r3, #23
 8022548:	d406      	bmi.n	8022558 <HAL_RCCEx_PeriphCLKConfig+0x15c>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802254a:	f7fe fafd 	bl	8020b48 <HAL_GetTick>
 802254e:	1b40      	subs	r0, r0, r5
 8022550:	2802      	cmp	r0, #2
 8022552:	d9f6      	bls.n	8022542 <HAL_RCCEx_PeriphCLKConfig+0x146>
        ret = HAL_TIMEOUT;
 8022554:	2503      	movs	r5, #3
 8022556:	e000      	b.n	802255a <HAL_RCCEx_PeriphCLKConfig+0x15e>
  HAL_StatusTypeDef ret = HAL_OK;   /* Intermediate status */
 8022558:	2500      	movs	r5, #0
    if (ret == HAL_OK)
 802255a:	2d00      	cmp	r5, #0
 802255c:	d000      	beq.n	8022560 <HAL_RCCEx_PeriphCLKConfig+0x164>
 802255e:	e754      	b.n	802240a <HAL_RCCEx_PeriphCLKConfig+0xe>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8022560:	22b0      	movs	r2, #176	@ 0xb0
 8022562:	05d2      	lsls	r2, r2, #23
 8022564:	2390      	movs	r3, #144	@ 0x90
 8022566:	58d3      	ldr	r3, [r2, r3]
 8022568:	22c0      	movs	r2, #192	@ 0xc0
 802256a:	0092      	lsls	r2, r2, #2
 802256c:	4013      	ands	r3, r2
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 802256e:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 8022570:	429a      	cmp	r2, r3
 8022572:	d01e      	beq.n	80225b2 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8022574:	21b0      	movs	r1, #176	@ 0xb0
 8022576:	05c9      	lsls	r1, r1, #23
 8022578:	2290      	movs	r2, #144	@ 0x90
 802257a:	588b      	ldr	r3, [r1, r2]
 802257c:	4823      	ldr	r0, [pc, #140]	@ (802260c <HAL_RCCEx_PeriphCLKConfig+0x210>)
 802257e:	4003      	ands	r3, r0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8022580:	588e      	ldr	r6, [r1, r2]
 8022582:	2080      	movs	r0, #128	@ 0x80
 8022584:	0240      	lsls	r0, r0, #9
 8022586:	4330      	orrs	r0, r6
 8022588:	5088      	str	r0, [r1, r2]
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802258a:	5888      	ldr	r0, [r1, r2]
 802258c:	4e22      	ldr	r6, [pc, #136]	@ (8022618 <HAL_RCCEx_PeriphCLKConfig+0x21c>)
 802258e:	4030      	ands	r0, r6
 8022590:	5088      	str	r0, [r1, r2]
        RCC->BDCR = tmpregister;
 8022592:	508b      	str	r3, [r1, r2]
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8022594:	079b      	lsls	r3, r3, #30
 8022596:	d40e      	bmi.n	80225b6 <HAL_RCCEx_PeriphCLKConfig+0x1ba>
      if (ret == HAL_OK)
 8022598:	2d00      	cmp	r5, #0
 802259a:	d000      	beq.n	802259e <HAL_RCCEx_PeriphCLKConfig+0x1a2>
 802259c:	e735      	b.n	802240a <HAL_RCCEx_PeriphCLKConfig+0xe>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 802259e:	6b63      	ldr	r3, [r4, #52]	@ 0x34
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 80225a0:	20b0      	movs	r0, #176	@ 0xb0
 80225a2:	05c0      	lsls	r0, r0, #23
 80225a4:	2190      	movs	r1, #144	@ 0x90
 80225a6:	5842      	ldr	r2, [r0, r1]
 80225a8:	4e18      	ldr	r6, [pc, #96]	@ (802260c <HAL_RCCEx_PeriphCLKConfig+0x210>)
 80225aa:	4032      	ands	r2, r6
 80225ac:	4313      	orrs	r3, r2
 80225ae:	5043      	str	r3, [r0, r1]
}
 80225b0:	e72b      	b.n	802240a <HAL_RCCEx_PeriphCLKConfig+0xe>
  uint32_t tmpregister = 0;
 80225b2:	2300      	movs	r3, #0
 80225b4:	e7ee      	b.n	8022594 <HAL_RCCEx_PeriphCLKConfig+0x198>
        tickstart = HAL_GetTick();
 80225b6:	f7fe fac7 	bl	8020b48 <HAL_GetTick>
 80225ba:	0006      	movs	r6, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 80225bc:	22b0      	movs	r2, #176	@ 0xb0
 80225be:	05d2      	lsls	r2, r2, #23
 80225c0:	2390      	movs	r3, #144	@ 0x90
 80225c2:	58d3      	ldr	r3, [r2, r3]
 80225c4:	079b      	lsls	r3, r3, #30
 80225c6:	d4e7      	bmi.n	8022598 <HAL_RCCEx_PeriphCLKConfig+0x19c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80225c8:	f7fe fabe 	bl	8020b48 <HAL_GetTick>
 80225cc:	1b80      	subs	r0, r0, r6
 80225ce:	4b13      	ldr	r3, [pc, #76]	@ (802261c <HAL_RCCEx_PeriphCLKConfig+0x220>)
 80225d0:	4298      	cmp	r0, r3
 80225d2:	d9f3      	bls.n	80225bc <HAL_RCCEx_PeriphCLKConfig+0x1c0>
            ret = HAL_TIMEOUT;
 80225d4:	2503      	movs	r5, #3
 80225d6:	e7df      	b.n	8022598 <HAL_RCCEx_PeriphCLKConfig+0x19c>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80225d8:	6960      	ldr	r0, [r4, #20]
 80225da:	f7ff feff 	bl	80223dc <LL_RCC_SetI2CClockSource>
 80225de:	e76a      	b.n	80224b6 <HAL_RCCEx_PeriphCLKConfig+0xba>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80225e0:	69a0      	ldr	r0, [r4, #24]
 80225e2:	f7ff fefb 	bl	80223dc <LL_RCC_SetI2CClockSource>
 80225e6:	e76a      	b.n	80224be <HAL_RCCEx_PeriphCLKConfig+0xc2>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80225e8:	69e0      	ldr	r0, [r4, #28]
 80225ea:	f7ff fef7 	bl	80223dc <LL_RCC_SetI2CClockSource>
 80225ee:	e76a      	b.n	80224c6 <HAL_RCCEx_PeriphCLKConfig+0xca>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 80225f0:	68c1      	ldr	r1, [r0, #12]
 80225f2:	2380      	movs	r3, #128	@ 0x80
 80225f4:	045b      	lsls	r3, r3, #17
 80225f6:	430b      	orrs	r3, r1
 80225f8:	60c3      	str	r3, [r0, #12]
 80225fa:	e776      	b.n	80224ea <HAL_RCCEx_PeriphCLKConfig+0xee>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80225fc:	68c1      	ldr	r1, [r0, #12]
 80225fe:	2380      	movs	r3, #128	@ 0x80
 8022600:	025b      	lsls	r3, r3, #9
 8022602:	430b      	orrs	r3, r1
 8022604:	60c3      	str	r3, [r0, #12]
 8022606:	e795      	b.n	8022534 <HAL_RCCEx_PeriphCLKConfig+0x138>
 8022608:	fffff3ff 	.word	0xfffff3ff
 802260c:	fffffcff 	.word	0xfffffcff
 8022610:	cfffffff 	.word	0xcfffffff
 8022614:	58000400 	.word	0x58000400
 8022618:	fffeffff 	.word	0xfffeffff
 802261c:	00001388 	.word	0x00001388

08022620 <HAL_RTC_DeactivateAlarm>:
{
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8022620:	232c      	movs	r3, #44	@ 0x2c
 8022622:	5cc3      	ldrb	r3, [r0, r3]
 8022624:	2b01      	cmp	r3, #1
 8022626:	d036      	beq.n	8022696 <HAL_RTC_DeactivateAlarm+0x76>
 8022628:	232c      	movs	r3, #44	@ 0x2c
 802262a:	2201      	movs	r2, #1
 802262c:	54c2      	strb	r2, [r0, r3]

  hrtc->State = HAL_RTC_STATE_BUSY;
 802262e:	3301      	adds	r3, #1
 8022630:	3201      	adds	r2, #1
 8022632:	54c2      	strb	r2, [r0, r3]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8022634:	4b19      	ldr	r3, [pc, #100]	@ (802269c <HAL_RTC_DeactivateAlarm+0x7c>)
 8022636:	32c8      	adds	r2, #200	@ 0xc8
 8022638:	625a      	str	r2, [r3, #36]	@ 0x24
 802263a:	3a77      	subs	r2, #119	@ 0x77
 802263c:	625a      	str	r2, [r3, #36]	@ 0x24

  if (Alarm == RTC_ALARM_A)
 802263e:	2380      	movs	r3, #128	@ 0x80
 8022640:	005b      	lsls	r3, r3, #1
 8022642:	4299      	cmp	r1, r3
 8022644:	d018      	beq.n	8022678 <HAL_RTC_DeactivateAlarm+0x58>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
  }
  else
  {
    /* AlarmB, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8022646:	4b15      	ldr	r3, [pc, #84]	@ (802269c <HAL_RTC_DeactivateAlarm+0x7c>)
 8022648:	699a      	ldr	r2, [r3, #24]
 802264a:	4915      	ldr	r1, [pc, #84]	@ (80226a0 <HAL_RTC_DeactivateAlarm+0x80>)
 802264c:	400a      	ands	r2, r1
 802264e:	619a      	str	r2, [r3, #24]

    /* AlarmB, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8022650:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8022652:	0052      	lsls	r2, r2, #1
 8022654:	0852      	lsrs	r2, r2, #1
 8022656:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Store in the handle the Alarm B disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8022658:	6b02      	ldr	r2, [r0, #48]	@ 0x30
 802265a:	2102      	movs	r1, #2
 802265c:	438a      	bics	r2, r1
 802265e:	6302      	str	r2, [r0, #48]	@ 0x30

    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8022660:	65d9      	str	r1, [r3, #92]	@ 0x5c
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8022662:	4b0e      	ldr	r3, [pc, #56]	@ (802269c <HAL_RTC_DeactivateAlarm+0x7c>)
 8022664:	22ff      	movs	r2, #255	@ 0xff
 8022666:	625a      	str	r2, [r3, #36]	@ 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8022668:	232d      	movs	r3, #45	@ 0x2d
 802266a:	3afe      	subs	r2, #254	@ 0xfe
 802266c:	54c2      	strb	r2, [r0, r3]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802266e:	3b01      	subs	r3, #1
 8022670:	2200      	movs	r2, #0
 8022672:	54c2      	strb	r2, [r0, r3]

  return HAL_OK;
 8022674:	2000      	movs	r0, #0
}
 8022676:	4770      	bx	lr
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8022678:	4b08      	ldr	r3, [pc, #32]	@ (802269c <HAL_RTC_DeactivateAlarm+0x7c>)
 802267a:	699a      	ldr	r2, [r3, #24]
 802267c:	4909      	ldr	r1, [pc, #36]	@ (80226a4 <HAL_RTC_DeactivateAlarm+0x84>)
 802267e:	400a      	ands	r2, r1
 8022680:	619a      	str	r2, [r3, #24]
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8022682:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8022684:	0052      	lsls	r2, r2, #1
 8022686:	0852      	lsrs	r2, r2, #1
 8022688:	645a      	str	r2, [r3, #68]	@ 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802268a:	6b02      	ldr	r2, [r0, #48]	@ 0x30
 802268c:	2101      	movs	r1, #1
 802268e:	438a      	bics	r2, r1
 8022690:	6302      	str	r2, [r0, #48]	@ 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8022692:	65d9      	str	r1, [r3, #92]	@ 0x5c
 8022694:	e7e5      	b.n	8022662 <HAL_RTC_DeactivateAlarm+0x42>
  __HAL_LOCK(hrtc);
 8022696:	2002      	movs	r0, #2
 8022698:	e7ed      	b.n	8022676 <HAL_RTC_DeactivateAlarm+0x56>
 802269a:	46c0      	nop			@ (mov r8, r8)
 802269c:	40002800 	.word	0x40002800
 80226a0:	ffffddff 	.word	0xffffddff
 80226a4:	ffffeeff 	.word	0xffffeeff

080226a8 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 80226a8:	b570      	push	{r4, r5, r6, lr}
 80226aa:	0005      	movs	r5, r0
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 80226ac:	4b0c      	ldr	r3, [pc, #48]	@ (80226e0 <HAL_RTC_AlarmIRQHandler+0x38>)
 80226ae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80226b0:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 80226b2:	401c      	ands	r4, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 80226b4:	07e3      	lsls	r3, r4, #31
 80226b6:	d405      	bmi.n	80226c4 <HAL_RTC_AlarmIRQHandler+0x1c>
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 80226b8:	07a4      	lsls	r4, r4, #30
 80226ba:	d409      	bmi.n	80226d0 <HAL_RTC_AlarmIRQHandler+0x28>
    HAL_RTCEx_AlarmBEventCallback(hrtc);
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80226bc:	232d      	movs	r3, #45	@ 0x2d
 80226be:	2201      	movs	r2, #1
 80226c0:	54ea      	strb	r2, [r5, r3]
}
 80226c2:	bd70      	pop	{r4, r5, r6, pc}
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 80226c4:	4b06      	ldr	r3, [pc, #24]	@ (80226e0 <HAL_RTC_AlarmIRQHandler+0x38>)
 80226c6:	2201      	movs	r2, #1
 80226c8:	65da      	str	r2, [r3, #92]	@ 0x5c
    HAL_RTC_AlarmAEventCallback(hrtc);
 80226ca:	f7fe fb87 	bl	8020ddc <HAL_RTC_AlarmAEventCallback>
 80226ce:	e7f3      	b.n	80226b8 <HAL_RTC_AlarmIRQHandler+0x10>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 80226d0:	4b03      	ldr	r3, [pc, #12]	@ (80226e0 <HAL_RTC_AlarmIRQHandler+0x38>)
 80226d2:	2202      	movs	r2, #2
 80226d4:	65da      	str	r2, [r3, #92]	@ 0x5c
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 80226d6:	0028      	movs	r0, r5
 80226d8:	f7fe fb96 	bl	8020e08 <HAL_RTCEx_AlarmBEventCallback>
 80226dc:	e7ee      	b.n	80226bc <HAL_RTC_AlarmIRQHandler+0x14>
 80226de:	46c0      	nop			@ (mov r8, r8)
 80226e0:	40002800 	.word	0x40002800

080226e4 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 80226e4:	b510      	push	{r4, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 80226e6:	4a0b      	ldr	r2, [pc, #44]	@ (8022714 <HAL_RTC_WaitForSynchro+0x30>)
 80226e8:	68d3      	ldr	r3, [r2, #12]
 80226ea:	2120      	movs	r1, #32
 80226ec:	438b      	bics	r3, r1
 80226ee:	60d3      	str	r3, [r2, #12]

  tickstart = HAL_GetTick();
 80226f0:	f7fe fa2a 	bl	8020b48 <HAL_GetTick>
 80226f4:	0004      	movs	r4, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 80226f6:	4b07      	ldr	r3, [pc, #28]	@ (8022714 <HAL_RTC_WaitForSynchro+0x30>)
 80226f8:	68db      	ldr	r3, [r3, #12]
 80226fa:	069b      	lsls	r3, r3, #26
 80226fc:	d408      	bmi.n	8022710 <HAL_RTC_WaitForSynchro+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80226fe:	f7fe fa23 	bl	8020b48 <HAL_GetTick>
 8022702:	1b00      	subs	r0, r0, r4
 8022704:	23fa      	movs	r3, #250	@ 0xfa
 8022706:	009b      	lsls	r3, r3, #2
 8022708:	4298      	cmp	r0, r3
 802270a:	d9f4      	bls.n	80226f6 <HAL_RTC_WaitForSynchro+0x12>
    {
      return HAL_TIMEOUT;
 802270c:	2003      	movs	r0, #3
 802270e:	e000      	b.n	8022712 <HAL_RTC_WaitForSynchro+0x2e>
    }
  }

  return HAL_OK;
 8022710:	2000      	movs	r0, #0
}
 8022712:	bd10      	pop	{r4, pc}
 8022714:	40002800 	.word	0x40002800

08022718 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 8022718:	b570      	push	{r4, r5, r6, lr}
 802271a:	0004      	movs	r4, r0
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802271c:	4b10      	ldr	r3, [pc, #64]	@ (8022760 <RTC_EnterInitMode+0x48>)
 802271e:	68db      	ldr	r3, [r3, #12]
 8022720:	065b      	lsls	r3, r3, #25
 8022722:	d502      	bpl.n	802272a <RTC_EnterInitMode+0x12>
  HAL_StatusTypeDef status = HAL_OK;
 8022724:	2500      	movs	r5, #0
      }
    }
  }

  return status;
}
 8022726:	0028      	movs	r0, r5
 8022728:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802272a:	4a0d      	ldr	r2, [pc, #52]	@ (8022760 <RTC_EnterInitMode+0x48>)
 802272c:	68d3      	ldr	r3, [r2, #12]
 802272e:	2180      	movs	r1, #128	@ 0x80
 8022730:	430b      	orrs	r3, r1
 8022732:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 8022734:	f7fe fa08 	bl	8020b48 <HAL_GetTick>
 8022738:	0006      	movs	r6, r0
  HAL_StatusTypeDef status = HAL_OK;
 802273a:	2500      	movs	r5, #0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 802273c:	4b08      	ldr	r3, [pc, #32]	@ (8022760 <RTC_EnterInitMode+0x48>)
 802273e:	68db      	ldr	r3, [r3, #12]
 8022740:	065b      	lsls	r3, r3, #25
 8022742:	d4f0      	bmi.n	8022726 <RTC_EnterInitMode+0xe>
 8022744:	2d03      	cmp	r5, #3
 8022746:	d0ee      	beq.n	8022726 <RTC_EnterInitMode+0xe>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8022748:	f7fe f9fe 	bl	8020b48 <HAL_GetTick>
 802274c:	1b80      	subs	r0, r0, r6
 802274e:	22fa      	movs	r2, #250	@ 0xfa
 8022750:	0092      	lsls	r2, r2, #2
 8022752:	4290      	cmp	r0, r2
 8022754:	d9f2      	bls.n	802273c <RTC_EnterInitMode+0x24>
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8022756:	232d      	movs	r3, #45	@ 0x2d
 8022758:	2203      	movs	r2, #3
 802275a:	54e2      	strb	r2, [r4, r3]
        status = HAL_TIMEOUT;
 802275c:	2503      	movs	r5, #3
 802275e:	e7ed      	b.n	802273c <RTC_EnterInitMode+0x24>
 8022760:	40002800 	.word	0x40002800

08022764 <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8022764:	b510      	push	{r4, lr}
 8022766:	0004      	movs	r4, r0
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8022768:	4b11      	ldr	r3, [pc, #68]	@ (80227b0 <RTC_ExitInitMode+0x4c>)
 802276a:	68da      	ldr	r2, [r3, #12]
 802276c:	2180      	movs	r1, #128	@ 0x80
 802276e:	438a      	bics	r2, r1
 8022770:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8022772:	699b      	ldr	r3, [r3, #24]
 8022774:	069b      	lsls	r3, r3, #26
 8022776:	d408      	bmi.n	802278a <RTC_ExitInitMode+0x26>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8022778:	f7ff ffb4 	bl	80226e4 <HAL_RTC_WaitForSynchro>
 802277c:	2800      	cmp	r0, #0
 802277e:	d016      	beq.n	80227ae <RTC_ExitInitMode+0x4a>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8022780:	232d      	movs	r3, #45	@ 0x2d
 8022782:	2203      	movs	r2, #3
 8022784:	54e2      	strb	r2, [r4, r3]
      status = HAL_TIMEOUT;
 8022786:	2003      	movs	r0, #3
 8022788:	e011      	b.n	80227ae <RTC_ExitInitMode+0x4a>
    }
  }
  else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry. */
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802278a:	4a09      	ldr	r2, [pc, #36]	@ (80227b0 <RTC_ExitInitMode+0x4c>)
 802278c:	6993      	ldr	r3, [r2, #24]
 802278e:	2120      	movs	r1, #32
 8022790:	438b      	bics	r3, r1
 8022792:	6193      	str	r3, [r2, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8022794:	f7ff ffa6 	bl	80226e4 <HAL_RTC_WaitForSynchro>
 8022798:	2800      	cmp	r0, #0
 802279a:	d003      	beq.n	80227a4 <RTC_ExitInitMode+0x40>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802279c:	232d      	movs	r3, #45	@ 0x2d
 802279e:	2203      	movs	r2, #3
 80227a0:	54e2      	strb	r2, [r4, r3]
      status = HAL_TIMEOUT;
 80227a2:	2003      	movs	r0, #3
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 80227a4:	4a02      	ldr	r2, [pc, #8]	@ (80227b0 <RTC_ExitInitMode+0x4c>)
 80227a6:	6993      	ldr	r3, [r2, #24]
 80227a8:	2120      	movs	r1, #32
 80227aa:	430b      	orrs	r3, r1
 80227ac:	6193      	str	r3, [r2, #24]
  }

  return status;
}
 80227ae:	bd10      	pop	{r4, pc}
 80227b0:	40002800 	.word	0x40002800

080227b4 <HAL_RTC_Init>:
{
 80227b4:	b570      	push	{r4, r5, r6, lr}
 80227b6:	1e04      	subs	r4, r0, #0
  if (hrtc != NULL)
 80227b8:	d054      	beq.n	8022864 <HAL_RTC_Init+0xb0>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 80227ba:	232d      	movs	r3, #45	@ 0x2d
 80227bc:	5cc3      	ldrb	r3, [r0, r3]
 80227be:	2b00      	cmp	r3, #0
 80227c0:	d00b      	beq.n	80227da <HAL_RTC_Init+0x26>
    hrtc->State = HAL_RTC_STATE_BUSY;
 80227c2:	232d      	movs	r3, #45	@ 0x2d
 80227c4:	2202      	movs	r2, #2
 80227c6:	54e2      	strb	r2, [r4, r3]
    if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 80227c8:	4b27      	ldr	r3, [pc, #156]	@ (8022868 <HAL_RTC_Init+0xb4>)
 80227ca:	68db      	ldr	r3, [r3, #12]
 80227cc:	06db      	lsls	r3, r3, #27
 80227ce:	d50a      	bpl.n	80227e6 <HAL_RTC_Init+0x32>
      status = HAL_OK;
 80227d0:	2000      	movs	r0, #0
      hrtc->State = HAL_RTC_STATE_READY;
 80227d2:	232d      	movs	r3, #45	@ 0x2d
 80227d4:	2201      	movs	r2, #1
 80227d6:	54e2      	strb	r2, [r4, r3]
}
 80227d8:	bd70      	pop	{r4, r5, r6, pc}
      hrtc->Lock = HAL_UNLOCKED;
 80227da:	332c      	adds	r3, #44	@ 0x2c
 80227dc:	2200      	movs	r2, #0
 80227de:	54c2      	strb	r2, [r0, r3]
      HAL_RTC_MspInit(hrtc);
 80227e0:	f7fe f86a 	bl	80208b8 <HAL_RTC_MspInit>
 80227e4:	e7ed      	b.n	80227c2 <HAL_RTC_Init+0xe>
      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80227e6:	4b20      	ldr	r3, [pc, #128]	@ (8022868 <HAL_RTC_Init+0xb4>)
 80227e8:	32c8      	adds	r2, #200	@ 0xc8
 80227ea:	625a      	str	r2, [r3, #36]	@ 0x24
 80227ec:	3a77      	subs	r2, #119	@ 0x77
 80227ee:	625a      	str	r2, [r3, #36]	@ 0x24
      status = RTC_EnterInitMode(hrtc);
 80227f0:	0020      	movs	r0, r4
 80227f2:	f7ff ff91 	bl	8022718 <RTC_EnterInitMode>
      if (status == HAL_OK)
 80227f6:	2800      	cmp	r0, #0
 80227f8:	d003      	beq.n	8022802 <HAL_RTC_Init+0x4e>
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80227fa:	4b1b      	ldr	r3, [pc, #108]	@ (8022868 <HAL_RTC_Init+0xb4>)
 80227fc:	22ff      	movs	r2, #255	@ 0xff
 80227fe:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
 8022800:	e7ea      	b.n	80227d8 <HAL_RTC_Init+0x24>
        CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 8022802:	4b19      	ldr	r3, [pc, #100]	@ (8022868 <HAL_RTC_Init+0xb4>)
 8022804:	699a      	ldr	r2, [r3, #24]
 8022806:	4919      	ldr	r1, [pc, #100]	@ (802286c <HAL_RTC_Init+0xb8>)
 8022808:	400a      	ands	r2, r1
 802280a:	619a      	str	r2, [r3, #24]
        SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 802280c:	6999      	ldr	r1, [r3, #24]
 802280e:	6862      	ldr	r2, [r4, #4]
 8022810:	6920      	ldr	r0, [r4, #16]
 8022812:	4302      	orrs	r2, r0
 8022814:	69a0      	ldr	r0, [r4, #24]
 8022816:	4302      	orrs	r2, r0
 8022818:	430a      	orrs	r2, r1
 802281a:	619a      	str	r2, [r3, #24]
        WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 802281c:	68e2      	ldr	r2, [r4, #12]
 802281e:	68a1      	ldr	r1, [r4, #8]
 8022820:	0409      	lsls	r1, r1, #16
 8022822:	430a      	orrs	r2, r1
 8022824:	611a      	str	r2, [r3, #16]
        MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 8022826:	68da      	ldr	r2, [r3, #12]
 8022828:	4911      	ldr	r1, [pc, #68]	@ (8022870 <HAL_RTC_Init+0xbc>)
 802282a:	400a      	ands	r2, r1
 802282c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 802282e:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8022830:	4301      	orrs	r1, r0
 8022832:	430a      	orrs	r2, r1
 8022834:	60da      	str	r2, [r3, #12]
        status = RTC_ExitInitMode(hrtc);
 8022836:	0020      	movs	r0, r4
 8022838:	f7ff ff94 	bl	8022764 <RTC_ExitInitMode>
        if (status == HAL_OK)
 802283c:	2800      	cmp	r0, #0
 802283e:	d003      	beq.n	8022848 <HAL_RTC_Init+0x94>
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8022840:	4b09      	ldr	r3, [pc, #36]	@ (8022868 <HAL_RTC_Init+0xb4>)
 8022842:	22ff      	movs	r2, #255	@ 0xff
 8022844:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
 8022846:	e7c7      	b.n	80227d8 <HAL_RTC_Init+0x24>
          MODIFY_REG(RTC->CR, \
 8022848:	4907      	ldr	r1, [pc, #28]	@ (8022868 <HAL_RTC_Init+0xb4>)
 802284a:	698b      	ldr	r3, [r1, #24]
 802284c:	00db      	lsls	r3, r3, #3
 802284e:	08db      	lsrs	r3, r3, #3
 8022850:	6a22      	ldr	r2, [r4, #32]
 8022852:	69e5      	ldr	r5, [r4, #28]
 8022854:	432a      	orrs	r2, r5
 8022856:	6965      	ldr	r5, [r4, #20]
 8022858:	432a      	orrs	r2, r5
 802285a:	4313      	orrs	r3, r2
 802285c:	618b      	str	r3, [r1, #24]
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802285e:	23ff      	movs	r3, #255	@ 0xff
 8022860:	624b      	str	r3, [r1, #36]	@ 0x24
    if (status == HAL_OK)
 8022862:	e7b6      	b.n	80227d2 <HAL_RTC_Init+0x1e>
  HAL_StatusTypeDef status = HAL_ERROR;
 8022864:	2001      	movs	r0, #1
 8022866:	e7b7      	b.n	80227d8 <HAL_RTC_Init+0x24>
 8022868:	40002800 	.word	0x40002800
 802286c:	fb8fffbf 	.word	0xfb8fffbf
 8022870:	ffffe0ff 	.word	0xffffe0ff

08022874 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8022874:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 8022876:	e002      	b.n	802287e <RTC_ByteToBcd2+0xa>
  {
    bcdhigh++;
 8022878:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 802287a:	380a      	subs	r0, #10
 802287c:	b2c0      	uxtb	r0, r0
  while (tmp_Value >= 10U)
 802287e:	2809      	cmp	r0, #9
 8022880:	d8fa      	bhi.n	8022878 <RTC_ByteToBcd2+0x4>
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8022882:	011b      	lsls	r3, r3, #4
 8022884:	b2db      	uxtb	r3, r3
 8022886:	4318      	orrs	r0, r3
}
 8022888:	4770      	bx	lr
	...

0802288c <HAL_RTC_SetAlarm_IT>:
{
 802288c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802288e:	46c6      	mov	lr, r8
 8022890:	b500      	push	{lr}
 8022892:	0005      	movs	r5, r0
 8022894:	000c      	movs	r4, r1
  __HAL_LOCK(hrtc);
 8022896:	232c      	movs	r3, #44	@ 0x2c
 8022898:	5cc3      	ldrb	r3, [r0, r3]
 802289a:	2b01      	cmp	r3, #1
 802289c:	d100      	bne.n	80228a0 <HAL_RTC_SetAlarm_IT+0x14>
 802289e:	e0b5      	b.n	8022a0c <HAL_RTC_SetAlarm_IT+0x180>
 80228a0:	232c      	movs	r3, #44	@ 0x2c
 80228a2:	2101      	movs	r1, #1
 80228a4:	54c1      	strb	r1, [r0, r3]
  hrtc->State = HAL_RTC_STATE_BUSY;
 80228a6:	3301      	adds	r3, #1
 80228a8:	3101      	adds	r1, #1
 80228aa:	54c1      	strb	r1, [r0, r3]
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 80228ac:	4b58      	ldr	r3, [pc, #352]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 80228ae:	68de      	ldr	r6, [r3, #12]
 80228b0:	23c0      	movs	r3, #192	@ 0xc0
 80228b2:	009b      	lsls	r3, r3, #2
 80228b4:	401e      	ands	r6, r3
  if (binaryMode != RTC_BINARY_ONLY)
 80228b6:	2380      	movs	r3, #128	@ 0x80
 80228b8:	005b      	lsls	r3, r3, #1
 80228ba:	429e      	cmp	r6, r3
 80228bc:	d044      	beq.n	8022948 <HAL_RTC_SetAlarm_IT+0xbc>
    if (Format == RTC_FORMAT_BIN)
 80228be:	2a00      	cmp	r2, #0
 80228c0:	d122      	bne.n	8022908 <HAL_RTC_SetAlarm_IT+0x7c>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 80228c2:	4b53      	ldr	r3, [pc, #332]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 80228c4:	699b      	ldr	r3, [r3, #24]
 80228c6:	065b      	lsls	r3, r3, #25
 80228c8:	d401      	bmi.n	80228ce <HAL_RTC_SetAlarm_IT+0x42>
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 80228ca:	2300      	movs	r3, #0
 80228cc:	70e3      	strb	r3, [r4, #3]
      if( sAlarm->AlarmMask != RTC_ALARMMASK_DATEWEEKDAY )
 80228ce:	6963      	ldr	r3, [r4, #20]
 80228d0:	4698      	mov	r8, r3
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80228d2:	7820      	ldrb	r0, [r4, #0]
 80228d4:	f7ff ffce 	bl	8022874 <RTC_ByteToBcd2>
 80228d8:	0407      	lsls	r7, r0, #16
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80228da:	7860      	ldrb	r0, [r4, #1]
 80228dc:	f7ff ffca 	bl	8022874 <RTC_ByteToBcd2>
 80228e0:	0200      	lsls	r0, r0, #8
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80228e2:	4307      	orrs	r7, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80228e4:	78a0      	ldrb	r0, [r4, #2]
 80228e6:	f7ff ffc5 	bl	8022874 <RTC_ByteToBcd2>
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80228ea:	4307      	orrs	r7, r0
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80228ec:	78e3      	ldrb	r3, [r4, #3]
 80228ee:	059b      	lsls	r3, r3, #22
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80228f0:	431f      	orrs	r7, r3
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 80228f2:	2324      	movs	r3, #36	@ 0x24
 80228f4:	5ce0      	ldrb	r0, [r4, r3]
 80228f6:	f7ff ffbd 	bl	8022874 <RTC_ByteToBcd2>
 80228fa:	0603      	lsls	r3, r0, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80228fc:	433b      	orrs	r3, r7
                ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 80228fe:	6a22      	ldr	r2, [r4, #32]
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8022900:	4313      	orrs	r3, r2
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8022902:	4642      	mov	r2, r8
 8022904:	4313      	orrs	r3, r2
 8022906:	e020      	b.n	802294a <HAL_RTC_SetAlarm_IT+0xbe>
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 8022908:	6963      	ldr	r3, [r4, #20]
 802290a:	4a42      	ldr	r2, [pc, #264]	@ (8022a14 <HAL_RTC_SetAlarm_IT+0x188>)
 802290c:	4293      	cmp	r3, r2
 802290e:	d009      	beq.n	8022924 <HAL_RTC_SetAlarm_IT+0x98>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 8022910:	2280      	movs	r2, #128	@ 0x80
 8022912:	0412      	lsls	r2, r2, #16
 8022914:	4293      	cmp	r3, r2
 8022916:	d005      	beq.n	8022924 <HAL_RTC_SetAlarm_IT+0x98>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8022918:	4a3d      	ldr	r2, [pc, #244]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 802291a:	6992      	ldr	r2, [r2, #24]
 802291c:	0652      	lsls	r2, r2, #25
 802291e:	d401      	bmi.n	8022924 <HAL_RTC_SetAlarm_IT+0x98>
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 8022920:	2200      	movs	r2, #0
 8022922:	70e2      	strb	r2, [r4, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8022924:	7822      	ldrb	r2, [r4, #0]
 8022926:	0412      	lsls	r2, r2, #16
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8022928:	7861      	ldrb	r1, [r4, #1]
 802292a:	0209      	lsls	r1, r1, #8
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802292c:	430a      	orrs	r2, r1
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 802292e:	78a1      	ldrb	r1, [r4, #2]
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8022930:	430a      	orrs	r2, r1
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8022932:	78e1      	ldrb	r1, [r4, #3]
 8022934:	0589      	lsls	r1, r1, #22
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8022936:	430a      	orrs	r2, r1
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8022938:	2124      	movs	r1, #36	@ 0x24
 802293a:	5c61      	ldrb	r1, [r4, r1]
 802293c:	0609      	lsls	r1, r1, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802293e:	430a      	orrs	r2, r1
                ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 8022940:	6a21      	ldr	r1, [r4, #32]
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8022942:	430a      	orrs	r2, r1
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8022944:	4313      	orrs	r3, r2
 8022946:	e000      	b.n	802294a <HAL_RTC_SetAlarm_IT+0xbe>
  uint32_t tmpreg = 0;
 8022948:	2300      	movs	r3, #0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802294a:	4a31      	ldr	r2, [pc, #196]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 802294c:	21ca      	movs	r1, #202	@ 0xca
 802294e:	6251      	str	r1, [r2, #36]	@ 0x24
 8022950:	3977      	subs	r1, #119	@ 0x77
 8022952:	6251      	str	r1, [r2, #36]	@ 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 8022954:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8022956:	2280      	movs	r2, #128	@ 0x80
 8022958:	0052      	lsls	r2, r2, #1
 802295a:	4291      	cmp	r1, r2
 802295c:	d02e      	beq.n	80229bc <HAL_RTC_SetAlarm_IT+0x130>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802295e:	4a2c      	ldr	r2, [pc, #176]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 8022960:	6991      	ldr	r1, [r2, #24]
 8022962:	482d      	ldr	r0, [pc, #180]	@ (8022a18 <HAL_RTC_SetAlarm_IT+0x18c>)
 8022964:	4001      	ands	r1, r0
 8022966:	6191      	str	r1, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8022968:	2102      	movs	r1, #2
 802296a:	65d1      	str	r1, [r2, #92]	@ 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802296c:	2280      	movs	r2, #128	@ 0x80
 802296e:	0052      	lsls	r2, r2, #1
 8022970:	4296      	cmp	r6, r2
 8022972:	d045      	beq.n	8022a00 <HAL_RTC_SetAlarm_IT+0x174>
      WRITE_REG(RTC->ALRMBR, tmpreg);
 8022974:	4a26      	ldr	r2, [pc, #152]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 8022976:	6493      	str	r3, [r2, #72]	@ 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 8022978:	69a3      	ldr	r3, [r4, #24]
 802297a:	64d3      	str	r3, [r2, #76]	@ 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 802297c:	6862      	ldr	r2, [r4, #4]
 802297e:	4b24      	ldr	r3, [pc, #144]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 8022980:	675a      	str	r2, [r3, #116]	@ 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8022982:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 8022984:	2102      	movs	r1, #2
 8022986:	430a      	orrs	r2, r1
 8022988:	632a      	str	r2, [r5, #48]	@ 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802298a:	6999      	ldr	r1, [r3, #24]
 802298c:	2288      	movs	r2, #136	@ 0x88
 802298e:	0192      	lsls	r2, r2, #6
 8022990:	430a      	orrs	r2, r1
 8022992:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8022994:	4921      	ldr	r1, [pc, #132]	@ (8022a1c <HAL_RTC_SetAlarm_IT+0x190>)
 8022996:	22c0      	movs	r2, #192	@ 0xc0
 8022998:	5888      	ldr	r0, [r1, r2]
 802299a:	2380      	movs	r3, #128	@ 0x80
 802299c:	029b      	lsls	r3, r3, #10
 802299e:	4303      	orrs	r3, r0
 80229a0:	508b      	str	r3, [r1, r2]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80229a2:	4b1b      	ldr	r3, [pc, #108]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 80229a4:	323f      	adds	r2, #63	@ 0x3f
 80229a6:	625a      	str	r2, [r3, #36]	@ 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 80229a8:	232d      	movs	r3, #45	@ 0x2d
 80229aa:	3afe      	subs	r2, #254	@ 0xfe
 80229ac:	54ea      	strb	r2, [r5, r3]
  __HAL_UNLOCK(hrtc);
 80229ae:	3b01      	subs	r3, #1
 80229b0:	2200      	movs	r2, #0
 80229b2:	54ea      	strb	r2, [r5, r3]
  return HAL_OK;
 80229b4:	2000      	movs	r0, #0
}
 80229b6:	bc80      	pop	{r7}
 80229b8:	46b8      	mov	r8, r7
 80229ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 80229bc:	4a14      	ldr	r2, [pc, #80]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 80229be:	6991      	ldr	r1, [r2, #24]
 80229c0:	4817      	ldr	r0, [pc, #92]	@ (8022a20 <HAL_RTC_SetAlarm_IT+0x194>)
 80229c2:	4001      	ands	r1, r0
 80229c4:	6191      	str	r1, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 80229c6:	2101      	movs	r1, #1
 80229c8:	65d1      	str	r1, [r2, #92]	@ 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 80229ca:	2280      	movs	r2, #128	@ 0x80
 80229cc:	0052      	lsls	r2, r2, #1
 80229ce:	4296      	cmp	r6, r2
 80229d0:	d010      	beq.n	80229f4 <HAL_RTC_SetAlarm_IT+0x168>
      WRITE_REG(RTC->ALRMAR, tmpreg);
 80229d2:	4a0f      	ldr	r2, [pc, #60]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 80229d4:	6413      	str	r3, [r2, #64]	@ 0x40
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 80229d6:	69a3      	ldr	r3, [r4, #24]
 80229d8:	6453      	str	r3, [r2, #68]	@ 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 80229da:	6862      	ldr	r2, [r4, #4]
 80229dc:	4b0c      	ldr	r3, [pc, #48]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 80229de:	671a      	str	r2, [r3, #112]	@ 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 80229e0:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 80229e2:	2101      	movs	r1, #1
 80229e4:	430a      	orrs	r2, r1
 80229e6:	632a      	str	r2, [r5, #48]	@ 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 80229e8:	6999      	ldr	r1, [r3, #24]
 80229ea:	2288      	movs	r2, #136	@ 0x88
 80229ec:	0152      	lsls	r2, r2, #5
 80229ee:	430a      	orrs	r2, r1
 80229f0:	619a      	str	r2, [r3, #24]
 80229f2:	e7cf      	b.n	8022994 <HAL_RTC_SetAlarm_IT+0x108>
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 80229f4:	69a3      	ldr	r3, [r4, #24]
 80229f6:	69e2      	ldr	r2, [r4, #28]
 80229f8:	4313      	orrs	r3, r2
 80229fa:	4a05      	ldr	r2, [pc, #20]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 80229fc:	6453      	str	r3, [r2, #68]	@ 0x44
 80229fe:	e7ec      	b.n	80229da <HAL_RTC_SetAlarm_IT+0x14e>
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 8022a00:	69a3      	ldr	r3, [r4, #24]
 8022a02:	69e2      	ldr	r2, [r4, #28]
 8022a04:	4313      	orrs	r3, r2
 8022a06:	4a02      	ldr	r2, [pc, #8]	@ (8022a10 <HAL_RTC_SetAlarm_IT+0x184>)
 8022a08:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8022a0a:	e7b7      	b.n	802297c <HAL_RTC_SetAlarm_IT+0xf0>
  __HAL_LOCK(hrtc);
 8022a0c:	2002      	movs	r0, #2
 8022a0e:	e7d2      	b.n	80229b6 <HAL_RTC_SetAlarm_IT+0x12a>
 8022a10:	40002800 	.word	0x40002800
 8022a14:	80808080 	.word	0x80808080
 8022a18:	ffffddff 	.word	0xffffddff
 8022a1c:	58000800 	.word	0x58000800
 8022a20:	ffffeeff 	.word	0xffffeeff

08022a24 <HAL_RTCEx_EnableBypassShadow>:
  *         directly from the Calendar counter.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
 8022a24:	b570      	push	{r4, r5, r6, lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8022a26:	232c      	movs	r3, #44	@ 0x2c
 8022a28:	5cc3      	ldrb	r3, [r0, r3]
 8022a2a:	2b01      	cmp	r3, #1
 8022a2c:	d015      	beq.n	8022a5a <HAL_RTCEx_EnableBypassShadow+0x36>
 8022a2e:	212c      	movs	r1, #44	@ 0x2c
 8022a30:	2501      	movs	r5, #1
 8022a32:	5445      	strb	r5, [r0, r1]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8022a34:	242d      	movs	r4, #45	@ 0x2d
 8022a36:	2302      	movs	r3, #2
 8022a38:	5503      	strb	r3, [r0, r4]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8022a3a:	4b09      	ldr	r3, [pc, #36]	@ (8022a60 <HAL_RTCEx_EnableBypassShadow+0x3c>)
 8022a3c:	22ca      	movs	r2, #202	@ 0xca
 8022a3e:	625a      	str	r2, [r3, #36]	@ 0x24
 8022a40:	3a77      	subs	r2, #119	@ 0x77
 8022a42:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8022a44:	699a      	ldr	r2, [r3, #24]
 8022a46:	2620      	movs	r6, #32
 8022a48:	4332      	orrs	r2, r6
 8022a4a:	619a      	str	r2, [r3, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8022a4c:	22ff      	movs	r2, #255	@ 0xff
 8022a4e:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8022a50:	5505      	strb	r5, [r0, r4]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8022a52:	2300      	movs	r3, #0
 8022a54:	5443      	strb	r3, [r0, r1]

  return HAL_OK;
 8022a56:	2000      	movs	r0, #0
}
 8022a58:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hrtc);
 8022a5a:	2002      	movs	r0, #2
 8022a5c:	e7fc      	b.n	8022a58 <HAL_RTCEx_EnableBypassShadow+0x34>
 8022a5e:	46c0      	nop			@ (mov r8, r8)
 8022a60:	40002800 	.word	0x40002800

08022a64 <HAL_RTCEx_SetSSRU_IT>:
  * @brief  Set SSR Underflow detection with Interrupt.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
 8022a64:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022a66:	46c6      	mov	lr, r8
 8022a68:	b500      	push	{lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8022a6a:	232c      	movs	r3, #44	@ 0x2c
 8022a6c:	5cc3      	ldrb	r3, [r0, r3]
 8022a6e:	2b01      	cmp	r3, #1
 8022a70:	d022      	beq.n	8022ab8 <HAL_RTCEx_SetSSRU_IT+0x54>
 8022a72:	232c      	movs	r3, #44	@ 0x2c
 8022a74:	4698      	mov	r8, r3
 8022a76:	2501      	movs	r5, #1
 8022a78:	54c5      	strb	r5, [r0, r3]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8022a7a:	242d      	movs	r4, #45	@ 0x2d
 8022a7c:	3b2a      	subs	r3, #42	@ 0x2a
 8022a7e:	5503      	strb	r3, [r0, r4]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8022a80:	4b0e      	ldr	r3, [pc, #56]	@ (8022abc <HAL_RTCEx_SetSSRU_IT+0x58>)
 8022a82:	22ca      	movs	r2, #202	@ 0xca
 8022a84:	625a      	str	r2, [r3, #36]	@ 0x24
 8022a86:	3a77      	subs	r2, #119	@ 0x77
 8022a88:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 8022a8a:	699a      	ldr	r2, [r3, #24]
 8022a8c:	2680      	movs	r6, #128	@ 0x80
 8022a8e:	4332      	orrs	r2, r6
 8022a90:	619a      	str	r2, [r3, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8022a92:	4f0b      	ldr	r7, [pc, #44]	@ (8022ac0 <HAL_RTCEx_SetSSRU_IT+0x5c>)
 8022a94:	3640      	adds	r6, #64	@ 0x40
 8022a96:	59ba      	ldr	r2, [r7, r6]
 8022a98:	4694      	mov	ip, r2
 8022a9a:	2280      	movs	r2, #128	@ 0x80
 8022a9c:	02d2      	lsls	r2, r2, #11
 8022a9e:	4661      	mov	r1, ip
 8022aa0:	430a      	orrs	r2, r1
 8022aa2:	51ba      	str	r2, [r7, r6]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8022aa4:	22ff      	movs	r2, #255	@ 0xff
 8022aa6:	625a      	str	r2, [r3, #36]	@ 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8022aa8:	5505      	strb	r5, [r0, r4]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8022aaa:	2300      	movs	r3, #0
 8022aac:	4642      	mov	r2, r8
 8022aae:	5483      	strb	r3, [r0, r2]

  return HAL_OK;
 8022ab0:	2000      	movs	r0, #0
}
 8022ab2:	bc80      	pop	{r7}
 8022ab4:	46b8      	mov	r8, r7
 8022ab6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(hrtc);
 8022ab8:	2002      	movs	r0, #2
 8022aba:	e7fa      	b.n	8022ab2 <HAL_RTCEx_SetSSRU_IT+0x4e>
 8022abc:	40002800 	.word	0x40002800
 8022ac0:	58000800 	.word	0x58000800

08022ac4 <HAL_RTCEx_SSRUIRQHandler>:
  * @brief  Handle SSR underflow interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8022ac4:	b510      	push	{r4, lr}
 8022ac6:	0004      	movs	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 8022ac8:	4b06      	ldr	r3, [pc, #24]	@ (8022ae4 <HAL_RTCEx_SSRUIRQHandler+0x20>)
 8022aca:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8022acc:	065b      	lsls	r3, r3, #25
 8022ace:	d403      	bmi.n	8022ad8 <HAL_RTCEx_SSRUIRQHandler+0x14>
    HAL_RTCEx_SSRUEventCallback(hrtc);
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8022ad0:	232d      	movs	r3, #45	@ 0x2d
 8022ad2:	2201      	movs	r2, #1
 8022ad4:	54e2      	strb	r2, [r4, r3]
}
 8022ad6:	bd10      	pop	{r4, pc}
    RTC->SCR = RTC_SCR_CSSRUF;
 8022ad8:	4b02      	ldr	r3, [pc, #8]	@ (8022ae4 <HAL_RTCEx_SSRUIRQHandler+0x20>)
 8022ada:	2240      	movs	r2, #64	@ 0x40
 8022adc:	65da      	str	r2, [r3, #92]	@ 0x5c
    HAL_RTCEx_SSRUEventCallback(hrtc);
 8022ade:	f7fe f997 	bl	8020e10 <HAL_RTCEx_SSRUEventCallback>
 8022ae2:	e7f5      	b.n	8022ad0 <HAL_RTCEx_SSRUIRQHandler+0xc>
 8022ae4:	40002800 	.word	0x40002800

08022ae8 <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8022ae8:	0089      	lsls	r1, r1, #2
 8022aea:	4b02      	ldr	r3, [pc, #8]	@ (8022af4 <HAL_RTCEx_BKUPWrite+0xc>)
 8022aec:	469c      	mov	ip, r3
 8022aee:	4461      	add	r1, ip

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8022af0:	600a      	str	r2, [r1, #0]
}
 8022af2:	4770      	bx	lr
 8022af4:	4000b100 	.word	0x4000b100

08022af8 <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8022af8:	0089      	lsls	r1, r1, #2
 8022afa:	4b02      	ldr	r3, [pc, #8]	@ (8022b04 <HAL_RTCEx_BKUPRead+0xc>)
 8022afc:	469c      	mov	ip, r3
 8022afe:	4461      	add	r1, ip

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8022b00:	6808      	ldr	r0, [r1, #0]
}
 8022b02:	4770      	bx	lr
 8022b04:	4000b100 	.word	0x4000b100

08022b08 <SUBGHZSPI_Init>:
{
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8022b08:	4b07      	ldr	r3, [pc, #28]	@ (8022b28 <SUBGHZSPI_Init+0x20>)
 8022b0a:	681a      	ldr	r2, [r3, #0]
 8022b0c:	2140      	movs	r1, #64	@ 0x40
 8022b0e:	438a      	bics	r2, r1
 8022b10:	601a      	str	r2, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 8022b12:	22c1      	movs	r2, #193	@ 0xc1
 8022b14:	0092      	lsls	r2, r2, #2
 8022b16:	4302      	orrs	r2, r0
 8022b18:	601a      	str	r2, [r3, #0]
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 8022b1a:	22b8      	movs	r2, #184	@ 0xb8
 8022b1c:	0152      	lsls	r2, r2, #5
 8022b1e:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8022b20:	681a      	ldr	r2, [r3, #0]
 8022b22:	430a      	orrs	r2, r1
 8022b24:	601a      	str	r2, [r3, #0]
}
 8022b26:	4770      	bx	lr
 8022b28:	58010000 	.word	0x58010000

08022b2c <HAL_SUBGHZ_Init>:
{
 8022b2c:	b530      	push	{r4, r5, lr}
 8022b2e:	b083      	sub	sp, #12
 8022b30:	1e04      	subs	r4, r0, #0
  if (hsubghz == NULL)
 8022b32:	d061      	beq.n	8022bf8 <HAL_SUBGHZ_Init+0xcc>
  subghz_state = hsubghz->State;
 8022b34:	7983      	ldrb	r3, [r0, #6]
 8022b36:	b2dd      	uxtb	r5, r3
  if ((subghz_state == HAL_SUBGHZ_STATE_RESET) ||
 8022b38:	2b00      	cmp	r3, #0
 8022b3a:	d001      	beq.n	8022b40 <HAL_SUBGHZ_Init+0x14>
 8022b3c:	2d03      	cmp	r5, #3
 8022b3e:	d10b      	bne.n	8022b58 <HAL_SUBGHZ_Init+0x2c>
    hsubghz->Lock = HAL_UNLOCKED;
 8022b40:	2300      	movs	r3, #0
 8022b42:	7163      	strb	r3, [r4, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 8022b44:	0020      	movs	r0, r4
 8022b46:	f7fd ff49 	bl	80209dc <HAL_SUBGHZ_MspInit>
 8022b4a:	492c      	ldr	r1, [pc, #176]	@ (8022bfc <HAL_SUBGHZ_Init+0xd0>)
 8022b4c:	22d0      	movs	r2, #208	@ 0xd0
 8022b4e:	5888      	ldr	r0, [r1, r2]
 8022b50:	2380      	movs	r3, #128	@ 0x80
 8022b52:	015b      	lsls	r3, r3, #5
 8022b54:	4303      	orrs	r3, r0
 8022b56:	508b      	str	r3, [r1, r2]
  if (subghz_state == HAL_SUBGHZ_STATE_RESET)
 8022b58:	2d00      	cmp	r5, #0
 8022b5a:	d010      	beq.n	8022b7e <HAL_SUBGHZ_Init+0x52>
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 8022b5c:	4b28      	ldr	r3, [pc, #160]	@ (8022c00 <HAL_SUBGHZ_Init+0xd4>)
 8022b5e:	2280      	movs	r2, #128	@ 0x80
 8022b60:	0112      	lsls	r2, r2, #4
 8022b62:	619a      	str	r2, [r3, #24]
    status = HAL_OK;
 8022b64:	2500      	movs	r5, #0
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 8022b66:	6820      	ldr	r0, [r4, #0]
 8022b68:	f7ff ffce 	bl	8022b08 <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 8022b6c:	2301      	movs	r3, #1
 8022b6e:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 8022b70:	2300      	movs	r3, #0
 8022b72:	60a3      	str	r3, [r4, #8]
  hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8022b74:	2301      	movs	r3, #1
 8022b76:	71a3      	strb	r3, [r4, #6]
}
 8022b78:	0028      	movs	r0, r5
 8022b7a:	b003      	add	sp, #12
 8022b7c:	bd30      	pop	{r4, r5, pc}
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8022b7e:	2302      	movs	r3, #2
 8022b80:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 8022b82:	21b0      	movs	r1, #176	@ 0xb0
 8022b84:	05c9      	lsls	r1, r1, #23
 8022b86:	2294      	movs	r2, #148	@ 0x94
 8022b88:	588b      	ldr	r3, [r1, r2]
 8022b8a:	481e      	ldr	r0, [pc, #120]	@ (8022c04 <HAL_SUBGHZ_Init+0xd8>)
 8022b8c:	4003      	ands	r3, r0
 8022b8e:	508b      	str	r3, [r1, r2]
    count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8022b90:	4b1d      	ldr	r3, [pc, #116]	@ (8022c08 <HAL_SUBGHZ_Init+0xdc>)
 8022b92:	681a      	ldr	r2, [r3, #0]
 8022b94:	00d3      	lsls	r3, r2, #3
 8022b96:	1a9b      	subs	r3, r3, r2
 8022b98:	009b      	lsls	r3, r3, #2
 8022b9a:	0cdb      	lsrs	r3, r3, #19
 8022b9c:	2264      	movs	r2, #100	@ 0x64
 8022b9e:	4353      	muls	r3, r2
 8022ba0:	9301      	str	r3, [sp, #4]
 8022ba2:	e017      	b.n	8022bd4 <HAL_SUBGHZ_Init+0xa8>
        hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8022ba4:	3301      	adds	r3, #1
 8022ba6:	60a3      	str	r3, [r4, #8]
        status  = HAL_ERROR;
 8022ba8:	2501      	movs	r5, #1
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022baa:	4b15      	ldr	r3, [pc, #84]	@ (8022c00 <HAL_SUBGHZ_Init+0xd4>)
 8022bac:	2190      	movs	r1, #144	@ 0x90
 8022bae:	5858      	ldr	r0, [r3, r1]
 8022bb0:	2280      	movs	r2, #128	@ 0x80
 8022bb2:	0212      	lsls	r2, r2, #8
 8022bb4:	4302      	orrs	r2, r0
 8022bb6:	505a      	str	r2, [r3, r1]
  MODIFY_REG(PWR->C2CR3, PWR_C2CR3_EWRFBUSY, RadioBusyTrigger);
 8022bb8:	2084      	movs	r0, #132	@ 0x84
 8022bba:	581a      	ldr	r2, [r3, r0]
 8022bbc:	4913      	ldr	r1, [pc, #76]	@ (8022c0c <HAL_SUBGHZ_Init+0xe0>)
 8022bbe:	400a      	ands	r2, r1
 8022bc0:	2180      	movs	r1, #128	@ 0x80
 8022bc2:	0109      	lsls	r1, r1, #4
 8022bc4:	430a      	orrs	r2, r1
 8022bc6:	501a      	str	r2, [r3, r0]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 8022bc8:	6199      	str	r1, [r3, #24]
  if (status == HAL_OK)
 8022bca:	2d00      	cmp	r5, #0
 8022bcc:	d1d2      	bne.n	8022b74 <HAL_SUBGHZ_Init+0x48>
 8022bce:	e7ca      	b.n	8022b66 <HAL_SUBGHZ_Init+0x3a>
    } while (LL_RCC_IsRFUnderReset() != 0UL);
 8022bd0:	2900      	cmp	r1, #0
 8022bd2:	d0ea      	beq.n	8022baa <HAL_SUBGHZ_Init+0x7e>
      if (count == 0U)
 8022bd4:	9b01      	ldr	r3, [sp, #4]
 8022bd6:	2b00      	cmp	r3, #0
 8022bd8:	d0e4      	beq.n	8022ba4 <HAL_SUBGHZ_Init+0x78>
      count--;
 8022bda:	9b01      	ldr	r3, [sp, #4]
 8022bdc:	3b01      	subs	r3, #1
 8022bde:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 8022be0:	22b0      	movs	r2, #176	@ 0xb0
 8022be2:	05d2      	lsls	r2, r2, #23
 8022be4:	2394      	movs	r3, #148	@ 0x94
 8022be6:	58d2      	ldr	r2, [r2, r3]
 8022be8:	2380      	movs	r3, #128	@ 0x80
 8022bea:	01db      	lsls	r3, r3, #7
 8022bec:	0011      	movs	r1, r2
 8022bee:	4019      	ands	r1, r3
 8022bf0:	421a      	tst	r2, r3
 8022bf2:	d0ed      	beq.n	8022bd0 <HAL_SUBGHZ_Init+0xa4>
 8022bf4:	2101      	movs	r1, #1
 8022bf6:	e7eb      	b.n	8022bd0 <HAL_SUBGHZ_Init+0xa4>
    return status;
 8022bf8:	2501      	movs	r5, #1
 8022bfa:	e7bd      	b.n	8022b78 <HAL_SUBGHZ_Init+0x4c>
 8022bfc:	58000800 	.word	0x58000800
 8022c00:	58000400 	.word	0x58000400
 8022c04:	ffff7fff 	.word	0xffff7fff
 8022c08:	2000a000 	.word	0x2000a000
 8022c0c:	fffff7ff 	.word	0xfffff7ff

08022c10 <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 8022c10:	b082      	sub	sp, #8
 8022c12:	0002      	movs	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8022c14:	4b1a      	ldr	r3, [pc, #104]	@ (8022c80 <SUBGHZSPI_Transmit+0x70>)
 8022c16:	6818      	ldr	r0, [r3, #0]
 8022c18:	00c3      	lsls	r3, r0, #3
 8022c1a:	1a1b      	subs	r3, r3, r0
 8022c1c:	009b      	lsls	r3, r3, #2
 8022c1e:	0cdb      	lsrs	r3, r3, #19
 8022c20:	2064      	movs	r0, #100	@ 0x64
 8022c22:	4343      	muls	r3, r0
 8022c24:	9301      	str	r3, [sp, #4]

  /* Wait until TXE flag is set */
  do
  {
    if (count == 0U)
 8022c26:	9b01      	ldr	r3, [sp, #4]
 8022c28:	2b00      	cmp	r3, #0
 8022c2a:	d008      	beq.n	8022c3e <SUBGHZSPI_Transmit+0x2e>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 8022c2c:	9b01      	ldr	r3, [sp, #4]
 8022c2e:	3b01      	subs	r3, #1
 8022c30:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 8022c32:	4b14      	ldr	r3, [pc, #80]	@ (8022c84 <SUBGHZSPI_Transmit+0x74>)
 8022c34:	689b      	ldr	r3, [r3, #8]
 8022c36:	079b      	lsls	r3, r3, #30
 8022c38:	d5f5      	bpl.n	8022c26 <SUBGHZSPI_Transmit+0x16>
  HAL_StatusTypeDef status = HAL_OK;
 8022c3a:	2000      	movs	r0, #0
 8022c3c:	e002      	b.n	8022c44 <SUBGHZSPI_Transmit+0x34>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8022c3e:	3301      	adds	r3, #1
 8022c40:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8022c42:	2001      	movs	r0, #1

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 8022c44:	4b10      	ldr	r3, [pc, #64]	@ (8022c88 <SUBGHZSPI_Transmit+0x78>)
 8022c46:	7019      	strb	r1, [r3, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8022c48:	4b0d      	ldr	r3, [pc, #52]	@ (8022c80 <SUBGHZSPI_Transmit+0x70>)
 8022c4a:	6819      	ldr	r1, [r3, #0]
 8022c4c:	00cb      	lsls	r3, r1, #3
 8022c4e:	1a5b      	subs	r3, r3, r1
 8022c50:	009b      	lsls	r3, r3, #2
 8022c52:	0cdb      	lsrs	r3, r3, #19
 8022c54:	2164      	movs	r1, #100	@ 0x64
 8022c56:	434b      	muls	r3, r1
 8022c58:	9301      	str	r3, [sp, #4]

  /* Wait until RXNE flag is set */
  do
  {
    if (count == 0U)
 8022c5a:	9b01      	ldr	r3, [sp, #4]
 8022c5c:	2b00      	cmp	r3, #0
 8022c5e:	d007      	beq.n	8022c70 <SUBGHZSPI_Transmit+0x60>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 8022c60:	9b01      	ldr	r3, [sp, #4]
 8022c62:	3b01      	subs	r3, #1
 8022c64:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 8022c66:	4b07      	ldr	r3, [pc, #28]	@ (8022c84 <SUBGHZSPI_Transmit+0x74>)
 8022c68:	689b      	ldr	r3, [r3, #8]
 8022c6a:	07db      	lsls	r3, r3, #31
 8022c6c:	d5f5      	bpl.n	8022c5a <SUBGHZSPI_Transmit+0x4a>
 8022c6e:	e002      	b.n	8022c76 <SUBGHZSPI_Transmit+0x66>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8022c70:	3301      	adds	r3, #1
 8022c72:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8022c74:	2001      	movs	r0, #1

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 8022c76:	4b03      	ldr	r3, [pc, #12]	@ (8022c84 <SUBGHZSPI_Transmit+0x74>)
 8022c78:	68db      	ldr	r3, [r3, #12]

  return status;
}
 8022c7a:	b002      	add	sp, #8
 8022c7c:	4770      	bx	lr
 8022c7e:	46c0      	nop			@ (mov r8, r8)
 8022c80:	2000a000 	.word	0x2000a000
 8022c84:	58010000 	.word	0x58010000
 8022c88:	5801000c 	.word	0x5801000c

08022c8c <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 8022c8c:	b510      	push	{r4, lr}
 8022c8e:	b082      	sub	sp, #8
 8022c90:	0002      	movs	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8022c92:	4b1b      	ldr	r3, [pc, #108]	@ (8022d00 <SUBGHZSPI_Receive+0x74>)
 8022c94:	6818      	ldr	r0, [r3, #0]
 8022c96:	00c3      	lsls	r3, r0, #3
 8022c98:	1a1b      	subs	r3, r3, r0
 8022c9a:	009b      	lsls	r3, r3, #2
 8022c9c:	0cdb      	lsrs	r3, r3, #19
 8022c9e:	2064      	movs	r0, #100	@ 0x64
 8022ca0:	4343      	muls	r3, r0
 8022ca2:	9301      	str	r3, [sp, #4]

  /* Wait until TXE flag is set */
  do
  {
    if (count == 0U)
 8022ca4:	9b01      	ldr	r3, [sp, #4]
 8022ca6:	2b00      	cmp	r3, #0
 8022ca8:	d008      	beq.n	8022cbc <SUBGHZSPI_Receive+0x30>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 8022caa:	9b01      	ldr	r3, [sp, #4]
 8022cac:	3b01      	subs	r3, #1
 8022cae:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 8022cb0:	4b14      	ldr	r3, [pc, #80]	@ (8022d04 <SUBGHZSPI_Receive+0x78>)
 8022cb2:	689b      	ldr	r3, [r3, #8]
 8022cb4:	079b      	lsls	r3, r3, #30
 8022cb6:	d5f5      	bpl.n	8022ca4 <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 8022cb8:	2000      	movs	r0, #0
 8022cba:	e002      	b.n	8022cc2 <SUBGHZSPI_Receive+0x36>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8022cbc:	3301      	adds	r3, #1
 8022cbe:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8022cc0:	2001      	movs	r0, #1

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 8022cc2:	4b11      	ldr	r3, [pc, #68]	@ (8022d08 <SUBGHZSPI_Receive+0x7c>)
 8022cc4:	24ff      	movs	r4, #255	@ 0xff
 8022cc6:	701c      	strb	r4, [r3, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8022cc8:	4b0d      	ldr	r3, [pc, #52]	@ (8022d00 <SUBGHZSPI_Receive+0x74>)
 8022cca:	681c      	ldr	r4, [r3, #0]
 8022ccc:	00e3      	lsls	r3, r4, #3
 8022cce:	1b1b      	subs	r3, r3, r4
 8022cd0:	009b      	lsls	r3, r3, #2
 8022cd2:	0cdb      	lsrs	r3, r3, #19
 8022cd4:	2464      	movs	r4, #100	@ 0x64
 8022cd6:	4363      	muls	r3, r4
 8022cd8:	9301      	str	r3, [sp, #4]

  /* Wait until RXNE flag is set */
  do
  {
    if (count == 0U)
 8022cda:	9b01      	ldr	r3, [sp, #4]
 8022cdc:	2b00      	cmp	r3, #0
 8022cde:	d007      	beq.n	8022cf0 <SUBGHZSPI_Receive+0x64>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 8022ce0:	9b01      	ldr	r3, [sp, #4]
 8022ce2:	3b01      	subs	r3, #1
 8022ce4:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 8022ce6:	4b07      	ldr	r3, [pc, #28]	@ (8022d04 <SUBGHZSPI_Receive+0x78>)
 8022ce8:	689b      	ldr	r3, [r3, #8]
 8022cea:	07db      	lsls	r3, r3, #31
 8022cec:	d5f5      	bpl.n	8022cda <SUBGHZSPI_Receive+0x4e>
 8022cee:	e002      	b.n	8022cf6 <SUBGHZSPI_Receive+0x6a>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8022cf0:	3301      	adds	r3, #1
 8022cf2:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8022cf4:	2001      	movs	r0, #1

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 8022cf6:	4b03      	ldr	r3, [pc, #12]	@ (8022d04 <SUBGHZSPI_Receive+0x78>)
 8022cf8:	68db      	ldr	r3, [r3, #12]
 8022cfa:	700b      	strb	r3, [r1, #0]

  return status;
}
 8022cfc:	b002      	add	sp, #8
 8022cfe:	bd10      	pop	{r4, pc}
 8022d00:	2000a000 	.word	0x2000a000
 8022d04:	58010000 	.word	0x58010000
 8022d08:	5801000c 	.word	0x5801000c

08022d0c <SUBGHZ_WaitOnBusy>:
  * @param  hsubghz pointer to a SUBGHZ_HandleTypeDef structure that contains
  *         the handle information for SUBGHZ module.
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZ_WaitOnBusy(SUBGHZ_HandleTypeDef *hsubghz)
{
 8022d0c:	b510      	push	{r4, lr}
 8022d0e:	b082      	sub	sp, #8
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 8022d10:	4b14      	ldr	r3, [pc, #80]	@ (8022d64 <SUBGHZ_WaitOnBusy+0x58>)
 8022d12:	681a      	ldr	r2, [r3, #0]
 8022d14:	0053      	lsls	r3, r2, #1
 8022d16:	189b      	adds	r3, r3, r2
 8022d18:	00db      	lsls	r3, r3, #3
 8022d1a:	0d1b      	lsrs	r3, r3, #20
 8022d1c:	2264      	movs	r2, #100	@ 0x64
 8022d1e:	4353      	muls	r3, r2
 8022d20:	9301      	str	r3, [sp, #4]
 8022d22:	e006      	b.n	8022d32 <SUBGHZ_WaitOnBusy+0x26>
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 8022d24:	3302      	adds	r3, #2
 8022d26:	6083      	str	r3, [r0, #8]
      status  = HAL_ERROR;
 8022d28:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 8022d2a:	b002      	add	sp, #8
 8022d2c:	bd10      	pop	{r4, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 8022d2e:	420c      	tst	r4, r1
 8022d30:	d016      	beq.n	8022d60 <SUBGHZ_WaitOnBusy+0x54>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8022d32:	4b0d      	ldr	r3, [pc, #52]	@ (8022d68 <SUBGHZ_WaitOnBusy+0x5c>)
 8022d34:	695b      	ldr	r3, [r3, #20]
 8022d36:	2204      	movs	r2, #4
 8022d38:	0011      	movs	r1, r2
 8022d3a:	4019      	ands	r1, r3
 8022d3c:	421a      	tst	r2, r3
 8022d3e:	d000      	beq.n	8022d42 <SUBGHZ_WaitOnBusy+0x36>
 8022d40:	2101      	movs	r1, #1
    if (count == 0U)
 8022d42:	9b01      	ldr	r3, [sp, #4]
 8022d44:	2b00      	cmp	r3, #0
 8022d46:	d0ed      	beq.n	8022d24 <SUBGHZ_WaitOnBusy+0x18>
    count--;
 8022d48:	9b01      	ldr	r3, [sp, #4]
 8022d4a:	3b01      	subs	r3, #1
 8022d4c:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 8022d4e:	4b06      	ldr	r3, [pc, #24]	@ (8022d68 <SUBGHZ_WaitOnBusy+0x5c>)
 8022d50:	695b      	ldr	r3, [r3, #20]
 8022d52:	2202      	movs	r2, #2
 8022d54:	0014      	movs	r4, r2
 8022d56:	401c      	ands	r4, r3
 8022d58:	421a      	tst	r2, r3
 8022d5a:	d0e8      	beq.n	8022d2e <SUBGHZ_WaitOnBusy+0x22>
 8022d5c:	2401      	movs	r4, #1
 8022d5e:	e7e6      	b.n	8022d2e <SUBGHZ_WaitOnBusy+0x22>
  status = HAL_OK;
 8022d60:	2000      	movs	r0, #0
 8022d62:	e7e2      	b.n	8022d2a <SUBGHZ_WaitOnBusy+0x1e>
 8022d64:	2000a000 	.word	0x2000a000
 8022d68:	58000400 	.word	0x58000400

08022d6c <SUBGHZ_CheckDeviceReady>:
{
 8022d6c:	b510      	push	{r4, lr}
 8022d6e:	b082      	sub	sp, #8
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 8022d70:	7903      	ldrb	r3, [r0, #4]
 8022d72:	2b01      	cmp	r3, #1
 8022d74:	d003      	beq.n	8022d7e <SUBGHZ_CheckDeviceReady+0x12>
  return (SUBGHZ_WaitOnBusy(hsubghz));
 8022d76:	f7ff ffc9 	bl	8022d0c <SUBGHZ_WaitOnBusy>
}
 8022d7a:	b002      	add	sp, #8
 8022d7c:	bd10      	pop	{r4, pc}
    count  = SUBGHZ_NSS_LOOP_TIME;
 8022d7e:	4b0d      	ldr	r3, [pc, #52]	@ (8022db4 <SUBGHZ_CheckDeviceReady+0x48>)
 8022d80:	681a      	ldr	r2, [r3, #0]
 8022d82:	0053      	lsls	r3, r2, #1
 8022d84:	189b      	adds	r3, r3, r2
 8022d86:	00db      	lsls	r3, r3, #3
 8022d88:	0c1b      	lsrs	r3, r3, #16
 8022d8a:	9301      	str	r3, [sp, #4]
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022d8c:	490a      	ldr	r1, [pc, #40]	@ (8022db8 <SUBGHZ_CheckDeviceReady+0x4c>)
 8022d8e:	2290      	movs	r2, #144	@ 0x90
 8022d90:	588b      	ldr	r3, [r1, r2]
 8022d92:	4c0a      	ldr	r4, [pc, #40]	@ (8022dbc <SUBGHZ_CheckDeviceReady+0x50>)
 8022d94:	4023      	ands	r3, r4
 8022d96:	508b      	str	r3, [r1, r2]
      count--;
 8022d98:	9b01      	ldr	r3, [sp, #4]
 8022d9a:	3b01      	subs	r3, #1
 8022d9c:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 8022d9e:	9b01      	ldr	r3, [sp, #4]
 8022da0:	2b00      	cmp	r3, #0
 8022da2:	d1f9      	bne.n	8022d98 <SUBGHZ_CheckDeviceReady+0x2c>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022da4:	4904      	ldr	r1, [pc, #16]	@ (8022db8 <SUBGHZ_CheckDeviceReady+0x4c>)
 8022da6:	2290      	movs	r2, #144	@ 0x90
 8022da8:	588c      	ldr	r4, [r1, r2]
 8022daa:	2380      	movs	r3, #128	@ 0x80
 8022dac:	021b      	lsls	r3, r3, #8
 8022dae:	4323      	orrs	r3, r4
 8022db0:	508b      	str	r3, [r1, r2]
}
 8022db2:	e7e0      	b.n	8022d76 <SUBGHZ_CheckDeviceReady+0xa>
 8022db4:	2000a000 	.word	0x2000a000
 8022db8:	58000400 	.word	0x58000400
 8022dbc:	ffff7fff 	.word	0xffff7fff

08022dc0 <HAL_SUBGHZ_WriteRegisters>:
{
 8022dc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022dc2:	46c6      	mov	lr, r8
 8022dc4:	b500      	push	{lr}
 8022dc6:	0005      	movs	r5, r0
 8022dc8:	000c      	movs	r4, r1
 8022dca:	0017      	movs	r7, r2
 8022dcc:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8022dce:	7983      	ldrb	r3, [r0, #6]
 8022dd0:	b2da      	uxtb	r2, r3
 8022dd2:	4690      	mov	r8, r2
 8022dd4:	2b01      	cmp	r3, #1
 8022dd6:	d13a      	bne.n	8022e4e <HAL_SUBGHZ_WriteRegisters+0x8e>
    __HAL_LOCK(hsubghz);
 8022dd8:	7943      	ldrb	r3, [r0, #5]
 8022dda:	2b01      	cmp	r3, #1
 8022ddc:	d03a      	beq.n	8022e54 <HAL_SUBGHZ_WriteRegisters+0x94>
 8022dde:	2301      	movs	r3, #1
 8022de0:	7143      	strb	r3, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8022de2:	3301      	adds	r3, #1
 8022de4:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8022de6:	f7ff ffc1 	bl	8022d6c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022dea:	491c      	ldr	r1, [pc, #112]	@ (8022e5c <HAL_SUBGHZ_WriteRegisters+0x9c>)
 8022dec:	2290      	movs	r2, #144	@ 0x90
 8022dee:	588b      	ldr	r3, [r1, r2]
 8022df0:	481b      	ldr	r0, [pc, #108]	@ (8022e60 <HAL_SUBGHZ_WriteRegisters+0xa0>)
 8022df2:	4003      	ands	r3, r0
 8022df4:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 8022df6:	210d      	movs	r1, #13
 8022df8:	0028      	movs	r0, r5
 8022dfa:	f7ff ff09 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 8022dfe:	0a21      	lsrs	r1, r4, #8
 8022e00:	0028      	movs	r0, r5
 8022e02:	f7ff ff05 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 8022e06:	b2e1      	uxtb	r1, r4
 8022e08:	0028      	movs	r0, r5
 8022e0a:	f7ff ff01 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8022e0e:	2400      	movs	r4, #0
 8022e10:	e005      	b.n	8022e1e <HAL_SUBGHZ_WriteRegisters+0x5e>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8022e12:	5d39      	ldrb	r1, [r7, r4]
 8022e14:	0028      	movs	r0, r5
 8022e16:	f7ff fefb 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8022e1a:	3401      	adds	r4, #1
 8022e1c:	b2a4      	uxth	r4, r4
 8022e1e:	42b4      	cmp	r4, r6
 8022e20:	d3f7      	bcc.n	8022e12 <HAL_SUBGHZ_WriteRegisters+0x52>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022e22:	490e      	ldr	r1, [pc, #56]	@ (8022e5c <HAL_SUBGHZ_WriteRegisters+0x9c>)
 8022e24:	2290      	movs	r2, #144	@ 0x90
 8022e26:	5888      	ldr	r0, [r1, r2]
 8022e28:	2380      	movs	r3, #128	@ 0x80
 8022e2a:	021b      	lsls	r3, r3, #8
 8022e2c:	4303      	orrs	r3, r0
 8022e2e:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8022e30:	0028      	movs	r0, r5
 8022e32:	f7ff ff6b 	bl	8022d0c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8022e36:	68ab      	ldr	r3, [r5, #8]
 8022e38:	2b00      	cmp	r3, #0
 8022e3a:	d100      	bne.n	8022e3e <HAL_SUBGHZ_WriteRegisters+0x7e>
      status = HAL_OK;
 8022e3c:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8022e3e:	2301      	movs	r3, #1
 8022e40:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8022e42:	2300      	movs	r3, #0
 8022e44:	716b      	strb	r3, [r5, #5]
}
 8022e46:	4640      	mov	r0, r8
 8022e48:	bc80      	pop	{r7}
 8022e4a:	46b8      	mov	r8, r7
 8022e4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8022e4e:	2302      	movs	r3, #2
 8022e50:	4698      	mov	r8, r3
 8022e52:	e7f8      	b.n	8022e46 <HAL_SUBGHZ_WriteRegisters+0x86>
    __HAL_LOCK(hsubghz);
 8022e54:	2302      	movs	r3, #2
 8022e56:	4698      	mov	r8, r3
 8022e58:	e7f5      	b.n	8022e46 <HAL_SUBGHZ_WriteRegisters+0x86>
 8022e5a:	46c0      	nop			@ (mov r8, r8)
 8022e5c:	58000400 	.word	0x58000400
 8022e60:	ffff7fff 	.word	0xffff7fff

08022e64 <HAL_SUBGHZ_ReadRegisters>:
{
 8022e64:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022e66:	46c6      	mov	lr, r8
 8022e68:	b500      	push	{lr}
 8022e6a:	0006      	movs	r6, r0
 8022e6c:	000c      	movs	r4, r1
 8022e6e:	0015      	movs	r5, r2
 8022e70:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8022e72:	7983      	ldrb	r3, [r0, #6]
 8022e74:	b2da      	uxtb	r2, r3
 8022e76:	4690      	mov	r8, r2
 8022e78:	2b01      	cmp	r3, #1
 8022e7a:	d13d      	bne.n	8022ef8 <HAL_SUBGHZ_ReadRegisters+0x94>
    __HAL_LOCK(hsubghz);
 8022e7c:	7943      	ldrb	r3, [r0, #5]
 8022e7e:	2b01      	cmp	r3, #1
 8022e80:	d03d      	beq.n	8022efe <HAL_SUBGHZ_ReadRegisters+0x9a>
 8022e82:	2301      	movs	r3, #1
 8022e84:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8022e86:	f7ff ff71 	bl	8022d6c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022e8a:	491e      	ldr	r1, [pc, #120]	@ (8022f04 <HAL_SUBGHZ_ReadRegisters+0xa0>)
 8022e8c:	2290      	movs	r2, #144	@ 0x90
 8022e8e:	588b      	ldr	r3, [r1, r2]
 8022e90:	481d      	ldr	r0, [pc, #116]	@ (8022f08 <HAL_SUBGHZ_ReadRegisters+0xa4>)
 8022e92:	4003      	ands	r3, r0
 8022e94:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 8022e96:	211d      	movs	r1, #29
 8022e98:	0030      	movs	r0, r6
 8022e9a:	f7ff feb9 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 8022e9e:	0a21      	lsrs	r1, r4, #8
 8022ea0:	0030      	movs	r0, r6
 8022ea2:	f7ff feb5 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 8022ea6:	b2e1      	uxtb	r1, r4
 8022ea8:	0030      	movs	r0, r6
 8022eaa:	f7ff feb1 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 8022eae:	2100      	movs	r1, #0
 8022eb0:	0030      	movs	r0, r6
 8022eb2:	f7ff fead 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8022eb6:	2400      	movs	r4, #0
 8022eb8:	e006      	b.n	8022ec8 <HAL_SUBGHZ_ReadRegisters+0x64>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8022eba:	0029      	movs	r1, r5
 8022ebc:	0030      	movs	r0, r6
 8022ebe:	f7ff fee5 	bl	8022c8c <SUBGHZSPI_Receive>
      pData++;
 8022ec2:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 8022ec4:	3401      	adds	r4, #1
 8022ec6:	b2a4      	uxth	r4, r4
 8022ec8:	42bc      	cmp	r4, r7
 8022eca:	d3f6      	bcc.n	8022eba <HAL_SUBGHZ_ReadRegisters+0x56>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022ecc:	490d      	ldr	r1, [pc, #52]	@ (8022f04 <HAL_SUBGHZ_ReadRegisters+0xa0>)
 8022ece:	2290      	movs	r2, #144	@ 0x90
 8022ed0:	5888      	ldr	r0, [r1, r2]
 8022ed2:	2380      	movs	r3, #128	@ 0x80
 8022ed4:	021b      	lsls	r3, r3, #8
 8022ed6:	4303      	orrs	r3, r0
 8022ed8:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8022eda:	0030      	movs	r0, r6
 8022edc:	f7ff ff16 	bl	8022d0c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8022ee0:	68b3      	ldr	r3, [r6, #8]
 8022ee2:	2b00      	cmp	r3, #0
 8022ee4:	d100      	bne.n	8022ee8 <HAL_SUBGHZ_ReadRegisters+0x84>
      status = HAL_OK;
 8022ee6:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8022ee8:	2301      	movs	r3, #1
 8022eea:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 8022eec:	2300      	movs	r3, #0
 8022eee:	7173      	strb	r3, [r6, #5]
}
 8022ef0:	4640      	mov	r0, r8
 8022ef2:	bc80      	pop	{r7}
 8022ef4:	46b8      	mov	r8, r7
 8022ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8022ef8:	2302      	movs	r3, #2
 8022efa:	4698      	mov	r8, r3
 8022efc:	e7f8      	b.n	8022ef0 <HAL_SUBGHZ_ReadRegisters+0x8c>
    __HAL_LOCK(hsubghz);
 8022efe:	2302      	movs	r3, #2
 8022f00:	4698      	mov	r8, r3
 8022f02:	e7f5      	b.n	8022ef0 <HAL_SUBGHZ_ReadRegisters+0x8c>
 8022f04:	58000400 	.word	0x58000400
 8022f08:	ffff7fff 	.word	0xffff7fff

08022f0c <HAL_SUBGHZ_ExecSetCmd>:
{
 8022f0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8022f0e:	46ce      	mov	lr, r9
 8022f10:	4647      	mov	r7, r8
 8022f12:	b580      	push	{r7, lr}
 8022f14:	0005      	movs	r5, r0
 8022f16:	4688      	mov	r8, r1
 8022f18:	0017      	movs	r7, r2
 8022f1a:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8022f1c:	7983      	ldrb	r3, [r0, #6]
 8022f1e:	b2da      	uxtb	r2, r3
 8022f20:	4691      	mov	r9, r2
 8022f22:	2b01      	cmp	r3, #1
 8022f24:	d13f      	bne.n	8022fa6 <HAL_SUBGHZ_ExecSetCmd+0x9a>
    __HAL_LOCK(hsubghz);
 8022f26:	7943      	ldrb	r3, [r0, #5]
 8022f28:	2b01      	cmp	r3, #1
 8022f2a:	d03f      	beq.n	8022fac <HAL_SUBGHZ_ExecSetCmd+0xa0>
 8022f2c:	2301      	movs	r3, #1
 8022f2e:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8022f30:	f7ff ff1c 	bl	8022d6c <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 8022f34:	4643      	mov	r3, r8
 8022f36:	2b84      	cmp	r3, #132	@ 0x84
 8022f38:	d004      	beq.n	8022f44 <HAL_SUBGHZ_ExecSetCmd+0x38>
 8022f3a:	2b94      	cmp	r3, #148	@ 0x94
 8022f3c:	d002      	beq.n	8022f44 <HAL_SUBGHZ_ExecSetCmd+0x38>
      hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_DISABLE;
 8022f3e:	2300      	movs	r3, #0
 8022f40:	712b      	strb	r3, [r5, #4]
 8022f42:	e001      	b.n	8022f48 <HAL_SUBGHZ_ExecSetCmd+0x3c>
      hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 8022f44:	2301      	movs	r3, #1
 8022f46:	712b      	strb	r3, [r5, #4]
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022f48:	491a      	ldr	r1, [pc, #104]	@ (8022fb4 <HAL_SUBGHZ_ExecSetCmd+0xa8>)
 8022f4a:	2290      	movs	r2, #144	@ 0x90
 8022f4c:	588b      	ldr	r3, [r1, r2]
 8022f4e:	481a      	ldr	r0, [pc, #104]	@ (8022fb8 <HAL_SUBGHZ_ExecSetCmd+0xac>)
 8022f50:	4003      	ands	r3, r0
 8022f52:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 8022f54:	4641      	mov	r1, r8
 8022f56:	0028      	movs	r0, r5
 8022f58:	f7ff fe5a 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8022f5c:	2400      	movs	r4, #0
 8022f5e:	e005      	b.n	8022f6c <HAL_SUBGHZ_ExecSetCmd+0x60>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8022f60:	5d39      	ldrb	r1, [r7, r4]
 8022f62:	0028      	movs	r0, r5
 8022f64:	f7ff fe54 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8022f68:	3401      	adds	r4, #1
 8022f6a:	b2a4      	uxth	r4, r4
 8022f6c:	42b4      	cmp	r4, r6
 8022f6e:	d3f7      	bcc.n	8022f60 <HAL_SUBGHZ_ExecSetCmd+0x54>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022f70:	4910      	ldr	r1, [pc, #64]	@ (8022fb4 <HAL_SUBGHZ_ExecSetCmd+0xa8>)
 8022f72:	2290      	movs	r2, #144	@ 0x90
 8022f74:	5888      	ldr	r0, [r1, r2]
 8022f76:	2380      	movs	r3, #128	@ 0x80
 8022f78:	021b      	lsls	r3, r3, #8
 8022f7a:	4303      	orrs	r3, r0
 8022f7c:	508b      	str	r3, [r1, r2]
    if (Command != RADIO_SET_SLEEP)
 8022f7e:	4643      	mov	r3, r8
 8022f80:	2b84      	cmp	r3, #132	@ 0x84
 8022f82:	d10c      	bne.n	8022f9e <HAL_SUBGHZ_ExecSetCmd+0x92>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8022f84:	68ab      	ldr	r3, [r5, #8]
 8022f86:	2b00      	cmp	r3, #0
 8022f88:	d100      	bne.n	8022f8c <HAL_SUBGHZ_ExecSetCmd+0x80>
      status = HAL_OK;
 8022f8a:	4699      	mov	r9, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8022f8c:	2301      	movs	r3, #1
 8022f8e:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8022f90:	2300      	movs	r3, #0
 8022f92:	716b      	strb	r3, [r5, #5]
}
 8022f94:	4648      	mov	r0, r9
 8022f96:	bcc0      	pop	{r6, r7}
 8022f98:	46b9      	mov	r9, r7
 8022f9a:	46b0      	mov	r8, r6
 8022f9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 8022f9e:	0028      	movs	r0, r5
 8022fa0:	f7ff feb4 	bl	8022d0c <SUBGHZ_WaitOnBusy>
 8022fa4:	e7ee      	b.n	8022f84 <HAL_SUBGHZ_ExecSetCmd+0x78>
    return HAL_BUSY;
 8022fa6:	2302      	movs	r3, #2
 8022fa8:	4699      	mov	r9, r3
 8022faa:	e7f3      	b.n	8022f94 <HAL_SUBGHZ_ExecSetCmd+0x88>
    __HAL_LOCK(hsubghz);
 8022fac:	2302      	movs	r3, #2
 8022fae:	4699      	mov	r9, r3
 8022fb0:	e7f0      	b.n	8022f94 <HAL_SUBGHZ_ExecSetCmd+0x88>
 8022fb2:	46c0      	nop			@ (mov r8, r8)
 8022fb4:	58000400 	.word	0x58000400
 8022fb8:	ffff7fff 	.word	0xffff7fff

08022fbc <HAL_SUBGHZ_ExecGetCmd>:
{
 8022fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022fbe:	46c6      	mov	lr, r8
 8022fc0:	b500      	push	{lr}
 8022fc2:	0006      	movs	r6, r0
 8022fc4:	000c      	movs	r4, r1
 8022fc6:	0015      	movs	r5, r2
 8022fc8:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8022fca:	7983      	ldrb	r3, [r0, #6]
 8022fcc:	b2da      	uxtb	r2, r3
 8022fce:	4690      	mov	r8, r2
 8022fd0:	2b01      	cmp	r3, #1
 8022fd2:	d135      	bne.n	8023040 <HAL_SUBGHZ_ExecGetCmd+0x84>
    __HAL_LOCK(hsubghz);
 8022fd4:	7943      	ldrb	r3, [r0, #5]
 8022fd6:	2b01      	cmp	r3, #1
 8022fd8:	d035      	beq.n	8023046 <HAL_SUBGHZ_ExecGetCmd+0x8a>
 8022fda:	2301      	movs	r3, #1
 8022fdc:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8022fde:	f7ff fec5 	bl	8022d6c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8022fe2:	491a      	ldr	r1, [pc, #104]	@ (802304c <HAL_SUBGHZ_ExecGetCmd+0x90>)
 8022fe4:	2290      	movs	r2, #144	@ 0x90
 8022fe6:	588b      	ldr	r3, [r1, r2]
 8022fe8:	4819      	ldr	r0, [pc, #100]	@ (8023050 <HAL_SUBGHZ_ExecGetCmd+0x94>)
 8022fea:	4003      	ands	r3, r0
 8022fec:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 8022fee:	0021      	movs	r1, r4
 8022ff0:	0030      	movs	r0, r6
 8022ff2:	f7ff fe0d 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 8022ff6:	2100      	movs	r1, #0
 8022ff8:	0030      	movs	r0, r6
 8022ffa:	f7ff fe09 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8022ffe:	2400      	movs	r4, #0
 8023000:	e006      	b.n	8023010 <HAL_SUBGHZ_ExecGetCmd+0x54>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8023002:	0029      	movs	r1, r5
 8023004:	0030      	movs	r0, r6
 8023006:	f7ff fe41 	bl	8022c8c <SUBGHZSPI_Receive>
      pData++;
 802300a:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802300c:	3401      	adds	r4, #1
 802300e:	b2a4      	uxth	r4, r4
 8023010:	42bc      	cmp	r4, r7
 8023012:	d3f6      	bcc.n	8023002 <HAL_SUBGHZ_ExecGetCmd+0x46>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8023014:	490d      	ldr	r1, [pc, #52]	@ (802304c <HAL_SUBGHZ_ExecGetCmd+0x90>)
 8023016:	2290      	movs	r2, #144	@ 0x90
 8023018:	5888      	ldr	r0, [r1, r2]
 802301a:	2380      	movs	r3, #128	@ 0x80
 802301c:	021b      	lsls	r3, r3, #8
 802301e:	4303      	orrs	r3, r0
 8023020:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8023022:	0030      	movs	r0, r6
 8023024:	f7ff fe72 	bl	8022d0c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8023028:	68b3      	ldr	r3, [r6, #8]
 802302a:	2b00      	cmp	r3, #0
 802302c:	d100      	bne.n	8023030 <HAL_SUBGHZ_ExecGetCmd+0x74>
      status = HAL_OK;
 802302e:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8023030:	2301      	movs	r3, #1
 8023032:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 8023034:	2300      	movs	r3, #0
 8023036:	7173      	strb	r3, [r6, #5]
}
 8023038:	4640      	mov	r0, r8
 802303a:	bc80      	pop	{r7}
 802303c:	46b8      	mov	r8, r7
 802303e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8023040:	2302      	movs	r3, #2
 8023042:	4698      	mov	r8, r3
 8023044:	e7f8      	b.n	8023038 <HAL_SUBGHZ_ExecGetCmd+0x7c>
    __HAL_LOCK(hsubghz);
 8023046:	2302      	movs	r3, #2
 8023048:	4698      	mov	r8, r3
 802304a:	e7f5      	b.n	8023038 <HAL_SUBGHZ_ExecGetCmd+0x7c>
 802304c:	58000400 	.word	0x58000400
 8023050:	ffff7fff 	.word	0xffff7fff

08023054 <HAL_SUBGHZ_IRQHandler>:
{
 8023054:	b570      	push	{r4, r5, r6, lr}
 8023056:	b082      	sub	sp, #8
 8023058:	0006      	movs	r6, r0
  uint8_t tmpisr[2U] = {0U};
 802305a:	ad01      	add	r5, sp, #4
 802305c:	2300      	movs	r3, #0
 802305e:	802b      	strh	r3, [r5, #0]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2U);
 8023060:	3302      	adds	r3, #2
 8023062:	002a      	movs	r2, r5
 8023064:	2112      	movs	r1, #18
 8023066:	f7ff ffa9 	bl	8022fbc <HAL_SUBGHZ_ExecGetCmd>
  itsource = tmpisr[0U];
 802306a:	782b      	ldrb	r3, [r5, #0]
  itsource = (itsource << 8U) | tmpisr[1U];
 802306c:	021b      	lsls	r3, r3, #8
 802306e:	786c      	ldrb	r4, [r5, #1]
 8023070:	431c      	orrs	r4, r3
 8023072:	b224      	sxth	r4, r4
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2U);
 8023074:	2302      	movs	r3, #2
 8023076:	002a      	movs	r2, r5
 8023078:	2102      	movs	r1, #2
 802307a:	0030      	movs	r0, r6
 802307c:	f7ff ff46 	bl	8022f0c <HAL_SUBGHZ_ExecSetCmd>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 8023080:	07e3      	lsls	r3, r4, #31
 8023082:	d41b      	bmi.n	80230bc <HAL_SUBGHZ_IRQHandler+0x68>
  if ((SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET) && \
 8023084:	2342      	movs	r3, #66	@ 0x42
 8023086:	4023      	ands	r3, r4
 8023088:	2b02      	cmp	r3, #2
 802308a:	d01b      	beq.n	80230c4 <HAL_SUBGHZ_IRQHandler+0x70>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 802308c:	0763      	lsls	r3, r4, #29
 802308e:	d41d      	bmi.n	80230cc <HAL_SUBGHZ_IRQHandler+0x78>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 8023090:	0723      	lsls	r3, r4, #28
 8023092:	d41f      	bmi.n	80230d4 <HAL_SUBGHZ_IRQHandler+0x80>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 8023094:	06e3      	lsls	r3, r4, #27
 8023096:	d421      	bmi.n	80230dc <HAL_SUBGHZ_IRQHandler+0x88>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 8023098:	06a3      	lsls	r3, r4, #26
 802309a:	d423      	bmi.n	80230e4 <HAL_SUBGHZ_IRQHandler+0x90>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 802309c:	0663      	lsls	r3, r4, #25
 802309e:	d425      	bmi.n	80230ec <HAL_SUBGHZ_IRQHandler+0x98>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 80230a0:	0623      	lsls	r3, r4, #24
 80230a2:	d505      	bpl.n	80230b0 <HAL_SUBGHZ_IRQHandler+0x5c>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 80230a4:	05e3      	lsls	r3, r4, #23
 80230a6:	d525      	bpl.n	80230f4 <HAL_SUBGHZ_IRQHandler+0xa0>
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 80230a8:	2101      	movs	r1, #1
 80230aa:	0030      	movs	r0, r6
 80230ac:	f002 f9dc 	bl	8025468 <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 80230b0:	05a3      	lsls	r3, r4, #22
 80230b2:	d424      	bmi.n	80230fe <HAL_SUBGHZ_IRQHandler+0xaa>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_LR_FHSS_HOP) != RESET)
 80230b4:	0464      	lsls	r4, r4, #17
 80230b6:	d426      	bmi.n	8023106 <HAL_SUBGHZ_IRQHandler+0xb2>
}
 80230b8:	b002      	add	sp, #8
 80230ba:	bd70      	pop	{r4, r5, r6, pc}
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 80230bc:	0030      	movs	r0, r6
 80230be:	f002 f9bb 	bl	8025438 <HAL_SUBGHZ_TxCpltCallback>
 80230c2:	e7df      	b.n	8023084 <HAL_SUBGHZ_IRQHandler+0x30>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 80230c4:	0030      	movs	r0, r6
 80230c6:	f002 f9bf 	bl	8025448 <HAL_SUBGHZ_RxCpltCallback>
 80230ca:	e7df      	b.n	802308c <HAL_SUBGHZ_IRQHandler+0x38>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 80230cc:	0030      	movs	r0, r6
 80230ce:	f002 f9f1 	bl	80254b4 <HAL_SUBGHZ_PreambleDetectedCallback>
 80230d2:	e7dd      	b.n	8023090 <HAL_SUBGHZ_IRQHandler+0x3c>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 80230d4:	0030      	movs	r0, r6
 80230d6:	f002 f9f5 	bl	80254c4 <HAL_SUBGHZ_SyncWordValidCallback>
 80230da:	e7db      	b.n	8023094 <HAL_SUBGHZ_IRQHandler+0x40>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 80230dc:	0030      	movs	r0, r6
 80230de:	f002 f9f9 	bl	80254d4 <HAL_SUBGHZ_HeaderValidCallback>
 80230e2:	e7d9      	b.n	8023098 <HAL_SUBGHZ_IRQHandler+0x44>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 80230e4:	0030      	movs	r0, r6
 80230e6:	f002 f9dd 	bl	80254a4 <HAL_SUBGHZ_HeaderErrorCallback>
 80230ea:	e7d7      	b.n	802309c <HAL_SUBGHZ_IRQHandler+0x48>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 80230ec:	0030      	movs	r0, r6
 80230ee:	f002 f9b3 	bl	8025458 <HAL_SUBGHZ_CRCErrorCallback>
 80230f2:	e7d5      	b.n	80230a0 <HAL_SUBGHZ_IRQHandler+0x4c>
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 80230f4:	2100      	movs	r1, #0
 80230f6:	0030      	movs	r0, r6
 80230f8:	f002 f9b6 	bl	8025468 <HAL_SUBGHZ_CADStatusCallback>
 80230fc:	e7d8      	b.n	80230b0 <HAL_SUBGHZ_IRQHandler+0x5c>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 80230fe:	0030      	movs	r0, r6
 8023100:	f002 f9c6 	bl	8025490 <HAL_SUBGHZ_RxTxTimeoutCallback>
 8023104:	e7d6      	b.n	80230b4 <HAL_SUBGHZ_IRQHandler+0x60>
    HAL_SUBGHZ_LrFhssHopCallback(hsubghz);
 8023106:	0030      	movs	r0, r6
 8023108:	f002 f9ec 	bl	80254e4 <HAL_SUBGHZ_LrFhssHopCallback>
}
 802310c:	e7d4      	b.n	80230b8 <HAL_SUBGHZ_IRQHandler+0x64>
	...

08023110 <HAL_SUBGHZ_WriteBuffer>:
{
 8023110:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023112:	46c6      	mov	lr, r8
 8023114:	b500      	push	{lr}
 8023116:	0005      	movs	r5, r0
 8023118:	000c      	movs	r4, r1
 802311a:	0017      	movs	r7, r2
 802311c:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802311e:	7983      	ldrb	r3, [r0, #6]
 8023120:	b2da      	uxtb	r2, r3
 8023122:	4690      	mov	r8, r2
 8023124:	2b01      	cmp	r3, #1
 8023126:	d134      	bne.n	8023192 <HAL_SUBGHZ_WriteBuffer+0x82>
    __HAL_LOCK(hsubghz);
 8023128:	7943      	ldrb	r3, [r0, #5]
 802312a:	2b01      	cmp	r3, #1
 802312c:	d034      	beq.n	8023198 <HAL_SUBGHZ_WriteBuffer+0x88>
 802312e:	2301      	movs	r3, #1
 8023130:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8023132:	f7ff fe1b 	bl	8022d6c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8023136:	491a      	ldr	r1, [pc, #104]	@ (80231a0 <HAL_SUBGHZ_WriteBuffer+0x90>)
 8023138:	2290      	movs	r2, #144	@ 0x90
 802313a:	588b      	ldr	r3, [r1, r2]
 802313c:	4819      	ldr	r0, [pc, #100]	@ (80231a4 <HAL_SUBGHZ_WriteBuffer+0x94>)
 802313e:	4003      	ands	r3, r0
 8023140:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 8023142:	210e      	movs	r1, #14
 8023144:	0028      	movs	r0, r5
 8023146:	f7ff fd63 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802314a:	0021      	movs	r1, r4
 802314c:	0028      	movs	r0, r5
 802314e:	f7ff fd5f 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8023152:	2400      	movs	r4, #0
 8023154:	e005      	b.n	8023162 <HAL_SUBGHZ_WriteBuffer+0x52>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8023156:	5d39      	ldrb	r1, [r7, r4]
 8023158:	0028      	movs	r0, r5
 802315a:	f7ff fd59 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802315e:	3401      	adds	r4, #1
 8023160:	b2a4      	uxth	r4, r4
 8023162:	42b4      	cmp	r4, r6
 8023164:	d3f7      	bcc.n	8023156 <HAL_SUBGHZ_WriteBuffer+0x46>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8023166:	490e      	ldr	r1, [pc, #56]	@ (80231a0 <HAL_SUBGHZ_WriteBuffer+0x90>)
 8023168:	2290      	movs	r2, #144	@ 0x90
 802316a:	5888      	ldr	r0, [r1, r2]
 802316c:	2380      	movs	r3, #128	@ 0x80
 802316e:	021b      	lsls	r3, r3, #8
 8023170:	4303      	orrs	r3, r0
 8023172:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8023174:	0028      	movs	r0, r5
 8023176:	f7ff fdc9 	bl	8022d0c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802317a:	68ab      	ldr	r3, [r5, #8]
 802317c:	2b00      	cmp	r3, #0
 802317e:	d100      	bne.n	8023182 <HAL_SUBGHZ_WriteBuffer+0x72>
      status = HAL_OK;
 8023180:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8023182:	2301      	movs	r3, #1
 8023184:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8023186:	2300      	movs	r3, #0
 8023188:	716b      	strb	r3, [r5, #5]
}
 802318a:	4640      	mov	r0, r8
 802318c:	bc80      	pop	{r7}
 802318e:	46b8      	mov	r8, r7
 8023190:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8023192:	2302      	movs	r3, #2
 8023194:	4698      	mov	r8, r3
 8023196:	e7f8      	b.n	802318a <HAL_SUBGHZ_WriteBuffer+0x7a>
    __HAL_LOCK(hsubghz);
 8023198:	2302      	movs	r3, #2
 802319a:	4698      	mov	r8, r3
 802319c:	e7f5      	b.n	802318a <HAL_SUBGHZ_WriteBuffer+0x7a>
 802319e:	46c0      	nop			@ (mov r8, r8)
 80231a0:	58000400 	.word	0x58000400
 80231a4:	ffff7fff 	.word	0xffff7fff

080231a8 <HAL_SUBGHZ_ReadBuffer>:
{
 80231a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80231aa:	46c6      	mov	lr, r8
 80231ac:	b500      	push	{lr}
 80231ae:	0006      	movs	r6, r0
 80231b0:	000c      	movs	r4, r1
 80231b2:	0015      	movs	r5, r2
 80231b4:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80231b6:	7983      	ldrb	r3, [r0, #6]
 80231b8:	b2da      	uxtb	r2, r3
 80231ba:	4690      	mov	r8, r2
 80231bc:	2b01      	cmp	r3, #1
 80231be:	d139      	bne.n	8023234 <HAL_SUBGHZ_ReadBuffer+0x8c>
    __HAL_LOCK(hsubghz);
 80231c0:	7943      	ldrb	r3, [r0, #5]
 80231c2:	2b01      	cmp	r3, #1
 80231c4:	d039      	beq.n	802323a <HAL_SUBGHZ_ReadBuffer+0x92>
 80231c6:	2301      	movs	r3, #1
 80231c8:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80231ca:	f7ff fdcf 	bl	8022d6c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80231ce:	491c      	ldr	r1, [pc, #112]	@ (8023240 <HAL_SUBGHZ_ReadBuffer+0x98>)
 80231d0:	2290      	movs	r2, #144	@ 0x90
 80231d2:	588b      	ldr	r3, [r1, r2]
 80231d4:	481b      	ldr	r0, [pc, #108]	@ (8023244 <HAL_SUBGHZ_ReadBuffer+0x9c>)
 80231d6:	4003      	ands	r3, r0
 80231d8:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 80231da:	211e      	movs	r1, #30
 80231dc:	0030      	movs	r0, r6
 80231de:	f7ff fd17 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 80231e2:	0021      	movs	r1, r4
 80231e4:	0030      	movs	r0, r6
 80231e6:	f7ff fd13 	bl	8022c10 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 80231ea:	2100      	movs	r1, #0
 80231ec:	0030      	movs	r0, r6
 80231ee:	f7ff fd0f 	bl	8022c10 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80231f2:	2400      	movs	r4, #0
 80231f4:	e006      	b.n	8023204 <HAL_SUBGHZ_ReadBuffer+0x5c>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 80231f6:	0029      	movs	r1, r5
 80231f8:	0030      	movs	r0, r6
 80231fa:	f7ff fd47 	bl	8022c8c <SUBGHZSPI_Receive>
      pData++;
 80231fe:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 8023200:	3401      	adds	r4, #1
 8023202:	b2a4      	uxth	r4, r4
 8023204:	42bc      	cmp	r4, r7
 8023206:	d3f6      	bcc.n	80231f6 <HAL_SUBGHZ_ReadBuffer+0x4e>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8023208:	490d      	ldr	r1, [pc, #52]	@ (8023240 <HAL_SUBGHZ_ReadBuffer+0x98>)
 802320a:	2290      	movs	r2, #144	@ 0x90
 802320c:	5888      	ldr	r0, [r1, r2]
 802320e:	2380      	movs	r3, #128	@ 0x80
 8023210:	021b      	lsls	r3, r3, #8
 8023212:	4303      	orrs	r3, r0
 8023214:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8023216:	0030      	movs	r0, r6
 8023218:	f7ff fd78 	bl	8022d0c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802321c:	68b3      	ldr	r3, [r6, #8]
 802321e:	2b00      	cmp	r3, #0
 8023220:	d100      	bne.n	8023224 <HAL_SUBGHZ_ReadBuffer+0x7c>
      status = HAL_OK;
 8023222:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8023224:	2301      	movs	r3, #1
 8023226:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 8023228:	2300      	movs	r3, #0
 802322a:	7173      	strb	r3, [r6, #5]
}
 802322c:	4640      	mov	r0, r8
 802322e:	bc80      	pop	{r7}
 8023230:	46b8      	mov	r8, r7
 8023232:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8023234:	2302      	movs	r3, #2
 8023236:	4698      	mov	r8, r3
 8023238:	e7f8      	b.n	802322c <HAL_SUBGHZ_ReadBuffer+0x84>
    __HAL_LOCK(hsubghz);
 802323a:	2302      	movs	r3, #2
 802323c:	4698      	mov	r8, r3
 802323e:	e7f5      	b.n	802322c <HAL_SUBGHZ_ReadBuffer+0x84>
 8023240:	58000400 	.word	0x58000400
 8023244:	ffff7fff 	.word	0xffff7fff

08023248 <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 8023248:	2001      	movs	r0, #1
 802324a:	4770      	bx	lr

0802324c <RadioGetLoRaBandwidthInHz>:

static uint32_t RadioGetLoRaBandwidthInHz( RadioLoRaBandwidths_t bw )
{
    uint32_t bandwidthInHz = 0;

    switch( bw )
 802324c:	280a      	cmp	r0, #10
 802324e:	d803      	bhi.n	8023258 <RadioGetLoRaBandwidthInHz+0xc>
 8023250:	0080      	lsls	r0, r0, #2
 8023252:	4b0c      	ldr	r3, [pc, #48]	@ (8023284 <RadioGetLoRaBandwidthInHz+0x38>)
 8023254:	581b      	ldr	r3, [r3, r0]
 8023256:	469f      	mov	pc, r3
 8023258:	2000      	movs	r0, #0
 802325a:	e012      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    {
    case LORA_BW_007:
        bandwidthInHz = 7812UL;
        break;
    case LORA_BW_010:
        bandwidthInHz = 10417UL;
 802325c:	480a      	ldr	r0, [pc, #40]	@ (8023288 <RadioGetLoRaBandwidthInHz+0x3c>)
        break;
 802325e:	e010      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_015:
        bandwidthInHz = 15625UL;
 8023260:	480a      	ldr	r0, [pc, #40]	@ (802328c <RadioGetLoRaBandwidthInHz+0x40>)
        break;
 8023262:	e00e      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_020:
        bandwidthInHz = 20833UL;
 8023264:	480a      	ldr	r0, [pc, #40]	@ (8023290 <RadioGetLoRaBandwidthInHz+0x44>)
        break;
 8023266:	e00c      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_031:
        bandwidthInHz = 31250UL;
 8023268:	480a      	ldr	r0, [pc, #40]	@ (8023294 <RadioGetLoRaBandwidthInHz+0x48>)
        break;
 802326a:	e00a      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_041:
        bandwidthInHz = 41667UL;
 802326c:	480a      	ldr	r0, [pc, #40]	@ (8023298 <RadioGetLoRaBandwidthInHz+0x4c>)
        break;
 802326e:	e008      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_062:
        bandwidthInHz = 62500UL;
 8023270:	480a      	ldr	r0, [pc, #40]	@ (802329c <RadioGetLoRaBandwidthInHz+0x50>)
        break;
 8023272:	e006      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_125:
        bandwidthInHz = 125000UL;
 8023274:	480a      	ldr	r0, [pc, #40]	@ (80232a0 <RadioGetLoRaBandwidthInHz+0x54>)
        break;
 8023276:	e004      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_250:
        bandwidthInHz = 250000UL;
 8023278:	480a      	ldr	r0, [pc, #40]	@ (80232a4 <RadioGetLoRaBandwidthInHz+0x58>)
        break;
 802327a:	e002      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_500:
        bandwidthInHz = 500000UL;
 802327c:	480a      	ldr	r0, [pc, #40]	@ (80232a8 <RadioGetLoRaBandwidthInHz+0x5c>)
        break;
 802327e:	e000      	b.n	8023282 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 7812UL;
 8023280:	480a      	ldr	r0, [pc, #40]	@ (80232ac <RadioGetLoRaBandwidthInHz+0x60>)
    }

    return bandwidthInHz;
}
 8023282:	4770      	bx	lr
 8023284:	0802657c 	.word	0x0802657c
 8023288:	000028b1 	.word	0x000028b1
 802328c:	00003d09 	.word	0x00003d09
 8023290:	00005161 	.word	0x00005161
 8023294:	00007a12 	.word	0x00007a12
 8023298:	0000a2c3 	.word	0x0000a2c3
 802329c:	0000f424 	.word	0x0000f424
 80232a0:	0001e848 	.word	0x0001e848
 80232a4:	0003d090 	.word	0x0003d090
 80232a8:	0007a120 	.word	0x0007a120
 80232ac:	00001e84 	.word	0x00001e84

080232b0 <RadioGetGfskTimeOnAirNumerator>:

static uint32_t RadioGetGfskTimeOnAirNumerator( uint32_t datarate, uint8_t coderate,
                                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                                bool crcOn )
{
 80232b0:	4669      	mov	r1, sp
 80232b2:	7809      	ldrb	r1, [r1, #0]
 80232b4:	a801      	add	r0, sp, #4
 80232b6:	7800      	ldrb	r0, [r0, #0]
    return ( preambleLen << 3 ) +
 80232b8:	00d2      	lsls	r2, r2, #3
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80232ba:	2b00      	cmp	r3, #0
 80232bc:	d109      	bne.n	80232d2 <RadioGetGfskTimeOnAirNumerator+0x22>
 80232be:	3308      	adds	r3, #8
    return ( preambleLen << 3 ) +
 80232c0:	18d2      	adds	r2, r2, r3
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80232c2:	3218      	adds	r2, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80232c4:	2800      	cmp	r0, #0
 80232c6:	d006      	beq.n	80232d6 <RadioGetGfskTimeOnAirNumerator+0x26>
 80232c8:	2302      	movs	r3, #2
 80232ca:	18c9      	adds	r1, r1, r3
 80232cc:	00c9      	lsls	r1, r1, #3
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80232ce:	1850      	adds	r0, r2, r1
}
 80232d0:	4770      	bx	lr
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80232d2:	2300      	movs	r3, #0
 80232d4:	e7f4      	b.n	80232c0 <RadioGetGfskTimeOnAirNumerator+0x10>
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80232d6:	2300      	movs	r3, #0
 80232d8:	e7f7      	b.n	80232ca <RadioGetGfskTimeOnAirNumerator+0x1a>

080232da <RadioGetLoRaTimeOnAirNumerator>:

static uint32_t RadioGetLoRaTimeOnAirNumerator( uint32_t bandwidth,
                                                uint32_t datarate, uint8_t coderate,
                                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                                bool crcOn )
{
 80232da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80232dc:	000d      	movs	r5, r1
 80232de:	001e      	movs	r6, r3
 80232e0:	ab06      	add	r3, sp, #24
 80232e2:	781b      	ldrb	r3, [r3, #0]
 80232e4:	a907      	add	r1, sp, #28
 80232e6:	780c      	ldrb	r4, [r1, #0]
 80232e8:	a908      	add	r1, sp, #32
 80232ea:	7809      	ldrb	r1, [r1, #0]
    int32_t crDenom           = coderate + 4;
 80232ec:	1d17      	adds	r7, r2, #4
    bool    lowDatareOptimize = false;

    // Ensure that the preamble length is at least 12 symbols when using SF5 or SF6
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 80232ee:	1f6a      	subs	r2, r5, #5
 80232f0:	2a01      	cmp	r2, #1
 80232f2:	d92e      	bls.n	8023352 <RadioGetLoRaTimeOnAirNumerator+0x78>
        {
            preambleLen = 12;
        }
    }

    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80232f4:	2800      	cmp	r0, #0
 80232f6:	d103      	bne.n	8023300 <RadioGetLoRaTimeOnAirNumerator+0x26>
 80232f8:	002a      	movs	r2, r5
 80232fa:	3a0b      	subs	r2, #11
 80232fc:	2a01      	cmp	r2, #1
 80232fe:	d931      	bls.n	8023364 <RadioGetLoRaTimeOnAirNumerator+0x8a>
 8023300:	2801      	cmp	r0, #1
 8023302:	d02a      	beq.n	802335a <RadioGetLoRaTimeOnAirNumerator+0x80>
    bool    lowDatareOptimize = false;
 8023304:	2200      	movs	r2, #0
 8023306:	4694      	mov	ip, r2
    {
        lowDatareOptimize = true;
    }

    int32_t ceilDenominator;
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 8023308:	00e0      	lsls	r0, r4, #3
                            ( crcOn ? 16 : 0 ) -
 802330a:	2900      	cmp	r1, #0
 802330c:	d030      	beq.n	8023370 <RadioGetLoRaTimeOnAirNumerator+0x96>
 802330e:	2210      	movs	r2, #16
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 8023310:	1880      	adds	r0, r0, r2
                            ( 4 * datarate ) +
 8023312:	00a9      	lsls	r1, r5, #2
                            ( crcOn ? 16 : 0 ) -
 8023314:	1a40      	subs	r0, r0, r1
                            ( fixLen ? 0 : 20 );
 8023316:	2b00      	cmp	r3, #0
 8023318:	d02c      	beq.n	8023374 <RadioGetLoRaTimeOnAirNumerator+0x9a>
 802331a:	2300      	movs	r3, #0
                            ( 4 * datarate ) +
 802331c:	18c0      	adds	r0, r0, r3

    if( datarate <= 6 )
 802331e:	2d06      	cmp	r5, #6
 8023320:	d905      	bls.n	802332e <RadioGetLoRaTimeOnAirNumerator+0x54>
    {
        ceilDenominator = 4 * datarate;
    }
    else
    {
        ceilNumerator += 8;
 8023322:	3008      	adds	r0, #8

        if( lowDatareOptimize == true )
 8023324:	4663      	mov	r3, ip
 8023326:	2b00      	cmp	r3, #0
 8023328:	d001      	beq.n	802332e <RadioGetLoRaTimeOnAirNumerator+0x54>
        {
            ceilDenominator = 4 * ( datarate - 2 );
 802332a:	1ea9      	subs	r1, r5, #2
 802332c:	0089      	lsls	r1, r1, #2
        {
            ceilDenominator = 4 * datarate;
        }
    }

    if( ceilNumerator < 0 )
 802332e:	2800      	cmp	r0, #0
 8023330:	db22      	blt.n	8023378 <RadioGetLoRaTimeOnAirNumerator+0x9e>
        ceilNumerator = 0;
    }

    // Perform integral ceil()
    int32_t intermediate =
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 8023332:	1808      	adds	r0, r1, r0
 8023334:	3801      	subs	r0, #1
 8023336:	f7fc ff79 	bl	802022c <__divsi3>
 802333a:	4347      	muls	r7, r0
 802333c:	19f6      	adds	r6, r6, r7
    int32_t intermediate =
 802333e:	0030      	movs	r0, r6
 8023340:	300c      	adds	r0, #12

    if( datarate <= 6 )
 8023342:	2d06      	cmp	r5, #6
 8023344:	d800      	bhi.n	8023348 <RadioGetLoRaTimeOnAirNumerator+0x6e>
    {
        intermediate += 2;
 8023346:	3002      	adds	r0, #2
    }

    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 8023348:	0080      	lsls	r0, r0, #2
 802334a:	3001      	adds	r0, #1
 802334c:	3d02      	subs	r5, #2
 802334e:	40a8      	lsls	r0, r5
}
 8023350:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( preambleLen < 12 )
 8023352:	2e0b      	cmp	r6, #11
 8023354:	d8ce      	bhi.n	80232f4 <RadioGetLoRaTimeOnAirNumerator+0x1a>
            preambleLen = 12;
 8023356:	260c      	movs	r6, #12
 8023358:	e7cc      	b.n	80232f4 <RadioGetLoRaTimeOnAirNumerator+0x1a>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 802335a:	2d0c      	cmp	r5, #12
 802335c:	d005      	beq.n	802336a <RadioGetLoRaTimeOnAirNumerator+0x90>
    bool    lowDatareOptimize = false;
 802335e:	2200      	movs	r2, #0
 8023360:	4694      	mov	ip, r2
 8023362:	e7d1      	b.n	8023308 <RadioGetLoRaTimeOnAirNumerator+0x2e>
        lowDatareOptimize = true;
 8023364:	2201      	movs	r2, #1
 8023366:	4694      	mov	ip, r2
 8023368:	e7ce      	b.n	8023308 <RadioGetLoRaTimeOnAirNumerator+0x2e>
 802336a:	2201      	movs	r2, #1
 802336c:	4694      	mov	ip, r2
 802336e:	e7cb      	b.n	8023308 <RadioGetLoRaTimeOnAirNumerator+0x2e>
                            ( crcOn ? 16 : 0 ) -
 8023370:	2200      	movs	r2, #0
 8023372:	e7cd      	b.n	8023310 <RadioGetLoRaTimeOnAirNumerator+0x36>
                            ( fixLen ? 0 : 20 );
 8023374:	2314      	movs	r3, #20
 8023376:	e7d1      	b.n	802331c <RadioGetLoRaTimeOnAirNumerator+0x42>
        ceilNumerator = 0;
 8023378:	2000      	movs	r0, #0
 802337a:	e7da      	b.n	8023332 <RadioGetLoRaTimeOnAirNumerator+0x58>

0802337c <RadioTimeOnAir>:

static uint32_t RadioTimeOnAir( RadioModems_t modem, uint32_t bandwidth,
                                uint32_t datarate, uint8_t coderate,
                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                bool crcOn )
{
 802337c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802337e:	b085      	sub	sp, #20
 8023380:	000d      	movs	r5, r1
 8023382:	0016      	movs	r6, r2
 8023384:	0019      	movs	r1, r3
 8023386:	ab0a      	add	r3, sp, #40	@ 0x28
 8023388:	881a      	ldrh	r2, [r3, #0]
 802338a:	ab0b      	add	r3, sp, #44	@ 0x2c
 802338c:	781b      	ldrb	r3, [r3, #0]
 802338e:	ac0c      	add	r4, sp, #48	@ 0x30
 8023390:	7827      	ldrb	r7, [r4, #0]
 8023392:	ac0d      	add	r4, sp, #52	@ 0x34
 8023394:	7824      	ldrb	r4, [r4, #0]
    uint32_t numerator = 0;
    uint32_t denominator = 1;

    switch( modem )
 8023396:	2800      	cmp	r0, #0
 8023398:	d00a      	beq.n	80233b0 <RadioTimeOnAir+0x34>
 802339a:	2801      	cmp	r0, #1
 802339c:	d013      	beq.n	80233c6 <RadioTimeOnAir+0x4a>
 802339e:	2601      	movs	r6, #1
 80233a0:	2400      	movs	r4, #0
        break;
    default:
        break;
    }
    // Perform integral ceil()
    return DIVC( numerator, denominator );
 80233a2:	19a0      	adds	r0, r4, r6
 80233a4:	3801      	subs	r0, #1
 80233a6:	0031      	movs	r1, r6
 80233a8:	f7fc feb6 	bl	8020118 <__udivsi3>
}
 80233ac:	b005      	add	sp, #20
 80233ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 80233b0:	9401      	str	r4, [sp, #4]
 80233b2:	9700      	str	r7, [sp, #0]
 80233b4:	0030      	movs	r0, r6
 80233b6:	f7ff ff7b 	bl	80232b0 <RadioGetGfskTimeOnAirNumerator>
 80233ba:	0144      	lsls	r4, r0, #5
 80233bc:	1a24      	subs	r4, r4, r0
 80233be:	00a4      	lsls	r4, r4, #2
 80233c0:	1824      	adds	r4, r4, r0
 80233c2:	00e4      	lsls	r4, r4, #3
        break;
 80233c4:	e7ed      	b.n	80233a2 <RadioTimeOnAir+0x26>
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 80233c6:	9402      	str	r4, [sp, #8]
 80233c8:	9701      	str	r7, [sp, #4]
 80233ca:	9300      	str	r3, [sp, #0]
 80233cc:	0013      	movs	r3, r2
 80233ce:	000a      	movs	r2, r1
 80233d0:	0031      	movs	r1, r6
 80233d2:	0028      	movs	r0, r5
 80233d4:	f7ff ff81 	bl	80232da <RadioGetLoRaTimeOnAirNumerator>
 80233d8:	0144      	lsls	r4, r0, #5
 80233da:	1a24      	subs	r4, r4, r0
 80233dc:	00a4      	lsls	r4, r4, #2
 80233de:	1824      	adds	r4, r4, r0
 80233e0:	00e4      	lsls	r4, r4, #3
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 80233e2:	4b03      	ldr	r3, [pc, #12]	@ (80233f0 <RadioTimeOnAir+0x74>)
 80233e4:	5d58      	ldrb	r0, [r3, r5]
 80233e6:	f7ff ff31 	bl	802324c <RadioGetLoRaBandwidthInHz>
 80233ea:	0006      	movs	r6, r0
        break;
 80233ec:	e7d9      	b.n	80233a2 <RadioTimeOnAir+0x26>
 80233ee:	46c0      	nop			@ (mov r8, r8)
 80233f0:	080266c4 	.word	0x080266c4

080233f4 <RadioOnTxTimeoutProcess>:
{
    RADIO_RX_TIMEOUT_PROCESS();
}

static void RadioOnTxTimeoutProcess( void )
{
 80233f4:	b510      	push	{r4, lr}
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 80233f6:	4b06      	ldr	r3, [pc, #24]	@ (8023410 <RadioOnTxTimeoutProcess+0x1c>)
 80233f8:	2280      	movs	r2, #128	@ 0x80
 80233fa:	0192      	lsls	r2, r2, #6
 80233fc:	629a      	str	r2, [r3, #40]	@ 0x28
    DBG_GPIO_RADIO_TX( RST );

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 80233fe:	4b05      	ldr	r3, [pc, #20]	@ (8023414 <RadioOnTxTimeoutProcess+0x20>)
 8023400:	681b      	ldr	r3, [r3, #0]
 8023402:	2b00      	cmp	r3, #0
 8023404:	d003      	beq.n	802340e <RadioOnTxTimeoutProcess+0x1a>
 8023406:	685b      	ldr	r3, [r3, #4]
 8023408:	2b00      	cmp	r3, #0
 802340a:	d000      	beq.n	802340e <RadioOnTxTimeoutProcess+0x1a>
    {
        RadioEvents->TxTimeout( );
 802340c:	4798      	blx	r3
    }
}
 802340e:	bd10      	pop	{r4, pc}
 8023410:	48000400 	.word	0x48000400
 8023414:	2000a218 	.word	0x2000a218

08023418 <RadioOnTxTimeoutIrq>:
{
 8023418:	b510      	push	{r4, lr}
    RADIO_TX_TIMEOUT_PROCESS();
 802341a:	f7ff ffeb 	bl	80233f4 <RadioOnTxTimeoutProcess>
}
 802341e:	bd10      	pop	{r4, pc}

08023420 <RadioOnRxTimeoutProcess>:

static void RadioOnRxTimeoutProcess( void )
{
 8023420:	b510      	push	{r4, lr}
 8023422:	4b06      	ldr	r3, [pc, #24]	@ (802343c <RadioOnRxTimeoutProcess+0x1c>)
 8023424:	2280      	movs	r2, #128	@ 0x80
 8023426:	0152      	lsls	r2, r2, #5
 8023428:	629a      	str	r2, [r3, #40]	@ 0x28
    DBG_GPIO_RADIO_RX( RST );

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 802342a:	4b05      	ldr	r3, [pc, #20]	@ (8023440 <RadioOnRxTimeoutProcess+0x20>)
 802342c:	681b      	ldr	r3, [r3, #0]
 802342e:	2b00      	cmp	r3, #0
 8023430:	d003      	beq.n	802343a <RadioOnRxTimeoutProcess+0x1a>
 8023432:	68db      	ldr	r3, [r3, #12]
 8023434:	2b00      	cmp	r3, #0
 8023436:	d000      	beq.n	802343a <RadioOnRxTimeoutProcess+0x1a>
    {
        RadioEvents->RxTimeout( );
 8023438:	4798      	blx	r3
    }
}
 802343a:	bd10      	pop	{r4, pc}
 802343c:	48000400 	.word	0x48000400
 8023440:	2000a218 	.word	0x2000a218

08023444 <RadioOnRxTimeoutIrq>:
{
 8023444:	b510      	push	{r4, lr}
    RADIO_RX_TIMEOUT_PROCESS();
 8023446:	f7ff ffeb 	bl	8023420 <RadioOnRxTimeoutProcess>
}
 802344a:	bd10      	pop	{r4, pc}

0802344c <payload_integration>:
    SUBGRF_SetTxContinuousWave( );
}

#if (RADIO_SIGFOX_ENABLE == 1)
static void payload_integration( uint8_t *outBuffer, uint8_t *inBuffer, uint8_t size )
{
 802344c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802344e:	46de      	mov	lr, fp
 8023450:	4657      	mov	r7, sl
 8023452:	464e      	mov	r6, r9
 8023454:	4645      	mov	r5, r8
 8023456:	b5e0      	push	{r5, r6, r7, lr}
 8023458:	b083      	sub	sp, #12
 802345a:	4693      	mov	fp, r2
    uint8_t index_byte;
    uint8_t index_bit_out;
    uint8_t index_byte_out;
    int32_t i = 0;

    for( i = 0; i < size; i++ )
 802345c:	2300      	movs	r3, #0
 802345e:	e006      	b.n	802346e <payload_integration+0x22>
    {
        /* reverse all inputs */
        inBuffer[i] = ~inBuffer[i];
 8023460:	5ccc      	ldrb	r4, [r1, r3]
 8023462:	43e4      	mvns	r4, r4
 8023464:	54cc      	strb	r4, [r1, r3]
        /* init outBuffer */
        outBuffer[i] = 0;
 8023466:	18c4      	adds	r4, r0, r3
 8023468:	2500      	movs	r5, #0
 802346a:	7025      	strb	r5, [r4, #0]
    for( i = 0; i < size; i++ )
 802346c:	3301      	adds	r3, #1
 802346e:	459b      	cmp	fp, r3
 8023470:	dcf6      	bgt.n	8023460 <payload_integration+0x14>
    }

    for( i = 0; i < ( size * 8 ); i++ )
 8023472:	2500      	movs	r5, #0
    uint8_t prevInt = 0;
 8023474:	2600      	movs	r6, #0
 8023476:	e039      	b.n	80234ec <payload_integration+0xa0>
    {
        /* index to take bit in inBuffer */
        index_bit = 7 - ( i % 8 );
 8023478:	17ef      	asrs	r7, r5, #31
 802347a:	0f7b      	lsrs	r3, r7, #29
 802347c:	469c      	mov	ip, r3
 802347e:	18eb      	adds	r3, r5, r3
 8023480:	2407      	movs	r4, #7
 8023482:	4023      	ands	r3, r4
 8023484:	4662      	mov	r2, ip
 8023486:	1a9b      	subs	r3, r3, r2
 8023488:	b2db      	uxtb	r3, r3
 802348a:	2207      	movs	r2, #7
 802348c:	4690      	mov	r8, r2
 802348e:	4642      	mov	r2, r8
 8023490:	1ad3      	subs	r3, r2, r3
 8023492:	b2db      	uxtb	r3, r3
 8023494:	9301      	str	r3, [sp, #4]
        index_byte = i / 8;
 8023496:	4027      	ands	r7, r4
 8023498:	197f      	adds	r7, r7, r5
 802349a:	10ff      	asrs	r7, r7, #3
        /* index to place bit in outBuffer is shifted 1 bit right */
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 802349c:	3501      	adds	r5, #1
 802349e:	17ea      	asrs	r2, r5, #31
 80234a0:	4691      	mov	r9, r2
 80234a2:	0f52      	lsrs	r2, r2, #29
 80234a4:	4692      	mov	sl, r2
 80234a6:	46ac      	mov	ip, r5
 80234a8:	44d4      	add	ip, sl
 80234aa:	4662      	mov	r2, ip
 80234ac:	4022      	ands	r2, r4
 80234ae:	4653      	mov	r3, sl
 80234b0:	1ad2      	subs	r2, r2, r3
 80234b2:	b2d3      	uxtb	r3, r2
 80234b4:	469c      	mov	ip, r3
 80234b6:	4643      	mov	r3, r8
 80234b8:	4662      	mov	r2, ip
 80234ba:	1a9b      	subs	r3, r3, r2
 80234bc:	b2db      	uxtb	r3, r3
 80234be:	4698      	mov	r8, r3
        index_byte_out = ( i + 1 ) / 8;
 80234c0:	464b      	mov	r3, r9
 80234c2:	401c      	ands	r4, r3
 80234c4:	1964      	adds	r4, r4, r5
 80234c6:	10e4      	asrs	r4, r4, #3
        /* extract current bit from input */
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 80234c8:	23ff      	movs	r3, #255	@ 0xff
 80234ca:	469c      	mov	ip, r3
 80234cc:	401f      	ands	r7, r3
 80234ce:	5dcf      	ldrb	r7, [r1, r7]
 80234d0:	9b01      	ldr	r3, [sp, #4]
 80234d2:	411f      	asrs	r7, r3
 80234d4:	003b      	movs	r3, r7
 80234d6:	2701      	movs	r7, #1
 80234d8:	403b      	ands	r3, r7
        /* integration */
        prevInt ^= currBit;
 80234da:	405e      	eors	r6, r3
        /* write result integration in output */
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 80234dc:	4663      	mov	r3, ip
 80234de:	4023      	ands	r3, r4
 80234e0:	5cc4      	ldrb	r4, [r0, r3]
 80234e2:	0037      	movs	r7, r6
 80234e4:	4642      	mov	r2, r8
 80234e6:	4097      	lsls	r7, r2
 80234e8:	433c      	orrs	r4, r7
 80234ea:	54c4      	strb	r4, [r0, r3]
    for( i = 0; i < ( size * 8 ); i++ )
 80234ec:	465b      	mov	r3, fp
 80234ee:	00db      	lsls	r3, r3, #3
 80234f0:	42ab      	cmp	r3, r5
 80234f2:	dcc1      	bgt.n	8023478 <payload_integration+0x2c>
    }

    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 80234f4:	01f3      	lsls	r3, r6, #7
 80234f6:	01b1      	lsls	r1, r6, #6
 80234f8:	430b      	orrs	r3, r1
 80234fa:	b25b      	sxtb	r3, r3
 80234fc:	2e00      	cmp	r6, #0
 80234fe:	d10a      	bne.n	8023516 <payload_integration+0xca>
 8023500:	2120      	movs	r1, #32
 8023502:	430b      	orrs	r3, r1
 8023504:	465a      	mov	r2, fp
 8023506:	5483      	strb	r3, [r0, r2]
}
 8023508:	b003      	add	sp, #12
 802350a:	bcf0      	pop	{r4, r5, r6, r7}
 802350c:	46bb      	mov	fp, r7
 802350e:	46b2      	mov	sl, r6
 8023510:	46a9      	mov	r9, r5
 8023512:	46a0      	mov	r8, r4
 8023514:	bdf0      	pop	{r4, r5, r6, r7, pc}
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8023516:	2100      	movs	r1, #0
 8023518:	e7f3      	b.n	8023502 <payload_integration+0xb6>

0802351a <RadioLrFhssSetCfg>:
        return status;
    }
    SubgRf.lr_fhss.is_lr_fhss_on = true;
#endif /* RADIO_LR_FHSS_IS_ON == 1 */
    return  status;
}
 802351a:	2001      	movs	r0, #1
 802351c:	4770      	bx	lr

0802351e <RadioLrFhssGetTimeOnAirInMs>:

    return RADIO_STATUS_OK;
#else
    return RADIO_STATUS_UNSUPPORTED_FEATURE;
#endif /* RADIO_LR_FHSS_IS_ON */
 802351e:	2001      	movs	r0, #1
 8023520:	4770      	bx	lr
	...

08023524 <RadioSetMaxPayloadLength>:
{
 8023524:	b510      	push	{r4, lr}
    if( modem == MODEM_LORA )
 8023526:	2801      	cmp	r0, #1
 8023528:	d004      	beq.n	8023534 <RadioSetMaxPayloadLength+0x10>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 802352a:	4b0a      	ldr	r3, [pc, #40]	@ (8023554 <RadioSetMaxPayloadLength+0x30>)
 802352c:	7d5b      	ldrb	r3, [r3, #21]
 802352e:	2b01      	cmp	r3, #1
 8023530:	d008      	beq.n	8023544 <RadioSetMaxPayloadLength+0x20>
}
 8023532:	bd10      	pop	{r4, pc}
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 8023534:	4b08      	ldr	r3, [pc, #32]	@ (8023558 <RadioSetMaxPayloadLength+0x34>)
 8023536:	7019      	strb	r1, [r3, #0]
 8023538:	4806      	ldr	r0, [pc, #24]	@ (8023554 <RadioSetMaxPayloadLength+0x30>)
 802353a:	77c1      	strb	r1, [r0, #31]
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 802353c:	300e      	adds	r0, #14
 802353e:	f001 fe3f 	bl	80251c0 <SUBGRF_SetPacketParams>
 8023542:	e7f6      	b.n	8023532 <RadioSetMaxPayloadLength+0xe>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 8023544:	4b04      	ldr	r3, [pc, #16]	@ (8023558 <RadioSetMaxPayloadLength+0x34>)
 8023546:	7019      	strb	r1, [r3, #0]
 8023548:	4802      	ldr	r0, [pc, #8]	@ (8023554 <RadioSetMaxPayloadLength+0x30>)
 802354a:	7581      	strb	r1, [r0, #22]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 802354c:	300e      	adds	r0, #14
 802354e:	f001 fe37 	bl	80251c0 <SUBGRF_SetPacketParams>
}
 8023552:	e7ee      	b.n	8023532 <RadioSetMaxPayloadLength+0xe>
 8023554:	2000a1bc 	.word	0x2000a1bc
 8023558:	2000a00c 	.word	0x2000a00c

0802355c <RadioRead>:
{
 802355c:	b510      	push	{r4, lr}
    return SUBGRF_ReadRegister( addr );
 802355e:	f001 fa05 	bl	802496c <SUBGRF_ReadRegister>
}
 8023562:	bd10      	pop	{r4, pc}

08023564 <RadioWrite>:
{
 8023564:	b510      	push	{r4, lr}
    SUBGRF_WriteRegister( addr, data );
 8023566:	f001 f9ed 	bl	8024944 <SUBGRF_WriteRegister>
}
 802356a:	bd10      	pop	{r4, pc}

0802356c <RadioTxCw>:
{
 802356c:	b510      	push	{r4, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 802356e:	f001 ff49 	bl	8025404 <SUBGRF_SetRfTxPower>
 8023572:	0004      	movs	r4, r0
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8023574:	210e      	movs	r1, #14
 8023576:	4805      	ldr	r0, [pc, #20]	@ (802358c <RadioTxCw+0x20>)
 8023578:	f001 f9e4 	bl	8024944 <SUBGRF_WriteRegister>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 802357c:	2101      	movs	r1, #1
 802357e:	0020      	movs	r0, r4
 8023580:	f001 ff2c 	bl	80253dc <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 8023584:	f001 fba6 	bl	8024cd4 <SUBGRF_SetTxContinuousWave>
}
 8023588:	bd10      	pop	{r4, pc}
 802358a:	46c0      	nop			@ (mov r8, r8)
 802358c:	0000091f 	.word	0x0000091f

08023590 <RadioTxPrbs>:
{
 8023590:	b510      	push	{r4, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 8023592:	4b08      	ldr	r3, [pc, #32]	@ (80235b4 <RadioTxPrbs+0x24>)
 8023594:	2256      	movs	r2, #86	@ 0x56
 8023596:	5c98      	ldrb	r0, [r3, r2]
 8023598:	2101      	movs	r1, #1
 802359a:	f001 ff1f 	bl	80253dc <SUBGRF_SetSwitch>
    Radio.Write( SUBGHZ_GPKTCTL1AR, 0x2d );  // sel mode prbs9 instead of preamble
 802359e:	20d7      	movs	r0, #215	@ 0xd7
 80235a0:	212d      	movs	r1, #45	@ 0x2d
 80235a2:	00c0      	lsls	r0, r0, #3
 80235a4:	f7ff ffde 	bl	8023564 <RadioWrite>
    SUBGRF_SetTxInfinitePreamble( );
 80235a8:	f001 fb9b 	bl	8024ce2 <SUBGRF_SetTxInfinitePreamble>
    SUBGRF_SetTx( 0x0fffff );
 80235ac:	4802      	ldr	r0, [pc, #8]	@ (80235b8 <RadioTxPrbs+0x28>)
 80235ae:	f001 fae9 	bl	8024b84 <SUBGRF_SetTx>
}
 80235b2:	bd10      	pop	{r4, pc}
 80235b4:	2000a1bc 	.word	0x2000a1bc
 80235b8:	000fffff 	.word	0x000fffff

080235bc <RadioSetRxDutyCycle>:
{
 80235bc:	b570      	push	{r4, r5, r6, lr}
 80235be:	0004      	movs	r4, r0
 80235c0:	000d      	movs	r5, r1
    SubgRf.RxDcPreambleDetectTimeout = 2 * rxTime + sleepTime;
 80235c2:	0043      	lsls	r3, r0, #1
 80235c4:	185b      	adds	r3, r3, r1
 80235c6:	4e09      	ldr	r6, [pc, #36]	@ (80235ec <RadioSetRxDutyCycle+0x30>)
 80235c8:	65b3      	str	r3, [r6, #88]	@ 0x58
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 80235ca:	4809      	ldr	r0, [pc, #36]	@ (80235f0 <RadioSetRxDutyCycle+0x34>)
 80235cc:	2300      	movs	r3, #0
 80235ce:	2200      	movs	r2, #0
 80235d0:	0001      	movs	r1, r0
 80235d2:	f001 fc49 	bl	8024e68 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 80235d6:	2356      	movs	r3, #86	@ 0x56
 80235d8:	5cf0      	ldrb	r0, [r6, r3]
 80235da:	2100      	movs	r1, #0
 80235dc:	f001 fefe 	bl	80253dc <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 80235e0:	0029      	movs	r1, r5
 80235e2:	0020      	movs	r0, r4
 80235e4:	f001 fb50 	bl	8024c88 <SUBGRF_SetRxDutyCycle>
}
 80235e8:	bd70      	pop	{r4, r5, r6, pc}
 80235ea:	46c0      	nop			@ (mov r8, r8)
 80235ec:	2000a1bc 	.word	0x2000a1bc
 80235f0:	0000ffff 	.word	0x0000ffff

080235f4 <RadioRxBoosted>:
{
 80235f4:	b510      	push	{r4, lr}
 80235f6:	0004      	movs	r4, r0
    if( 1UL == RFW_Is_Init() )
 80235f8:	f001 ffe2 	bl	80255c0 <RFW_Is_Init>
 80235fc:	2801      	cmp	r0, #1
 80235fe:	d01a      	beq.n	8023636 <RadioRxBoosted+0x42>
        SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8023600:	4816      	ldr	r0, [pc, #88]	@ (802365c <RadioRxBoosted+0x68>)
 8023602:	2300      	movs	r3, #0
 8023604:	2200      	movs	r2, #0
 8023606:	0001      	movs	r1, r0
 8023608:	f001 fc2e 	bl	8024e68 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 802360c:	2c00      	cmp	r4, #0
 802360e:	d115      	bne.n	802363c <RadioRxBoosted+0x48>
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8023610:	4c13      	ldr	r4, [pc, #76]	@ (8023660 <RadioRxBoosted+0x6c>)
 8023612:	2300      	movs	r3, #0
 8023614:	65a3      	str	r3, [r4, #88]	@ 0x58
  WRITE_REG(GPIOx->BSRR, PinMask);
 8023616:	4b13      	ldr	r3, [pc, #76]	@ (8023664 <RadioRxBoosted+0x70>)
 8023618:	2280      	movs	r2, #128	@ 0x80
 802361a:	0152      	lsls	r2, r2, #5
 802361c:	619a      	str	r2, [r3, #24]
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 802361e:	2356      	movs	r3, #86	@ 0x56
 8023620:	5ce0      	ldrb	r0, [r4, r3]
 8023622:	2100      	movs	r1, #0
 8023624:	f001 feda 	bl	80253dc <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8023628:	7863      	ldrb	r3, [r4, #1]
 802362a:	2b00      	cmp	r3, #0
 802362c:	d010      	beq.n	8023650 <RadioRxBoosted+0x5c>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 802362e:	480e      	ldr	r0, [pc, #56]	@ (8023668 <RadioRxBoosted+0x74>)
 8023630:	f001 fb10 	bl	8024c54 <SUBGRF_SetRxBoosted>
}
 8023634:	bd10      	pop	{r4, pc}
        RFW_ReceiveInit();
 8023636:	f001 ffcb 	bl	80255d0 <RFW_ReceiveInit>
 802363a:	e7e7      	b.n	802360c <RadioRxBoosted+0x18>
        TimerSetValue( &RxTimeoutTimer, timeout );
 802363c:	4b0b      	ldr	r3, [pc, #44]	@ (802366c <RadioRxBoosted+0x78>)
 802363e:	0021      	movs	r1, r4
 8023640:	001c      	movs	r4, r3
 8023642:	0018      	movs	r0, r3
 8023644:	f002 fc3a 	bl	8025ebc <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8023648:	0020      	movs	r0, r4
 802364a:	f002 fbf1 	bl	8025e30 <UTIL_TIMER_Start>
 802364e:	e7df      	b.n	8023610 <RadioRxBoosted+0x1c>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 8023650:	4b03      	ldr	r3, [pc, #12]	@ (8023660 <RadioRxBoosted+0x6c>)
 8023652:	6898      	ldr	r0, [r3, #8]
 8023654:	0180      	lsls	r0, r0, #6
 8023656:	f001 fafd 	bl	8024c54 <SUBGRF_SetRxBoosted>
}
 802365a:	e7eb      	b.n	8023634 <RadioRxBoosted+0x40>
 802365c:	00000262 	.word	0x00000262
 8023660:	2000a1bc 	.word	0x2000a1bc
 8023664:	48000400 	.word	0x48000400
 8023668:	00ffffff 	.word	0x00ffffff
 802366c:	2000a18c 	.word	0x2000a18c

08023670 <RadioStandby>:
{
 8023670:	b510      	push	{r4, lr}
    SUBGRF_SetStandby( STDBY_RC );
 8023672:	2000      	movs	r0, #0
 8023674:	f001 fa6e 	bl	8024b54 <SUBGRF_SetStandby>
}
 8023678:	bd10      	pop	{r4, pc}

0802367a <RadioGetStatus>:
{
 802367a:	b510      	push	{r4, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 802367c:	f001 f956 	bl	802492c <SUBGRF_GetOperatingMode>
 8023680:	2805      	cmp	r0, #5
 8023682:	d007      	beq.n	8023694 <RadioGetStatus+0x1a>
 8023684:	2807      	cmp	r0, #7
 8023686:	d007      	beq.n	8023698 <RadioGetStatus+0x1e>
 8023688:	2804      	cmp	r0, #4
 802368a:	d001      	beq.n	8023690 <RadioGetStatus+0x16>
            return RF_IDLE;
 802368c:	2000      	movs	r0, #0
}
 802368e:	bd10      	pop	{r4, pc}
    switch( SUBGRF_GetOperatingMode( ) )
 8023690:	3802      	subs	r0, #2
 8023692:	e7fc      	b.n	802368e <RadioGetStatus+0x14>
            return RF_RX_RUNNING;
 8023694:	2001      	movs	r0, #1
 8023696:	e7fa      	b.n	802368e <RadioGetStatus+0x14>
            return RF_CAD;
 8023698:	2003      	movs	r0, #3
 802369a:	e7f8      	b.n	802368e <RadioGetStatus+0x14>

0802369c <RadioIrqProcess>:
{
 802369c:	b530      	push	{r4, r5, lr}
 802369e:	b083      	sub	sp, #12
    uint8_t size = 0;
 80236a0:	2300      	movs	r3, #0
 80236a2:	466a      	mov	r2, sp
 80236a4:	71d3      	strb	r3, [r2, #7]
    int32_t cfo = 0;
 80236a6:	9300      	str	r3, [sp, #0]
    switch( SubgRf.RadioIrq )
 80236a8:	4bad      	ldr	r3, [pc, #692]	@ (8023960 <RadioIrqProcess+0x2c4>)
 80236aa:	2254      	movs	r2, #84	@ 0x54
 80236ac:	5a9b      	ldrh	r3, [r3, r2]
 80236ae:	2b20      	cmp	r3, #32
 80236b0:	d80a      	bhi.n	80236c8 <RadioIrqProcess+0x2c>
 80236b2:	b21a      	sxth	r2, r3
 80236b4:	2a00      	cmp	r2, #0
 80236b6:	d100      	bne.n	80236ba <RadioIrqProcess+0x1e>
 80236b8:	e11e      	b.n	80238f8 <RadioIrqProcess+0x25c>
 80236ba:	2b20      	cmp	r3, #32
 80236bc:	d900      	bls.n	80236c0 <RadioIrqProcess+0x24>
 80236be:	e11b      	b.n	80238f8 <RadioIrqProcess+0x25c>
 80236c0:	009b      	lsls	r3, r3, #2
 80236c2:	4aa8      	ldr	r2, [pc, #672]	@ (8023964 <RadioIrqProcess+0x2c8>)
 80236c4:	58d3      	ldr	r3, [r2, r3]
 80236c6:	469f      	mov	pc, r3
 80236c8:	2280      	movs	r2, #128	@ 0x80
 80236ca:	0052      	lsls	r2, r2, #1
 80236cc:	4293      	cmp	r3, r2
 80236ce:	d100      	bne.n	80236d2 <RadioIrqProcess+0x36>
 80236d0:	e0b2      	b.n	8023838 <RadioIrqProcess+0x19c>
 80236d2:	d929      	bls.n	8023728 <RadioIrqProcess+0x8c>
 80236d4:	2280      	movs	r2, #128	@ 0x80
 80236d6:	0092      	lsls	r2, r2, #2
 80236d8:	4293      	cmp	r3, r2
 80236da:	d000      	beq.n	80236de <RadioIrqProcess+0x42>
 80236dc:	e10c      	b.n	80238f8 <RadioIrqProcess+0x25c>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 80236de:	4ba2      	ldr	r3, [pc, #648]	@ (8023968 <RadioIrqProcess+0x2cc>)
 80236e0:	2201      	movs	r2, #1
 80236e2:	2100      	movs	r1, #0
 80236e4:	2002      	movs	r0, #2
 80236e6:	f002 f84d 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 80236ea:	f001 f91f 	bl	802492c <SUBGRF_GetOperatingMode>
 80236ee:	2804      	cmp	r0, #4
 80236f0:	d100      	bne.n	80236f4 <RadioIrqProcess+0x58>
 80236f2:	e0ae      	b.n	8023852 <RadioIrqProcess+0x1b6>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 80236f4:	f001 f91a 	bl	802492c <SUBGRF_GetOperatingMode>
 80236f8:	2805      	cmp	r0, #5
 80236fa:	d000      	beq.n	80236fe <RadioIrqProcess+0x62>
 80236fc:	e0fc      	b.n	80238f8 <RadioIrqProcess+0x25c>
  WRITE_REG(GPIOx->BRR, PinMask);
 80236fe:	4b9b      	ldr	r3, [pc, #620]	@ (802396c <RadioIrqProcess+0x2d0>)
 8023700:	2280      	movs	r2, #128	@ 0x80
 8023702:	0152      	lsls	r2, r2, #5
 8023704:	629a      	str	r2, [r3, #40]	@ 0x28
            TimerStop( &RxTimeoutTimer );
 8023706:	489a      	ldr	r0, [pc, #616]	@ (8023970 <RadioIrqProcess+0x2d4>)
 8023708:	f002 fb30 	bl	8025d6c <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 802370c:	2000      	movs	r0, #0
 802370e:	f001 fa21 	bl	8024b54 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8023712:	4b98      	ldr	r3, [pc, #608]	@ (8023974 <RadioIrqProcess+0x2d8>)
 8023714:	681b      	ldr	r3, [r3, #0]
 8023716:	2b00      	cmp	r3, #0
 8023718:	d100      	bne.n	802371c <RadioIrqProcess+0x80>
 802371a:	e0ed      	b.n	80238f8 <RadioIrqProcess+0x25c>
 802371c:	68db      	ldr	r3, [r3, #12]
 802371e:	2b00      	cmp	r3, #0
 8023720:	d100      	bne.n	8023724 <RadioIrqProcess+0x88>
 8023722:	e0e9      	b.n	80238f8 <RadioIrqProcess+0x25c>
                RadioEvents->RxTimeout( );
 8023724:	4798      	blx	r3
 8023726:	e0e7      	b.n	80238f8 <RadioIrqProcess+0x25c>
    switch( SubgRf.RadioIrq )
 8023728:	2b40      	cmp	r3, #64	@ 0x40
 802372a:	d100      	bne.n	802372e <RadioIrqProcess+0x92>
 802372c:	e100      	b.n	8023930 <RadioIrqProcess+0x294>
 802372e:	2b80      	cmp	r3, #128	@ 0x80
 8023730:	d000      	beq.n	8023734 <RadioIrqProcess+0x98>
 8023732:	e0e1      	b.n	80238f8 <RadioIrqProcess+0x25c>
        SUBGRF_SetStandby( STDBY_RC );
 8023734:	2000      	movs	r0, #0
 8023736:	f001 fa0d 	bl	8024b54 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 802373a:	4b8e      	ldr	r3, [pc, #568]	@ (8023974 <RadioIrqProcess+0x2d8>)
 802373c:	681b      	ldr	r3, [r3, #0]
 802373e:	2b00      	cmp	r3, #0
 8023740:	d100      	bne.n	8023744 <RadioIrqProcess+0xa8>
 8023742:	e0d9      	b.n	80238f8 <RadioIrqProcess+0x25c>
 8023744:	699b      	ldr	r3, [r3, #24]
 8023746:	2b00      	cmp	r3, #0
 8023748:	d100      	bne.n	802374c <RadioIrqProcess+0xb0>
 802374a:	e0d5      	b.n	80238f8 <RadioIrqProcess+0x25c>
            RadioEvents->CadDone( false );
 802374c:	2000      	movs	r0, #0
 802374e:	4798      	blx	r3
 8023750:	e0d2      	b.n	80238f8 <RadioIrqProcess+0x25c>
 8023752:	4b86      	ldr	r3, [pc, #536]	@ (802396c <RadioIrqProcess+0x2d0>)
 8023754:	2280      	movs	r2, #128	@ 0x80
 8023756:	0192      	lsls	r2, r2, #6
 8023758:	629a      	str	r2, [r3, #40]	@ 0x28
        TimerStop( &TxTimeoutTimer );
 802375a:	4887      	ldr	r0, [pc, #540]	@ (8023978 <RadioIrqProcess+0x2dc>)
 802375c:	f002 fb06 	bl	8025d6c <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 8023760:	2000      	movs	r0, #0
 8023762:	f001 f9f7 	bl	8024b54 <SUBGRF_SetStandby>
        if( RFW_Is_LongPacketModeEnabled() == 1 )
 8023766:	f001 ff2d 	bl	80255c4 <RFW_Is_LongPacketModeEnabled>
 802376a:	2801      	cmp	r0, #1
 802376c:	d00a      	beq.n	8023784 <RadioIrqProcess+0xe8>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 802376e:	4b81      	ldr	r3, [pc, #516]	@ (8023974 <RadioIrqProcess+0x2d8>)
 8023770:	681b      	ldr	r3, [r3, #0]
 8023772:	2b00      	cmp	r3, #0
 8023774:	d100      	bne.n	8023778 <RadioIrqProcess+0xdc>
 8023776:	e0bf      	b.n	80238f8 <RadioIrqProcess+0x25c>
 8023778:	681b      	ldr	r3, [r3, #0]
 802377a:	2b00      	cmp	r3, #0
 802377c:	d100      	bne.n	8023780 <RadioIrqProcess+0xe4>
 802377e:	e0bb      	b.n	80238f8 <RadioIrqProcess+0x25c>
            RadioEvents->TxDone( );
 8023780:	4798      	blx	r3
 8023782:	e0b9      	b.n	80238f8 <RadioIrqProcess+0x25c>
            RFW_DeInit_TxLongPacket( );
 8023784:	f001 ff27 	bl	80255d6 <RFW_DeInit_TxLongPacket>
 8023788:	e7f1      	b.n	802376e <RadioIrqProcess+0xd2>
 802378a:	4b78      	ldr	r3, [pc, #480]	@ (802396c <RadioIrqProcess+0x2d0>)
 802378c:	2280      	movs	r2, #128	@ 0x80
 802378e:	0152      	lsls	r2, r2, #5
 8023790:	629a      	str	r2, [r3, #40]	@ 0x28
        TimerStop( &RxTimeoutTimer );
 8023792:	4877      	ldr	r0, [pc, #476]	@ (8023970 <RadioIrqProcess+0x2d4>)
 8023794:	f002 faea 	bl	8025d6c <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 8023798:	4b71      	ldr	r3, [pc, #452]	@ (8023960 <RadioIrqProcess+0x2c4>)
 802379a:	785b      	ldrb	r3, [r3, #1]
 802379c:	2b00      	cmp	r3, #0
 802379e:	d021      	beq.n	80237e4 <RadioIrqProcess+0x148>
        SUBGRF_GetPayload( RadioBuffer, &size, 255 );
 80237a0:	4876      	ldr	r0, [pc, #472]	@ (802397c <RadioIrqProcess+0x2e0>)
 80237a2:	22ff      	movs	r2, #255	@ 0xff
 80237a4:	466b      	mov	r3, sp
 80237a6:	1dd9      	adds	r1, r3, #7
 80237a8:	f001 fdc4 	bl	8025334 <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &( SubgRf.PacketStatus ) );
 80237ac:	4874      	ldr	r0, [pc, #464]	@ (8023980 <RadioIrqProcess+0x2e4>)
 80237ae:	f001 fddb 	bl	8025368 <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 80237b2:	4b70      	ldr	r3, [pc, #448]	@ (8023974 <RadioIrqProcess+0x2d8>)
 80237b4:	681b      	ldr	r3, [r3, #0]
 80237b6:	2b00      	cmp	r3, #0
 80237b8:	d100      	bne.n	80237bc <RadioIrqProcess+0x120>
 80237ba:	e09d      	b.n	80238f8 <RadioIrqProcess+0x25c>
 80237bc:	689c      	ldr	r4, [r3, #8]
 80237be:	2c00      	cmp	r4, #0
 80237c0:	d100      	bne.n	80237c4 <RadioIrqProcess+0x128>
 80237c2:	e099      	b.n	80238f8 <RadioIrqProcess+0x25c>
            switch( SubgRf.PacketStatus.packetType )
 80237c4:	4b66      	ldr	r3, [pc, #408]	@ (8023960 <RadioIrqProcess+0x2c4>)
 80237c6:	2224      	movs	r2, #36	@ 0x24
 80237c8:	5c9b      	ldrb	r3, [r3, r2]
 80237ca:	2b01      	cmp	r3, #1
 80237cc:	d11c      	bne.n	8023808 <RadioIrqProcess+0x16c>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt,
 80237ce:	4b64      	ldr	r3, [pc, #400]	@ (8023960 <RadioIrqProcess+0x2c4>)
 80237d0:	320c      	adds	r2, #12
 80237d2:	569a      	ldrsb	r2, [r3, r2]
 80237d4:	2131      	movs	r1, #49	@ 0x31
 80237d6:	565b      	ldrsb	r3, [r3, r1]
 80237d8:	4669      	mov	r1, sp
 80237da:	3107      	adds	r1, #7
 80237dc:	7809      	ldrb	r1, [r1, #0]
 80237de:	4867      	ldr	r0, [pc, #412]	@ (802397c <RadioIrqProcess+0x2e0>)
 80237e0:	47a0      	blx	r4
                break;
 80237e2:	e089      	b.n	80238f8 <RadioIrqProcess+0x25c>
            SUBGRF_SetStandby( STDBY_RC );
 80237e4:	2000      	movs	r0, #0
 80237e6:	f001 f9b5 	bl	8024b54 <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( SUBGHZ_RTCCTLR, 0x00 );
 80237ea:	2100      	movs	r1, #0
 80237ec:	4865      	ldr	r0, [pc, #404]	@ (8023984 <RadioIrqProcess+0x2e8>)
 80237ee:	f001 f8a9 	bl	8024944 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( SUBGHZ_EVENTMASKR, SUBGRF_ReadRegister( SUBGHZ_EVENTMASKR ) | ( 1 << 1 ) );
 80237f2:	4c65      	ldr	r4, [pc, #404]	@ (8023988 <RadioIrqProcess+0x2ec>)
 80237f4:	0020      	movs	r0, r4
 80237f6:	f001 f8b9 	bl	802496c <SUBGRF_ReadRegister>
 80237fa:	2302      	movs	r3, #2
 80237fc:	4318      	orrs	r0, r3
 80237fe:	b2c1      	uxtb	r1, r0
 8023800:	0020      	movs	r0, r4
 8023802:	f001 f89f 	bl	8024944 <SUBGRF_WriteRegister>
 8023806:	e7cb      	b.n	80237a0 <RadioIrqProcess+0x104>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 8023808:	4c55      	ldr	r4, [pc, #340]	@ (8023960 <RadioIrqProcess+0x2c4>)
 802380a:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 802380c:	4669      	mov	r1, sp
 802380e:	f001 fe89 	bl	8025524 <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, ( int8_t ) DIVR( cfo, 1000 ) );
 8023812:	4b58      	ldr	r3, [pc, #352]	@ (8023974 <RadioIrqProcess+0x2d8>)
 8023814:	681b      	ldr	r3, [r3, #0]
 8023816:	689d      	ldr	r5, [r3, #8]
 8023818:	2329      	movs	r3, #41	@ 0x29
 802381a:	56e4      	ldrsb	r4, [r4, r3]
 802381c:	9800      	ldr	r0, [sp, #0]
 802381e:	30f5      	adds	r0, #245	@ 0xf5
 8023820:	30ff      	adds	r0, #255	@ 0xff
 8023822:	21fa      	movs	r1, #250	@ 0xfa
 8023824:	0089      	lsls	r1, r1, #2
 8023826:	f7fc fd01 	bl	802022c <__divsi3>
 802382a:	b243      	sxtb	r3, r0
 802382c:	466a      	mov	r2, sp
 802382e:	79d1      	ldrb	r1, [r2, #7]
 8023830:	4852      	ldr	r0, [pc, #328]	@ (802397c <RadioIrqProcess+0x2e0>)
 8023832:	0022      	movs	r2, r4
 8023834:	47a8      	blx	r5
                break;
 8023836:	e05f      	b.n	80238f8 <RadioIrqProcess+0x25c>
        SUBGRF_SetStandby( STDBY_RC );
 8023838:	2000      	movs	r0, #0
 802383a:	f001 f98b 	bl	8024b54 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 802383e:	4b4d      	ldr	r3, [pc, #308]	@ (8023974 <RadioIrqProcess+0x2d8>)
 8023840:	681b      	ldr	r3, [r3, #0]
 8023842:	2b00      	cmp	r3, #0
 8023844:	d058      	beq.n	80238f8 <RadioIrqProcess+0x25c>
 8023846:	699b      	ldr	r3, [r3, #24]
 8023848:	2b00      	cmp	r3, #0
 802384a:	d055      	beq.n	80238f8 <RadioIrqProcess+0x25c>
            RadioEvents->CadDone( true );
 802384c:	2001      	movs	r0, #1
 802384e:	4798      	blx	r3
 8023850:	e052      	b.n	80238f8 <RadioIrqProcess+0x25c>
 8023852:	4b46      	ldr	r3, [pc, #280]	@ (802396c <RadioIrqProcess+0x2d0>)
 8023854:	2280      	movs	r2, #128	@ 0x80
 8023856:	0192      	lsls	r2, r2, #6
 8023858:	629a      	str	r2, [r3, #40]	@ 0x28
            TimerStop( &TxTimeoutTimer );
 802385a:	4847      	ldr	r0, [pc, #284]	@ (8023978 <RadioIrqProcess+0x2dc>)
 802385c:	f002 fa86 	bl	8025d6c <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8023860:	2000      	movs	r0, #0
 8023862:	f001 f977 	bl	8024b54 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8023866:	4b43      	ldr	r3, [pc, #268]	@ (8023974 <RadioIrqProcess+0x2d8>)
 8023868:	681b      	ldr	r3, [r3, #0]
 802386a:	2b00      	cmp	r3, #0
 802386c:	d044      	beq.n	80238f8 <RadioIrqProcess+0x25c>
 802386e:	685b      	ldr	r3, [r3, #4]
 8023870:	2b00      	cmp	r3, #0
 8023872:	d041      	beq.n	80238f8 <RadioIrqProcess+0x25c>
                RadioEvents->TxTimeout( );
 8023874:	4798      	blx	r3
 8023876:	e03f      	b.n	80238f8 <RadioIrqProcess+0x25c>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 8023878:	4b44      	ldr	r3, [pc, #272]	@ (802398c <RadioIrqProcess+0x2f0>)
 802387a:	2201      	movs	r2, #1
 802387c:	2100      	movs	r1, #0
 802387e:	2002      	movs	r0, #2
 8023880:	f001 ff80 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxDcPreambleDetectTimeout != 0 )
 8023884:	4b36      	ldr	r3, [pc, #216]	@ (8023960 <RadioIrqProcess+0x2c4>)
 8023886:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8023888:	2b00      	cmp	r3, #0
 802388a:	d035      	beq.n	80238f8 <RadioIrqProcess+0x25c>
            Radio.Write( SUBGHZ_RTCPRDR2, ( SubgRf.RxDcPreambleDetectTimeout >> 16 ) & 0xFF ); /*Update Radio RTC Period MSB*/
 802388c:	0c1b      	lsrs	r3, r3, #16
 802388e:	b2d9      	uxtb	r1, r3
 8023890:	483f      	ldr	r0, [pc, #252]	@ (8023990 <RadioIrqProcess+0x2f4>)
 8023892:	f7ff fe67 	bl	8023564 <RadioWrite>
            Radio.Write( SUBGHZ_RTCPRDR1, ( SubgRf.RxDcPreambleDetectTimeout >> 8 ) & 0xFF ); /*Update Radio RTC Period MidByte*/
 8023896:	4c32      	ldr	r4, [pc, #200]	@ (8023960 <RadioIrqProcess+0x2c4>)
 8023898:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 802389a:	0a09      	lsrs	r1, r1, #8
 802389c:	b2c9      	uxtb	r1, r1
 802389e:	483d      	ldr	r0, [pc, #244]	@ (8023994 <RadioIrqProcess+0x2f8>)
 80238a0:	f7ff fe60 	bl	8023564 <RadioWrite>
            Radio.Write( SUBGHZ_RTCPRDR0, ( SubgRf.RxDcPreambleDetectTimeout ) & 0xFF ); /*Update Radio RTC Period lsb*/
 80238a4:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 80238a6:	b2c9      	uxtb	r1, r1
 80238a8:	483b      	ldr	r0, [pc, #236]	@ (8023998 <RadioIrqProcess+0x2fc>)
 80238aa:	f7ff fe5b 	bl	8023564 <RadioWrite>
            Radio.Write( SUBGHZ_RTCCTLR, Radio.Read( SUBGHZ_RTCCTLR ) | 0x1 ); /*restart Radio RTC*/
 80238ae:	4d35      	ldr	r5, [pc, #212]	@ (8023984 <RadioIrqProcess+0x2e8>)
 80238b0:	0028      	movs	r0, r5
 80238b2:	f7ff fe53 	bl	802355c <RadioRead>
 80238b6:	2301      	movs	r3, #1
 80238b8:	4318      	orrs	r0, r3
 80238ba:	b2c1      	uxtb	r1, r0
 80238bc:	0028      	movs	r0, r5
 80238be:	f7ff fe51 	bl	8023564 <RadioWrite>
            SubgRf.RxDcPreambleDetectTimeout = 0;
 80238c2:	2300      	movs	r3, #0
 80238c4:	65a3      	str	r3, [r4, #88]	@ 0x58
            SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 80238c6:	4835      	ldr	r0, [pc, #212]	@ (802399c <RadioIrqProcess+0x300>)
 80238c8:	2200      	movs	r2, #0
 80238ca:	0001      	movs	r1, r0
 80238cc:	f001 facc 	bl	8024e68 <SUBGRF_SetDioIrqParams>
 80238d0:	e012      	b.n	80238f8 <RadioIrqProcess+0x25c>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 80238d2:	4b33      	ldr	r3, [pc, #204]	@ (80239a0 <RadioIrqProcess+0x304>)
 80238d4:	2201      	movs	r2, #1
 80238d6:	2100      	movs	r1, #0
 80238d8:	2002      	movs	r0, #2
 80238da:	f001 ff53 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
        if( 1UL == RFW_Is_Init( ) )
 80238de:	f001 fe6f 	bl	80255c0 <RFW_Is_Init>
 80238e2:	2801      	cmp	r0, #1
 80238e4:	d108      	bne.n	80238f8 <RadioIrqProcess+0x25c>
            RFW_ReceivePayload( );
 80238e6:	f001 fe77 	bl	80255d8 <RFW_ReceivePayload>
 80238ea:	e005      	b.n	80238f8 <RadioIrqProcess+0x25c>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 80238ec:	4b2d      	ldr	r3, [pc, #180]	@ (80239a4 <RadioIrqProcess+0x308>)
 80238ee:	2201      	movs	r2, #1
 80238f0:	2100      	movs	r1, #0
 80238f2:	2002      	movs	r0, #2
 80238f4:	f001 ff46 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
}
 80238f8:	b003      	add	sp, #12
 80238fa:	bd30      	pop	{r4, r5, pc}
        TimerStop( &RxTimeoutTimer );
 80238fc:	481c      	ldr	r0, [pc, #112]	@ (8023970 <RadioIrqProcess+0x2d4>)
 80238fe:	f002 fa35 	bl	8025d6c <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 8023902:	4b17      	ldr	r3, [pc, #92]	@ (8023960 <RadioIrqProcess+0x2c4>)
 8023904:	785b      	ldrb	r3, [r3, #1]
 8023906:	2b00      	cmp	r3, #0
 8023908:	d00e      	beq.n	8023928 <RadioIrqProcess+0x28c>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 802390a:	4b1a      	ldr	r3, [pc, #104]	@ (8023974 <RadioIrqProcess+0x2d8>)
 802390c:	681b      	ldr	r3, [r3, #0]
 802390e:	2b00      	cmp	r3, #0
 8023910:	d0f2      	beq.n	80238f8 <RadioIrqProcess+0x25c>
 8023912:	68db      	ldr	r3, [r3, #12]
 8023914:	2b00      	cmp	r3, #0
 8023916:	d0ef      	beq.n	80238f8 <RadioIrqProcess+0x25c>
            RadioEvents->RxTimeout( );
 8023918:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 802391a:	4b23      	ldr	r3, [pc, #140]	@ (80239a8 <RadioIrqProcess+0x30c>)
 802391c:	2201      	movs	r2, #1
 802391e:	2100      	movs	r1, #0
 8023920:	2002      	movs	r0, #2
 8023922:	f001 ff2f 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
 8023926:	e7e7      	b.n	80238f8 <RadioIrqProcess+0x25c>
            SUBGRF_SetStandby( STDBY_RC );
 8023928:	2000      	movs	r0, #0
 802392a:	f001 f913 	bl	8024b54 <SUBGRF_SetStandby>
 802392e:	e7ec      	b.n	802390a <RadioIrqProcess+0x26e>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 8023930:	4b1e      	ldr	r3, [pc, #120]	@ (80239ac <RadioIrqProcess+0x310>)
 8023932:	2201      	movs	r2, #1
 8023934:	2100      	movs	r1, #0
 8023936:	2002      	movs	r0, #2
 8023938:	f001 ff24 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 802393c:	4b08      	ldr	r3, [pc, #32]	@ (8023960 <RadioIrqProcess+0x2c4>)
 802393e:	785b      	ldrb	r3, [r3, #1]
 8023940:	2b00      	cmp	r3, #0
 8023942:	d008      	beq.n	8023956 <RadioIrqProcess+0x2ba>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 8023944:	4b0b      	ldr	r3, [pc, #44]	@ (8023974 <RadioIrqProcess+0x2d8>)
 8023946:	681b      	ldr	r3, [r3, #0]
 8023948:	2b00      	cmp	r3, #0
 802394a:	d0d5      	beq.n	80238f8 <RadioIrqProcess+0x25c>
 802394c:	691b      	ldr	r3, [r3, #16]
 802394e:	2b00      	cmp	r3, #0
 8023950:	d0d2      	beq.n	80238f8 <RadioIrqProcess+0x25c>
            RadioEvents->RxError( );
 8023952:	4798      	blx	r3
}
 8023954:	e7d0      	b.n	80238f8 <RadioIrqProcess+0x25c>
            SUBGRF_SetStandby( STDBY_RC );
 8023956:	2000      	movs	r0, #0
 8023958:	f001 f8fc 	bl	8024b54 <SUBGRF_SetStandby>
 802395c:	e7f2      	b.n	8023944 <RadioIrqProcess+0x2a8>
 802395e:	46c0      	nop			@ (mov r8, r8)
 8023960:	2000a1bc 	.word	0x2000a1bc
 8023964:	080265fc 	.word	0x080265fc
 8023968:	080265a8 	.word	0x080265a8
 802396c:	48000400 	.word	0x48000400
 8023970:	2000a18c 	.word	0x2000a18c
 8023974:	2000a218 	.word	0x2000a218
 8023978:	2000a1a4 	.word	0x2000a1a4
 802397c:	2000a21c 	.word	0x2000a21c
 8023980:	2000a1e0 	.word	0x2000a1e0
 8023984:	00000902 	.word	0x00000902
 8023988:	00000944 	.word	0x00000944
 802398c:	080265bc 	.word	0x080265bc
 8023990:	00000903 	.word	0x00000903
 8023994:	00000904 	.word	0x00000904
 8023998:	00000905 	.word	0x00000905
 802399c:	00000262 	.word	0x00000262
 80239a0:	080265c8 	.word	0x080265c8
 80239a4:	080265d4 	.word	0x080265d4
 80239a8:	080265e0 	.word	0x080265e0
 80239ac:	080265ec 	.word	0x080265ec

080239b0 <RadioOnDioIrq>:
{
 80239b0:	b510      	push	{r4, lr}
    SubgRf.RadioIrq = radioIrq;
 80239b2:	4b03      	ldr	r3, [pc, #12]	@ (80239c0 <RadioOnDioIrq+0x10>)
 80239b4:	2254      	movs	r2, #84	@ 0x54
 80239b6:	5298      	strh	r0, [r3, r2]
    RADIO_IRQ_PROCESS();
 80239b8:	f7ff fe70 	bl	802369c <RadioIrqProcess>
}
 80239bc:	bd10      	pop	{r4, pc}
 80239be:	46c0      	nop			@ (mov r8, r8)
 80239c0:	2000a1bc 	.word	0x2000a1bc

080239c4 <RadioGetWakeupTime>:
{
 80239c4:	b510      	push	{r4, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 80239c6:	f001 fd35 	bl	8025434 <SUBGRF_GetRadioWakeUpTime>
 80239ca:	3003      	adds	r0, #3
}
 80239cc:	bd10      	pop	{r4, pc}

080239ce <RadioReadRegisters>:
{
 80239ce:	b510      	push	{r4, lr}
    SUBGRF_ReadRegisters( addr, buffer, size );
 80239d0:	f001 f856 	bl	8024a80 <SUBGRF_ReadRegisters>
}
 80239d4:	bd10      	pop	{r4, pc}

080239d6 <RadioWriteRegisters>:
{
 80239d6:	b510      	push	{r4, lr}
    SUBGRF_WriteRegisters( addr, buffer, size );
 80239d8:	f001 f810 	bl	80249fc <SUBGRF_WriteRegisters>
}
 80239dc:	bd10      	pop	{r4, pc}

080239de <RadioRssi>:
{
 80239de:	b510      	push	{r4, lr}
    return SUBGRF_GetRssiInst( );
 80239e0:	f001 fc78 	bl	80252d4 <SUBGRF_GetRssiInst>
}
 80239e4:	bd10      	pop	{r4, pc}
	...

080239e8 <RadioSetTxContinuousWave>:
{
 80239e8:	b570      	push	{r4, r5, r6, lr}
 80239ea:	000d      	movs	r5, r1
    uint32_t timeout = ( uint32_t )time * 1000;
 80239ec:	0154      	lsls	r4, r2, #5
 80239ee:	1aa4      	subs	r4, r4, r2
 80239f0:	00a4      	lsls	r4, r4, #2
 80239f2:	18a4      	adds	r4, r4, r2
 80239f4:	00e4      	lsls	r4, r4, #3
    SUBGRF_SetRfFrequency( freq );
 80239f6:	f001 fa9d 	bl	8024f34 <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 80239fa:	0028      	movs	r0, r5
 80239fc:	f001 fd02 	bl	8025404 <SUBGRF_SetRfTxPower>
 8023a00:	0005      	movs	r5, r0
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8023a02:	210e      	movs	r1, #14
 8023a04:	4809      	ldr	r0, [pc, #36]	@ (8023a2c <RadioSetTxContinuousWave+0x44>)
 8023a06:	f000 ff9d 	bl	8024944 <SUBGRF_WriteRegister>
    SUBGRF_SetSwitch( antswitchpow, RFSWITCH_TX );
 8023a0a:	2101      	movs	r1, #1
 8023a0c:	0028      	movs	r0, r5
 8023a0e:	f001 fce5 	bl	80253dc <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 8023a12:	f001 f95f 	bl	8024cd4 <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 8023a16:	4b06      	ldr	r3, [pc, #24]	@ (8023a30 <RadioSetTxContinuousWave+0x48>)
 8023a18:	0021      	movs	r1, r4
 8023a1a:	001c      	movs	r4, r3
 8023a1c:	0018      	movs	r0, r3
 8023a1e:	f002 fa4d 	bl	8025ebc <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 8023a22:	0020      	movs	r0, r4
 8023a24:	f002 fa04 	bl	8025e30 <UTIL_TIMER_Start>
}
 8023a28:	bd70      	pop	{r4, r5, r6, pc}
 8023a2a:	46c0      	nop			@ (mov r8, r8)
 8023a2c:	0000091f 	.word	0x0000091f
 8023a30:	2000a1a4 	.word	0x2000a1a4

08023a34 <RadioSetChannel>:
{
 8023a34:	b510      	push	{r4, lr}
    SUBGRF_SetRfFrequency( freq );
 8023a36:	f001 fa7d 	bl	8024f34 <SUBGRF_SetRfFrequency>
}
 8023a3a:	bd10      	pop	{r4, pc}

08023a3c <RadioStartCad>:
{
 8023a3c:	b510      	push	{r4, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 8023a3e:	4b08      	ldr	r3, [pc, #32]	@ (8023a60 <RadioStartCad+0x24>)
 8023a40:	2256      	movs	r2, #86	@ 0x56
 8023a42:	5c98      	ldrb	r0, [r3, r2]
 8023a44:	2100      	movs	r1, #0
 8023a46:	f001 fcc9 	bl	80253dc <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 8023a4a:	20c0      	movs	r0, #192	@ 0xc0
 8023a4c:	0040      	lsls	r0, r0, #1
 8023a4e:	2300      	movs	r3, #0
 8023a50:	2200      	movs	r2, #0
 8023a52:	0001      	movs	r1, r0
 8023a54:	f001 fa08 	bl	8024e68 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetCad( );
 8023a58:	f001 f930 	bl	8024cbc <SUBGRF_SetCad>
}
 8023a5c:	bd10      	pop	{r4, pc}
 8023a5e:	46c0      	nop			@ (mov r8, r8)
 8023a60:	2000a1bc 	.word	0x2000a1bc

08023a64 <RadioRx>:
{
 8023a64:	b510      	push	{r4, lr}
 8023a66:	0004      	movs	r4, r0
    if( 1UL == RFW_Is_Init( ) )
 8023a68:	f001 fdaa 	bl	80255c0 <RFW_Is_Init>
 8023a6c:	2801      	cmp	r0, #1
 8023a6e:	d01a      	beq.n	8023aa6 <RadioRx+0x42>
        SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8023a70:	4816      	ldr	r0, [pc, #88]	@ (8023acc <RadioRx+0x68>)
 8023a72:	2300      	movs	r3, #0
 8023a74:	2200      	movs	r2, #0
 8023a76:	0001      	movs	r1, r0
 8023a78:	f001 f9f6 	bl	8024e68 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 8023a7c:	2c00      	cmp	r4, #0
 8023a7e:	d115      	bne.n	8023aac <RadioRx+0x48>
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8023a80:	4c13      	ldr	r4, [pc, #76]	@ (8023ad0 <RadioRx+0x6c>)
 8023a82:	2300      	movs	r3, #0
 8023a84:	65a3      	str	r3, [r4, #88]	@ 0x58
  WRITE_REG(GPIOx->BSRR, PinMask);
 8023a86:	4b13      	ldr	r3, [pc, #76]	@ (8023ad4 <RadioRx+0x70>)
 8023a88:	2280      	movs	r2, #128	@ 0x80
 8023a8a:	0152      	lsls	r2, r2, #5
 8023a8c:	619a      	str	r2, [r3, #24]
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 8023a8e:	2356      	movs	r3, #86	@ 0x56
 8023a90:	5ce0      	ldrb	r0, [r4, r3]
 8023a92:	2100      	movs	r1, #0
 8023a94:	f001 fca2 	bl	80253dc <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8023a98:	7863      	ldrb	r3, [r4, #1]
 8023a9a:	2b00      	cmp	r3, #0
 8023a9c:	d010      	beq.n	8023ac0 <RadioRx+0x5c>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8023a9e:	480e      	ldr	r0, [pc, #56]	@ (8023ad8 <RadioRx+0x74>)
 8023aa0:	f001 f88c 	bl	8024bbc <SUBGRF_SetRx>
}
 8023aa4:	bd10      	pop	{r4, pc}
        RFW_ReceiveInit( );
 8023aa6:	f001 fd93 	bl	80255d0 <RFW_ReceiveInit>
 8023aaa:	e7e7      	b.n	8023a7c <RadioRx+0x18>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8023aac:	4b0b      	ldr	r3, [pc, #44]	@ (8023adc <RadioRx+0x78>)
 8023aae:	0021      	movs	r1, r4
 8023ab0:	001c      	movs	r4, r3
 8023ab2:	0018      	movs	r0, r3
 8023ab4:	f002 fa02 	bl	8025ebc <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8023ab8:	0020      	movs	r0, r4
 8023aba:	f002 f9b9 	bl	8025e30 <UTIL_TIMER_Start>
 8023abe:	e7df      	b.n	8023a80 <RadioRx+0x1c>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 8023ac0:	4b03      	ldr	r3, [pc, #12]	@ (8023ad0 <RadioRx+0x6c>)
 8023ac2:	6898      	ldr	r0, [r3, #8]
 8023ac4:	0180      	lsls	r0, r0, #6
 8023ac6:	f001 f879 	bl	8024bbc <SUBGRF_SetRx>
}
 8023aca:	e7eb      	b.n	8023aa4 <RadioRx+0x40>
 8023acc:	00000262 	.word	0x00000262
 8023ad0:	2000a1bc 	.word	0x2000a1bc
 8023ad4:	48000400 	.word	0x48000400
 8023ad8:	00ffffff 	.word	0x00ffffff
 8023adc:	2000a18c 	.word	0x2000a18c

08023ae0 <RadioSleep>:
{
 8023ae0:	b510      	push	{r4, lr}
    SUBGRF_SetSleep( params );
 8023ae2:	2004      	movs	r0, #4
 8023ae4:	f001 f814 	bl	8024b10 <SUBGRF_SetSleep>
    RADIO_DELAY_MS( 2 );
 8023ae8:	2002      	movs	r0, #2
 8023aea:	f7fd f839 	bl	8020b60 <HAL_Delay>
}
 8023aee:	bd10      	pop	{r4, pc}

08023af0 <RadioSend>:
{
 8023af0:	b570      	push	{r4, r5, r6, lr}
 8023af2:	b082      	sub	sp, #8
 8023af4:	0006      	movs	r6, r0
 8023af6:	000c      	movs	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8023af8:	485f      	ldr	r0, [pc, #380]	@ (8023c78 <RadioSend+0x188>)
 8023afa:	2300      	movs	r3, #0
 8023afc:	2200      	movs	r2, #0
 8023afe:	0001      	movs	r1, r0
 8023b00:	f001 f9b2 	bl	8024e68 <SUBGRF_SetDioIrqParams>
 8023b04:	4b5d      	ldr	r3, [pc, #372]	@ (8023c7c <RadioSend+0x18c>)
 8023b06:	2280      	movs	r2, #128	@ 0x80
 8023b08:	0192      	lsls	r2, r2, #6
 8023b0a:	619a      	str	r2, [r3, #24]
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 8023b0c:	4d5c      	ldr	r5, [pc, #368]	@ (8023c80 <RadioSend+0x190>)
 8023b0e:	2356      	movs	r3, #86	@ 0x56
 8023b10:	5ce8      	ldrb	r0, [r5, r3]
 8023b12:	2101      	movs	r1, #1
 8023b14:	f001 fc62 	bl	80253dc <SUBGRF_SetSwitch>
    if( ( SubgRf.Modem == MODEM_LORA ) && ( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ) )
 8023b18:	782b      	ldrb	r3, [r5, #0]
 8023b1a:	2b01      	cmp	r3, #1
 8023b1c:	d104      	bne.n	8023b28 <RadioSend+0x38>
 8023b1e:	4b58      	ldr	r3, [pc, #352]	@ (8023c80 <RadioSend+0x190>)
 8023b20:	2251      	movs	r2, #81	@ 0x51
 8023b22:	5c9b      	ldrb	r3, [r3, r2]
 8023b24:	2b06      	cmp	r3, #6
 8023b26:	d011      	beq.n	8023b4c <RadioSend+0x5c>
        SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) | ( 1 << 2 ) );
 8023b28:	4d56      	ldr	r5, [pc, #344]	@ (8023c84 <RadioSend+0x194>)
 8023b2a:	0028      	movs	r0, r5
 8023b2c:	f000 ff1e 	bl	802496c <SUBGRF_ReadRegister>
 8023b30:	2304      	movs	r3, #4
 8023b32:	4318      	orrs	r0, r3
 8023b34:	b2c1      	uxtb	r1, r0
 8023b36:	0028      	movs	r0, r5
 8023b38:	f000 ff04 	bl	8024944 <SUBGRF_WriteRegister>
        switch( SubgRf.Modem )
 8023b3c:	4b50      	ldr	r3, [pc, #320]	@ (8023c80 <RadioSend+0x190>)
 8023b3e:	781b      	ldrb	r3, [r3, #0]
 8023b40:	2b04      	cmp	r3, #4
 8023b42:	d818      	bhi.n	8023b76 <RadioSend+0x86>
 8023b44:	009b      	lsls	r3, r3, #2
 8023b46:	4a50      	ldr	r2, [pc, #320]	@ (8023c88 <RadioSend+0x198>)
 8023b48:	58d3      	ldr	r3, [r2, r3]
 8023b4a:	469f      	mov	pc, r3
        SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) & ~( 1 << 2 ) );
 8023b4c:	4d4d      	ldr	r5, [pc, #308]	@ (8023c84 <RadioSend+0x194>)
 8023b4e:	0028      	movs	r0, r5
 8023b50:	f000 ff0c 	bl	802496c <SUBGRF_ReadRegister>
 8023b54:	2304      	movs	r3, #4
 8023b56:	4398      	bics	r0, r3
 8023b58:	b2c1      	uxtb	r1, r0
 8023b5a:	0028      	movs	r0, r5
 8023b5c:	f000 fef2 	bl	8024944 <SUBGRF_WriteRegister>
 8023b60:	e7ec      	b.n	8023b3c <RadioSend+0x4c>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 8023b62:	4847      	ldr	r0, [pc, #284]	@ (8023c80 <RadioSend+0x190>)
 8023b64:	77c4      	strb	r4, [r0, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023b66:	300e      	adds	r0, #14
 8023b68:	f001 fb2a 	bl	80251c0 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8023b6c:	2200      	movs	r2, #0
 8023b6e:	0021      	movs	r1, r4
 8023b70:	0030      	movs	r0, r6
 8023b72:	f001 f81b 	bl	8024bac <SUBGRF_SendPayload>
        TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 8023b76:	4b42      	ldr	r3, [pc, #264]	@ (8023c80 <RadioSend+0x190>)
 8023b78:	6859      	ldr	r1, [r3, #4]
 8023b7a:	4c44      	ldr	r4, [pc, #272]	@ (8023c8c <RadioSend+0x19c>)
 8023b7c:	0020      	movs	r0, r4
 8023b7e:	f002 f99d 	bl	8025ebc <UTIL_TIMER_SetPeriod>
        TimerStart( &TxTimeoutTimer );
 8023b82:	0020      	movs	r0, r4
 8023b84:	f002 f954 	bl	8025e30 <UTIL_TIMER_Start>
    return RADIO_STATUS_OK;
 8023b88:	2000      	movs	r0, #0
}
 8023b8a:	b002      	add	sp, #8
 8023b8c:	bd70      	pop	{r4, r5, r6, pc}
            if ( 1UL == RFW_Is_Init( ) )
 8023b8e:	f001 fd17 	bl	80255c0 <RFW_Is_Init>
 8023b92:	2801      	cmp	r0, #1
 8023b94:	d00a      	beq.n	8023bac <RadioSend+0xbc>
                SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 8023b96:	483a      	ldr	r0, [pc, #232]	@ (8023c80 <RadioSend+0x190>)
 8023b98:	7584      	strb	r4, [r0, #22]
                SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023b9a:	300e      	adds	r0, #14
 8023b9c:	f001 fb10 	bl	80251c0 <SUBGRF_SetPacketParams>
                SUBGRF_SendPayload( buffer, size, 0 );
 8023ba0:	2200      	movs	r2, #0
 8023ba2:	0021      	movs	r1, r4
 8023ba4:	0030      	movs	r0, r6
 8023ba6:	f001 f801 	bl	8024bac <SUBGRF_SendPayload>
 8023baa:	e7e4      	b.n	8023b76 <RadioSend+0x86>
                if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 8023bac:	466b      	mov	r3, sp
 8023bae:	1dda      	adds	r2, r3, #7
 8023bb0:	0021      	movs	r1, r4
 8023bb2:	0030      	movs	r0, r6
 8023bb4:	f001 fd09 	bl	80255ca <RFW_TransmitInit>
 8023bb8:	2800      	cmp	r0, #0
 8023bba:	d10d      	bne.n	8023bd8 <RadioSend+0xe8>
                    SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 8023bbc:	4830      	ldr	r0, [pc, #192]	@ (8023c80 <RadioSend+0x190>)
 8023bbe:	466b      	mov	r3, sp
 8023bc0:	1ddc      	adds	r4, r3, #7
 8023bc2:	79db      	ldrb	r3, [r3, #7]
 8023bc4:	7583      	strb	r3, [r0, #22]
                    SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023bc6:	300e      	adds	r0, #14
 8023bc8:	f001 fafa 	bl	80251c0 <SUBGRF_SetPacketParams>
                    SUBGRF_SendPayload( buffer, outsize, 0 );
 8023bcc:	7821      	ldrb	r1, [r4, #0]
 8023bce:	2200      	movs	r2, #0
 8023bd0:	0030      	movs	r0, r6
 8023bd2:	f000 ffeb 	bl	8024bac <SUBGRF_SendPayload>
 8023bd6:	e7ce      	b.n	8023b76 <RadioSend+0x86>
                    MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n" );
 8023bd8:	4b2d      	ldr	r3, [pc, #180]	@ (8023c90 <RadioSend+0x1a0>)
 8023bda:	2201      	movs	r2, #1
 8023bdc:	2100      	movs	r1, #0
 8023bde:	2002      	movs	r0, #2
 8023be0:	f001 fdd0 	bl	8025784 <UTIL_ADV_TRACE_COND_FSend>
                    return RADIO_STATUS_ERROR;
 8023be4:	2003      	movs	r0, #3
 8023be6:	e7d0      	b.n	8023b8a <RadioSend+0x9a>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8023be8:	4825      	ldr	r0, [pc, #148]	@ (8023c80 <RadioSend+0x190>)
 8023bea:	2302      	movs	r3, #2
 8023bec:	7383      	strb	r3, [r0, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 8023bee:	7684      	strb	r4, [r0, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023bf0:	300e      	adds	r0, #14
 8023bf2:	f001 fae5 	bl	80251c0 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8023bf6:	2200      	movs	r2, #0
 8023bf8:	0021      	movs	r1, r4
 8023bfa:	0030      	movs	r0, r6
 8023bfc:	f000 ffd6 	bl	8024bac <SUBGRF_SendPayload>
            break;
 8023c00:	e7b9      	b.n	8023b76 <RadioSend+0x86>
            payload_integration( RadioBuffer, buffer, size );
 8023c02:	4824      	ldr	r0, [pc, #144]	@ (8023c94 <RadioSend+0x1a4>)
 8023c04:	0022      	movs	r2, r4
 8023c06:	0031      	movs	r1, r6
 8023c08:	f7ff fc20 	bl	802344c <payload_integration>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8023c0c:	4d1c      	ldr	r5, [pc, #112]	@ (8023c80 <RadioSend+0x190>)
 8023c0e:	2302      	movs	r3, #2
 8023c10:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8023c12:	1c66      	adds	r6, r4, #1
 8023c14:	b2f6      	uxtb	r6, r6
 8023c16:	76ae      	strb	r6, [r5, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023c18:	0028      	movs	r0, r5
 8023c1a:	300e      	adds	r0, #14
 8023c1c:	f001 fad0 	bl	80251c0 <SUBGRF_SetPacketParams>
            RadioWrite( SUBGHZ_RAM_RAMPUPL, 0 ); // clean start-up LSB
 8023c20:	2100      	movs	r1, #0
 8023c22:	20f1      	movs	r0, #241	@ 0xf1
 8023c24:	f7ff fc9e 	bl	8023564 <RadioWrite>
            RadioWrite( SUBGHZ_RAM_RAMPUPH, 0 ); // clean start-up MSB
 8023c28:	2100      	movs	r1, #0
 8023c2a:	20f0      	movs	r0, #240	@ 0xf0
 8023c2c:	f7ff fc9a 	bl	8023564 <RadioWrite>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 8023c30:	6cab      	ldr	r3, [r5, #72]	@ 0x48
 8023c32:	2b64      	cmp	r3, #100	@ 0x64
 8023c34:	d017      	beq.n	8023c66 <RadioSend+0x176>
                RadioWrite( SUBGHZ_RAM_RAMPDNL, 0xE1 ); // clean end of frame LSB
 8023c36:	21e1      	movs	r1, #225	@ 0xe1
 8023c38:	20f3      	movs	r0, #243	@ 0xf3
 8023c3a:	f7ff fc93 	bl	8023564 <RadioWrite>
                RadioWrite( SUBGHZ_RAM_RAMPDNH, 0x04 ); // clean end of frame MSB
 8023c3e:	2104      	movs	r1, #4
 8023c40:	20f2      	movs	r0, #242	@ 0xf2
 8023c42:	f7ff fc8f 	bl	8023564 <RadioWrite>
            uint16_t bitNum = ( size * 8 ) + 2;
 8023c46:	00e4      	lsls	r4, r4, #3
 8023c48:	1ca5      	adds	r5, r4, #2
            RadioWrite( SUBGHZ_RAM_FRAMELIMH, ( bitNum >> 8 ) & 0x00FF );    // limit frame
 8023c4a:	0a21      	lsrs	r1, r4, #8
 8023c4c:	20f4      	movs	r0, #244	@ 0xf4
 8023c4e:	f7ff fc89 	bl	8023564 <RadioWrite>
            RadioWrite( SUBGHZ_RAM_FRAMELIML, bitNum & 0x00FF );             // limit frame
 8023c52:	b2e9      	uxtb	r1, r5
 8023c54:	20f5      	movs	r0, #245	@ 0xf5
 8023c56:	f7ff fc85 	bl	8023564 <RadioWrite>
            SUBGRF_SendPayload( RadioBuffer, size + 1, 0xFFFFFF );
 8023c5a:	480e      	ldr	r0, [pc, #56]	@ (8023c94 <RadioSend+0x1a4>)
 8023c5c:	4a0e      	ldr	r2, [pc, #56]	@ (8023c98 <RadioSend+0x1a8>)
 8023c5e:	0031      	movs	r1, r6
 8023c60:	f000 ffa4 	bl	8024bac <SUBGRF_SendPayload>
            break;
 8023c64:	e787      	b.n	8023b76 <RadioSend+0x86>
                RadioWrite( SUBGHZ_RAM_RAMPDNL, 0x70 ); // clean end of frame LSB
 8023c66:	2170      	movs	r1, #112	@ 0x70
 8023c68:	20f3      	movs	r0, #243	@ 0xf3
 8023c6a:	f7ff fc7b 	bl	8023564 <RadioWrite>
                RadioWrite( SUBGHZ_RAM_RAMPDNH, 0x1D ); // clean end of frame MSB
 8023c6e:	211d      	movs	r1, #29
 8023c70:	20f2      	movs	r0, #242	@ 0xf2
 8023c72:	f7ff fc77 	bl	8023564 <RadioWrite>
 8023c76:	e7e6      	b.n	8023c46 <RadioSend+0x156>
 8023c78:	00000201 	.word	0x00000201
 8023c7c:	48000400 	.word	0x48000400
 8023c80:	2000a1bc 	.word	0x2000a1bc
 8023c84:	00000889 	.word	0x00000889
 8023c88:	08026698 	.word	0x08026698
 8023c8c:	2000a1a4 	.word	0x2000a1a4
 8023c90:	08026680 	.word	0x08026680
 8023c94:	2000a21c 	.word	0x2000a21c
 8023c98:	00ffffff 	.word	0x00ffffff

08023c9c <RadioRandom>:
{
 8023c9c:	b510      	push	{r4, lr}
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8023c9e:	2300      	movs	r3, #0
 8023ca0:	2200      	movs	r2, #0
 8023ca2:	2100      	movs	r1, #0
 8023ca4:	2000      	movs	r0, #0
 8023ca6:	f001 f8df 	bl	8024e68 <SUBGRF_SetDioIrqParams>
    rnd = SUBGRF_GetRandom();
 8023caa:	f000 ff9b 	bl	8024be4 <SUBGRF_GetRandom>
}
 8023cae:	bd10      	pop	{r4, pc}

08023cb0 <RadioSetModem>:
{
 8023cb0:	b510      	push	{r4, lr}
 8023cb2:	0004      	movs	r4, r0
    SubgRf.Modem = modem;
 8023cb4:	4b1c      	ldr	r3, [pc, #112]	@ (8023d28 <RadioSetModem+0x78>)
 8023cb6:	7018      	strb	r0, [r3, #0]
    RFW_SetRadioModem( modem );
 8023cb8:	f001 fc8f 	bl	80255da <RFW_SetRadioModem>
    switch( modem )
 8023cbc:	2c05      	cmp	r4, #5
 8023cbe:	d803      	bhi.n	8023cc8 <RadioSetModem+0x18>
 8023cc0:	00a4      	lsls	r4, r4, #2
 8023cc2:	4b1a      	ldr	r3, [pc, #104]	@ (8023d2c <RadioSetModem+0x7c>)
 8023cc4:	591b      	ldr	r3, [r3, r4]
 8023cc6:	469f      	mov	pc, r3
        SUBGRF_SetPacketType( PACKET_TYPE_GMSK );
 8023cc8:	2003      	movs	r0, #3
 8023cca:	f001 f959 	bl	8024f80 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8023cce:	4b16      	ldr	r3, [pc, #88]	@ (8023d28 <RadioSetModem+0x78>)
 8023cd0:	2200      	movs	r2, #0
 8023cd2:	735a      	strb	r2, [r3, #13]
}
 8023cd4:	bd10      	pop	{r4, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8023cd6:	2000      	movs	r0, #0
 8023cd8:	f001 f952 	bl	8024f80 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8023cdc:	4b12      	ldr	r3, [pc, #72]	@ (8023d28 <RadioSetModem+0x78>)
 8023cde:	2200      	movs	r2, #0
 8023ce0:	735a      	strb	r2, [r3, #13]
        break;
 8023ce2:	e7f7      	b.n	8023cd4 <RadioSetModem+0x24>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8023ce4:	2001      	movs	r0, #1
 8023ce6:	f001 f94b 	bl	8024f80 <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8023cea:	4b0f      	ldr	r3, [pc, #60]	@ (8023d28 <RadioSetModem+0x78>)
 8023cec:	7b5a      	ldrb	r2, [r3, #13]
 8023cee:	7b18      	ldrb	r0, [r3, #12]
 8023cf0:	4282      	cmp	r2, r0
 8023cf2:	d0ef      	beq.n	8023cd4 <RadioSetModem+0x24>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8023cf4:	7358      	strb	r0, [r3, #13]
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 8023cf6:	f000 faed 	bl	80242d4 <RadioSetPublicNetwork>
 8023cfa:	e7eb      	b.n	8023cd4 <RadioSetModem+0x24>
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 8023cfc:	2002      	movs	r0, #2
 8023cfe:	f001 f93f 	bl	8024f80 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8023d02:	4b09      	ldr	r3, [pc, #36]	@ (8023d28 <RadioSetModem+0x78>)
 8023d04:	2200      	movs	r2, #0
 8023d06:	735a      	strb	r2, [r3, #13]
        break;
 8023d08:	e7e4      	b.n	8023cd4 <RadioSetModem+0x24>
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 8023d0a:	2002      	movs	r0, #2
 8023d0c:	f001 f938 	bl	8024f80 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8023d10:	4b05      	ldr	r3, [pc, #20]	@ (8023d28 <RadioSetModem+0x78>)
 8023d12:	2200      	movs	r2, #0
 8023d14:	735a      	strb	r2, [r3, #13]
        break;
 8023d16:	e7dd      	b.n	8023cd4 <RadioSetModem+0x24>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8023d18:	2000      	movs	r0, #0
 8023d1a:	f001 f931 	bl	8024f80 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8023d1e:	4b02      	ldr	r3, [pc, #8]	@ (8023d28 <RadioSetModem+0x78>)
 8023d20:	2200      	movs	r2, #0
 8023d22:	735a      	strb	r2, [r3, #13]
}
 8023d24:	e7d6      	b.n	8023cd4 <RadioSetModem+0x24>
 8023d26:	46c0      	nop			@ (mov r8, r8)
 8023d28:	2000a1bc 	.word	0x2000a1bc
 8023d2c:	080266ac 	.word	0x080266ac

08023d30 <RadioSetTxGenericConfig>:
{
 8023d30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023d32:	b087      	sub	sp, #28
 8023d34:	0005      	movs	r5, r0
 8023d36:	000c      	movs	r4, r1
 8023d38:	0017      	movs	r7, r2
 8023d3a:	001e      	movs	r6, r3
    uint8_t syncword[8] = {0};
 8023d3c:	2300      	movs	r3, #0
 8023d3e:	9304      	str	r3, [sp, #16]
 8023d40:	9305      	str	r3, [sp, #20]
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8023d42:	f001 fc3c 	bl	80255be <RFW_DeInit>
    switch( modem )
 8023d46:	2d02      	cmp	r5, #2
 8023d48:	d100      	bne.n	8023d4c <RadioSetTxGenericConfig+0x1c>
 8023d4a:	e145      	b.n	8023fd8 <RadioSetTxGenericConfig+0x2a8>
 8023d4c:	d846      	bhi.n	8023ddc <RadioSetTxGenericConfig+0xac>
 8023d4e:	2d00      	cmp	r5, #0
 8023d50:	d100      	bne.n	8023d54 <RadioSetTxGenericConfig+0x24>
 8023d52:	e0bb      	b.n	8023ecc <RadioSetTxGenericConfig+0x19c>
 8023d54:	2d01      	cmp	r5, #1
 8023d56:	d000      	beq.n	8023d5a <RadioSetTxGenericConfig+0x2a>
 8023d58:	e153      	b.n	8024002 <RadioSetTxGenericConfig+0x2d2>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8023d5a:	4bb7      	ldr	r3, [pc, #732]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023d5c:	2238      	movs	r2, #56	@ 0x38
 8023d5e:	2101      	movs	r1, #1
 8023d60:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 8023d62:	7821      	ldrb	r1, [r4, #0]
 8023d64:	3218      	adds	r2, #24
 8023d66:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 8023d68:	7861      	ldrb	r1, [r4, #1]
 8023d6a:	3201      	adds	r2, #1
 8023d6c:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 8023d6e:	78a1      	ldrb	r1, [r4, #2]
 8023d70:	3201      	adds	r2, #1
 8023d72:	5499      	strb	r1, [r3, r2]
        switch( config->lora.LowDatarateOptimize )
 8023d74:	78e3      	ldrb	r3, [r4, #3]
 8023d76:	2b01      	cmp	r3, #1
 8023d78:	d100      	bne.n	8023d7c <RadioSetTxGenericConfig+0x4c>
 8023d7a:	e10e      	b.n	8023f9a <RadioSetTxGenericConfig+0x26a>
 8023d7c:	2b02      	cmp	r3, #2
 8023d7e:	d100      	bne.n	8023d82 <RadioSetTxGenericConfig+0x52>
 8023d80:	e110      	b.n	8023fa4 <RadioSetTxGenericConfig+0x274>
 8023d82:	2b00      	cmp	r3, #0
 8023d84:	d100      	bne.n	8023d88 <RadioSetTxGenericConfig+0x58>
 8023d86:	e103      	b.n	8023f90 <RadioSetTxGenericConfig+0x260>
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8023d88:	4dab      	ldr	r5, [pc, #684]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023d8a:	2301      	movs	r3, #1
 8023d8c:	73ab      	strb	r3, [r5, #14]
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 8023d8e:	88a3      	ldrh	r3, [r4, #4]
 8023d90:	83ab      	strh	r3, [r5, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 8023d92:	79a3      	ldrb	r3, [r4, #6]
 8023d94:	77ab      	strb	r3, [r5, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 8023d96:	79e2      	ldrb	r2, [r4, #7]
 8023d98:	2320      	movs	r3, #32
 8023d9a:	54ea      	strb	r2, [r5, r3]
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 8023d9c:	7a22      	ldrb	r2, [r4, #8]
 8023d9e:	3301      	adds	r3, #1
 8023da0:	54ea      	strb	r2, [r5, r3]
        RadioStandby( );
 8023da2:	f7ff fc65 	bl	8023670 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 8023da6:	2001      	movs	r0, #1
 8023da8:	f7ff ff82 	bl	8023cb0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8023dac:	0028      	movs	r0, r5
 8023dae:	3038      	adds	r0, #56	@ 0x38
 8023db0:	f001 f98e 	bl	80250d0 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023db4:	0028      	movs	r0, r5
 8023db6:	300e      	adds	r0, #14
 8023db8:	f001 fa02 	bl	80251c0 <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 8023dbc:	2351      	movs	r3, #81	@ 0x51
 8023dbe:	5ceb      	ldrb	r3, [r5, r3]
 8023dc0:	2b06      	cmp	r3, #6
 8023dc2:	d100      	bne.n	8023dc6 <RadioSetTxGenericConfig+0x96>
 8023dc4:	e0fd      	b.n	8023fc2 <RadioSetTxGenericConfig+0x292>
            SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) | ( 1 << 2 ) );
 8023dc6:	4c9d      	ldr	r4, [pc, #628]	@ (802403c <RadioSetTxGenericConfig+0x30c>)
 8023dc8:	0020      	movs	r0, r4
 8023dca:	f000 fdcf 	bl	802496c <SUBGRF_ReadRegister>
 8023dce:	2304      	movs	r3, #4
 8023dd0:	4318      	orrs	r0, r3
 8023dd2:	b2c1      	uxtb	r1, r0
 8023dd4:	0020      	movs	r0, r4
 8023dd6:	f000 fdb5 	bl	8024944 <SUBGRF_WriteRegister>
 8023dda:	e112      	b.n	8024002 <RadioSetTxGenericConfig+0x2d2>
    switch( modem )
 8023ddc:	2d03      	cmp	r5, #3
 8023dde:	d000      	beq.n	8023de2 <RadioSetTxGenericConfig+0xb2>
 8023de0:	e10f      	b.n	8024002 <RadioSetTxGenericConfig+0x2d2>
        if( config->msk.SyncWordLength > 8 )
 8023de2:	7ca2      	ldrb	r2, [r4, #18]
 8023de4:	2a08      	cmp	r2, #8
 8023de6:	d900      	bls.n	8023dea <RadioSetTxGenericConfig+0xba>
 8023de8:	e117      	b.n	802401a <RadioSetTxGenericConfig+0x2ea>
            RADIO_MEMCPY8( syncword, config->msk.SyncWord, config->msk.SyncWordLength );
 8023dea:	68a1      	ldr	r1, [r4, #8]
 8023dec:	a804      	add	r0, sp, #16
 8023dee:	f001 fde1 	bl	80259b4 <UTIL_MEM_cpy_8>
        if( ( config->msk.BitRate == 0 ) )
 8023df2:	6823      	ldr	r3, [r4, #0]
 8023df4:	2b00      	cmp	r3, #0
 8023df6:	d100      	bne.n	8023dfa <RadioSetTxGenericConfig+0xca>
 8023df8:	e112      	b.n	8024020 <RadioSetTxGenericConfig+0x2f0>
        else if( config->msk.BitRate <= 10000 )
 8023dfa:	4a91      	ldr	r2, [pc, #580]	@ (8024040 <RadioSetTxGenericConfig+0x310>)
 8023dfc:	4293      	cmp	r3, r2
 8023dfe:	d823      	bhi.n	8023e48 <RadioSetTxGenericConfig+0x118>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GMSK;
 8023e00:	4b8d      	ldr	r3, [pc, #564]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023e02:	2203      	movs	r2, #3
 8023e04:	739a      	strb	r2, [r3, #14]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GMSK;
 8023e06:	2138      	movs	r1, #56	@ 0x38
 8023e08:	545a      	strb	r2, [r3, r1]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = config->msk.BitRate;
 8023e0a:	6822      	ldr	r2, [r4, #0]
 8023e0c:	63da      	str	r2, [r3, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->msk.ModulationShaping;
 8023e0e:	7ce1      	ldrb	r1, [r4, #19]
 8023e10:	2244      	movs	r2, #68	@ 0x44
 8023e12:	5499      	strb	r1, [r3, r2]
            radio_modem = MODEM_MSK;
 8023e14:	3d01      	subs	r5, #1
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->msk.PreambleLen ) << 3; // convert byte into bit
 8023e16:	6862      	ldr	r2, [r4, #4]
 8023e18:	00d2      	lsls	r2, r2, #3
 8023e1a:	4b87      	ldr	r3, [pc, #540]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023e1c:	821a      	strh	r2, [r3, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 8023e1e:	2204      	movs	r2, #4
 8023e20:	749a      	strb	r2, [r3, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->msk.SyncWordLength ) << 3; // convert byte into bit
 8023e22:	7ca2      	ldrb	r2, [r4, #18]
 8023e24:	00d2      	lsls	r2, r2, #3
 8023e26:	74da      	strb	r2, [r3, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 8023e28:	2200      	movs	r2, #0
 8023e2a:	751a      	strb	r2, [r3, #20]
        if( ( config->msk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 8023e2c:	7da3      	ldrb	r3, [r4, #22]
 8023e2e:	2b02      	cmp	r3, #2
 8023e30:	d019      	beq.n	8023e66 <RadioSetTxGenericConfig+0x136>
            || ( config->msk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8023e32:	7d23      	ldrb	r3, [r4, #20]
 8023e34:	2b02      	cmp	r3, #2
 8023e36:	d016      	beq.n	8023e66 <RadioSetTxGenericConfig+0x136>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->msk.CrcLength;
 8023e38:	7d62      	ldrb	r2, [r4, #21]
 8023e3a:	4b7f      	ldr	r3, [pc, #508]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023e3c:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->msk.Whitening;
 8023e3e:	7da2      	ldrb	r2, [r4, #22]
 8023e40:	761a      	strb	r2, [r3, #24]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->msk.HeaderType;
 8023e42:	7d22      	ldrb	r2, [r4, #20]
 8023e44:	755a      	strb	r2, [r3, #21]
 8023e46:	e027      	b.n	8023e98 <RadioSetTxGenericConfig+0x168>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8023e48:	4b7b      	ldr	r3, [pc, #492]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023e4a:	2200      	movs	r2, #0
 8023e4c:	739a      	strb	r2, [r3, #14]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8023e4e:	2138      	movs	r1, #56	@ 0x38
 8023e50:	545a      	strb	r2, [r3, r1]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = config->msk.BitRate;
 8023e52:	6822      	ldr	r2, [r4, #0]
 8023e54:	63da      	str	r2, [r3, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->msk.ModulationShaping;
 8023e56:	7ce1      	ldrb	r1, [r4, #19]
 8023e58:	2244      	movs	r2, #68	@ 0x44
 8023e5a:	5499      	strb	r1, [r3, r2]
            SubgRf.ModulationParams.Params.Gfsk.Fdev = config->msk.BitRate / 4;
 8023e5c:	6822      	ldr	r2, [r4, #0]
 8023e5e:	0892      	lsrs	r2, r2, #2
 8023e60:	641a      	str	r2, [r3, #64]	@ 0x40
            radio_modem = MODEM_FSK;
 8023e62:	2500      	movs	r5, #0
 8023e64:	e7d7      	b.n	8023e16 <RadioSetTxGenericConfig+0xe6>
            if( ( config->msk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->msk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT )
 8023e66:	7d62      	ldrb	r2, [r4, #21]
 8023e68:	0013      	movs	r3, r2
 8023e6a:	330f      	adds	r3, #15
 8023e6c:	b2db      	uxtb	r3, r3
 8023e6e:	2b01      	cmp	r3, #1
 8023e70:	d901      	bls.n	8023e76 <RadioSetTxGenericConfig+0x146>
                && ( config->msk.CrcLength != RADIO_FSK_CRC_OFF ) )
 8023e72:	2a01      	cmp	r2, #1
 8023e74:	d127      	bne.n	8023ec6 <RadioSetTxGenericConfig+0x196>
            ConfigGeneric.TxConfig = config;
 8023e76:	a801      	add	r0, sp, #4
 8023e78:	9401      	str	r4, [sp, #4]
            ConfigGeneric.rtx = CONFIG_TX;
 8023e7a:	2301      	movs	r3, #1
 8023e7c:	7203      	strb	r3, [r0, #8]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8023e7e:	4a71      	ldr	r2, [pc, #452]	@ (8024044 <RadioSetTxGenericConfig+0x314>)
 8023e80:	4b71      	ldr	r3, [pc, #452]	@ (8024048 <RadioSetTxGenericConfig+0x318>)
 8023e82:	6819      	ldr	r1, [r3, #0]
 8023e84:	f001 fb98 	bl	80255b8 <RFW_Init>
 8023e88:	2800      	cmp	r0, #0
 8023e8a:	d11c      	bne.n	8023ec6 <RadioSetTxGenericConfig+0x196>
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 8023e8c:	4b6a      	ldr	r3, [pc, #424]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023e8e:	2200      	movs	r2, #0
 8023e90:	761a      	strb	r2, [r3, #24]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8023e92:	2101      	movs	r1, #1
 8023e94:	75d9      	strb	r1, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 8023e96:	755a      	strb	r2, [r3, #21]
        RadioStandby( );
 8023e98:	f7ff fbea 	bl	8023670 <RadioStandby>
        RadioSetModem( radio_modem );
 8023e9c:	0028      	movs	r0, r5
 8023e9e:	f7ff ff07 	bl	8023cb0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8023ea2:	4d6a      	ldr	r5, [pc, #424]	@ (802404c <RadioSetTxGenericConfig+0x31c>)
 8023ea4:	0028      	movs	r0, r5
 8023ea6:	f001 f913 	bl	80250d0 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023eaa:	0028      	movs	r0, r5
 8023eac:	382a      	subs	r0, #42	@ 0x2a
 8023eae:	f001 f987 	bl	80251c0 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 8023eb2:	a804      	add	r0, sp, #16
 8023eb4:	f000 fdb2 	bl	8024a1c <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->msk.whiteSeed );
 8023eb8:	8a20      	ldrh	r0, [r4, #16]
 8023eba:	f000 fd83 	bl	80249c4 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->msk.CrcPolynomial );
 8023ebe:	89a0      	ldrh	r0, [r4, #12]
 8023ec0:	f000 fdca 	bl	8024a58 <SUBGRF_SetCrcPolynomial>
        break;
 8023ec4:	e09d      	b.n	8024002 <RadioSetTxGenericConfig+0x2d2>
                return -1;
 8023ec6:	2001      	movs	r0, #1
 8023ec8:	4240      	negs	r0, r0
 8023eca:	e0a4      	b.n	8024016 <RadioSetTxGenericConfig+0x2e6>
        if( config->fsk.BitRate == 0 )
 8023ecc:	6823      	ldr	r3, [r4, #0]
 8023ece:	2b00      	cmp	r3, #0
 8023ed0:	d100      	bne.n	8023ed4 <RadioSetTxGenericConfig+0x1a4>
 8023ed2:	e0a8      	b.n	8024026 <RadioSetTxGenericConfig+0x2f6>
        if( config->fsk.SyncWordLength > 8 )
 8023ed4:	7ca2      	ldrb	r2, [r4, #18]
 8023ed6:	2a08      	cmp	r2, #8
 8023ed8:	d900      	bls.n	8023edc <RadioSetTxGenericConfig+0x1ac>
 8023eda:	e0a7      	b.n	802402c <RadioSetTxGenericConfig+0x2fc>
            RADIO_MEMCPY8( syncword, config->fsk.SyncWord, config->fsk.SyncWordLength );
 8023edc:	68a1      	ldr	r1, [r4, #8]
 8023ede:	a804      	add	r0, sp, #16
 8023ee0:	f001 fd68 	bl	80259b4 <UTIL_MEM_cpy_8>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8023ee4:	4b54      	ldr	r3, [pc, #336]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023ee6:	2200      	movs	r2, #0
 8023ee8:	2138      	movs	r1, #56	@ 0x38
 8023eea:	545a      	strb	r2, [r3, r1]
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8023eec:	6821      	ldr	r1, [r4, #0]
 8023eee:	63d9      	str	r1, [r3, #60]	@ 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 8023ef0:	7ce0      	ldrb	r0, [r4, #19]
 8023ef2:	2144      	movs	r1, #68	@ 0x44
 8023ef4:	5458      	strb	r0, [r3, r1]
        SubgRf.ModulationParams.Params.Gfsk.Fdev = config->fsk.FrequencyDeviation;
 8023ef6:	69a1      	ldr	r1, [r4, #24]
 8023ef8:	6419      	str	r1, [r3, #64]	@ 0x40
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8023efa:	739a      	strb	r2, [r3, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 8023efc:	6861      	ldr	r1, [r4, #4]
 8023efe:	00c9      	lsls	r1, r1, #3
 8023f00:	8219      	strh	r1, [r3, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 8023f02:	2104      	movs	r1, #4
 8023f04:	7499      	strb	r1, [r3, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 8023f06:	7ca1      	ldrb	r1, [r4, #18]
 8023f08:	00c9      	lsls	r1, r1, #3
 8023f0a:	74d9      	strb	r1, [r3, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 8023f0c:	751a      	strb	r2, [r3, #20]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 8023f0e:	7da3      	ldrb	r3, [r4, #22]
 8023f10:	2b02      	cmp	r3, #2
 8023f12:	d00a      	beq.n	8023f2a <RadioSetTxGenericConfig+0x1fa>
            || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8023f14:	7d23      	ldrb	r3, [r4, #20]
 8023f16:	2b02      	cmp	r3, #2
 8023f18:	d007      	beq.n	8023f2a <RadioSetTxGenericConfig+0x1fa>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8023f1a:	7d62      	ldrb	r2, [r4, #21]
 8023f1c:	4b46      	ldr	r3, [pc, #280]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023f1e:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8023f20:	7da2      	ldrb	r2, [r4, #22]
 8023f22:	761a      	strb	r2, [r3, #24]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 8023f24:	7d22      	ldrb	r2, [r4, #20]
 8023f26:	755a      	strb	r2, [r3, #21]
 8023f28:	e018      	b.n	8023f5c <RadioSetTxGenericConfig+0x22c>
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT )
 8023f2a:	7d62      	ldrb	r2, [r4, #21]
 8023f2c:	0013      	movs	r3, r2
 8023f2e:	330f      	adds	r3, #15
 8023f30:	b2db      	uxtb	r3, r3
 8023f32:	2b01      	cmp	r3, #1
 8023f34:	d901      	bls.n	8023f3a <RadioSetTxGenericConfig+0x20a>
                && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 8023f36:	2a01      	cmp	r2, #1
 8023f38:	d127      	bne.n	8023f8a <RadioSetTxGenericConfig+0x25a>
            ConfigGeneric.rtx = CONFIG_TX;
 8023f3a:	a801      	add	r0, sp, #4
 8023f3c:	2301      	movs	r3, #1
 8023f3e:	7203      	strb	r3, [r0, #8]
            ConfigGeneric.TxConfig = config;
 8023f40:	9401      	str	r4, [sp, #4]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8023f42:	4a40      	ldr	r2, [pc, #256]	@ (8024044 <RadioSetTxGenericConfig+0x314>)
 8023f44:	4b40      	ldr	r3, [pc, #256]	@ (8024048 <RadioSetTxGenericConfig+0x318>)
 8023f46:	6819      	ldr	r1, [r3, #0]
 8023f48:	f001 fb36 	bl	80255b8 <RFW_Init>
 8023f4c:	2800      	cmp	r0, #0
 8023f4e:	d11c      	bne.n	8023f8a <RadioSetTxGenericConfig+0x25a>
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 8023f50:	4b39      	ldr	r3, [pc, #228]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023f52:	2200      	movs	r2, #0
 8023f54:	761a      	strb	r2, [r3, #24]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8023f56:	2101      	movs	r1, #1
 8023f58:	75d9      	strb	r1, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 8023f5a:	755a      	strb	r2, [r3, #21]
        RadioStandby( );
 8023f5c:	f7ff fb88 	bl	8023670 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 8023f60:	2000      	movs	r0, #0
 8023f62:	f7ff fea5 	bl	8023cb0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8023f66:	4d39      	ldr	r5, [pc, #228]	@ (802404c <RadioSetTxGenericConfig+0x31c>)
 8023f68:	0028      	movs	r0, r5
 8023f6a:	f001 f8b1 	bl	80250d0 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8023f6e:	0028      	movs	r0, r5
 8023f70:	382a      	subs	r0, #42	@ 0x2a
 8023f72:	f001 f925 	bl	80251c0 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 8023f76:	a804      	add	r0, sp, #16
 8023f78:	f000 fd50 	bl	8024a1c <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 8023f7c:	8a20      	ldrh	r0, [r4, #16]
 8023f7e:	f000 fd21 	bl	80249c4 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 8023f82:	89a0      	ldrh	r0, [r4, #12]
 8023f84:	f000 fd68 	bl	8024a58 <SUBGRF_SetCrcPolynomial>
        break;
 8023f88:	e03b      	b.n	8024002 <RadioSetTxGenericConfig+0x2d2>
                return -1;
 8023f8a:	2001      	movs	r0, #1
 8023f8c:	4240      	negs	r0, r0
 8023f8e:	e042      	b.n	8024016 <RadioSetTxGenericConfig+0x2e6>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8023f90:	4b29      	ldr	r3, [pc, #164]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023f92:	3201      	adds	r2, #1
 8023f94:	2100      	movs	r1, #0
 8023f96:	5499      	strb	r1, [r3, r2]
            break;
 8023f98:	e6f6      	b.n	8023d88 <RadioSetTxGenericConfig+0x58>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8023f9a:	4b27      	ldr	r3, [pc, #156]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023f9c:	2253      	movs	r2, #83	@ 0x53
 8023f9e:	2101      	movs	r1, #1
 8023fa0:	5499      	strb	r1, [r3, r2]
            break;
 8023fa2:	e6f1      	b.n	8023d88 <RadioSetTxGenericConfig+0x58>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 8023fa4:	7823      	ldrb	r3, [r4, #0]
 8023fa6:	3b0b      	subs	r3, #11
 8023fa8:	b2db      	uxtb	r3, r3
 8023faa:	2b01      	cmp	r3, #1
 8023fac:	d904      	bls.n	8023fb8 <RadioSetTxGenericConfig+0x288>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8023fae:	4b22      	ldr	r3, [pc, #136]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023fb0:	2253      	movs	r2, #83	@ 0x53
 8023fb2:	2100      	movs	r1, #0
 8023fb4:	5499      	strb	r1, [r3, r2]
 8023fb6:	e6e7      	b.n	8023d88 <RadioSetTxGenericConfig+0x58>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8023fb8:	4b1f      	ldr	r3, [pc, #124]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023fba:	2253      	movs	r2, #83	@ 0x53
 8023fbc:	2101      	movs	r1, #1
 8023fbe:	5499      	strb	r1, [r3, r2]
 8023fc0:	e6e2      	b.n	8023d88 <RadioSetTxGenericConfig+0x58>
            SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) & ~( 1 << 2 ) );
 8023fc2:	4c1e      	ldr	r4, [pc, #120]	@ (802403c <RadioSetTxGenericConfig+0x30c>)
 8023fc4:	0020      	movs	r0, r4
 8023fc6:	f000 fcd1 	bl	802496c <SUBGRF_ReadRegister>
 8023fca:	2304      	movs	r3, #4
 8023fcc:	4398      	bics	r0, r3
 8023fce:	b2c1      	uxtb	r1, r0
 8023fd0:	0020      	movs	r0, r4
 8023fd2:	f000 fcb7 	bl	8024944 <SUBGRF_WriteRegister>
 8023fd6:	e014      	b.n	8024002 <RadioSetTxGenericConfig+0x2d2>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 8023fd8:	6823      	ldr	r3, [r4, #0]
 8023fda:	3b01      	subs	r3, #1
 8023fdc:	22fa      	movs	r2, #250	@ 0xfa
 8023fde:	0092      	lsls	r2, r2, #2
 8023fe0:	4293      	cmp	r3, r2
 8023fe2:	d226      	bcs.n	8024032 <RadioSetTxGenericConfig+0x302>
        RadioSetModem( MODEM_BPSK );
 8023fe4:	2003      	movs	r0, #3
 8023fe6:	f7ff fe63 	bl	8023cb0 <RadioSetModem>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8023fea:	4813      	ldr	r0, [pc, #76]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 8023fec:	2338      	movs	r3, #56	@ 0x38
 8023fee:	2202      	movs	r2, #2
 8023ff0:	54c2      	strb	r2, [r0, r3]
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 8023ff2:	6823      	ldr	r3, [r4, #0]
 8023ff4:	6483      	str	r3, [r0, #72]	@ 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8023ff6:	234c      	movs	r3, #76	@ 0x4c
 8023ff8:	3214      	adds	r2, #20
 8023ffa:	54c2      	strb	r2, [r0, r3]
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8023ffc:	3038      	adds	r0, #56	@ 0x38
 8023ffe:	f001 f867 	bl	80250d0 <SUBGRF_SetModulationParams>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8024002:	0038      	movs	r0, r7
 8024004:	f001 f9fe 	bl	8025404 <SUBGRF_SetRfTxPower>
 8024008:	4c0b      	ldr	r4, [pc, #44]	@ (8024038 <RadioSetTxGenericConfig+0x308>)
 802400a:	2356      	movs	r3, #86	@ 0x56
 802400c:	54e0      	strb	r0, [r4, r3]
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 802400e:	f001 fadb 	bl	80255c8 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8024012:	6066      	str	r6, [r4, #4]
    return 0;
 8024014:	2000      	movs	r0, #0
}
 8024016:	b007      	add	sp, #28
 8024018:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return -1;
 802401a:	2001      	movs	r0, #1
 802401c:	4240      	negs	r0, r0
 802401e:	e7fa      	b.n	8024016 <RadioSetTxGenericConfig+0x2e6>
            return -1;
 8024020:	2001      	movs	r0, #1
 8024022:	4240      	negs	r0, r0
 8024024:	e7f7      	b.n	8024016 <RadioSetTxGenericConfig+0x2e6>
            return -1;
 8024026:	2001      	movs	r0, #1
 8024028:	4240      	negs	r0, r0
 802402a:	e7f4      	b.n	8024016 <RadioSetTxGenericConfig+0x2e6>
            return -1;
 802402c:	2001      	movs	r0, #1
 802402e:	4240      	negs	r0, r0
 8024030:	e7f1      	b.n	8024016 <RadioSetTxGenericConfig+0x2e6>
            return -1;
 8024032:	2001      	movs	r0, #1
 8024034:	4240      	negs	r0, r0
 8024036:	e7ee      	b.n	8024016 <RadioSetTxGenericConfig+0x2e6>
 8024038:	2000a1bc 	.word	0x2000a1bc
 802403c:	00000889 	.word	0x00000889
 8024040:	00002710 	.word	0x00002710
 8024044:	2000a1a4 	.word	0x2000a1a4
 8024048:	2000a218 	.word	0x2000a218
 802404c:	2000a1f4 	.word	0x2000a1f4

08024050 <RadioSetRxGenericConfig>:
{
 8024050:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024052:	b087      	sub	sp, #28
 8024054:	0007      	movs	r7, r0
 8024056:	000c      	movs	r4, r1
 8024058:	0015      	movs	r5, r2
 802405a:	001e      	movs	r6, r3
    uint8_t syncword[8] = {0};
 802405c:	2300      	movs	r3, #0
 802405e:	9304      	str	r3, [sp, #16]
 8024060:	9305      	str	r3, [sp, #20]
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8024062:	f001 faac 	bl	80255be <RFW_DeInit>
    if( rxContinuous != 0 )
 8024066:	2d00      	cmp	r5, #0
 8024068:	d000      	beq.n	802406c <RadioSetRxGenericConfig+0x1c>
        symbTimeout = 0;
 802406a:	2600      	movs	r6, #0
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 802406c:	1e6b      	subs	r3, r5, #1
 802406e:	419d      	sbcs	r5, r3
 8024070:	4b92      	ldr	r3, [pc, #584]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 8024072:	705d      	strb	r5, [r3, #1]
    switch( modem )
 8024074:	2f00      	cmp	r7, #0
 8024076:	d005      	beq.n	8024084 <RadioSetRxGenericConfig+0x34>
 8024078:	2f01      	cmp	r7, #1
 802407a:	d100      	bne.n	802407e <RadioSetRxGenericConfig+0x2e>
 802407c:	e090      	b.n	80241a0 <RadioSetRxGenericConfig+0x150>
 802407e:	2000      	movs	r0, #0
}
 8024080:	b007      	add	sp, #28
 8024082:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 8024084:	68a3      	ldr	r3, [r4, #8]
 8024086:	2b00      	cmp	r3, #0
 8024088:	d100      	bne.n	802408c <RadioSetRxGenericConfig+0x3c>
 802408a:	e10b      	b.n	80242a4 <RadioSetRxGenericConfig+0x254>
 802408c:	68e3      	ldr	r3, [r4, #12]
 802408e:	2b00      	cmp	r3, #0
 8024090:	d100      	bne.n	8024094 <RadioSetRxGenericConfig+0x44>
 8024092:	e10a      	b.n	80242aa <RadioSetRxGenericConfig+0x25a>
        if( config->fsk.SyncWordLength > 8 )
 8024094:	7fa2      	ldrb	r2, [r4, #30]
 8024096:	2a08      	cmp	r2, #8
 8024098:	d900      	bls.n	802409c <RadioSetRxGenericConfig+0x4c>
 802409a:	e109      	b.n	80242b0 <RadioSetRxGenericConfig+0x260>
            RADIO_MEMCPY8( syncword, config->fsk.SyncWord, config->fsk.SyncWordLength );
 802409c:	6921      	ldr	r1, [r4, #16]
 802409e:	a804      	add	r0, sp, #16
 80240a0:	f001 fc88 	bl	80259b4 <UTIL_MEM_cpy_8>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 80240a4:	6820      	ldr	r0, [r4, #0]
 80240a6:	1e43      	subs	r3, r0, #1
 80240a8:	4198      	sbcs	r0, r3
 80240aa:	b2c0      	uxtb	r0, r0
 80240ac:	f000 fe20 	bl	8024cf0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80240b0:	4d82      	ldr	r5, [pc, #520]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 80240b2:	2700      	movs	r7, #0
 80240b4:	2338      	movs	r3, #56	@ 0x38
 80240b6:	54ef      	strb	r7, [r5, r3]
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 80240b8:	68a3      	ldr	r3, [r4, #8]
 80240ba:	63eb      	str	r3, [r5, #60]	@ 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 80240bc:	2320      	movs	r3, #32
 80240be:	5ce2      	ldrb	r2, [r4, r3]
 80240c0:	3324      	adds	r3, #36	@ 0x24
 80240c2:	54ea      	strb	r2, [r5, r3]
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 80240c4:	6860      	ldr	r0, [r4, #4]
 80240c6:	f001 fa17 	bl	80254f8 <SUBGRF_GetFskBandwidthRegValue>
 80240ca:	2345      	movs	r3, #69	@ 0x45
 80240cc:	54e8      	strb	r0, [r5, r3]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80240ce:	73af      	strb	r7, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 80240d0:	68e3      	ldr	r3, [r4, #12]
 80240d2:	00db      	lsls	r3, r3, #3
 80240d4:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 80240d6:	7fe3      	ldrb	r3, [r4, #31]
 80240d8:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80240da:	7fa3      	ldrb	r3, [r4, #30]
 80240dc:	00db      	lsls	r3, r3, #3
 80240de:	74eb      	strb	r3, [r5, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 80240e0:	2321      	movs	r3, #33	@ 0x21
 80240e2:	5ce3      	ldrb	r3, [r4, r3]
 80240e4:	752b      	strb	r3, [r5, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 80240e6:	2322      	movs	r3, #34	@ 0x22
 80240e8:	5ce3      	ldrb	r3, [r4, r3]
 80240ea:	2b00      	cmp	r3, #0
 80240ec:	d10f      	bne.n	802410e <RadioSetRxGenericConfig+0xbe>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 80240ee:	6961      	ldr	r1, [r4, #20]
 80240f0:	4a72      	ldr	r2, [pc, #456]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 80240f2:	7591      	strb	r1, [r2, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 80240f4:	2224      	movs	r2, #36	@ 0x24
 80240f6:	5ca2      	ldrb	r2, [r4, r2]
 80240f8:	2a02      	cmp	r2, #2
 80240fa:	d012      	beq.n	8024122 <RadioSetRxGenericConfig+0xd2>
            || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80240fc:	2b02      	cmp	r3, #2
 80240fe:	d010      	beq.n	8024122 <RadioSetRxGenericConfig+0xd2>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8024100:	2123      	movs	r1, #35	@ 0x23
 8024102:	5c60      	ldrb	r0, [r4, r1]
 8024104:	496d      	ldr	r1, [pc, #436]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 8024106:	75c8      	strb	r0, [r1, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8024108:	760a      	strb	r2, [r1, #24]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 802410a:	754b      	strb	r3, [r1, #21]
 802410c:	e023      	b.n	8024156 <RadioSetRxGenericConfig+0x106>
        else if( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH )
 802410e:	2b02      	cmp	r3, #2
 8024110:	d003      	beq.n	802411a <RadioSetRxGenericConfig+0xca>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 8024112:	4a6a      	ldr	r2, [pc, #424]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 8024114:	21ff      	movs	r1, #255	@ 0xff
 8024116:	7591      	strb	r1, [r2, #22]
 8024118:	e7ec      	b.n	80240f4 <RadioSetRxGenericConfig+0xa4>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 802411a:	4a68      	ldr	r2, [pc, #416]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 802411c:	21ff      	movs	r1, #255	@ 0xff
 802411e:	7591      	strb	r1, [r2, #22]
 8024120:	e7e8      	b.n	80240f4 <RadioSetRxGenericConfig+0xa4>
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT )
 8024122:	2323      	movs	r3, #35	@ 0x23
 8024124:	5ce2      	ldrb	r2, [r4, r3]
 8024126:	0013      	movs	r3, r2
 8024128:	330f      	adds	r3, #15
 802412a:	b2db      	uxtb	r3, r3
 802412c:	2b01      	cmp	r3, #1
 802412e:	d901      	bls.n	8024134 <RadioSetRxGenericConfig+0xe4>
                && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 8024130:	2a01      	cmp	r2, #1
 8024132:	d132      	bne.n	802419a <RadioSetRxGenericConfig+0x14a>
            ConfigGeneric.rtx = CONFIG_RX;
 8024134:	a801      	add	r0, sp, #4
 8024136:	2300      	movs	r3, #0
 8024138:	7203      	strb	r3, [r0, #8]
            ConfigGeneric.RxConfig = config;
 802413a:	6044      	str	r4, [r0, #4]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 802413c:	4a60      	ldr	r2, [pc, #384]	@ (80242c0 <RadioSetRxGenericConfig+0x270>)
 802413e:	4b61      	ldr	r3, [pc, #388]	@ (80242c4 <RadioSetRxGenericConfig+0x274>)
 8024140:	6819      	ldr	r1, [r3, #0]
 8024142:	f001 fa39 	bl	80255b8 <RFW_Init>
 8024146:	2800      	cmp	r0, #0
 8024148:	d127      	bne.n	802419a <RadioSetRxGenericConfig+0x14a>
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 802414a:	4b5c      	ldr	r3, [pc, #368]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 802414c:	2200      	movs	r2, #0
 802414e:	761a      	strb	r2, [r3, #24]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8024150:	2101      	movs	r1, #1
 8024152:	75d9      	strb	r1, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 8024154:	755a      	strb	r2, [r3, #21]
        RadioStandby( );
 8024156:	f7ff fa8b 	bl	8023670 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 802415a:	2000      	movs	r0, #0
 802415c:	f7ff fda8 	bl	8023cb0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8024160:	4d59      	ldr	r5, [pc, #356]	@ (80242c8 <RadioSetRxGenericConfig+0x278>)
 8024162:	0028      	movs	r0, r5
 8024164:	f000 ffb4 	bl	80250d0 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8024168:	0028      	movs	r0, r5
 802416a:	382a      	subs	r0, #42	@ 0x2a
 802416c:	f001 f828 	bl	80251c0 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 8024170:	a804      	add	r0, sp, #16
 8024172:	f000 fc53 	bl	8024a1c <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 8024176:	8ba0      	ldrh	r0, [r4, #28]
 8024178:	f000 fc24 	bl	80249c4 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 802417c:	8b20      	ldrh	r0, [r4, #24]
 802417e:	f000 fc6b 	bl	8024a58 <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 8024182:	0170      	lsls	r0, r6, #5
 8024184:	1b80      	subs	r0, r0, r6
 8024186:	0080      	lsls	r0, r0, #2
 8024188:	1980      	adds	r0, r0, r6
 802418a:	0180      	lsls	r0, r0, #6
 802418c:	68a1      	ldr	r1, [r4, #8]
 802418e:	f7fb ffc3 	bl	8020118 <__udivsi3>
 8024192:	3d38      	subs	r5, #56	@ 0x38
 8024194:	60a8      	str	r0, [r5, #8]
    return status;
 8024196:	2000      	movs	r0, #0
        break;
 8024198:	e772      	b.n	8024080 <RadioSetRxGenericConfig+0x30>
                return -1;
 802419a:	2001      	movs	r0, #1
 802419c:	4240      	negs	r0, r0
 802419e:	e76f      	b.n	8024080 <RadioSetRxGenericConfig+0x30>
        if( config->lora.PreambleLen == 0 )
 80241a0:	8e23      	ldrh	r3, [r4, #48]	@ 0x30
 80241a2:	2b00      	cmp	r3, #0
 80241a4:	d100      	bne.n	80241a8 <RadioSetRxGenericConfig+0x158>
 80241a6:	e086      	b.n	80242b6 <RadioSetRxGenericConfig+0x266>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 80241a8:	2332      	movs	r3, #50	@ 0x32
 80241aa:	5ce3      	ldrb	r3, [r4, r3]
 80241ac:	2b01      	cmp	r3, #1
 80241ae:	d051      	beq.n	8024254 <RadioSetRxGenericConfig+0x204>
            MaxPayloadLength = 0xFF;
 80241b0:	27ff      	movs	r7, #255	@ 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 80241b2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 80241b4:	1e43      	subs	r3, r0, #1
 80241b6:	4198      	sbcs	r0, r3
 80241b8:	b2c0      	uxtb	r0, r0
 80241ba:	f000 fd99 	bl	8024cf0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 80241be:	b2f0      	uxtb	r0, r6
 80241c0:	f000 fda2 	bl	8024d08 <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80241c4:	4b3d      	ldr	r3, [pc, #244]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 80241c6:	2238      	movs	r2, #56	@ 0x38
 80241c8:	2101      	movs	r1, #1
 80241ca:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 80241cc:	3a0c      	subs	r2, #12
 80241ce:	5ca1      	ldrb	r1, [r4, r2]
 80241d0:	3224      	adds	r2, #36	@ 0x24
 80241d2:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 80241d4:	3a23      	subs	r2, #35	@ 0x23
 80241d6:	5ca1      	ldrb	r1, [r4, r2]
 80241d8:	3224      	adds	r2, #36	@ 0x24
 80241da:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 80241dc:	3a23      	subs	r2, #35	@ 0x23
 80241de:	5ca1      	ldrb	r1, [r4, r2]
 80241e0:	3224      	adds	r2, #36	@ 0x24
 80241e2:	5499      	strb	r1, [r3, r2]
        switch( config->lora.LowDatarateOptimize )
 80241e4:	232f      	movs	r3, #47	@ 0x2f
 80241e6:	5ce3      	ldrb	r3, [r4, r3]
 80241e8:	2b01      	cmp	r3, #1
 80241ea:	d03b      	beq.n	8024264 <RadioSetRxGenericConfig+0x214>
 80241ec:	2b02      	cmp	r3, #2
 80241ee:	d03e      	beq.n	802426e <RadioSetRxGenericConfig+0x21e>
 80241f0:	2b00      	cmp	r3, #0
 80241f2:	d032      	beq.n	802425a <RadioSetRxGenericConfig+0x20a>
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80241f4:	4d31      	ldr	r5, [pc, #196]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 80241f6:	2301      	movs	r3, #1
 80241f8:	73ab      	strb	r3, [r5, #14]
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 80241fa:	8e23      	ldrh	r3, [r4, #48]	@ 0x30
 80241fc:	83ab      	strh	r3, [r5, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 80241fe:	2332      	movs	r3, #50	@ 0x32
 8024200:	5ce3      	ldrb	r3, [r4, r3]
 8024202:	77ab      	strb	r3, [r5, #30]
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8024204:	77ef      	strb	r7, [r5, #31]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 8024206:	2334      	movs	r3, #52	@ 0x34
 8024208:	5ce2      	ldrb	r2, [r4, r3]
 802420a:	3b14      	subs	r3, #20
 802420c:	54ea      	strb	r2, [r5, r3]
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 802420e:	3315      	adds	r3, #21
 8024210:	5ce3      	ldrb	r3, [r4, r3]
 8024212:	2421      	movs	r4, #33	@ 0x21
 8024214:	552b      	strb	r3, [r5, r4]
        RadioStandby( );
 8024216:	f7ff fa2b 	bl	8023670 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 802421a:	2001      	movs	r0, #1
 802421c:	f7ff fd48 	bl	8023cb0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8024220:	0028      	movs	r0, r5
 8024222:	3038      	adds	r0, #56	@ 0x38
 8024224:	f000 ff54 	bl	80250d0 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8024228:	0028      	movs	r0, r5
 802422a:	300e      	adds	r0, #14
 802422c:	f000 ffc8 	bl	80251c0 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8024230:	5d2b      	ldrb	r3, [r5, r4]
 8024232:	2b01      	cmp	r3, #1
 8024234:	d02b      	beq.n	802428e <RadioSetRxGenericConfig+0x23e>
            SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) | ( 1 << 2 ) );
 8024236:	4c25      	ldr	r4, [pc, #148]	@ (80242cc <RadioSetRxGenericConfig+0x27c>)
 8024238:	0020      	movs	r0, r4
 802423a:	f000 fb97 	bl	802496c <SUBGRF_ReadRegister>
 802423e:	2304      	movs	r3, #4
 8024240:	4318      	orrs	r0, r3
 8024242:	b2c1      	uxtb	r1, r0
 8024244:	0020      	movs	r0, r4
 8024246:	f000 fb7d 	bl	8024944 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 802424a:	4b1c      	ldr	r3, [pc, #112]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 802424c:	4a20      	ldr	r2, [pc, #128]	@ (80242d0 <RadioSetRxGenericConfig+0x280>)
 802424e:	609a      	str	r2, [r3, #8]
    return status;
 8024250:	2000      	movs	r0, #0
        break;
 8024252:	e715      	b.n	8024080 <RadioSetRxGenericConfig+0x30>
            MaxPayloadLength = config->lora.MaxPayloadLength;
 8024254:	3332      	adds	r3, #50	@ 0x32
 8024256:	5ce7      	ldrb	r7, [r4, r3]
 8024258:	e7ab      	b.n	80241b2 <RadioSetRxGenericConfig+0x162>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 802425a:	4b18      	ldr	r3, [pc, #96]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 802425c:	3201      	adds	r2, #1
 802425e:	2100      	movs	r1, #0
 8024260:	5499      	strb	r1, [r3, r2]
            break;
 8024262:	e7c7      	b.n	80241f4 <RadioSetRxGenericConfig+0x1a4>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8024264:	4b15      	ldr	r3, [pc, #84]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 8024266:	2253      	movs	r2, #83	@ 0x53
 8024268:	2101      	movs	r1, #1
 802426a:	5499      	strb	r1, [r3, r2]
            break;
 802426c:	e7c2      	b.n	80241f4 <RadioSetRxGenericConfig+0x1a4>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 802426e:	232c      	movs	r3, #44	@ 0x2c
 8024270:	5ce3      	ldrb	r3, [r4, r3]
 8024272:	3b0b      	subs	r3, #11
 8024274:	b2db      	uxtb	r3, r3
 8024276:	2b01      	cmp	r3, #1
 8024278:	d904      	bls.n	8024284 <RadioSetRxGenericConfig+0x234>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 802427a:	4b10      	ldr	r3, [pc, #64]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 802427c:	2253      	movs	r2, #83	@ 0x53
 802427e:	2100      	movs	r1, #0
 8024280:	5499      	strb	r1, [r3, r2]
 8024282:	e7b7      	b.n	80241f4 <RadioSetRxGenericConfig+0x1a4>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8024284:	4b0d      	ldr	r3, [pc, #52]	@ (80242bc <RadioSetRxGenericConfig+0x26c>)
 8024286:	2253      	movs	r2, #83	@ 0x53
 8024288:	2101      	movs	r1, #1
 802428a:	5499      	strb	r1, [r3, r2]
 802428c:	e7b2      	b.n	80241f4 <RadioSetRxGenericConfig+0x1a4>
            SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) & ~( 1 << 2 ) );
 802428e:	4c0f      	ldr	r4, [pc, #60]	@ (80242cc <RadioSetRxGenericConfig+0x27c>)
 8024290:	0020      	movs	r0, r4
 8024292:	f000 fb6b 	bl	802496c <SUBGRF_ReadRegister>
 8024296:	2304      	movs	r3, #4
 8024298:	4398      	bics	r0, r3
 802429a:	b2c1      	uxtb	r1, r0
 802429c:	0020      	movs	r0, r4
 802429e:	f000 fb51 	bl	8024944 <SUBGRF_WriteRegister>
 80242a2:	e7d2      	b.n	802424a <RadioSetRxGenericConfig+0x1fa>
            return -1;
 80242a4:	2001      	movs	r0, #1
 80242a6:	4240      	negs	r0, r0
 80242a8:	e6ea      	b.n	8024080 <RadioSetRxGenericConfig+0x30>
 80242aa:	2001      	movs	r0, #1
 80242ac:	4240      	negs	r0, r0
 80242ae:	e6e7      	b.n	8024080 <RadioSetRxGenericConfig+0x30>
            return -1;
 80242b0:	2001      	movs	r0, #1
 80242b2:	4240      	negs	r0, r0
 80242b4:	e6e4      	b.n	8024080 <RadioSetRxGenericConfig+0x30>
            return -1;
 80242b6:	2001      	movs	r0, #1
 80242b8:	4240      	negs	r0, r0
 80242ba:	e6e1      	b.n	8024080 <RadioSetRxGenericConfig+0x30>
 80242bc:	2000a1bc 	.word	0x2000a1bc
 80242c0:	2000a18c 	.word	0x2000a18c
 80242c4:	2000a218 	.word	0x2000a218
 80242c8:	2000a1f4 	.word	0x2000a1f4
 80242cc:	00000736 	.word	0x00000736
 80242d0:	0000ffff 	.word	0x0000ffff

080242d4 <RadioSetPublicNetwork>:
{
 80242d4:	b510      	push	{r4, lr}
 80242d6:	0004      	movs	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 80242d8:	4b0d      	ldr	r3, [pc, #52]	@ (8024310 <RadioSetPublicNetwork+0x3c>)
 80242da:	7318      	strb	r0, [r3, #12]
 80242dc:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 80242de:	2001      	movs	r0, #1
 80242e0:	f7ff fce6 	bl	8023cb0 <RadioSetModem>
    if( enable == true )
 80242e4:	2c00      	cmp	r4, #0
 80242e6:	d009      	beq.n	80242fc <RadioSetPublicNetwork+0x28>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 80242e8:	20e8      	movs	r0, #232	@ 0xe8
 80242ea:	2134      	movs	r1, #52	@ 0x34
 80242ec:	00c0      	lsls	r0, r0, #3
 80242ee:	f000 fb29 	bl	8024944 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 80242f2:	2144      	movs	r1, #68	@ 0x44
 80242f4:	4807      	ldr	r0, [pc, #28]	@ (8024314 <RadioSetPublicNetwork+0x40>)
 80242f6:	f000 fb25 	bl	8024944 <SUBGRF_WriteRegister>
}
 80242fa:	bd10      	pop	{r4, pc}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 80242fc:	20e8      	movs	r0, #232	@ 0xe8
 80242fe:	2114      	movs	r1, #20
 8024300:	00c0      	lsls	r0, r0, #3
 8024302:	f000 fb1f 	bl	8024944 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8024306:	2124      	movs	r1, #36	@ 0x24
 8024308:	4802      	ldr	r0, [pc, #8]	@ (8024314 <RadioSetPublicNetwork+0x40>)
 802430a:	f000 fb1b 	bl	8024944 <SUBGRF_WriteRegister>
}
 802430e:	e7f4      	b.n	80242fa <RadioSetPublicNetwork+0x26>
 8024310:	2000a1bc 	.word	0x2000a1bc
 8024314:	00000741 	.word	0x00000741

08024318 <RadioSetTxConfig>:
{
 8024318:	b5f0      	push	{r4, r5, r6, r7, lr}
 802431a:	46de      	mov	lr, fp
 802431c:	4657      	mov	r7, sl
 802431e:	464e      	mov	r6, r9
 8024320:	4645      	mov	r5, r8
 8024322:	b5e0      	push	{r5, r6, r7, lr}
 8024324:	b085      	sub	sp, #20
 8024326:	0004      	movs	r4, r0
 8024328:	9100      	str	r1, [sp, #0]
 802432a:	9201      	str	r2, [sp, #4]
 802432c:	001d      	movs	r5, r3
 802432e:	ab0e      	add	r3, sp, #56	@ 0x38
 8024330:	cb80      	ldmia	r3!, {r7}
 8024332:	781b      	ldrb	r3, [r3, #0]
 8024334:	469b      	mov	fp, r3
 8024336:	ab10      	add	r3, sp, #64	@ 0x40
 8024338:	881e      	ldrh	r6, [r3, #0]
 802433a:	ab11      	add	r3, sp, #68	@ 0x44
 802433c:	781b      	ldrb	r3, [r3, #0]
 802433e:	4699      	mov	r9, r3
 8024340:	ab12      	add	r3, sp, #72	@ 0x48
 8024342:	781b      	ldrb	r3, [r3, #0]
 8024344:	4698      	mov	r8, r3
 8024346:	ab15      	add	r3, sp, #84	@ 0x54
 8024348:	781b      	ldrb	r3, [r3, #0]
 802434a:	469a      	mov	sl, r3
    RFW_DeInit();
 802434c:	f001 f937 	bl	80255be <RFW_DeInit>
    switch( modem )
 8024350:	2c01      	cmp	r4, #1
 8024352:	d05e      	beq.n	8024412 <RadioSetTxConfig+0xfa>
 8024354:	2c04      	cmp	r4, #4
 8024356:	d100      	bne.n	802435a <RadioSetTxConfig+0x42>
 8024358:	e0a8      	b.n	80244ac <RadioSetTxConfig+0x194>
 802435a:	2c00      	cmp	r4, #0
 802435c:	d015      	beq.n	802438a <RadioSetTxConfig+0x72>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 802435e:	9800      	ldr	r0, [sp, #0]
 8024360:	f001 f850 	bl	8025404 <SUBGRF_SetRfTxPower>
 8024364:	4c59      	ldr	r4, [pc, #356]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 8024366:	2556      	movs	r5, #86	@ 0x56
 8024368:	5560      	strb	r0, [r4, r5]
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 802436a:	210e      	movs	r1, #14
 802436c:	4858      	ldr	r0, [pc, #352]	@ (80244d0 <RadioSetTxConfig+0x1b8>)
 802436e:	f000 fae9 	bl	8024944 <SUBGRF_WriteRegister>
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 8024372:	5d60      	ldrb	r0, [r4, r5]
 8024374:	f001 f928 	bl	80255c8 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8024378:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 802437a:	6063      	str	r3, [r4, #4]
}
 802437c:	b005      	add	sp, #20
 802437e:	bcf0      	pop	{r4, r5, r6, r7}
 8024380:	46bb      	mov	fp, r7
 8024382:	46b2      	mov	sl, r6
 8024384:	46a9      	mov	r9, r5
 8024386:	46a0      	mov	r8, r4
 8024388:	bdf0      	pop	{r4, r5, r6, r7, pc}
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 802438a:	4c50      	ldr	r4, [pc, #320]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 802438c:	2300      	movs	r3, #0
 802438e:	469a      	mov	sl, r3
 8024390:	3338      	adds	r3, #56	@ 0x38
 8024392:	4652      	mov	r2, sl
 8024394:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8024396:	63e7      	str	r7, [r4, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8024398:	330c      	adds	r3, #12
 802439a:	320b      	adds	r2, #11
 802439c:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 802439e:	0028      	movs	r0, r5
 80243a0:	f001 f8aa 	bl	80254f8 <SUBGRF_GetFskBandwidthRegValue>
 80243a4:	2345      	movs	r3, #69	@ 0x45
 80243a6:	54e0      	strb	r0, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 80243a8:	9b01      	ldr	r3, [sp, #4]
 80243aa:	6423      	str	r3, [r4, #64]	@ 0x40
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80243ac:	4653      	mov	r3, sl
 80243ae:	73a3      	strb	r3, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 80243b0:	00f6      	lsls	r6, r6, #3
 80243b2:	8226      	strh	r6, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 80243b4:	3304      	adds	r3, #4
 80243b6:	74a3      	strb	r3, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 3 << 3 ; // convert byte into bit
 80243b8:	3314      	adds	r3, #20
 80243ba:	74e3      	strb	r3, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 80243bc:	4653      	mov	r3, sl
 80243be:	7523      	strb	r3, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 80243c0:	2301      	movs	r3, #1
 80243c2:	464a      	mov	r2, r9
 80243c4:	405a      	eors	r2, r3
 80243c6:	7562      	strb	r2, [r4, #21]
            if( crcOn == true )
 80243c8:	4643      	mov	r3, r8
 80243ca:	2b00      	cmp	r3, #0
 80243cc:	d01d      	beq.n	802440a <RadioSetTxConfig+0xf2>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 80243ce:	4b3f      	ldr	r3, [pc, #252]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 80243d0:	22f2      	movs	r2, #242	@ 0xf2
 80243d2:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 80243d4:	4c3d      	ldr	r4, [pc, #244]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 80243d6:	2301      	movs	r3, #1
 80243d8:	7623      	strb	r3, [r4, #24]
            RadioStandby( );
 80243da:	f7ff f949 	bl	8023670 <RadioStandby>
            RadioSetModem(  MODEM_FSK  );
 80243de:	2000      	movs	r0, #0
 80243e0:	f7ff fc66 	bl	8023cb0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80243e4:	0020      	movs	r0, r4
 80243e6:	3038      	adds	r0, #56	@ 0x38
 80243e8:	f000 fe72 	bl	80250d0 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80243ec:	0020      	movs	r0, r4
 80243ee:	300e      	adds	r0, #14
 80243f0:	f000 fee6 	bl	80251c0 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 80243f4:	a802      	add	r0, sp, #8
 80243f6:	4b37      	ldr	r3, [pc, #220]	@ (80244d4 <RadioSetTxConfig+0x1bc>)
 80243f8:	0002      	movs	r2, r0
 80243fa:	cb12      	ldmia	r3!, {r1, r4}
 80243fc:	c212      	stmia	r2!, {r1, r4}
 80243fe:	f000 fb0d 	bl	8024a1c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8024402:	4835      	ldr	r0, [pc, #212]	@ (80244d8 <RadioSetTxConfig+0x1c0>)
 8024404:	f000 fade 	bl	80249c4 <SUBGRF_SetWhiteningSeed>
            break;
 8024408:	e7a9      	b.n	802435e <RadioSetTxConfig+0x46>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 802440a:	4b30      	ldr	r3, [pc, #192]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 802440c:	2201      	movs	r2, #1
 802440e:	75da      	strb	r2, [r3, #23]
 8024410:	e7e0      	b.n	80243d4 <RadioSetTxConfig+0xbc>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8024412:	4a2e      	ldr	r2, [pc, #184]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 8024414:	2338      	movs	r3, #56	@ 0x38
 8024416:	2101      	movs	r1, #1
 8024418:	54d1      	strb	r1, [r2, r3]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 802441a:	b2fb      	uxtb	r3, r7
 802441c:	314f      	adds	r1, #79	@ 0x4f
 802441e:	5453      	strb	r3, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8024420:	492e      	ldr	r1, [pc, #184]	@ (80244dc <RadioSetTxConfig+0x1c4>)
 8024422:	5d48      	ldrb	r0, [r1, r5]
 8024424:	2151      	movs	r1, #81	@ 0x51
 8024426:	5450      	strb	r0, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 8024428:	3101      	adds	r1, #1
 802442a:	4658      	mov	r0, fp
 802442c:	5450      	strb	r0, [r2, r1]
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 802442e:	2d00      	cmp	r5, #0
 8024430:	d103      	bne.n	802443a <RadioSetTxConfig+0x122>
 8024432:	003a      	movs	r2, r7
 8024434:	3a0b      	subs	r2, #11
 8024436:	2a01      	cmp	r2, #1
 8024438:	d92a      	bls.n	8024490 <RadioSetTxConfig+0x178>
 802443a:	2d01      	cmp	r5, #1
 802443c:	d026      	beq.n	802448c <RadioSetTxConfig+0x174>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 802443e:	4a23      	ldr	r2, [pc, #140]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 8024440:	2153      	movs	r1, #83	@ 0x53
 8024442:	2000      	movs	r0, #0
 8024444:	5450      	strb	r0, [r2, r1]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8024446:	4a21      	ldr	r2, [pc, #132]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 8024448:	2101      	movs	r1, #1
 802444a:	7391      	strb	r1, [r2, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 802444c:	3b05      	subs	r3, #5
 802444e:	b2db      	uxtb	r3, r3
 8024450:	2b01      	cmp	r3, #1
 8024452:	d922      	bls.n	802449a <RadioSetTxConfig+0x182>
                SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8024454:	4b1d      	ldr	r3, [pc, #116]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 8024456:	839e      	strh	r6, [r3, #28]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8024458:	4c1c      	ldr	r4, [pc, #112]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 802445a:	464b      	mov	r3, r9
 802445c:	77a3      	strb	r3, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 802445e:	4b20      	ldr	r3, [pc, #128]	@ (80244e0 <RadioSetTxConfig+0x1c8>)
 8024460:	781b      	ldrb	r3, [r3, #0]
 8024462:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8024464:	2320      	movs	r3, #32
 8024466:	4642      	mov	r2, r8
 8024468:	54e2      	strb	r2, [r4, r3]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 802446a:	3301      	adds	r3, #1
 802446c:	4652      	mov	r2, sl
 802446e:	54e2      	strb	r2, [r4, r3]
            RadioStandby( );
 8024470:	f7ff f8fe 	bl	8023670 <RadioStandby>
            RadioSetModem( MODEM_LORA );
 8024474:	2001      	movs	r0, #1
 8024476:	f7ff fc1b 	bl	8023cb0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 802447a:	0020      	movs	r0, r4
 802447c:	3038      	adds	r0, #56	@ 0x38
 802447e:	f000 fe27 	bl	80250d0 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8024482:	0020      	movs	r0, r4
 8024484:	300e      	adds	r0, #14
 8024486:	f000 fe9b 	bl	80251c0 <SUBGRF_SetPacketParams>
            break;
 802448a:	e768      	b.n	802435e <RadioSetTxConfig+0x46>
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 802448c:	2f0c      	cmp	r7, #12
 802448e:	d1d6      	bne.n	802443e <RadioSetTxConfig+0x126>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
 8024490:	4a0e      	ldr	r2, [pc, #56]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 8024492:	2153      	movs	r1, #83	@ 0x53
 8024494:	2001      	movs	r0, #1
 8024496:	5450      	strb	r0, [r2, r1]
 8024498:	e7d5      	b.n	8024446 <RadioSetTxConfig+0x12e>
                if( preambleLen < 12 )
 802449a:	2e0b      	cmp	r6, #11
 802449c:	d803      	bhi.n	80244a6 <RadioSetTxConfig+0x18e>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 802449e:	0013      	movs	r3, r2
 80244a0:	220c      	movs	r2, #12
 80244a2:	839a      	strh	r2, [r3, #28]
 80244a4:	e7d8      	b.n	8024458 <RadioSetTxConfig+0x140>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 80244a6:	4b09      	ldr	r3, [pc, #36]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 80244a8:	839e      	strh	r6, [r3, #28]
 80244aa:	e7d5      	b.n	8024458 <RadioSetTxConfig+0x140>
            RadioSetModem(MODEM_SIGFOX_TX);
 80244ac:	2004      	movs	r0, #4
 80244ae:	f7ff fbff 	bl	8023cb0 <RadioSetModem>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 80244b2:	4806      	ldr	r0, [pc, #24]	@ (80244cc <RadioSetTxConfig+0x1b4>)
 80244b4:	2338      	movs	r3, #56	@ 0x38
 80244b6:	2202      	movs	r2, #2
 80244b8:	54c2      	strb	r2, [r0, r3]
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 80244ba:	6487      	str	r7, [r0, #72]	@ 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 80244bc:	3314      	adds	r3, #20
 80244be:	3214      	adds	r2, #20
 80244c0:	54c2      	strb	r2, [r0, r3]
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80244c2:	3038      	adds	r0, #56	@ 0x38
 80244c4:	f000 fe04 	bl	80250d0 <SUBGRF_SetModulationParams>
            break;
 80244c8:	e749      	b.n	802435e <RadioSetTxConfig+0x46>
 80244ca:	46c0      	nop			@ (mov r8, r8)
 80244cc:	2000a1bc 	.word	0x2000a1bc
 80244d0:	0000091f 	.word	0x0000091f
 80244d4:	08026308 	.word	0x08026308
 80244d8:	000001ff 	.word	0x000001ff
 80244dc:	080266c4 	.word	0x080266c4
 80244e0:	2000a00c 	.word	0x2000a00c

080244e4 <RadioSetRxConfig>:
{
 80244e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80244e6:	46de      	mov	lr, fp
 80244e8:	4657      	mov	r7, sl
 80244ea:	464e      	mov	r6, r9
 80244ec:	4645      	mov	r5, r8
 80244ee:	b5e0      	push	{r5, r6, r7, lr}
 80244f0:	b089      	sub	sp, #36	@ 0x24
 80244f2:	0004      	movs	r4, r0
 80244f4:	9102      	str	r1, [sp, #8]
 80244f6:	9201      	str	r2, [sp, #4]
 80244f8:	9303      	str	r3, [sp, #12]
 80244fa:	ab13      	add	r3, sp, #76	@ 0x4c
 80244fc:	881b      	ldrh	r3, [r3, #0]
 80244fe:	4699      	mov	r9, r3
 8024500:	ab14      	add	r3, sp, #80	@ 0x50
 8024502:	881f      	ldrh	r7, [r3, #0]
 8024504:	ab15      	add	r3, sp, #84	@ 0x54
 8024506:	781b      	ldrb	r3, [r3, #0]
 8024508:	469a      	mov	sl, r3
 802450a:	ab16      	add	r3, sp, #88	@ 0x58
 802450c:	781b      	ldrb	r3, [r3, #0]
 802450e:	469b      	mov	fp, r3
 8024510:	ab17      	add	r3, sp, #92	@ 0x5c
 8024512:	781d      	ldrb	r5, [r3, #0]
 8024514:	ab1a      	add	r3, sp, #104	@ 0x68
 8024516:	781b      	ldrb	r3, [r3, #0]
 8024518:	4698      	mov	r8, r3
 802451a:	ab1b      	add	r3, sp, #108	@ 0x6c
 802451c:	781e      	ldrb	r6, [r3, #0]
    SubgRf.RxContinuous = rxContinuous;
 802451e:	4bb0      	ldr	r3, [pc, #704]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 8024520:	705e      	strb	r6, [r3, #1]
    RFW_DeInit();
 8024522:	f001 f84c 	bl	80255be <RFW_DeInit>
    if( rxContinuous == true )
 8024526:	2e00      	cmp	r6, #0
 8024528:	d000      	beq.n	802452c <RadioSetRxConfig+0x48>
        symbTimeout = 0;
 802452a:	2700      	movs	r7, #0
    if( fixLen == true )
 802452c:	4653      	mov	r3, sl
 802452e:	2b00      	cmp	r3, #0
 8024530:	d011      	beq.n	8024556 <RadioSetRxConfig+0x72>
        MaxPayloadLength = payloadLen;
 8024532:	4bac      	ldr	r3, [pc, #688]	@ (80247e4 <RadioSetRxConfig+0x300>)
 8024534:	465a      	mov	r2, fp
 8024536:	701a      	strb	r2, [r3, #0]
    switch( modem )
 8024538:	2c01      	cmp	r4, #1
 802453a:	d100      	bne.n	802453e <RadioSetRxConfig+0x5a>
 802453c:	e0d2      	b.n	80246e4 <RadioSetRxConfig+0x200>
 802453e:	2c05      	cmp	r4, #5
 8024540:	d00d      	beq.n	802455e <RadioSetRxConfig+0x7a>
 8024542:	2c00      	cmp	r4, #0
 8024544:	d100      	bne.n	8024548 <RadioSetRxConfig+0x64>
 8024546:	e07f      	b.n	8024648 <RadioSetRxConfig+0x164>
}
 8024548:	b009      	add	sp, #36	@ 0x24
 802454a:	bcf0      	pop	{r4, r5, r6, r7}
 802454c:	46bb      	mov	fp, r7
 802454e:	46b2      	mov	sl, r6
 8024550:	46a9      	mov	r9, r5
 8024552:	46a0      	mov	r8, r4
 8024554:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MaxPayloadLength = 0xFF;
 8024556:	4ba3      	ldr	r3, [pc, #652]	@ (80247e4 <RadioSetRxConfig+0x300>)
 8024558:	22ff      	movs	r2, #255	@ 0xff
 802455a:	701a      	strb	r2, [r3, #0]
 802455c:	e7ec      	b.n	8024538 <RadioSetRxConfig+0x54>
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 802455e:	2001      	movs	r0, #1
 8024560:	f000 fbc6 	bl	8024cf0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8024564:	4c9e      	ldr	r4, [pc, #632]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 8024566:	2500      	movs	r5, #0
 8024568:	2338      	movs	r3, #56	@ 0x38
 802456a:	54e5      	strb	r5, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 802456c:	9b01      	ldr	r3, [sp, #4]
 802456e:	63e3      	str	r3, [r4, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8024570:	2344      	movs	r3, #68	@ 0x44
 8024572:	2209      	movs	r2, #9
 8024574:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 8024576:	23c8      	movs	r3, #200	@ 0xc8
 8024578:	009b      	lsls	r3, r3, #2
 802457a:	6423      	str	r3, [r4, #64]	@ 0x40
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 802457c:	9802      	ldr	r0, [sp, #8]
 802457e:	f000 ffbb 	bl	80254f8 <SUBGRF_GetFskBandwidthRegValue>
 8024582:	2345      	movs	r3, #69	@ 0x45
 8024584:	54e0      	strb	r0, [r4, r3]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8024586:	73a5      	strb	r5, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8024588:	464a      	mov	r2, r9
 802458a:	00d3      	lsls	r3, r2, #3
 802458c:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 802458e:	74a5      	strb	r5, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 2 << 3; // convert byte into bit
 8024590:	2610      	movs	r6, #16
 8024592:	74e6      	strb	r6, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8024594:	7525      	strb	r5, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = RADIO_PACKET_FIXED_LENGTH;
 8024596:	7565      	strb	r5, [r4, #21]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8024598:	4b92      	ldr	r3, [pc, #584]	@ (80247e4 <RadioSetRxConfig+0x300>)
 802459a:	781b      	ldrb	r3, [r3, #0]
 802459c:	75a3      	strb	r3, [r4, #22]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 802459e:	2301      	movs	r3, #1
 80245a0:	75e3      	strb	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 80245a2:	7625      	strb	r5, [r4, #24]
            RadioSetModem( MODEM_SIGFOX_RX );
 80245a4:	2005      	movs	r0, #5
 80245a6:	f7ff fb83 	bl	8023cb0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80245aa:	0020      	movs	r0, r4
 80245ac:	3038      	adds	r0, #56	@ 0x38
 80245ae:	f000 fd8f 	bl	80250d0 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80245b2:	0020      	movs	r0, r4
 80245b4:	300e      	adds	r0, #14
 80245b6:	f000 fe03 	bl	80251c0 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 80245ba:	a804      	add	r0, sp, #16
 80245bc:	4b8a      	ldr	r3, [pc, #552]	@ (80247e8 <RadioSetRxConfig+0x304>)
 80245be:	0002      	movs	r2, r0
 80245c0:	cb22      	ldmia	r3!, {r1, r5}
 80245c2:	c222      	stmia	r2!, {r1, r5}
 80245c4:	f000 fa2a 	bl	8024a1c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 80245c8:	4888      	ldr	r0, [pc, #544]	@ (80247ec <RadioSetRxConfig+0x308>)
 80245ca:	f000 f9fb 	bl	80249c4 <SUBGRF_SetWhiteningSeed>
            modReg= RadioRead(SUBGHZ_AGCGFORSTCFGR);
 80245ce:	4d88      	ldr	r5, [pc, #544]	@ (80247f0 <RadioSetRxConfig+0x30c>)
 80245d0:	0028      	movs	r0, r5
 80245d2:	f7fe ffc3 	bl	802355c <RadioRead>
            modReg&=RADIO_BIT_MASK(4);
 80245d6:	43b0      	bics	r0, r6
 80245d8:	b2c1      	uxtb	r1, r0
            RadioWrite(SUBGHZ_AGCGFORSTCFGR, modReg);
 80245da:	0028      	movs	r0, r5
 80245dc:	f7fe ffc2 	bl	8023564 <RadioWrite>
            RadioWrite(SUBGHZ_AGCGFORSTPOWTHR, 0x4 );
 80245e0:	2104      	movs	r1, #4
 80245e2:	4884      	ldr	r0, [pc, #528]	@ (80247f4 <RadioSetRxConfig+0x310>)
 80245e4:	f7fe ffbe 	bl	8023564 <RadioWrite>
            modReg= RadioRead(SUBGHZ_AGCRSSICTL0R);
 80245e8:	4e83      	ldr	r6, [pc, #524]	@ (80247f8 <RadioSetRxConfig+0x314>)
 80245ea:	0030      	movs	r0, r6
 80245ec:	f7fe ffb6 	bl	802355c <RadioRead>
            modReg&=( RADIO_BIT_MASK(2) & RADIO_BIT_MASK(3) & RADIO_BIT_MASK(4) );
 80245f0:	231c      	movs	r3, #28
 80245f2:	4398      	bics	r0, r3
 80245f4:	b2c1      	uxtb	r1, r0
            RadioWrite(SUBGHZ_AGCRSSICTL0R, (modReg| (0x1<<3) ) );
 80245f6:	2308      	movs	r3, #8
 80245f8:	4319      	orrs	r1, r3
 80245fa:	b2c9      	uxtb	r1, r1
 80245fc:	0030      	movs	r0, r6
 80245fe:	f7fe ffb1 	bl	8023564 <RadioWrite>
            modReg= RadioRead(SUBGHZ_GAFCR);
 8024602:	4e7e      	ldr	r6, [pc, #504]	@ (80247fc <RadioSetRxConfig+0x318>)
 8024604:	0030      	movs	r0, r6
 8024606:	f7fe ffa9 	bl	802355c <RadioRead>
            modReg&=( RADIO_BIT_MASK(3) & RADIO_BIT_MASK(4) );
 802460a:	2318      	movs	r3, #24
 802460c:	4398      	bics	r0, r3
 802460e:	b2c1      	uxtb	r1, r0
            RadioWrite(SUBGHZ_GAFCR, (modReg| (0x3<<3) ));
 8024610:	4319      	orrs	r1, r3
 8024612:	b2c9      	uxtb	r1, r1
 8024614:	0030      	movs	r0, r6
 8024616:	f7fe ffa5 	bl	8023564 <RadioWrite>
            modReg= RadioRead(SUBGHZ_GBSYNCR);
 802461a:	4e79      	ldr	r6, [pc, #484]	@ (8024800 <RadioSetRxConfig+0x31c>)
 802461c:	0030      	movs	r0, r6
 802461e:	f7fe ff9d 	bl	802355c <RadioRead>
            modReg&=( RADIO_BIT_MASK(4) & RADIO_BIT_MASK(5) & RADIO_BIT_MASK(6) );
 8024622:	2370      	movs	r3, #112	@ 0x70
 8024624:	4398      	bics	r0, r3
 8024626:	b2c1      	uxtb	r1, r0
            RadioWrite(SUBGHZ_GBSYNCR, (modReg| (0x5<<4) ));
 8024628:	2350      	movs	r3, #80	@ 0x50
 802462a:	4319      	orrs	r1, r3
 802462c:	b2c9      	uxtb	r1, r1
 802462e:	0030      	movs	r0, r6
 8024630:	f7fe ff98 	bl	8023564 <RadioWrite>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8024634:	0178      	lsls	r0, r7, #5
 8024636:	1bc0      	subs	r0, r0, r7
 8024638:	0080      	lsls	r0, r0, #2
 802463a:	19c0      	adds	r0, r0, r7
 802463c:	0180      	lsls	r0, r0, #6
 802463e:	9901      	ldr	r1, [sp, #4]
 8024640:	f7fb fd6a 	bl	8020118 <__udivsi3>
 8024644:	60a0      	str	r0, [r4, #8]
            break;
 8024646:	e77f      	b.n	8024548 <RadioSetRxConfig+0x64>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8024648:	2000      	movs	r0, #0
 802464a:	f000 fb51 	bl	8024cf0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 802464e:	4c64      	ldr	r4, [pc, #400]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 8024650:	2600      	movs	r6, #0
 8024652:	2338      	movs	r3, #56	@ 0x38
 8024654:	54e6      	strb	r6, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8024656:	9b01      	ldr	r3, [sp, #4]
 8024658:	63e3      	str	r3, [r4, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 802465a:	2344      	movs	r3, #68	@ 0x44
 802465c:	220b      	movs	r2, #11
 802465e:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8024660:	9802      	ldr	r0, [sp, #8]
 8024662:	f000 ff49 	bl	80254f8 <SUBGRF_GetFskBandwidthRegValue>
 8024666:	2345      	movs	r3, #69	@ 0x45
 8024668:	54e0      	strb	r0, [r4, r3]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 802466a:	73a6      	strb	r6, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 802466c:	464b      	mov	r3, r9
 802466e:	00db      	lsls	r3, r3, #3
 8024670:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8024672:	2304      	movs	r3, #4
 8024674:	74a3      	strb	r3, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 3 << 3; // convert byte into bit
 8024676:	3314      	adds	r3, #20
 8024678:	74e3      	strb	r3, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 802467a:	7526      	strb	r6, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 802467c:	2301      	movs	r3, #1
 802467e:	4652      	mov	r2, sl
 8024680:	405a      	eors	r2, r3
 8024682:	7562      	strb	r2, [r4, #21]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8024684:	4b57      	ldr	r3, [pc, #348]	@ (80247e4 <RadioSetRxConfig+0x300>)
 8024686:	781b      	ldrb	r3, [r3, #0]
 8024688:	75a3      	strb	r3, [r4, #22]
            if( crcOn == true )
 802468a:	2d00      	cmp	r5, #0
 802468c:	d026      	beq.n	80246dc <RadioSetRxConfig+0x1f8>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 802468e:	4b54      	ldr	r3, [pc, #336]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 8024690:	22f2      	movs	r2, #242	@ 0xf2
 8024692:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8024694:	4c52      	ldr	r4, [pc, #328]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 8024696:	2301      	movs	r3, #1
 8024698:	7623      	strb	r3, [r4, #24]
            RadioStandby( );
 802469a:	f7fe ffe9 	bl	8023670 <RadioStandby>
            RadioSetModem( MODEM_FSK );
 802469e:	2000      	movs	r0, #0
 80246a0:	f7ff fb06 	bl	8023cb0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80246a4:	0020      	movs	r0, r4
 80246a6:	3038      	adds	r0, #56	@ 0x38
 80246a8:	f000 fd12 	bl	80250d0 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80246ac:	0020      	movs	r0, r4
 80246ae:	300e      	adds	r0, #14
 80246b0:	f000 fd86 	bl	80251c0 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 80246b4:	a806      	add	r0, sp, #24
 80246b6:	4b53      	ldr	r3, [pc, #332]	@ (8024804 <RadioSetRxConfig+0x320>)
 80246b8:	0002      	movs	r2, r0
 80246ba:	cb42      	ldmia	r3!, {r1, r6}
 80246bc:	c242      	stmia	r2!, {r1, r6}
 80246be:	f000 f9ad 	bl	8024a1c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 80246c2:	484a      	ldr	r0, [pc, #296]	@ (80247ec <RadioSetRxConfig+0x308>)
 80246c4:	f000 f97e 	bl	80249c4 <SUBGRF_SetWhiteningSeed>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 80246c8:	0178      	lsls	r0, r7, #5
 80246ca:	1bc0      	subs	r0, r0, r7
 80246cc:	0080      	lsls	r0, r0, #2
 80246ce:	19c0      	adds	r0, r0, r7
 80246d0:	0180      	lsls	r0, r0, #6
 80246d2:	9901      	ldr	r1, [sp, #4]
 80246d4:	f7fb fd20 	bl	8020118 <__udivsi3>
 80246d8:	60a0      	str	r0, [r4, #8]
            break;
 80246da:	e735      	b.n	8024548 <RadioSetRxConfig+0x64>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 80246dc:	4b40      	ldr	r3, [pc, #256]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 80246de:	2201      	movs	r2, #1
 80246e0:	75da      	strb	r2, [r3, #23]
 80246e2:	e7d7      	b.n	8024694 <RadioSetRxConfig+0x1b0>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 80246e4:	2000      	movs	r0, #0
 80246e6:	f000 fb03 	bl	8024cf0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80246ea:	4a3d      	ldr	r2, [pc, #244]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 80246ec:	2338      	movs	r3, #56	@ 0x38
 80246ee:	2101      	movs	r1, #1
 80246f0:	54d1      	strb	r1, [r2, r3]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 80246f2:	9e01      	ldr	r6, [sp, #4]
 80246f4:	b2f3      	uxtb	r3, r6
 80246f6:	314f      	adds	r1, #79	@ 0x4f
 80246f8:	5453      	strb	r3, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 80246fa:	4943      	ldr	r1, [pc, #268]	@ (8024808 <RadioSetRxConfig+0x324>)
 80246fc:	9c02      	ldr	r4, [sp, #8]
 80246fe:	5d08      	ldrb	r0, [r1, r4]
 8024700:	2151      	movs	r1, #81	@ 0x51
 8024702:	5450      	strb	r0, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8024704:	3101      	adds	r1, #1
 8024706:	9803      	ldr	r0, [sp, #12]
 8024708:	5450      	strb	r0, [r2, r1]
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 802470a:	2c00      	cmp	r4, #0
 802470c:	d103      	bne.n	8024716 <RadioSetRxConfig+0x232>
 802470e:	0032      	movs	r2, r6
 8024710:	3a0b      	subs	r2, #11
 8024712:	2a01      	cmp	r2, #1
 8024714:	d948      	bls.n	80247a8 <RadioSetRxConfig+0x2c4>
 8024716:	9a02      	ldr	r2, [sp, #8]
 8024718:	2a01      	cmp	r2, #1
 802471a:	d042      	beq.n	80247a2 <RadioSetRxConfig+0x2be>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 802471c:	4a30      	ldr	r2, [pc, #192]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 802471e:	2153      	movs	r1, #83	@ 0x53
 8024720:	2000      	movs	r0, #0
 8024722:	5450      	strb	r0, [r2, r1]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8024724:	4a2e      	ldr	r2, [pc, #184]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 8024726:	2101      	movs	r1, #1
 8024728:	7391      	strb	r1, [r2, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 802472a:	3b05      	subs	r3, #5
 802472c:	b2db      	uxtb	r3, r3
 802472e:	2b01      	cmp	r3, #1
 8024730:	d93f      	bls.n	80247b2 <RadioSetRxConfig+0x2ce>
                SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8024732:	4b2b      	ldr	r3, [pc, #172]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 8024734:	464a      	mov	r2, r9
 8024736:	839a      	strh	r2, [r3, #28]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8024738:	4c29      	ldr	r4, [pc, #164]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 802473a:	4653      	mov	r3, sl
 802473c:	77a3      	strb	r3, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 802473e:	4b29      	ldr	r3, [pc, #164]	@ (80247e4 <RadioSetRxConfig+0x300>)
 8024740:	781b      	ldrb	r3, [r3, #0]
 8024742:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8024744:	2320      	movs	r3, #32
 8024746:	54e5      	strb	r5, [r4, r3]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8024748:	2521      	movs	r5, #33	@ 0x21
 802474a:	4643      	mov	r3, r8
 802474c:	5563      	strb	r3, [r4, r5]
            RadioStandby( );
 802474e:	f7fe ff8f 	bl	8023670 <RadioStandby>
            RadioSetModem( MODEM_LORA );
 8024752:	2001      	movs	r0, #1
 8024754:	f7ff faac 	bl	8023cb0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8024758:	0020      	movs	r0, r4
 802475a:	3038      	adds	r0, #56	@ 0x38
 802475c:	f000 fcb8 	bl	80250d0 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8024760:	0020      	movs	r0, r4
 8024762:	300e      	adds	r0, #14
 8024764:	f000 fd2c 	bl	80251c0 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8024768:	b2f8      	uxtb	r0, r7
 802476a:	f000 facd 	bl	8024d08 <SUBGRF_SetLoRaSymbNumTimeout>
            SUBGRF_WriteRegister(SUBGHZ_AGCCFG,SUBGRF_ReadRegister(SUBGHZ_AGCCFG)&0x1);
 802476e:	4e27      	ldr	r6, [pc, #156]	@ (802480c <RadioSetRxConfig+0x328>)
 8024770:	0030      	movs	r0, r6
 8024772:	f000 f8fb 	bl	802496c <SUBGRF_ReadRegister>
 8024776:	2101      	movs	r1, #1
 8024778:	4001      	ands	r1, r0
 802477a:	0030      	movs	r0, r6
 802477c:	f000 f8e2 	bl	8024944 <SUBGRF_WriteRegister>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8024780:	5d63      	ldrb	r3, [r4, r5]
 8024782:	2b01      	cmp	r3, #1
 8024784:	d020      	beq.n	80247c8 <RadioSetRxConfig+0x2e4>
                SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) | ( 1 << 2 ) );
 8024786:	4c22      	ldr	r4, [pc, #136]	@ (8024810 <RadioSetRxConfig+0x32c>)
 8024788:	0020      	movs	r0, r4
 802478a:	f000 f8ef 	bl	802496c <SUBGRF_ReadRegister>
 802478e:	2304      	movs	r3, #4
 8024790:	4318      	orrs	r0, r3
 8024792:	b2c1      	uxtb	r1, r0
 8024794:	0020      	movs	r0, r4
 8024796:	f000 f8d5 	bl	8024944 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 802479a:	4b11      	ldr	r3, [pc, #68]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 802479c:	4a1d      	ldr	r2, [pc, #116]	@ (8024814 <RadioSetRxConfig+0x330>)
 802479e:	609a      	str	r2, [r3, #8]
}
 80247a0:	e6d2      	b.n	8024548 <RadioSetRxConfig+0x64>
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 80247a2:	9a01      	ldr	r2, [sp, #4]
 80247a4:	2a0c      	cmp	r2, #12
 80247a6:	d1b9      	bne.n	802471c <RadioSetRxConfig+0x238>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
 80247a8:	4a0d      	ldr	r2, [pc, #52]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 80247aa:	2153      	movs	r1, #83	@ 0x53
 80247ac:	2001      	movs	r0, #1
 80247ae:	5450      	strb	r0, [r2, r1]
 80247b0:	e7b8      	b.n	8024724 <RadioSetRxConfig+0x240>
                if( preambleLen < 12 )
 80247b2:	464b      	mov	r3, r9
 80247b4:	2b0b      	cmp	r3, #11
 80247b6:	d803      	bhi.n	80247c0 <RadioSetRxConfig+0x2dc>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 80247b8:	0013      	movs	r3, r2
 80247ba:	220c      	movs	r2, #12
 80247bc:	839a      	strh	r2, [r3, #28]
 80247be:	e7bb      	b.n	8024738 <RadioSetRxConfig+0x254>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 80247c0:	4b07      	ldr	r3, [pc, #28]	@ (80247e0 <RadioSetRxConfig+0x2fc>)
 80247c2:	464a      	mov	r2, r9
 80247c4:	839a      	strh	r2, [r3, #28]
 80247c6:	e7b7      	b.n	8024738 <RadioSetRxConfig+0x254>
                SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) & ~( 1 << 2 ) );
 80247c8:	4c11      	ldr	r4, [pc, #68]	@ (8024810 <RadioSetRxConfig+0x32c>)
 80247ca:	0020      	movs	r0, r4
 80247cc:	f000 f8ce 	bl	802496c <SUBGRF_ReadRegister>
 80247d0:	2304      	movs	r3, #4
 80247d2:	4398      	bics	r0, r3
 80247d4:	b2c1      	uxtb	r1, r0
 80247d6:	0020      	movs	r0, r4
 80247d8:	f000 f8b4 	bl	8024944 <SUBGRF_WriteRegister>
 80247dc:	e7dd      	b.n	802479a <RadioSetRxConfig+0x2b6>
 80247de:	46c0      	nop			@ (mov r8, r8)
 80247e0:	2000a1bc 	.word	0x2000a1bc
 80247e4:	2000a00c 	.word	0x2000a00c
 80247e8:	08026310 	.word	0x08026310
 80247ec:	000001ff 	.word	0x000001ff
 80247f0:	000008b8 	.word	0x000008b8
 80247f4:	000008b9 	.word	0x000008b9
 80247f8:	0000089b 	.word	0x0000089b
 80247fc:	000006d1 	.word	0x000006d1
 8024800:	000006ac 	.word	0x000006ac
 8024804:	08026308 	.word	0x08026308
 8024808:	080266c4 	.word	0x080266c4
 802480c:	000008a3 	.word	0x000008a3
 8024810:	00000736 	.word	0x00000736
 8024814:	0000ffff 	.word	0x0000ffff

08024818 <RadioIsChannelFree>:
{
 8024818:	b5f0      	push	{r4, r5, r6, r7, lr}
 802481a:	b08b      	sub	sp, #44	@ 0x2c
 802481c:	0007      	movs	r7, r0
 802481e:	000c      	movs	r4, r1
 8024820:	0016      	movs	r6, r2
 8024822:	001d      	movs	r5, r3
    RadioStandby( );
 8024824:	f7fe ff24 	bl	8023670 <RadioStandby>
    RadioSetModem( MODEM_FSK );
 8024828:	2000      	movs	r0, #0
 802482a:	f7ff fa41 	bl	8023cb0 <RadioSetModem>
    RadioSetChannel( freq );
 802482e:	0038      	movs	r0, r7
 8024830:	f7ff f900 	bl	8023a34 <RadioSetChannel>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 8024834:	2296      	movs	r2, #150	@ 0x96
 8024836:	2301      	movs	r3, #1
 8024838:	9309      	str	r3, [sp, #36]	@ 0x24
 802483a:	2300      	movs	r3, #0
 802483c:	9308      	str	r3, [sp, #32]
 802483e:	9307      	str	r3, [sp, #28]
 8024840:	9306      	str	r3, [sp, #24]
 8024842:	9305      	str	r3, [sp, #20]
 8024844:	9304      	str	r3, [sp, #16]
 8024846:	9303      	str	r3, [sp, #12]
 8024848:	9302      	str	r3, [sp, #8]
 802484a:	3303      	adds	r3, #3
 802484c:	9301      	str	r3, [sp, #4]
 802484e:	9400      	str	r4, [sp, #0]
 8024850:	2300      	movs	r3, #0
 8024852:	0092      	lsls	r2, r2, #2
 8024854:	0021      	movs	r1, r4
 8024856:	2000      	movs	r0, #0
 8024858:	f7ff fe44 	bl	80244e4 <RadioSetRxConfig>
    RadioRx( 0 );
 802485c:	2000      	movs	r0, #0
 802485e:	f7ff f901 	bl	8023a64 <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8024862:	f7ff f8af 	bl	80239c4 <RadioGetWakeupTime>
 8024866:	f7fc f97b 	bl	8020b60 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 802486a:	f001 fa3f 	bl	8025cec <UTIL_TIMER_GetCurrentTime>
 802486e:	0004      	movs	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8024870:	0020      	movs	r0, r4
 8024872:	f001 fa45 	bl	8025d00 <UTIL_TIMER_GetElapsedTime>
 8024876:	42a8      	cmp	r0, r5
 8024878:	d206      	bcs.n	8024888 <RadioIsChannelFree+0x70>
        rssi = RadioRssi( MODEM_FSK );
 802487a:	2000      	movs	r0, #0
 802487c:	f7ff f8af 	bl	80239de <RadioRssi>
        if( rssi > rssiThresh )
 8024880:	42b0      	cmp	r0, r6
 8024882:	ddf5      	ble.n	8024870 <RadioIsChannelFree+0x58>
            status = false;
 8024884:	2400      	movs	r4, #0
 8024886:	e000      	b.n	802488a <RadioIsChannelFree+0x72>
    bool status = true;
 8024888:	2401      	movs	r4, #1
    RadioStandby( );
 802488a:	f7fe fef1 	bl	8023670 <RadioStandby>
}
 802488e:	0020      	movs	r0, r4
 8024890:	b00b      	add	sp, #44	@ 0x2c
 8024892:	bdf0      	pop	{r4, r5, r6, r7, pc}

08024894 <RadioInit>:
{
 8024894:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024896:	b083      	sub	sp, #12
    RadioEvents = events;
 8024898:	4b1c      	ldr	r3, [pc, #112]	@ (802490c <RadioInit+0x78>)
 802489a:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 802489c:	4d1c      	ldr	r5, [pc, #112]	@ (8024910 <RadioInit+0x7c>)
 802489e:	2400      	movs	r4, #0
 80248a0:	706c      	strb	r4, [r5, #1]
    SubgRf.TxTimeout = 0;
 80248a2:	606c      	str	r4, [r5, #4]
    SubgRf.RxTimeout = 0;
 80248a4:	60ac      	str	r4, [r5, #8]
    SubgRf.RxDcPreambleDetectTimeout = 0;
 80248a6:	65ac      	str	r4, [r5, #88]	@ 0x58
    SUBGRF_Init( RadioOnDioIrq );
 80248a8:	481a      	ldr	r0, [pc, #104]	@ (8024914 <RadioInit+0x80>)
 80248aa:	f000 fb05 	bl	8024eb8 <SUBGRF_Init>
    SubgRf.PublicNetwork.Current = false;
 80248ae:	736c      	strb	r4, [r5, #13]
    SubgRf.PublicNetwork.Previous = false;
 80248b0:	732c      	strb	r4, [r5, #12]
    SUBGRF_SetRegulatorMode( );
 80248b2:	f000 fa49 	bl	8024d48 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 80248b6:	2100      	movs	r1, #0
 80248b8:	2000      	movs	r0, #0
 80248ba:	f000 fcef 	bl	802529c <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams( RFO_LP, 0, RADIO_RAMP_200_US );
 80248be:	2204      	movs	r2, #4
 80248c0:	2100      	movs	r1, #0
 80248c2:	2001      	movs	r0, #1
 80248c4:	f000 fb76 	bl	8024fb4 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 80248c8:	4813      	ldr	r0, [pc, #76]	@ (8024918 <RadioInit+0x84>)
 80248ca:	2300      	movs	r3, #0
 80248cc:	2200      	movs	r2, #0
 80248ce:	0001      	movs	r1, r0
 80248d0:	f000 faca 	bl	8024e68 <SUBGRF_SetDioIrqParams>
    RadioSleep();
 80248d4:	f7ff f904 	bl	8023ae0 <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 80248d8:	4b10      	ldr	r3, [pc, #64]	@ (802491c <RadioInit+0x88>)
 80248da:	2701      	movs	r7, #1
 80248dc:	427f      	negs	r7, r7
 80248de:	4e10      	ldr	r6, [pc, #64]	@ (8024920 <RadioInit+0x8c>)
 80248e0:	9400      	str	r4, [sp, #0]
 80248e2:	2200      	movs	r2, #0
 80248e4:	0039      	movs	r1, r7
 80248e6:	0030      	movs	r0, r6
 80248e8:	f001 f9e0 	bl	8025cac <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 80248ec:	4b0d      	ldr	r3, [pc, #52]	@ (8024924 <RadioInit+0x90>)
 80248ee:	4d0e      	ldr	r5, [pc, #56]	@ (8024928 <RadioInit+0x94>)
 80248f0:	9400      	str	r4, [sp, #0]
 80248f2:	2200      	movs	r2, #0
 80248f4:	0039      	movs	r1, r7
 80248f6:	0028      	movs	r0, r5
 80248f8:	f001 f9d8 	bl	8025cac <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 80248fc:	0030      	movs	r0, r6
 80248fe:	f001 fa35 	bl	8025d6c <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8024902:	0028      	movs	r0, r5
 8024904:	f001 fa32 	bl	8025d6c <UTIL_TIMER_Stop>
}
 8024908:	b003      	add	sp, #12
 802490a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802490c:	2000a218 	.word	0x2000a218
 8024910:	2000a1bc 	.word	0x2000a1bc
 8024914:	080239b1 	.word	0x080239b1
 8024918:	0000ffff 	.word	0x0000ffff
 802491c:	08023419 	.word	0x08023419
 8024920:	2000a1a4 	.word	0x2000a1a4
 8024924:	08023445 	.word	0x08023445
 8024928:	2000a18c 	.word	0x2000a18c

0802492c <SUBGRF_GetOperatingMode>:
    OperatingMode = MODE_STDBY_RC;
}

RadioOperatingModes_t SUBGRF_GetOperatingMode( void )
{
    return OperatingMode;
 802492c:	4b01      	ldr	r3, [pc, #4]	@ (8024934 <SUBGRF_GetOperatingMode+0x8>)
 802492e:	7818      	ldrb	r0, [r3, #0]
}
 8024930:	4770      	bx	lr
 8024932:	46c0      	nop			@ (mov r8, r8)
 8024934:	2000a32a 	.word	0x2000a32a

08024938 <SUBGRF_GetPacketType>:
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
}

RadioPacketTypes_t SUBGRF_GetPacketType( void )
{
    return PacketType;
 8024938:	4b01      	ldr	r3, [pc, #4]	@ (8024940 <SUBGRF_GetPacketType+0x8>)
 802493a:	7818      	ldrb	r0, [r3, #0]
}
 802493c:	4770      	bx	lr
 802493e:	46c0      	nop			@ (mov r8, r8)
 8024940:	2000a329 	.word	0x2000a329

08024944 <SUBGRF_WriteRegister>:
    buf[1] = ( uint8_t )( ( uint16_t )irq & 0x00FF );
    SUBGRF_WriteCommand( RADIO_CLR_IRQSTATUS, buf, 2 );
}

void SUBGRF_WriteRegister( uint16_t addr, uint8_t data )
{
 8024944:	b530      	push	{r4, r5, lr}
 8024946:	b083      	sub	sp, #12
 8024948:	466b      	mov	r3, sp
 802494a:	1dda      	adds	r2, r3, #7
 802494c:	7011      	strb	r1, [r2, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802494e:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8024952:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8024954:	4c04      	ldr	r4, [pc, #16]	@ (8024968 <SUBGRF_WriteRegister+0x24>)
 8024956:	2301      	movs	r3, #1
 8024958:	0001      	movs	r1, r0
 802495a:	0020      	movs	r0, r4
 802495c:	f7fe fa30 	bl	8022dc0 <HAL_SUBGHZ_WriteRegisters>
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024960:	f385 8810 	msr	PRIMASK, r5
    CRITICAL_SECTION_END();
}
 8024964:	b003      	add	sp, #12
 8024966:	bd30      	pop	{r4, r5, pc}
 8024968:	2000a0b0 	.word	0x2000a0b0

0802496c <SUBGRF_ReadRegister>:

uint8_t SUBGRF_ReadRegister( uint16_t addr )
{
 802496c:	b570      	push	{r4, r5, r6, lr}
 802496e:	b082      	sub	sp, #8
 8024970:	0001      	movs	r1, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8024972:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8024976:	b672      	cpsid	i
    uint8_t data;
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8024978:	466b      	mov	r3, sp
 802497a:	1ddd      	adds	r5, r3, #7
 802497c:	4c05      	ldr	r4, [pc, #20]	@ (8024994 <SUBGRF_ReadRegister+0x28>)
 802497e:	2301      	movs	r3, #1
 8024980:	002a      	movs	r2, r5
 8024982:	0020      	movs	r0, r4
 8024984:	f7fe fa6e 	bl	8022e64 <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024988:	f386 8810 	msr	PRIMASK, r6
    CRITICAL_SECTION_END();
    return data;
 802498c:	7828      	ldrb	r0, [r5, #0]
}
 802498e:	b002      	add	sp, #8
 8024990:	bd70      	pop	{r4, r5, r6, pc}
 8024992:	46c0      	nop			@ (mov r8, r8)
 8024994:	2000a0b0 	.word	0x2000a0b0

08024998 <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_LR_FHSS_HOP );
}

static void Radio_SMPS_Set(uint8_t level)
{
 8024998:	b570      	push	{r4, r5, r6, lr}
 802499a:	0004      	movs	r4, r0
  if ( 1U == RBI_IsDCDC() )
 802499c:	f7fc ff9f 	bl	80218de <RBI_IsDCDC>
 80249a0:	2801      	cmp	r0, #1
 80249a2:	d000      	beq.n	80249a6 <Radio_SMPS_Set+0xe>
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
  }
}
 80249a4:	bd70      	pop	{r4, r5, r6, pc}
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 80249a6:	4d06      	ldr	r5, [pc, #24]	@ (80249c0 <Radio_SMPS_Set+0x28>)
 80249a8:	0028      	movs	r0, r5
 80249aa:	f7ff ffdf 	bl	802496c <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
 80249ae:	2306      	movs	r3, #6
 80249b0:	4398      	bics	r0, r3
 80249b2:	b2c1      	uxtb	r1, r0
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 80249b4:	4321      	orrs	r1, r4
 80249b6:	0028      	movs	r0, r5
 80249b8:	f7ff ffc4 	bl	8024944 <SUBGRF_WriteRegister>
}
 80249bc:	e7f2      	b.n	80249a4 <Radio_SMPS_Set+0xc>
 80249be:	46c0      	nop			@ (mov r8, r8)
 80249c0:	00000923 	.word	0x00000923

080249c4 <SUBGRF_SetWhiteningSeed>:
{
 80249c4:	b570      	push	{r4, r5, r6, lr}
 80249c6:	0004      	movs	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 80249c8:	f7ff ffb6 	bl	8024938 <SUBGRF_GetPacketType>
 80249cc:	2800      	cmp	r0, #0
 80249ce:	d000      	beq.n	80249d2 <SUBGRF_SetWhiteningSeed+0xe>
}
 80249d0:	bd70      	pop	{r4, r5, r6, pc}
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 80249d2:	25d7      	movs	r5, #215	@ 0xd7
 80249d4:	00ed      	lsls	r5, r5, #3
 80249d6:	0028      	movs	r0, r5
 80249d8:	f7ff ffc8 	bl	802496c <SUBGRF_ReadRegister>
 80249dc:	2301      	movs	r3, #1
 80249de:	4398      	bics	r0, r3
 80249e0:	b2c1      	uxtb	r1, r0
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 80249e2:	0a22      	lsrs	r2, r4, #8
 80249e4:	4013      	ands	r3, r2
 80249e6:	4319      	orrs	r1, r3
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 80249e8:	0028      	movs	r0, r5
 80249ea:	f7ff ffab 	bl	8024944 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 80249ee:	b2e1      	uxtb	r1, r4
 80249f0:	4801      	ldr	r0, [pc, #4]	@ (80249f8 <SUBGRF_SetWhiteningSeed+0x34>)
 80249f2:	f7ff ffa7 	bl	8024944 <SUBGRF_WriteRegister>
}
 80249f6:	e7eb      	b.n	80249d0 <SUBGRF_SetWhiteningSeed+0xc>
 80249f8:	000006b9 	.word	0x000006b9

080249fc <SUBGRF_WriteRegisters>:
{
 80249fc:	b570      	push	{r4, r5, r6, lr}
 80249fe:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8024a00:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8024a04:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 8024a06:	4c04      	ldr	r4, [pc, #16]	@ (8024a18 <SUBGRF_WriteRegisters+0x1c>)
 8024a08:	000a      	movs	r2, r1
 8024a0a:	0001      	movs	r1, r0
 8024a0c:	0020      	movs	r0, r4
 8024a0e:	f7fe f9d7 	bl	8022dc0 <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024a12:	f385 8810 	msr	PRIMASK, r5
}
 8024a16:	bd70      	pop	{r4, r5, r6, pc}
 8024a18:	2000a0b0 	.word	0x2000a0b0

08024a1c <SUBGRF_SetSyncWord>:
{
 8024a1c:	b510      	push	{r4, lr}
 8024a1e:	0001      	movs	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 8024a20:	20d8      	movs	r0, #216	@ 0xd8
 8024a22:	2208      	movs	r2, #8
 8024a24:	00c0      	lsls	r0, r0, #3
 8024a26:	f7ff ffe9 	bl	80249fc <SUBGRF_WriteRegisters>
}
 8024a2a:	2000      	movs	r0, #0
 8024a2c:	bd10      	pop	{r4, pc}
	...

08024a30 <SUBGRF_SetCrcSeed>:
{
 8024a30:	b500      	push	{lr}
 8024a32:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 8024a34:	0a02      	lsrs	r2, r0, #8
 8024a36:	ab01      	add	r3, sp, #4
 8024a38:	701a      	strb	r2, [r3, #0]
    buf[1] = ( uint8_t )( seed & 0xFF );
 8024a3a:	7058      	strb	r0, [r3, #1]
    switch( SUBGRF_GetPacketType( ) )
 8024a3c:	f7ff ff7c 	bl	8024938 <SUBGRF_GetPacketType>
 8024a40:	2800      	cmp	r0, #0
 8024a42:	d001      	beq.n	8024a48 <SUBGRF_SetCrcSeed+0x18>
}
 8024a44:	b003      	add	sp, #12
 8024a46:	bd00      	pop	{pc}
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 8024a48:	2202      	movs	r2, #2
 8024a4a:	a901      	add	r1, sp, #4
 8024a4c:	4801      	ldr	r0, [pc, #4]	@ (8024a54 <SUBGRF_SetCrcSeed+0x24>)
 8024a4e:	f7ff ffd5 	bl	80249fc <SUBGRF_WriteRegisters>
}
 8024a52:	e7f7      	b.n	8024a44 <SUBGRF_SetCrcSeed+0x14>
 8024a54:	000006bc 	.word	0x000006bc

08024a58 <SUBGRF_SetCrcPolynomial>:
{
 8024a58:	b500      	push	{lr}
 8024a5a:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 8024a5c:	0a02      	lsrs	r2, r0, #8
 8024a5e:	ab01      	add	r3, sp, #4
 8024a60:	701a      	strb	r2, [r3, #0]
    buf[1] = ( uint8_t )( polynomial & 0xFF );
 8024a62:	7058      	strb	r0, [r3, #1]
    switch( SUBGRF_GetPacketType( ) )
 8024a64:	f7ff ff68 	bl	8024938 <SUBGRF_GetPacketType>
 8024a68:	2800      	cmp	r0, #0
 8024a6a:	d001      	beq.n	8024a70 <SUBGRF_SetCrcPolynomial+0x18>
}
 8024a6c:	b003      	add	sp, #12
 8024a6e:	bd00      	pop	{pc}
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 8024a70:	2202      	movs	r2, #2
 8024a72:	a901      	add	r1, sp, #4
 8024a74:	4801      	ldr	r0, [pc, #4]	@ (8024a7c <SUBGRF_SetCrcPolynomial+0x24>)
 8024a76:	f7ff ffc1 	bl	80249fc <SUBGRF_WriteRegisters>
}
 8024a7a:	e7f7      	b.n	8024a6c <SUBGRF_SetCrcPolynomial+0x14>
 8024a7c:	000006be 	.word	0x000006be

08024a80 <SUBGRF_ReadRegisters>:
{
 8024a80:	b570      	push	{r4, r5, r6, lr}
 8024a82:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8024a84:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8024a88:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 8024a8a:	4c04      	ldr	r4, [pc, #16]	@ (8024a9c <SUBGRF_ReadRegisters+0x1c>)
 8024a8c:	000a      	movs	r2, r1
 8024a8e:	0001      	movs	r1, r0
 8024a90:	0020      	movs	r0, r4
 8024a92:	f7fe f9e7 	bl	8022e64 <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024a96:	f385 8810 	msr	PRIMASK, r5
}
 8024a9a:	bd70      	pop	{r4, r5, r6, pc}
 8024a9c:	2000a0b0 	.word	0x2000a0b0

08024aa0 <SUBGRF_WriteBuffer>:
{
 8024aa0:	b570      	push	{r4, r5, r6, lr}
 8024aa2:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8024aa4:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8024aa8:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 8024aaa:	4c04      	ldr	r4, [pc, #16]	@ (8024abc <SUBGRF_WriteBuffer+0x1c>)
 8024aac:	000a      	movs	r2, r1
 8024aae:	0001      	movs	r1, r0
 8024ab0:	0020      	movs	r0, r4
 8024ab2:	f7fe fb2d 	bl	8023110 <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024ab6:	f385 8810 	msr	PRIMASK, r5
}
 8024aba:	bd70      	pop	{r4, r5, r6, pc}
 8024abc:	2000a0b0 	.word	0x2000a0b0

08024ac0 <SUBGRF_SetPayload>:
{
 8024ac0:	b510      	push	{r4, lr}
 8024ac2:	000a      	movs	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 8024ac4:	0001      	movs	r1, r0
 8024ac6:	2000      	movs	r0, #0
 8024ac8:	f7ff ffea 	bl	8024aa0 <SUBGRF_WriteBuffer>
}
 8024acc:	bd10      	pop	{r4, pc}
	...

08024ad0 <SUBGRF_ReadBuffer>:
{
 8024ad0:	b570      	push	{r4, r5, r6, lr}
 8024ad2:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8024ad4:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8024ad8:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 8024ada:	4c04      	ldr	r4, [pc, #16]	@ (8024aec <SUBGRF_ReadBuffer+0x1c>)
 8024adc:	000a      	movs	r2, r1
 8024ade:	0001      	movs	r1, r0
 8024ae0:	0020      	movs	r0, r4
 8024ae2:	f7fe fb61 	bl	80231a8 <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024ae6:	f385 8810 	msr	PRIMASK, r5
}
 8024aea:	bd70      	pop	{r4, r5, r6, pc}
 8024aec:	2000a0b0 	.word	0x2000a0b0

08024af0 <SUBGRF_WriteCommand>:
{
 8024af0:	b570      	push	{r4, r5, r6, lr}
 8024af2:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8024af4:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8024af8:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8024afa:	4c04      	ldr	r4, [pc, #16]	@ (8024b0c <SUBGRF_WriteCommand+0x1c>)
 8024afc:	000a      	movs	r2, r1
 8024afe:	0001      	movs	r1, r0
 8024b00:	0020      	movs	r0, r4
 8024b02:	f7fe fa03 	bl	8022f0c <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024b06:	f385 8810 	msr	PRIMASK, r5
}
 8024b0a:	bd70      	pop	{r4, r5, r6, pc}
 8024b0c:	2000a0b0 	.word	0x2000a0b0

08024b10 <SUBGRF_SetSleep>:
{
 8024b10:	b510      	push	{r4, lr}
 8024b12:	b082      	sub	sp, #8
 8024b14:	1c04      	adds	r4, r0, #0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 8024b16:	2000      	movs	r0, #0
 8024b18:	f7fc fed5 	bl	80218c6 <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 8024b1c:	2002      	movs	r0, #2
 8024b1e:	f7ff ff3b 	bl	8024998 <Radio_SMPS_Set>
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8024b22:	0763      	lsls	r3, r4, #29
 8024b24:	0fdb      	lsrs	r3, r3, #31
 8024b26:	009b      	lsls	r3, r3, #2
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 8024b28:	07a2      	lsls	r2, r4, #30
 8024b2a:	0fd2      	lsrs	r2, r2, #31
 8024b2c:	0052      	lsls	r2, r2, #1
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8024b2e:	4313      	orrs	r3, r2
                      ( ( uint8_t )sleepConfig.Fields.WakeUpRTC ) );
 8024b30:	07e4      	lsls	r4, r4, #31
 8024b32:	0fe4      	lsrs	r4, r4, #31
 8024b34:	b264      	sxtb	r4, r4
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 8024b36:	4323      	orrs	r3, r4
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8024b38:	466a      	mov	r2, sp
 8024b3a:	1dd1      	adds	r1, r2, #7
 8024b3c:	700b      	strb	r3, [r1, #0]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 8024b3e:	2201      	movs	r2, #1
 8024b40:	2084      	movs	r0, #132	@ 0x84
 8024b42:	f7ff ffd5 	bl	8024af0 <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 8024b46:	4b02      	ldr	r3, [pc, #8]	@ (8024b50 <SUBGRF_SetSleep+0x40>)
 8024b48:	2200      	movs	r2, #0
 8024b4a:	701a      	strb	r2, [r3, #0]
}
 8024b4c:	b002      	add	sp, #8
 8024b4e:	bd10      	pop	{r4, pc}
 8024b50:	2000a32a 	.word	0x2000a32a

08024b54 <SUBGRF_SetStandby>:
{
 8024b54:	b500      	push	{lr}
 8024b56:	b083      	sub	sp, #12
 8024b58:	466b      	mov	r3, sp
 8024b5a:	71d8      	strb	r0, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 8024b5c:	2201      	movs	r2, #1
 8024b5e:	1dd9      	adds	r1, r3, #7
 8024b60:	2080      	movs	r0, #128	@ 0x80
 8024b62:	f7ff ffc5 	bl	8024af0 <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 8024b66:	466b      	mov	r3, sp
 8024b68:	79db      	ldrb	r3, [r3, #7]
 8024b6a:	2b00      	cmp	r3, #0
 8024b6c:	d104      	bne.n	8024b78 <SUBGRF_SetStandby+0x24>
        OperatingMode = MODE_STDBY_RC;
 8024b6e:	4b04      	ldr	r3, [pc, #16]	@ (8024b80 <SUBGRF_SetStandby+0x2c>)
 8024b70:	2201      	movs	r2, #1
 8024b72:	701a      	strb	r2, [r3, #0]
}
 8024b74:	b003      	add	sp, #12
 8024b76:	bd00      	pop	{pc}
        OperatingMode = MODE_STDBY_XOSC;
 8024b78:	4b01      	ldr	r3, [pc, #4]	@ (8024b80 <SUBGRF_SetStandby+0x2c>)
 8024b7a:	2202      	movs	r2, #2
 8024b7c:	701a      	strb	r2, [r3, #0]
}
 8024b7e:	e7f9      	b.n	8024b74 <SUBGRF_SetStandby+0x20>
 8024b80:	2000a32a 	.word	0x2000a32a

08024b84 <SUBGRF_SetTx>:
{
 8024b84:	b500      	push	{lr}
 8024b86:	b083      	sub	sp, #12
    OperatingMode = MODE_TX;
 8024b88:	4b07      	ldr	r3, [pc, #28]	@ (8024ba8 <SUBGRF_SetTx+0x24>)
 8024b8a:	2204      	movs	r2, #4
 8024b8c:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8024b8e:	0c03      	lsrs	r3, r0, #16
 8024b90:	a901      	add	r1, sp, #4
 8024b92:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8024b94:	0a03      	lsrs	r3, r0, #8
 8024b96:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8024b98:	7088      	strb	r0, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 8024b9a:	3a01      	subs	r2, #1
 8024b9c:	2083      	movs	r0, #131	@ 0x83
 8024b9e:	f7ff ffa7 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024ba2:	b003      	add	sp, #12
 8024ba4:	bd00      	pop	{pc}
 8024ba6:	46c0      	nop			@ (mov r8, r8)
 8024ba8:	2000a32a 	.word	0x2000a32a

08024bac <SUBGRF_SendPayload>:
{
 8024bac:	b510      	push	{r4, lr}
 8024bae:	0014      	movs	r4, r2
    SUBGRF_SetPayload( payload, size );
 8024bb0:	f7ff ff86 	bl	8024ac0 <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 8024bb4:	0020      	movs	r0, r4
 8024bb6:	f7ff ffe5 	bl	8024b84 <SUBGRF_SetTx>
}
 8024bba:	bd10      	pop	{r4, pc}

08024bbc <SUBGRF_SetRx>:
{
 8024bbc:	b500      	push	{lr}
 8024bbe:	b083      	sub	sp, #12
    OperatingMode = MODE_RX;
 8024bc0:	4b07      	ldr	r3, [pc, #28]	@ (8024be0 <SUBGRF_SetRx+0x24>)
 8024bc2:	2205      	movs	r2, #5
 8024bc4:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8024bc6:	0c03      	lsrs	r3, r0, #16
 8024bc8:	a901      	add	r1, sp, #4
 8024bca:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8024bcc:	0a03      	lsrs	r3, r0, #8
 8024bce:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8024bd0:	7088      	strb	r0, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 8024bd2:	3a02      	subs	r2, #2
 8024bd4:	2082      	movs	r0, #130	@ 0x82
 8024bd6:	f7ff ff8b 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024bda:	b003      	add	sp, #12
 8024bdc:	bd00      	pop	{pc}
 8024bde:	46c0      	nop			@ (mov r8, r8)
 8024be0:	2000a32a 	.word	0x2000a32a

08024be4 <SUBGRF_GetRandom>:
{
 8024be4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024be6:	b083      	sub	sp, #12
    uint32_t number = 0;
 8024be8:	2300      	movs	r3, #0
 8024bea:	9301      	str	r3, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 8024bec:	4f15      	ldr	r7, [pc, #84]	@ (8024c44 <SUBGRF_GetRandom+0x60>)
 8024bee:	0038      	movs	r0, r7
 8024bf0:	f7ff febc 	bl	802496c <SUBGRF_ReadRegister>
 8024bf4:	0005      	movs	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 8024bf6:	2301      	movs	r3, #1
 8024bf8:	0001      	movs	r1, r0
 8024bfa:	4399      	bics	r1, r3
 8024bfc:	b2c9      	uxtb	r1, r1
 8024bfe:	0038      	movs	r0, r7
 8024c00:	f7ff fea0 	bl	8024944 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 8024c04:	4e10      	ldr	r6, [pc, #64]	@ (8024c48 <SUBGRF_GetRandom+0x64>)
 8024c06:	0030      	movs	r0, r6
 8024c08:	f7ff feb0 	bl	802496c <SUBGRF_ReadRegister>
 8024c0c:	0004      	movs	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 8024c0e:	217f      	movs	r1, #127	@ 0x7f
 8024c10:	4001      	ands	r1, r0
 8024c12:	0030      	movs	r0, r6
 8024c14:	f7ff fe96 	bl	8024944 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8024c18:	480c      	ldr	r0, [pc, #48]	@ (8024c4c <SUBGRF_GetRandom+0x68>)
 8024c1a:	f7ff ffcf 	bl	8024bbc <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 8024c1e:	2204      	movs	r2, #4
 8024c20:	a901      	add	r1, sp, #4
 8024c22:	480b      	ldr	r0, [pc, #44]	@ (8024c50 <SUBGRF_GetRandom+0x6c>)
 8024c24:	f7ff ff2c 	bl	8024a80 <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 8024c28:	2000      	movs	r0, #0
 8024c2a:	f7ff ff93 	bl	8024b54 <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 8024c2e:	0029      	movs	r1, r5
 8024c30:	0038      	movs	r0, r7
 8024c32:	f7ff fe87 	bl	8024944 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 8024c36:	0021      	movs	r1, r4
 8024c38:	0030      	movs	r0, r6
 8024c3a:	f7ff fe83 	bl	8024944 <SUBGRF_WriteRegister>
    return number;
 8024c3e:	9801      	ldr	r0, [sp, #4]
}
 8024c40:	b003      	add	sp, #12
 8024c42:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024c44:	000008e2 	.word	0x000008e2
 8024c48:	000008e5 	.word	0x000008e5
 8024c4c:	00ffffff 	.word	0x00ffffff
 8024c50:	00000819 	.word	0x00000819

08024c54 <SUBGRF_SetRxBoosted>:
{
 8024c54:	b510      	push	{r4, lr}
 8024c56:	b082      	sub	sp, #8
 8024c58:	0004      	movs	r4, r0
    OperatingMode = MODE_RX;
 8024c5a:	4b09      	ldr	r3, [pc, #36]	@ (8024c80 <SUBGRF_SetRxBoosted+0x2c>)
 8024c5c:	2205      	movs	r2, #5
 8024c5e:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 8024c60:	2197      	movs	r1, #151	@ 0x97
 8024c62:	4808      	ldr	r0, [pc, #32]	@ (8024c84 <SUBGRF_SetRxBoosted+0x30>)
 8024c64:	f7ff fe6e 	bl	8024944 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8024c68:	0c23      	lsrs	r3, r4, #16
 8024c6a:	a901      	add	r1, sp, #4
 8024c6c:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8024c6e:	0a23      	lsrs	r3, r4, #8
 8024c70:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8024c72:	708c      	strb	r4, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 8024c74:	2203      	movs	r2, #3
 8024c76:	2082      	movs	r0, #130	@ 0x82
 8024c78:	f7ff ff3a 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024c7c:	b002      	add	sp, #8
 8024c7e:	bd10      	pop	{r4, pc}
 8024c80:	2000a32a 	.word	0x2000a32a
 8024c84:	000008ac 	.word	0x000008ac

08024c88 <SUBGRF_SetRxDutyCycle>:
{
 8024c88:	b500      	push	{lr}
 8024c8a:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 8024c8c:	0c03      	lsrs	r3, r0, #16
 8024c8e:	466a      	mov	r2, sp
 8024c90:	7013      	strb	r3, [r2, #0]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 8024c92:	0a03      	lsrs	r3, r0, #8
 8024c94:	7053      	strb	r3, [r2, #1]
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 8024c96:	7090      	strb	r0, [r2, #2]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 8024c98:	0c0b      	lsrs	r3, r1, #16
 8024c9a:	70d3      	strb	r3, [r2, #3]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 8024c9c:	0a0b      	lsrs	r3, r1, #8
 8024c9e:	7113      	strb	r3, [r2, #4]
    buf[5] = ( uint8_t )( sleepTime & 0xFF );
 8024ca0:	7151      	strb	r1, [r2, #5]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 8024ca2:	2206      	movs	r2, #6
 8024ca4:	4669      	mov	r1, sp
 8024ca6:	2094      	movs	r0, #148	@ 0x94
 8024ca8:	f7ff ff22 	bl	8024af0 <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 8024cac:	4b02      	ldr	r3, [pc, #8]	@ (8024cb8 <SUBGRF_SetRxDutyCycle+0x30>)
 8024cae:	2206      	movs	r2, #6
 8024cb0:	701a      	strb	r2, [r3, #0]
}
 8024cb2:	b003      	add	sp, #12
 8024cb4:	bd00      	pop	{pc}
 8024cb6:	46c0      	nop			@ (mov r8, r8)
 8024cb8:	2000a32a 	.word	0x2000a32a

08024cbc <SUBGRF_SetCad>:
{
 8024cbc:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 8024cbe:	2200      	movs	r2, #0
 8024cc0:	2100      	movs	r1, #0
 8024cc2:	20c5      	movs	r0, #197	@ 0xc5
 8024cc4:	f7ff ff14 	bl	8024af0 <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 8024cc8:	4b01      	ldr	r3, [pc, #4]	@ (8024cd0 <SUBGRF_SetCad+0x14>)
 8024cca:	2207      	movs	r2, #7
 8024ccc:	701a      	strb	r2, [r3, #0]
}
 8024cce:	bd10      	pop	{r4, pc}
 8024cd0:	2000a32a 	.word	0x2000a32a

08024cd4 <SUBGRF_SetTxContinuousWave>:
{
 8024cd4:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 8024cd6:	2200      	movs	r2, #0
 8024cd8:	2100      	movs	r1, #0
 8024cda:	20d1      	movs	r0, #209	@ 0xd1
 8024cdc:	f7ff ff08 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024ce0:	bd10      	pop	{r4, pc}

08024ce2 <SUBGRF_SetTxInfinitePreamble>:
{
 8024ce2:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 8024ce4:	2200      	movs	r2, #0
 8024ce6:	2100      	movs	r1, #0
 8024ce8:	20d2      	movs	r0, #210	@ 0xd2
 8024cea:	f7ff ff01 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024cee:	bd10      	pop	{r4, pc}

08024cf0 <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 8024cf0:	b500      	push	{lr}
 8024cf2:	b083      	sub	sp, #12
 8024cf4:	466b      	mov	r3, sp
 8024cf6:	1dd9      	adds	r1, r3, #7
 8024cf8:	7008      	strb	r0, [r1, #0]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 8024cfa:	2201      	movs	r2, #1
 8024cfc:	209f      	movs	r0, #159	@ 0x9f
 8024cfe:	f7ff fef7 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024d02:	b003      	add	sp, #12
 8024d04:	bd00      	pop	{pc}
	...

08024d08 <SUBGRF_SetLoRaSymbNumTimeout>:
{
 8024d08:	b500      	push	{lr}
 8024d0a:	b083      	sub	sp, #12
 8024d0c:	466b      	mov	r3, sp
 8024d0e:	71d8      	strb	r0, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 8024d10:	2201      	movs	r2, #1
 8024d12:	1dd9      	adds	r1, r3, #7
 8024d14:	20a0      	movs	r0, #160	@ 0xa0
 8024d16:	f7ff feeb 	bl	8024af0 <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 8024d1a:	466b      	mov	r3, sp
 8024d1c:	79db      	ldrb	r3, [r3, #7]
 8024d1e:	2b3f      	cmp	r3, #63	@ 0x3f
 8024d20:	d90e      	bls.n	8024d40 <SUBGRF_SetLoRaSymbNumTimeout+0x38>
        uint8_t mant = symbNum >> 1;
 8024d22:	085b      	lsrs	r3, r3, #1
        uint8_t exp  = 0;
 8024d24:	2200      	movs	r2, #0
        while( mant > 31 )
 8024d26:	e002      	b.n	8024d2e <SUBGRF_SetLoRaSymbNumTimeout+0x26>
            mant >>= 2;
 8024d28:	089b      	lsrs	r3, r3, #2
            exp++;
 8024d2a:	3201      	adds	r2, #1
 8024d2c:	b2d2      	uxtb	r2, r2
        while( mant > 31 )
 8024d2e:	2b1f      	cmp	r3, #31
 8024d30:	d8fa      	bhi.n	8024d28 <SUBGRF_SetLoRaSymbNumTimeout+0x20>
        reg = exp + ( mant << 3 );
 8024d32:	00d9      	lsls	r1, r3, #3
 8024d34:	b2c9      	uxtb	r1, r1
 8024d36:	1889      	adds	r1, r1, r2
 8024d38:	b2c9      	uxtb	r1, r1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 8024d3a:	4802      	ldr	r0, [pc, #8]	@ (8024d44 <SUBGRF_SetLoRaSymbNumTimeout+0x3c>)
 8024d3c:	f7ff fe02 	bl	8024944 <SUBGRF_WriteRegister>
}
 8024d40:	b003      	add	sp, #12
 8024d42:	bd00      	pop	{pc}
 8024d44:	00000706 	.word	0x00000706

08024d48 <SUBGRF_SetRegulatorMode>:
{
 8024d48:	b500      	push	{lr}
 8024d4a:	b083      	sub	sp, #12
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 8024d4c:	f7fc fdc7 	bl	80218de <RBI_IsDCDC>
 8024d50:	2801      	cmp	r0, #1
 8024d52:	d00a      	beq.n	8024d6a <SUBGRF_SetRegulatorMode+0x22>
        mode = USE_LDO ;
 8024d54:	466b      	mov	r3, sp
 8024d56:	2200      	movs	r2, #0
 8024d58:	71da      	strb	r2, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 8024d5a:	2201      	movs	r2, #1
 8024d5c:	466b      	mov	r3, sp
 8024d5e:	1dd9      	adds	r1, r3, #7
 8024d60:	2096      	movs	r0, #150	@ 0x96
 8024d62:	f7ff fec5 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024d66:	b003      	add	sp, #12
 8024d68:	bd00      	pop	{pc}
        mode = USE_DCDC ;
 8024d6a:	466b      	mov	r3, sp
 8024d6c:	2201      	movs	r2, #1
 8024d6e:	71da      	strb	r2, [r3, #7]
 8024d70:	e7f3      	b.n	8024d5a <SUBGRF_SetRegulatorMode+0x12>

08024d72 <SUBGRF_Calibrate>:
{
 8024d72:	b500      	push	{lr}
 8024d74:	b083      	sub	sp, #12
 8024d76:	1c03      	adds	r3, r0, #0
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8024d78:	0658      	lsls	r0, r3, #25
 8024d7a:	0fc0      	lsrs	r0, r0, #31
 8024d7c:	0180      	lsls	r0, r0, #6
                      ( ( uint8_t )calibParam.Fields.ADCBulkPEnable << 5 ) |
 8024d7e:	069a      	lsls	r2, r3, #26
 8024d80:	0fd2      	lsrs	r2, r2, #31
 8024d82:	0152      	lsls	r2, r2, #5
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8024d84:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.ADCBulkNEnable << 4 ) |
 8024d86:	06da      	lsls	r2, r3, #27
 8024d88:	0fd2      	lsrs	r2, r2, #31
 8024d8a:	0112      	lsls	r2, r2, #4
                      ( ( uint8_t )calibParam.Fields.ADCBulkPEnable << 5 ) |
 8024d8c:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.ADCPulseEnable << 3 ) |
 8024d8e:	071a      	lsls	r2, r3, #28
 8024d90:	0fd2      	lsrs	r2, r2, #31
 8024d92:	00d2      	lsls	r2, r2, #3
                      ( ( uint8_t )calibParam.Fields.ADCBulkNEnable << 4 ) |
 8024d94:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.PLLEnable << 2 ) |
 8024d96:	075a      	lsls	r2, r3, #29
 8024d98:	0fd2      	lsrs	r2, r2, #31
 8024d9a:	0092      	lsls	r2, r2, #2
                      ( ( uint8_t )calibParam.Fields.ADCPulseEnable << 3 ) |
 8024d9c:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 8024d9e:	079a      	lsls	r2, r3, #30
 8024da0:	0fd2      	lsrs	r2, r2, #31
 8024da2:	0052      	lsls	r2, r2, #1
                      ( ( uint8_t )calibParam.Fields.PLLEnable << 2 ) |
 8024da4:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.RC64KEnable ) );
 8024da6:	07db      	lsls	r3, r3, #31
 8024da8:	0fdb      	lsrs	r3, r3, #31
 8024daa:	b25b      	sxtb	r3, r3
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 8024dac:	4318      	orrs	r0, r3
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8024dae:	466b      	mov	r3, sp
 8024db0:	1dd9      	adds	r1, r3, #7
 8024db2:	7008      	strb	r0, [r1, #0]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 8024db4:	2201      	movs	r2, #1
 8024db6:	2089      	movs	r0, #137	@ 0x89
 8024db8:	f7ff fe9a 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024dbc:	b003      	add	sp, #12
 8024dbe:	bd00      	pop	{pc}

08024dc0 <SUBGRF_CalibrateImage>:
{
 8024dc0:	b500      	push	{lr}
 8024dc2:	b083      	sub	sp, #12
    if( freq > 900000000 )
 8024dc4:	4b1c      	ldr	r3, [pc, #112]	@ (8024e38 <SUBGRF_CalibrateImage+0x78>)
 8024dc6:	4298      	cmp	r0, r3
 8024dc8:	d90b      	bls.n	8024de2 <SUBGRF_CalibrateImage+0x22>
        calFreq[0] = 0xE1;
 8024dca:	ab01      	add	r3, sp, #4
 8024dcc:	22e1      	movs	r2, #225	@ 0xe1
 8024dce:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xE9;
 8024dd0:	3208      	adds	r2, #8
 8024dd2:	705a      	strb	r2, [r3, #1]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 8024dd4:	2202      	movs	r2, #2
 8024dd6:	a901      	add	r1, sp, #4
 8024dd8:	2098      	movs	r0, #152	@ 0x98
 8024dda:	f7ff fe89 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024dde:	b003      	add	sp, #12
 8024de0:	bd00      	pop	{pc}
    else if( freq > 850000000 )
 8024de2:	4b16      	ldr	r3, [pc, #88]	@ (8024e3c <SUBGRF_CalibrateImage+0x7c>)
 8024de4:	4298      	cmp	r0, r3
 8024de6:	d905      	bls.n	8024df4 <SUBGRF_CalibrateImage+0x34>
        calFreq[0] = 0xD7;
 8024de8:	ab01      	add	r3, sp, #4
 8024dea:	22d7      	movs	r2, #215	@ 0xd7
 8024dec:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xDB;
 8024dee:	3204      	adds	r2, #4
 8024df0:	705a      	strb	r2, [r3, #1]
 8024df2:	e7ef      	b.n	8024dd4 <SUBGRF_CalibrateImage+0x14>
    else if( freq > 770000000 )
 8024df4:	4b12      	ldr	r3, [pc, #72]	@ (8024e40 <SUBGRF_CalibrateImage+0x80>)
 8024df6:	4298      	cmp	r0, r3
 8024df8:	d905      	bls.n	8024e06 <SUBGRF_CalibrateImage+0x46>
        calFreq[0] = 0xC1;
 8024dfa:	ab01      	add	r3, sp, #4
 8024dfc:	22c1      	movs	r2, #193	@ 0xc1
 8024dfe:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xC5;
 8024e00:	3204      	adds	r2, #4
 8024e02:	705a      	strb	r2, [r3, #1]
 8024e04:	e7e6      	b.n	8024dd4 <SUBGRF_CalibrateImage+0x14>
    else if( freq > 460000000 )
 8024e06:	4b0f      	ldr	r3, [pc, #60]	@ (8024e44 <SUBGRF_CalibrateImage+0x84>)
 8024e08:	4298      	cmp	r0, r3
 8024e0a:	d905      	bls.n	8024e18 <SUBGRF_CalibrateImage+0x58>
        calFreq[0] = 0x75;
 8024e0c:	ab01      	add	r3, sp, #4
 8024e0e:	2275      	movs	r2, #117	@ 0x75
 8024e10:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x81;
 8024e12:	320c      	adds	r2, #12
 8024e14:	705a      	strb	r2, [r3, #1]
 8024e16:	e7dd      	b.n	8024dd4 <SUBGRF_CalibrateImage+0x14>
    else if( freq > 425000000 )
 8024e18:	4b0b      	ldr	r3, [pc, #44]	@ (8024e48 <SUBGRF_CalibrateImage+0x88>)
 8024e1a:	4298      	cmp	r0, r3
 8024e1c:	d905      	bls.n	8024e2a <SUBGRF_CalibrateImage+0x6a>
        calFreq[0] = 0x6B;
 8024e1e:	ab01      	add	r3, sp, #4
 8024e20:	226b      	movs	r2, #107	@ 0x6b
 8024e22:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x6F;
 8024e24:	3204      	adds	r2, #4
 8024e26:	705a      	strb	r2, [r3, #1]
 8024e28:	e7d4      	b.n	8024dd4 <SUBGRF_CalibrateImage+0x14>
        calFreq[0] = 0x29;
 8024e2a:	ab01      	add	r3, sp, #4
 8024e2c:	2229      	movs	r2, #41	@ 0x29
 8024e2e:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x2B ;
 8024e30:	3202      	adds	r2, #2
 8024e32:	705a      	strb	r2, [r3, #1]
 8024e34:	e7ce      	b.n	8024dd4 <SUBGRF_CalibrateImage+0x14>
 8024e36:	46c0      	nop			@ (mov r8, r8)
 8024e38:	35a4e900 	.word	0x35a4e900
 8024e3c:	32a9f880 	.word	0x32a9f880
 8024e40:	2de54480 	.word	0x2de54480
 8024e44:	1b6b0b00 	.word	0x1b6b0b00
 8024e48:	1954fc40 	.word	0x1954fc40

08024e4c <SUBGRF_SetPaConfig>:
{
 8024e4c:	b510      	push	{r4, lr}
 8024e4e:	b082      	sub	sp, #8
    buf[0] = paDutyCycle;
 8024e50:	ac01      	add	r4, sp, #4
 8024e52:	7020      	strb	r0, [r4, #0]
    buf[1] = hpMax;
 8024e54:	7061      	strb	r1, [r4, #1]
    buf[2] = deviceSel;
 8024e56:	70a2      	strb	r2, [r4, #2]
    buf[3] = paLut;
 8024e58:	70e3      	strb	r3, [r4, #3]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 8024e5a:	2204      	movs	r2, #4
 8024e5c:	0021      	movs	r1, r4
 8024e5e:	2095      	movs	r0, #149	@ 0x95
 8024e60:	f7ff fe46 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024e64:	b002      	add	sp, #8
 8024e66:	bd10      	pop	{r4, pc}

08024e68 <SUBGRF_SetDioIrqParams>:
{
 8024e68:	b530      	push	{r4, r5, lr}
 8024e6a:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 8024e6c:	0a04      	lsrs	r4, r0, #8
 8024e6e:	466d      	mov	r5, sp
 8024e70:	702c      	strb	r4, [r5, #0]
    buf[1] = ( uint8_t )( irqMask & 0x00FF );
 8024e72:	7068      	strb	r0, [r5, #1]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 8024e74:	0a08      	lsrs	r0, r1, #8
 8024e76:	70a8      	strb	r0, [r5, #2]
    buf[3] = ( uint8_t )( dio1Mask & 0x00FF );
 8024e78:	70e9      	strb	r1, [r5, #3]
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 8024e7a:	0a11      	lsrs	r1, r2, #8
 8024e7c:	7129      	strb	r1, [r5, #4]
    buf[5] = ( uint8_t )( dio2Mask & 0x00FF );
 8024e7e:	4669      	mov	r1, sp
 8024e80:	716a      	strb	r2, [r5, #5]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 8024e82:	0a1a      	lsrs	r2, r3, #8
 8024e84:	71aa      	strb	r2, [r5, #6]
    buf[7] = ( uint8_t )( dio3Mask & 0x00FF );
 8024e86:	71eb      	strb	r3, [r5, #7]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 8024e88:	2208      	movs	r2, #8
 8024e8a:	2008      	movs	r0, #8
 8024e8c:	f7ff fe30 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024e90:	b003      	add	sp, #12
 8024e92:	bd30      	pop	{r4, r5, pc}

08024e94 <SUBGRF_SetTcxoMode>:
{
 8024e94:	b500      	push	{lr}
 8024e96:	b083      	sub	sp, #12
 8024e98:	000b      	movs	r3, r1
    buf[0] = tcxoVoltage & 0x07;
 8024e9a:	2207      	movs	r2, #7
 8024e9c:	4010      	ands	r0, r2
 8024e9e:	a901      	add	r1, sp, #4
 8024ea0:	7008      	strb	r0, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8024ea2:	0c1a      	lsrs	r2, r3, #16
 8024ea4:	704a      	strb	r2, [r1, #1]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8024ea6:	0a1a      	lsrs	r2, r3, #8
 8024ea8:	708a      	strb	r2, [r1, #2]
    buf[3] = ( uint8_t )( timeout & 0xFF );
 8024eaa:	70cb      	strb	r3, [r1, #3]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 8024eac:	2204      	movs	r2, #4
 8024eae:	2097      	movs	r0, #151	@ 0x97
 8024eb0:	f7ff fe1e 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024eb4:	b003      	add	sp, #12
 8024eb6:	bd00      	pop	{pc}

08024eb8 <SUBGRF_Init>:
{
 8024eb8:	b510      	push	{r4, lr}
    if ( dioIrq != NULL)
 8024eba:	2800      	cmp	r0, #0
 8024ebc:	d001      	beq.n	8024ec2 <SUBGRF_Init+0xa>
        RadioOnDioIrqCb = dioIrq;
 8024ebe:	4b17      	ldr	r3, [pc, #92]	@ (8024f1c <SUBGRF_Init+0x64>)
 8024ec0:	6018      	str	r0, [r3, #0]
    RADIO_INIT();
 8024ec2:	f7fb fd7d 	bl	80209c0 <MX_SUBGHZ_Init>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 8024ec6:	2002      	movs	r0, #2
 8024ec8:	f7ff fd66 	bl	8024998 <Radio_SMPS_Set>
    ImageCalibrated = false;
 8024ecc:	4b14      	ldr	r3, [pc, #80]	@ (8024f20 <SUBGRF_Init+0x68>)
 8024ece:	2200      	movs	r2, #0
 8024ed0:	701a      	strb	r2, [r3, #0]
    SUBGRF_SetStandby( STDBY_RC );
 8024ed2:	2000      	movs	r0, #0
 8024ed4:	f7ff fe3e 	bl	8024b54 <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 8024ed8:	f7fc fcfd 	bl	80218d6 <RBI_IsTCXO>
 8024edc:	2801      	cmp	r0, #1
 8024ede:	d011      	beq.n	8024f04 <SUBGRF_Init+0x4c>
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 8024ee0:	2120      	movs	r1, #32
 8024ee2:	4810      	ldr	r0, [pc, #64]	@ (8024f24 <SUBGRF_Init+0x6c>)
 8024ee4:	f7ff fd2e 	bl	8024944 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 8024ee8:	2120      	movs	r1, #32
 8024eea:	480f      	ldr	r0, [pc, #60]	@ (8024f28 <SUBGRF_Init+0x70>)
 8024eec:	f7ff fd2a 	bl	8024944 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8024ef0:	210e      	movs	r1, #14
 8024ef2:	480e      	ldr	r0, [pc, #56]	@ (8024f2c <SUBGRF_Init+0x74>)
 8024ef4:	f7ff fd26 	bl	8024944 <SUBGRF_WriteRegister>
    RBI_Init();
 8024ef8:	f7fc fce1 	bl	80218be <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 8024efc:	4b0c      	ldr	r3, [pc, #48]	@ (8024f30 <SUBGRF_Init+0x78>)
 8024efe:	2201      	movs	r2, #1
 8024f00:	701a      	strb	r2, [r3, #0]
}
 8024f02:	bd10      	pop	{r4, pc}
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 8024f04:	2140      	movs	r1, #64	@ 0x40
 8024f06:	f7ff ffc5 	bl	8024e94 <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 8024f0a:	2100      	movs	r1, #0
 8024f0c:	4805      	ldr	r0, [pc, #20]	@ (8024f24 <SUBGRF_Init+0x6c>)
 8024f0e:	f7ff fd19 	bl	8024944 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 8024f12:	207f      	movs	r0, #127	@ 0x7f
 8024f14:	f7ff ff2d 	bl	8024d72 <SUBGRF_Calibrate>
 8024f18:	e7ea      	b.n	8024ef0 <SUBGRF_Init+0x38>
 8024f1a:	46c0      	nop			@ (mov r8, r8)
 8024f1c:	2000a31c 	.word	0x2000a31c
 8024f20:	2000a320 	.word	0x2000a320
 8024f24:	00000911 	.word	0x00000911
 8024f28:	00000912 	.word	0x00000912
 8024f2c:	0000091f 	.word	0x0000091f
 8024f30:	2000a32a 	.word	0x2000a32a

08024f34 <SUBGRF_SetRfFrequency>:
{
 8024f34:	b510      	push	{r4, lr}
 8024f36:	b082      	sub	sp, #8
 8024f38:	0004      	movs	r4, r0
    if( ImageCalibrated == false )
 8024f3a:	4b0f      	ldr	r3, [pc, #60]	@ (8024f78 <SUBGRF_SetRfFrequency+0x44>)
 8024f3c:	781b      	ldrb	r3, [r3, #0]
 8024f3e:	2b00      	cmp	r3, #0
 8024f40:	d013      	beq.n	8024f6a <SUBGRF_SetRfFrequency+0x36>
    SX_FREQ_TO_CHANNEL(chan, frequency);
 8024f42:	09e1      	lsrs	r1, r4, #7
 8024f44:	0660      	lsls	r0, r4, #25
 8024f46:	4a0d      	ldr	r2, [pc, #52]	@ (8024f7c <SUBGRF_SetRfFrequency+0x48>)
 8024f48:	2300      	movs	r3, #0
 8024f4a:	f7fb fa5b 	bl	8020404 <__aeabi_uldivmod>
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 8024f4e:	0e03      	lsrs	r3, r0, #24
 8024f50:	a901      	add	r1, sp, #4
 8024f52:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( chan >> 16 ) & 0xFF );
 8024f54:	0c03      	lsrs	r3, r0, #16
 8024f56:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( ( chan >> 8 ) & 0xFF );
 8024f58:	0a03      	lsrs	r3, r0, #8
 8024f5a:	708b      	strb	r3, [r1, #2]
    buf[3] = ( uint8_t )( chan & 0xFF );
 8024f5c:	70c8      	strb	r0, [r1, #3]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 8024f5e:	2204      	movs	r2, #4
 8024f60:	2086      	movs	r0, #134	@ 0x86
 8024f62:	f7ff fdc5 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024f66:	b002      	add	sp, #8
 8024f68:	bd10      	pop	{r4, pc}
        SUBGRF_CalibrateImage( frequency );
 8024f6a:	f7ff ff29 	bl	8024dc0 <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 8024f6e:	4b02      	ldr	r3, [pc, #8]	@ (8024f78 <SUBGRF_SetRfFrequency+0x44>)
 8024f70:	2201      	movs	r2, #1
 8024f72:	701a      	strb	r2, [r3, #0]
 8024f74:	e7e5      	b.n	8024f42 <SUBGRF_SetRfFrequency+0xe>
 8024f76:	46c0      	nop			@ (mov r8, r8)
 8024f78:	2000a320 	.word	0x2000a320
 8024f7c:	01e84800 	.word	0x01e84800

08024f80 <SUBGRF_SetPacketType>:
{
 8024f80:	b500      	push	{lr}
 8024f82:	b083      	sub	sp, #12
 8024f84:	466b      	mov	r3, sp
 8024f86:	71d8      	strb	r0, [r3, #7]
    PacketType = packetType;
 8024f88:	b2c3      	uxtb	r3, r0
 8024f8a:	4a08      	ldr	r2, [pc, #32]	@ (8024fac <SUBGRF_SetPacketType+0x2c>)
 8024f8c:	7013      	strb	r3, [r2, #0]
    if( packetType == PACKET_TYPE_GFSK )
 8024f8e:	2b00      	cmp	r3, #0
 8024f90:	d007      	beq.n	8024fa2 <SUBGRF_SetPacketType+0x22>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 8024f92:	2201      	movs	r2, #1
 8024f94:	466b      	mov	r3, sp
 8024f96:	1dd9      	adds	r1, r3, #7
 8024f98:	208a      	movs	r0, #138	@ 0x8a
 8024f9a:	f7ff fda9 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8024f9e:	b003      	add	sp, #12
 8024fa0:	bd00      	pop	{pc}
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 8024fa2:	2100      	movs	r1, #0
 8024fa4:	4802      	ldr	r0, [pc, #8]	@ (8024fb0 <SUBGRF_SetPacketType+0x30>)
 8024fa6:	f7ff fccd 	bl	8024944 <SUBGRF_WriteRegister>
 8024faa:	e7f2      	b.n	8024f92 <SUBGRF_SetPacketType+0x12>
 8024fac:	2000a329 	.word	0x2000a329
 8024fb0:	000006ac 	.word	0x000006ac

08024fb4 <SUBGRF_SetTxParams>:
{
 8024fb4:	b570      	push	{r4, r5, r6, lr}
 8024fb6:	b082      	sub	sp, #8
 8024fb8:	000c      	movs	r4, r1
 8024fba:	0016      	movs	r6, r2
    if (paSelect == RFO_LP)
 8024fbc:	2801      	cmp	r0, #1
 8024fbe:	d032      	beq.n	8025026 <SUBGRF_SetTxParams+0x72>
        SUBGRF_WriteRegister(REG_TX_CLAMP, SUBGRF_ReadRegister(REG_TX_CLAMP) | (0x0F << 1));
 8024fc0:	4d41      	ldr	r5, [pc, #260]	@ (80250c8 <SUBGRF_SetTxParams+0x114>)
 8024fc2:	0028      	movs	r0, r5
 8024fc4:	f7ff fcd2 	bl	802496c <SUBGRF_ReadRegister>
 8024fc8:	231e      	movs	r3, #30
 8024fca:	4318      	orrs	r0, r3
 8024fcc:	b2c1      	uxtb	r1, r0
 8024fce:	0028      	movs	r0, r5
 8024fd0:	f7ff fcb8 	bl	8024944 <SUBGRF_WriteRegister>
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_HP_MAXPOWER);
 8024fd4:	2001      	movs	r0, #1
 8024fd6:	f7fc fc86 	bl	80218e6 <RBI_GetRFOMaxPowerConfig>
 8024fda:	0005      	movs	r5, r0
        if (power > max_power)
 8024fdc:	4284      	cmp	r4, r0
 8024fde:	dd00      	ble.n	8024fe2 <SUBGRF_SetTxParams+0x2e>
            power = max_power;
 8024fe0:	b244      	sxtb	r4, r0
        if (max_power == 20)
 8024fe2:	2d14      	cmp	r5, #20
 8024fe4:	d051      	beq.n	802508a <SUBGRF_SetTxParams+0xd6>
        else if (max_power == 17)
 8024fe6:	2d11      	cmp	r5, #17
 8024fe8:	d059      	beq.n	802509e <SUBGRF_SetTxParams+0xea>
        else if (max_power == 14)
 8024fea:	2d0e      	cmp	r5, #14
 8024fec:	d061      	beq.n	80250b2 <SUBGRF_SetTxParams+0xfe>
            SUBGRF_SetPaConfig(0x04, 0x07, 0x00, 0x01);
 8024fee:	2301      	movs	r3, #1
 8024ff0:	2200      	movs	r2, #0
 8024ff2:	2107      	movs	r1, #7
 8024ff4:	2004      	movs	r0, #4
 8024ff6:	f7ff ff29 	bl	8024e4c <SUBGRF_SetPaConfig>
            power = 0x16 - (max_power - power);
 8024ffa:	1b64      	subs	r4, r4, r5
 8024ffc:	3416      	adds	r4, #22
 8024ffe:	b265      	sxtb	r5, r4
        if (power < -9)
 8025000:	002b      	movs	r3, r5
 8025002:	3309      	adds	r3, #9
 8025004:	da01      	bge.n	802500a <SUBGRF_SetTxParams+0x56>
            power = -9;
 8025006:	2509      	movs	r5, #9
 8025008:	426d      	negs	r5, r5
        SUBGRF_WriteRegister(REG_OCP, 0x38);   /*current max 160mA for the whole device*/
 802500a:	2138      	movs	r1, #56	@ 0x38
 802500c:	482f      	ldr	r0, [pc, #188]	@ (80250cc <SUBGRF_SetTxParams+0x118>)
 802500e:	f7ff fc99 	bl	8024944 <SUBGRF_WriteRegister>
    buf[0] = power;
 8025012:	466b      	mov	r3, sp
 8025014:	711d      	strb	r5, [r3, #4]
    buf[1] = (uint8_t)rampTime;
 8025016:	715e      	strb	r6, [r3, #5]
    SUBGRF_WriteCommand(RADIO_SET_TXPARAMS, buf, 2);
 8025018:	2202      	movs	r2, #2
 802501a:	a901      	add	r1, sp, #4
 802501c:	208e      	movs	r0, #142	@ 0x8e
 802501e:	f7ff fd67 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8025022:	b002      	add	sp, #8
 8025024:	bd70      	pop	{r4, r5, r6, pc}
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_LP_MAXPOWER);
 8025026:	2000      	movs	r0, #0
 8025028:	f7fc fc5d 	bl	80218e6 <RBI_GetRFOMaxPowerConfig>
 802502c:	0005      	movs	r5, r0
        if (power >  max_power)
 802502e:	4284      	cmp	r4, r0
 8025030:	dd00      	ble.n	8025034 <SUBGRF_SetTxParams+0x80>
          power = max_power;
 8025032:	b244      	sxtb	r4, r0
        if (max_power == 14)
 8025034:	2d0e      	cmp	r5, #14
 8025036:	d014      	beq.n	8025062 <SUBGRF_SetTxParams+0xae>
        else if (max_power == 10)
 8025038:	2d0a      	cmp	r5, #10
 802503a:	d01c      	beq.n	8025076 <SUBGRF_SetTxParams+0xc2>
            SUBGRF_SetPaConfig(0x07, 0x00, 0x01, 0x01);
 802503c:	2301      	movs	r3, #1
 802503e:	2201      	movs	r2, #1
 8025040:	2100      	movs	r1, #0
 8025042:	2007      	movs	r0, #7
 8025044:	f7ff ff02 	bl	8024e4c <SUBGRF_SetPaConfig>
            power = 0x0E - (max_power - power);
 8025048:	1b65      	subs	r5, r4, r5
 802504a:	350e      	adds	r5, #14
 802504c:	b26d      	sxtb	r5, r5
        if (power < -17)
 802504e:	002b      	movs	r3, r5
 8025050:	3311      	adds	r3, #17
 8025052:	da01      	bge.n	8025058 <SUBGRF_SetTxParams+0xa4>
            power = -17;
 8025054:	2511      	movs	r5, #17
 8025056:	426d      	negs	r5, r5
        SUBGRF_WriteRegister(REG_OCP, 0x18);   /* current max is 80 mA for the whole device*/
 8025058:	2118      	movs	r1, #24
 802505a:	481c      	ldr	r0, [pc, #112]	@ (80250cc <SUBGRF_SetTxParams+0x118>)
 802505c:	f7ff fc72 	bl	8024944 <SUBGRF_WriteRegister>
 8025060:	e7d7      	b.n	8025012 <SUBGRF_SetTxParams+0x5e>
            SUBGRF_SetPaConfig(0x04, 0x00, 0x01, 0x01);
 8025062:	2301      	movs	r3, #1
 8025064:	2201      	movs	r2, #1
 8025066:	2100      	movs	r1, #0
 8025068:	2004      	movs	r0, #4
 802506a:	f7ff feef 	bl	8024e4c <SUBGRF_SetPaConfig>
            power = 0x0E - (max_power - power);
 802506e:	1b65      	subs	r5, r4, r5
 8025070:	350e      	adds	r5, #14
 8025072:	b26d      	sxtb	r5, r5
 8025074:	e7eb      	b.n	802504e <SUBGRF_SetTxParams+0x9a>
            SUBGRF_SetPaConfig(0x01, 0x00, 0x01, 0x01);
 8025076:	2301      	movs	r3, #1
 8025078:	2201      	movs	r2, #1
 802507a:	2100      	movs	r1, #0
 802507c:	2001      	movs	r0, #1
 802507e:	f7ff fee5 	bl	8024e4c <SUBGRF_SetPaConfig>
            power = 0x0D - (max_power - power);
 8025082:	1b65      	subs	r5, r4, r5
 8025084:	350d      	adds	r5, #13
 8025086:	b26d      	sxtb	r5, r5
 8025088:	e7e1      	b.n	802504e <SUBGRF_SetTxParams+0x9a>
            SUBGRF_SetPaConfig(0x03, 0x05, 0x00, 0x01);
 802508a:	2301      	movs	r3, #1
 802508c:	2200      	movs	r2, #0
 802508e:	2105      	movs	r1, #5
 8025090:	2003      	movs	r0, #3
 8025092:	f7ff fedb 	bl	8024e4c <SUBGRF_SetPaConfig>
            power = 0x16 - (max_power - power);
 8025096:	1b65      	subs	r5, r4, r5
 8025098:	3516      	adds	r5, #22
 802509a:	b26d      	sxtb	r5, r5
 802509c:	e7b0      	b.n	8025000 <SUBGRF_SetTxParams+0x4c>
            SUBGRF_SetPaConfig(0x02, 0x03, 0x00, 0x01);
 802509e:	2301      	movs	r3, #1
 80250a0:	2200      	movs	r2, #0
 80250a2:	2103      	movs	r1, #3
 80250a4:	2002      	movs	r0, #2
 80250a6:	f7ff fed1 	bl	8024e4c <SUBGRF_SetPaConfig>
            power = 0x16 - (max_power - power);
 80250aa:	1b65      	subs	r5, r4, r5
 80250ac:	3516      	adds	r5, #22
 80250ae:	b26d      	sxtb	r5, r5
 80250b0:	e7a6      	b.n	8025000 <SUBGRF_SetTxParams+0x4c>
            SUBGRF_SetPaConfig(0x02, 0x02, 0x00, 0x01);
 80250b2:	2301      	movs	r3, #1
 80250b4:	2200      	movs	r2, #0
 80250b6:	2102      	movs	r1, #2
 80250b8:	2002      	movs	r0, #2
 80250ba:	f7ff fec7 	bl	8024e4c <SUBGRF_SetPaConfig>
            power = 0x0E - (max_power - power);
 80250be:	1b65      	subs	r5, r4, r5
 80250c0:	350e      	adds	r5, #14
 80250c2:	b26d      	sxtb	r5, r5
 80250c4:	e79c      	b.n	8025000 <SUBGRF_SetTxParams+0x4c>
 80250c6:	46c0      	nop			@ (mov r8, r8)
 80250c8:	000008d8 	.word	0x000008d8
 80250cc:	000008e7 	.word	0x000008e7

080250d0 <SUBGRF_SetModulationParams>:
{
 80250d0:	b530      	push	{r4, r5, lr}
 80250d2:	b083      	sub	sp, #12
 80250d4:	0004      	movs	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 80250d6:	466a      	mov	r2, sp
 80250d8:	4b35      	ldr	r3, [pc, #212]	@ (80251b0 <SUBGRF_SetModulationParams+0xe0>)
 80250da:	cb21      	ldmia	r3!, {r0, r5}
 80250dc:	c221      	stmia	r2!, {r0, r5}
    if( PacketType != modulationParams->PacketType )
 80250de:	7820      	ldrb	r0, [r4, #0]
 80250e0:	4b34      	ldr	r3, [pc, #208]	@ (80251b4 <SUBGRF_SetModulationParams+0xe4>)
 80250e2:	781b      	ldrb	r3, [r3, #0]
 80250e4:	4298      	cmp	r0, r3
 80250e6:	d116      	bne.n	8025116 <SUBGRF_SetModulationParams+0x46>
    switch( modulationParams->PacketType )
 80250e8:	7823      	ldrb	r3, [r4, #0]
 80250ea:	2b02      	cmp	r3, #2
 80250ec:	d04e      	beq.n	802518c <SUBGRF_SetModulationParams+0xbc>
 80250ee:	d815      	bhi.n	802511c <SUBGRF_SetModulationParams+0x4c>
 80250f0:	2b00      	cmp	r3, #0
 80250f2:	d029      	beq.n	8025148 <SUBGRF_SetModulationParams+0x78>
 80250f4:	2b01      	cmp	r3, #1
 80250f6:	d147      	bne.n	8025188 <SUBGRF_SetModulationParams+0xb8>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 80250f8:	7e23      	ldrb	r3, [r4, #24]
 80250fa:	466a      	mov	r2, sp
 80250fc:	7013      	strb	r3, [r2, #0]
        buf[1] = modulationParams->Params.LoRa.Bandwidth;
 80250fe:	7e63      	ldrb	r3, [r4, #25]
 8025100:	7053      	strb	r3, [r2, #1]
        buf[2] = modulationParams->Params.LoRa.CodingRate;
 8025102:	7ea3      	ldrb	r3, [r4, #26]
 8025104:	7093      	strb	r3, [r2, #2]
        buf[3] = modulationParams->Params.LoRa.LowDatarateOptimize;
 8025106:	7ee3      	ldrb	r3, [r4, #27]
 8025108:	70d3      	strb	r3, [r2, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 802510a:	2204      	movs	r2, #4
 802510c:	4669      	mov	r1, sp
 802510e:	208b      	movs	r0, #139	@ 0x8b
 8025110:	f7ff fcee 	bl	8024af0 <SUBGRF_WriteCommand>
        break;
 8025114:	e038      	b.n	8025188 <SUBGRF_SetModulationParams+0xb8>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 8025116:	f7ff ff33 	bl	8024f80 <SUBGRF_SetPacketType>
 802511a:	e7e5      	b.n	80250e8 <SUBGRF_SetModulationParams+0x18>
    switch( modulationParams->PacketType )
 802511c:	2b03      	cmp	r3, #3
 802511e:	d133      	bne.n	8025188 <SUBGRF_SetModulationParams+0xb8>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 8025120:	6861      	ldr	r1, [r4, #4]
 8025122:	4825      	ldr	r0, [pc, #148]	@ (80251b8 <SUBGRF_SetModulationParams+0xe8>)
 8025124:	f7fa fff8 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8025128:	0c03      	lsrs	r3, r0, #16
 802512a:	466a      	mov	r2, sp
 802512c:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 802512e:	0a03      	lsrs	r3, r0, #8
 8025130:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 8025132:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 8025134:	7b23      	ldrb	r3, [r4, #12]
 8025136:	70d3      	strb	r3, [r2, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 8025138:	7b63      	ldrb	r3, [r4, #13]
 802513a:	7113      	strb	r3, [r2, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 802513c:	2205      	movs	r2, #5
 802513e:	4669      	mov	r1, sp
 8025140:	208b      	movs	r0, #139	@ 0x8b
 8025142:	f7ff fcd5 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8025146:	e01f      	b.n	8025188 <SUBGRF_SetModulationParams+0xb8>
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 8025148:	6861      	ldr	r1, [r4, #4]
 802514a:	481b      	ldr	r0, [pc, #108]	@ (80251b8 <SUBGRF_SetModulationParams+0xe8>)
 802514c:	f7fa ffe4 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8025150:	0c03      	lsrs	r3, r0, #16
 8025152:	466a      	mov	r2, sp
 8025154:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 8025156:	0a03      	lsrs	r3, r0, #8
 8025158:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 802515a:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 802515c:	7b23      	ldrb	r3, [r4, #12]
 802515e:	70d3      	strb	r3, [r2, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 8025160:	7b63      	ldrb	r3, [r4, #13]
 8025162:	7113      	strb	r3, [r2, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 8025164:	68a0      	ldr	r0, [r4, #8]
 8025166:	09c1      	lsrs	r1, r0, #7
 8025168:	0640      	lsls	r0, r0, #25
 802516a:	4a14      	ldr	r2, [pc, #80]	@ (80251bc <SUBGRF_SetModulationParams+0xec>)
 802516c:	2300      	movs	r3, #0
 802516e:	f7fb f949 	bl	8020404 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 8025172:	0c03      	lsrs	r3, r0, #16
 8025174:	466a      	mov	r2, sp
 8025176:	7153      	strb	r3, [r2, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 8025178:	0a03      	lsrs	r3, r0, #8
 802517a:	7193      	strb	r3, [r2, #6]
        buf[7] = ( tempVal& 0xFF );
 802517c:	71d0      	strb	r0, [r2, #7]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 802517e:	2208      	movs	r2, #8
 8025180:	4669      	mov	r1, sp
 8025182:	208b      	movs	r0, #139	@ 0x8b
 8025184:	f7ff fcb4 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8025188:	b003      	add	sp, #12
 802518a:	bd30      	pop	{r4, r5, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 802518c:	6921      	ldr	r1, [r4, #16]
 802518e:	480a      	ldr	r0, [pc, #40]	@ (80251b8 <SUBGRF_SetModulationParams+0xe8>)
 8025190:	f7fa ffc2 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8025194:	0c03      	lsrs	r3, r0, #16
 8025196:	466a      	mov	r2, sp
 8025198:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 802519a:	0a03      	lsrs	r3, r0, #8
 802519c:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 802519e:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 80251a0:	7d23      	ldrb	r3, [r4, #20]
 80251a2:	70d3      	strb	r3, [r2, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 80251a4:	2204      	movs	r2, #4
 80251a6:	4669      	mov	r1, sp
 80251a8:	208b      	movs	r0, #139	@ 0x8b
 80251aa:	f7ff fca1 	bl	8024af0 <SUBGRF_WriteCommand>
        break;
 80251ae:	e7eb      	b.n	8025188 <SUBGRF_SetModulationParams+0xb8>
 80251b0:	08026318 	.word	0x08026318
 80251b4:	2000a329 	.word	0x2000a329
 80251b8:	3d090000 	.word	0x3d090000
 80251bc:	01e84800 	.word	0x01e84800

080251c0 <SUBGRF_SetPacketParams>:
{
 80251c0:	b530      	push	{r4, r5, lr}
 80251c2:	b085      	sub	sp, #20
 80251c4:	0004      	movs	r4, r0
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 80251c6:	aa01      	add	r2, sp, #4
 80251c8:	4b2d      	ldr	r3, [pc, #180]	@ (8025280 <SUBGRF_SetPacketParams+0xc0>)
 80251ca:	cb21      	ldmia	r3!, {r0, r5}
 80251cc:	c221      	stmia	r2!, {r0, r5}
 80251ce:	781b      	ldrb	r3, [r3, #0]
 80251d0:	7013      	strb	r3, [r2, #0]
    if( PacketType != packetParams->PacketType )
 80251d2:	7820      	ldrb	r0, [r4, #0]
 80251d4:	4b2b      	ldr	r3, [pc, #172]	@ (8025284 <SUBGRF_SetPacketParams+0xc4>)
 80251d6:	781b      	ldrb	r3, [r3, #0]
 80251d8:	4298      	cmp	r0, r3
 80251da:	d118      	bne.n	802520e <SUBGRF_SetPacketParams+0x4e>
    switch( packetParams->PacketType )
 80251dc:	7823      	ldrb	r3, [r4, #0]
 80251de:	2b02      	cmp	r3, #2
 80251e0:	d048      	beq.n	8025274 <SUBGRF_SetPacketParams+0xb4>
 80251e2:	d817      	bhi.n	8025214 <SUBGRF_SetPacketParams+0x54>
 80251e4:	2b00      	cmp	r3, #0
 80251e6:	d017      	beq.n	8025218 <SUBGRF_SetPacketParams+0x58>
 80251e8:	2b01      	cmp	r3, #1
 80251ea:	d131      	bne.n	8025250 <SUBGRF_SetPacketParams+0x90>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 80251ec:	89e2      	ldrh	r2, [r4, #14]
 80251ee:	ab01      	add	r3, sp, #4
 80251f0:	0a11      	lsrs	r1, r2, #8
 80251f2:	7019      	strb	r1, [r3, #0]
        buf[1] = packetParams->Params.LoRa.PreambleLength;
 80251f4:	705a      	strb	r2, [r3, #1]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 80251f6:	7c22      	ldrb	r2, [r4, #16]
 80251f8:	4923      	ldr	r1, [pc, #140]	@ (8025288 <SUBGRF_SetPacketParams+0xc8>)
 80251fa:	700a      	strb	r2, [r1, #0]
 80251fc:	709a      	strb	r2, [r3, #2]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 80251fe:	7c62      	ldrb	r2, [r4, #17]
 8025200:	70da      	strb	r2, [r3, #3]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 8025202:	7ca2      	ldrb	r2, [r4, #18]
 8025204:	711a      	strb	r2, [r3, #4]
        buf[5] = packetParams->Params.LoRa.InvertIQ;
 8025206:	7ce2      	ldrb	r2, [r4, #19]
 8025208:	715a      	strb	r2, [r3, #5]
        n = 6;
 802520a:	2206      	movs	r2, #6
        break;
 802520c:	e01c      	b.n	8025248 <SUBGRF_SetPacketParams+0x88>
        SUBGRF_SetPacketType( packetParams->PacketType );
 802520e:	f7ff feb7 	bl	8024f80 <SUBGRF_SetPacketType>
 8025212:	e7e3      	b.n	80251dc <SUBGRF_SetPacketParams+0x1c>
    switch( packetParams->PacketType )
 8025214:	2b03      	cmp	r3, #3
 8025216:	d11b      	bne.n	8025250 <SUBGRF_SetPacketParams+0x90>
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 8025218:	7a62      	ldrb	r2, [r4, #9]
 802521a:	2af1      	cmp	r2, #241	@ 0xf1
 802521c:	d01a      	beq.n	8025254 <SUBGRF_SetPacketParams+0x94>
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 802521e:	2af2      	cmp	r2, #242	@ 0xf2
 8025220:	d020      	beq.n	8025264 <SUBGRF_SetPacketParams+0xa4>
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 8025222:	8861      	ldrh	r1, [r4, #2]
 8025224:	ab01      	add	r3, sp, #4
 8025226:	0a08      	lsrs	r0, r1, #8
 8025228:	7018      	strb	r0, [r3, #0]
        buf[1] = packetParams->Params.Gfsk.PreambleLength;
 802522a:	7059      	strb	r1, [r3, #1]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 802522c:	7921      	ldrb	r1, [r4, #4]
 802522e:	7099      	strb	r1, [r3, #2]
        buf[3] = ( packetParams->Params.Gfsk.SyncWordLength /*<< 3*/ ); // convert from byte to bit
 8025230:	7961      	ldrb	r1, [r4, #5]
 8025232:	70d9      	strb	r1, [r3, #3]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 8025234:	79a1      	ldrb	r1, [r4, #6]
 8025236:	7119      	strb	r1, [r3, #4]
        buf[5] = packetParams->Params.Gfsk.HeaderType;
 8025238:	79e1      	ldrb	r1, [r4, #7]
 802523a:	7159      	strb	r1, [r3, #5]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 802523c:	7a21      	ldrb	r1, [r4, #8]
 802523e:	7199      	strb	r1, [r3, #6]
        buf[7] = crcVal;
 8025240:	71da      	strb	r2, [r3, #7]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 8025242:	7aa2      	ldrb	r2, [r4, #10]
 8025244:	721a      	strb	r2, [r3, #8]
        n = 9;
 8025246:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 8025248:	a901      	add	r1, sp, #4
 802524a:	208c      	movs	r0, #140	@ 0x8c
 802524c:	f7ff fc50 	bl	8024af0 <SUBGRF_WriteCommand>
}
 8025250:	b005      	add	sp, #20
 8025252:	bd30      	pop	{r4, r5, pc}
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 8025254:	480d      	ldr	r0, [pc, #52]	@ (802528c <SUBGRF_SetPacketParams+0xcc>)
 8025256:	f7ff fbeb 	bl	8024a30 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 802525a:	480d      	ldr	r0, [pc, #52]	@ (8025290 <SUBGRF_SetPacketParams+0xd0>)
 802525c:	f7ff fbfc 	bl	8024a58 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 8025260:	2202      	movs	r2, #2
 8025262:	e7de      	b.n	8025222 <SUBGRF_SetPacketParams+0x62>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 8025264:	480b      	ldr	r0, [pc, #44]	@ (8025294 <SUBGRF_SetPacketParams+0xd4>)
 8025266:	f7ff fbe3 	bl	8024a30 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 802526a:	480b      	ldr	r0, [pc, #44]	@ (8025298 <SUBGRF_SetPacketParams+0xd8>)
 802526c:	f7ff fbf4 	bl	8024a58 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 8025270:	2206      	movs	r2, #6
 8025272:	e7d6      	b.n	8025222 <SUBGRF_SetPacketParams+0x62>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 8025274:	7b22      	ldrb	r2, [r4, #12]
 8025276:	ab01      	add	r3, sp, #4
 8025278:	701a      	strb	r2, [r3, #0]
        n = 1;
 802527a:	2201      	movs	r2, #1
        break;
 802527c:	e7e4      	b.n	8025248 <SUBGRF_SetPacketParams+0x88>
 802527e:	46c0      	nop			@ (mov r8, r8)
 8025280:	08026320 	.word	0x08026320
 8025284:	2000a329 	.word	0x2000a329
 8025288:	2000a328 	.word	0x2000a328
 802528c:	0000ffff 	.word	0x0000ffff
 8025290:	00008005 	.word	0x00008005
 8025294:	00001d0f 	.word	0x00001d0f
 8025298:	00001021 	.word	0x00001021

0802529c <SUBGRF_SetBufferBaseAddress>:
{
 802529c:	b500      	push	{lr}
 802529e:	b083      	sub	sp, #12
    buf[0] = txBaseAddress;
 80252a0:	466b      	mov	r3, sp
 80252a2:	7118      	strb	r0, [r3, #4]
    buf[1] = rxBaseAddress;
 80252a4:	7159      	strb	r1, [r3, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 80252a6:	2202      	movs	r2, #2
 80252a8:	a901      	add	r1, sp, #4
 80252aa:	208f      	movs	r0, #143	@ 0x8f
 80252ac:	f7ff fc20 	bl	8024af0 <SUBGRF_WriteCommand>
}
 80252b0:	b003      	add	sp, #12
 80252b2:	bd00      	pop	{pc}

080252b4 <SUBGRF_ReadCommand>:
{
 80252b4:	b570      	push	{r4, r5, r6, lr}
 80252b6:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80252b8:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80252bc:	b672      	cpsid	i
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 80252be:	4c04      	ldr	r4, [pc, #16]	@ (80252d0 <SUBGRF_ReadCommand+0x1c>)
 80252c0:	000a      	movs	r2, r1
 80252c2:	0001      	movs	r1, r0
 80252c4:	0020      	movs	r0, r4
 80252c6:	f7fd fe79 	bl	8022fbc <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80252ca:	f385 8810 	msr	PRIMASK, r5
}
 80252ce:	bd70      	pop	{r4, r5, r6, pc}
 80252d0:	2000a0b0 	.word	0x2000a0b0

080252d4 <SUBGRF_GetRssiInst>:
{
 80252d4:	b510      	push	{r4, lr}
 80252d6:	b082      	sub	sp, #8
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 80252d8:	ac01      	add	r4, sp, #4
 80252da:	2201      	movs	r2, #1
 80252dc:	0021      	movs	r1, r4
 80252de:	2015      	movs	r0, #21
 80252e0:	f7ff ffe8 	bl	80252b4 <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 80252e4:	7820      	ldrb	r0, [r4, #0]
 80252e6:	4240      	negs	r0, r0
 80252e8:	1040      	asrs	r0, r0, #1
}
 80252ea:	b002      	add	sp, #8
 80252ec:	bd10      	pop	{r4, pc}
	...

080252f0 <SUBGRF_GetRxBufferStatus>:
{
 80252f0:	b530      	push	{r4, r5, lr}
 80252f2:	b083      	sub	sp, #12
 80252f4:	0005      	movs	r5, r0
 80252f6:	000c      	movs	r4, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 80252f8:	2202      	movs	r2, #2
 80252fa:	a901      	add	r1, sp, #4
 80252fc:	2013      	movs	r0, #19
 80252fe:	f7ff ffd9 	bl	80252b4 <SUBGRF_ReadCommand>
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 8025302:	f7ff fb19 	bl	8024938 <SUBGRF_GetPacketType>
 8025306:	2801      	cmp	r0, #1
 8025308:	d007      	beq.n	802531a <SUBGRF_GetRxBufferStatus+0x2a>
        *payloadLength = status[0];
 802530a:	ab01      	add	r3, sp, #4
 802530c:	781b      	ldrb	r3, [r3, #0]
 802530e:	702b      	strb	r3, [r5, #0]
    *rxStartBufferPointer = status[1];
 8025310:	ab01      	add	r3, sp, #4
 8025312:	785b      	ldrb	r3, [r3, #1]
 8025314:	7023      	strb	r3, [r4, #0]
}
 8025316:	b003      	add	sp, #12
 8025318:	bd30      	pop	{r4, r5, pc}
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 802531a:	4b04      	ldr	r3, [pc, #16]	@ (802532c <SUBGRF_GetRxBufferStatus+0x3c>)
 802531c:	781b      	ldrb	r3, [r3, #0]
 802531e:	2b01      	cmp	r3, #1
 8025320:	d1f3      	bne.n	802530a <SUBGRF_GetRxBufferStatus+0x1a>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 8025322:	4803      	ldr	r0, [pc, #12]	@ (8025330 <SUBGRF_GetRxBufferStatus+0x40>)
 8025324:	f7ff fb22 	bl	802496c <SUBGRF_ReadRegister>
 8025328:	7028      	strb	r0, [r5, #0]
 802532a:	e7f1      	b.n	8025310 <SUBGRF_GetRxBufferStatus+0x20>
 802532c:	2000a328 	.word	0x2000a328
 8025330:	00000702 	.word	0x00000702

08025334 <SUBGRF_GetPayload>:
{
 8025334:	b570      	push	{r4, r5, r6, lr}
 8025336:	b082      	sub	sp, #8
 8025338:	0006      	movs	r6, r0
 802533a:	000c      	movs	r4, r1
 802533c:	0015      	movs	r5, r2
    uint8_t offset = 0;
 802533e:	466b      	mov	r3, sp
 8025340:	1dd9      	adds	r1, r3, #7
 8025342:	2300      	movs	r3, #0
 8025344:	700b      	strb	r3, [r1, #0]
    SUBGRF_GetRxBufferStatus( size, &offset );
 8025346:	0020      	movs	r0, r4
 8025348:	f7ff ffd2 	bl	80252f0 <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 802534c:	7822      	ldrb	r2, [r4, #0]
 802534e:	42aa      	cmp	r2, r5
 8025350:	d902      	bls.n	8025358 <SUBGRF_GetPayload+0x24>
        return 1;
 8025352:	2001      	movs	r0, #1
}
 8025354:	b002      	add	sp, #8
 8025356:	bd70      	pop	{r4, r5, r6, pc}
    SUBGRF_ReadBuffer( offset, buffer, *size );
 8025358:	466b      	mov	r3, sp
 802535a:	79d8      	ldrb	r0, [r3, #7]
 802535c:	0031      	movs	r1, r6
 802535e:	f7ff fbb7 	bl	8024ad0 <SUBGRF_ReadBuffer>
    return 0;
 8025362:	2000      	movs	r0, #0
 8025364:	e7f6      	b.n	8025354 <SUBGRF_GetPayload+0x20>
	...

08025368 <SUBGRF_GetPacketStatus>:
{
 8025368:	b510      	push	{r4, lr}
 802536a:	b082      	sub	sp, #8
 802536c:	0004      	movs	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 802536e:	2203      	movs	r2, #3
 8025370:	a901      	add	r1, sp, #4
 8025372:	2014      	movs	r0, #20
 8025374:	f7ff ff9e 	bl	80252b4 <SUBGRF_ReadCommand>
    pktStatus->packetType = SUBGRF_GetPacketType( );
 8025378:	f7ff fade 	bl	8024938 <SUBGRF_GetPacketType>
 802537c:	7020      	strb	r0, [r4, #0]
    switch( pktStatus->packetType )
 802537e:	2800      	cmp	r0, #0
 8025380:	d009      	beq.n	8025396 <SUBGRF_GetPacketStatus+0x2e>
 8025382:	2801      	cmp	r0, #1
 8025384:	d016      	beq.n	80253b4 <SUBGRF_GetPacketStatus+0x4c>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 8025386:	2214      	movs	r2, #20
 8025388:	2100      	movs	r1, #0
 802538a:	0020      	movs	r0, r4
 802538c:	f000 fb1d 	bl	80259ca <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 8025390:	230f      	movs	r3, #15
 8025392:	7023      	strb	r3, [r4, #0]
}
 8025394:	e00c      	b.n	80253b0 <SUBGRF_GetPacketStatus+0x48>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 8025396:	aa01      	add	r2, sp, #4
 8025398:	7813      	ldrb	r3, [r2, #0]
 802539a:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 802539c:	7853      	ldrb	r3, [r2, #1]
 802539e:	425b      	negs	r3, r3
 80253a0:	105b      	asrs	r3, r3, #1
 80253a2:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 80253a4:	7893      	ldrb	r3, [r2, #2]
 80253a6:	425b      	negs	r3, r3
 80253a8:	105b      	asrs	r3, r3, #1
 80253aa:	7163      	strb	r3, [r4, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 80253ac:	2300      	movs	r3, #0
 80253ae:	60a3      	str	r3, [r4, #8]
}
 80253b0:	b002      	add	sp, #8
 80253b2:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 80253b4:	aa01      	add	r2, sp, #4
 80253b6:	7813      	ldrb	r3, [r2, #0]
 80253b8:	425b      	negs	r3, r3
 80253ba:	105b      	asrs	r3, r3, #1
 80253bc:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 80253be:	2301      	movs	r3, #1
 80253c0:	56d3      	ldrsb	r3, [r2, r3]
 80253c2:	3302      	adds	r3, #2
 80253c4:	109b      	asrs	r3, r3, #2
 80253c6:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 80253c8:	7893      	ldrb	r3, [r2, #2]
 80253ca:	425b      	negs	r3, r3
 80253cc:	105b      	asrs	r3, r3, #1
 80253ce:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 80253d0:	4b01      	ldr	r3, [pc, #4]	@ (80253d8 <SUBGRF_GetPacketStatus+0x70>)
 80253d2:	681b      	ldr	r3, [r3, #0]
 80253d4:	6123      	str	r3, [r4, #16]
            break;
 80253d6:	e7eb      	b.n	80253b0 <SUBGRF_GetPacketStatus+0x48>
 80253d8:	2000a324 	.word	0x2000a324

080253dc <SUBGRF_SetSwitch>:
{
 80253dc:	b510      	push	{r4, lr}
 80253de:	0004      	movs	r4, r0
 80253e0:	0008      	movs	r0, r1
    if (rxtx == RFSWITCH_TX)
 80253e2:	2901      	cmp	r1, #1
 80253e4:	d003      	beq.n	80253ee <SUBGRF_SetSwitch+0x12>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 80253e6:	2001      	movs	r0, #1
    RBI_ConfigRFSwitch(state);
 80253e8:	f7fc fa6d 	bl	80218c6 <RBI_ConfigRFSwitch>
}
 80253ec:	bd10      	pop	{r4, pc}
        if (paSelect == RFO_LP)
 80253ee:	2c01      	cmp	r4, #1
 80253f0:	d003      	beq.n	80253fa <SUBGRF_SetSwitch+0x1e>
        if (paSelect == RFO_HP)
 80253f2:	2c02      	cmp	r4, #2
 80253f4:	d1f8      	bne.n	80253e8 <SUBGRF_SetSwitch+0xc>
            state = RBI_SWITCH_RFO_HP;
 80253f6:	2003      	movs	r0, #3
 80253f8:	e7f6      	b.n	80253e8 <SUBGRF_SetSwitch+0xc>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 80253fa:	3003      	adds	r0, #3
 80253fc:	f7ff facc 	bl	8024998 <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 8025400:	2002      	movs	r0, #2
 8025402:	e7f6      	b.n	80253f2 <SUBGRF_SetSwitch+0x16>

08025404 <SUBGRF_SetRfTxPower>:
{
 8025404:	b570      	push	{r4, r5, r6, lr}
 8025406:	0004      	movs	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 8025408:	f7fc fa61 	bl	80218ce <RBI_GetTxConfig>
    switch (TxConfig)
 802540c:	2800      	cmp	r0, #0
 802540e:	d009      	beq.n	8025424 <SUBGRF_SetRfTxPower+0x20>
 8025410:	2802      	cmp	r0, #2
 8025412:	d10d      	bne.n	8025430 <SUBGRF_SetRfTxPower+0x2c>
            paSelect = RFO_HP;
 8025414:	2502      	movs	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 8025416:	2202      	movs	r2, #2
 8025418:	0021      	movs	r1, r4
 802541a:	0028      	movs	r0, r5
 802541c:	f7ff fdca 	bl	8024fb4 <SUBGRF_SetTxParams>
}
 8025420:	0028      	movs	r0, r5
 8025422:	bd70      	pop	{r4, r5, r6, pc}
            if (power > 15)
 8025424:	2c0f      	cmp	r4, #15
 8025426:	dc01      	bgt.n	802542c <SUBGRF_SetRfTxPower+0x28>
                paSelect = RFO_LP;
 8025428:	2501      	movs	r5, #1
 802542a:	e7f4      	b.n	8025416 <SUBGRF_SetRfTxPower+0x12>
                paSelect = RFO_HP;
 802542c:	2502      	movs	r5, #2
 802542e:	e7f2      	b.n	8025416 <SUBGRF_SetRfTxPower+0x12>
    switch (TxConfig)
 8025430:	2501      	movs	r5, #1
 8025432:	e7f0      	b.n	8025416 <SUBGRF_SetRfTxPower+0x12>

08025434 <SUBGRF_GetRadioWakeUpTime>:
}
 8025434:	2001      	movs	r0, #1
 8025436:	4770      	bx	lr

08025438 <HAL_SUBGHZ_TxCpltCallback>:
{
 8025438:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_TX_DONE );
 802543a:	4b02      	ldr	r3, [pc, #8]	@ (8025444 <HAL_SUBGHZ_TxCpltCallback+0xc>)
 802543c:	681b      	ldr	r3, [r3, #0]
 802543e:	2001      	movs	r0, #1
 8025440:	4798      	blx	r3
}
 8025442:	bd10      	pop	{r4, pc}
 8025444:	2000a31c 	.word	0x2000a31c

08025448 <HAL_SUBGHZ_RxCpltCallback>:
{
 8025448:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_RX_DONE );
 802544a:	4b02      	ldr	r3, [pc, #8]	@ (8025454 <HAL_SUBGHZ_RxCpltCallback+0xc>)
 802544c:	681b      	ldr	r3, [r3, #0]
 802544e:	2002      	movs	r0, #2
 8025450:	4798      	blx	r3
}
 8025452:	bd10      	pop	{r4, pc}
 8025454:	2000a31c 	.word	0x2000a31c

08025458 <HAL_SUBGHZ_CRCErrorCallback>:
{
 8025458:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 802545a:	4b02      	ldr	r3, [pc, #8]	@ (8025464 <HAL_SUBGHZ_CRCErrorCallback+0xc>)
 802545c:	681b      	ldr	r3, [r3, #0]
 802545e:	2040      	movs	r0, #64	@ 0x40
 8025460:	4798      	blx	r3
}
 8025462:	bd10      	pop	{r4, pc}
 8025464:	2000a31c 	.word	0x2000a31c

08025468 <HAL_SUBGHZ_CADStatusCallback>:
{
 8025468:	b510      	push	{r4, lr}
    switch (cadstatus)
 802546a:	2900      	cmp	r1, #0
 802546c:	d002      	beq.n	8025474 <HAL_SUBGHZ_CADStatusCallback+0xc>
 802546e:	2901      	cmp	r1, #1
 8025470:	d005      	beq.n	802547e <HAL_SUBGHZ_CADStatusCallback+0x16>
}
 8025472:	bd10      	pop	{r4, pc}
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 8025474:	4b05      	ldr	r3, [pc, #20]	@ (802548c <HAL_SUBGHZ_CADStatusCallback+0x24>)
 8025476:	681b      	ldr	r3, [r3, #0]
 8025478:	2080      	movs	r0, #128	@ 0x80
 802547a:	4798      	blx	r3
            break;
 802547c:	e7f9      	b.n	8025472 <HAL_SUBGHZ_CADStatusCallback+0xa>
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 802547e:	2080      	movs	r0, #128	@ 0x80
 8025480:	4b02      	ldr	r3, [pc, #8]	@ (802548c <HAL_SUBGHZ_CADStatusCallback+0x24>)
 8025482:	681b      	ldr	r3, [r3, #0]
 8025484:	0040      	lsls	r0, r0, #1
 8025486:	4798      	blx	r3
}
 8025488:	e7f3      	b.n	8025472 <HAL_SUBGHZ_CADStatusCallback+0xa>
 802548a:	46c0      	nop			@ (mov r8, r8)
 802548c:	2000a31c 	.word	0x2000a31c

08025490 <HAL_SUBGHZ_RxTxTimeoutCallback>:
{
 8025490:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 8025492:	2080      	movs	r0, #128	@ 0x80
 8025494:	4b02      	ldr	r3, [pc, #8]	@ (80254a0 <HAL_SUBGHZ_RxTxTimeoutCallback+0x10>)
 8025496:	681b      	ldr	r3, [r3, #0]
 8025498:	0080      	lsls	r0, r0, #2
 802549a:	4798      	blx	r3
}
 802549c:	bd10      	pop	{r4, pc}
 802549e:	46c0      	nop			@ (mov r8, r8)
 80254a0:	2000a31c 	.word	0x2000a31c

080254a4 <HAL_SUBGHZ_HeaderErrorCallback>:
{
 80254a4:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 80254a6:	4b02      	ldr	r3, [pc, #8]	@ (80254b0 <HAL_SUBGHZ_HeaderErrorCallback+0xc>)
 80254a8:	681b      	ldr	r3, [r3, #0]
 80254aa:	2020      	movs	r0, #32
 80254ac:	4798      	blx	r3
}
 80254ae:	bd10      	pop	{r4, pc}
 80254b0:	2000a31c 	.word	0x2000a31c

080254b4 <HAL_SUBGHZ_PreambleDetectedCallback>:
{
 80254b4:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 80254b6:	4b02      	ldr	r3, [pc, #8]	@ (80254c0 <HAL_SUBGHZ_PreambleDetectedCallback+0xc>)
 80254b8:	681b      	ldr	r3, [r3, #0]
 80254ba:	2004      	movs	r0, #4
 80254bc:	4798      	blx	r3
}
 80254be:	bd10      	pop	{r4, pc}
 80254c0:	2000a31c 	.word	0x2000a31c

080254c4 <HAL_SUBGHZ_SyncWordValidCallback>:
{
 80254c4:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 80254c6:	4b02      	ldr	r3, [pc, #8]	@ (80254d0 <HAL_SUBGHZ_SyncWordValidCallback+0xc>)
 80254c8:	681b      	ldr	r3, [r3, #0]
 80254ca:	2008      	movs	r0, #8
 80254cc:	4798      	blx	r3
}
 80254ce:	bd10      	pop	{r4, pc}
 80254d0:	2000a31c 	.word	0x2000a31c

080254d4 <HAL_SUBGHZ_HeaderValidCallback>:
{
 80254d4:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 80254d6:	4b02      	ldr	r3, [pc, #8]	@ (80254e0 <HAL_SUBGHZ_HeaderValidCallback+0xc>)
 80254d8:	681b      	ldr	r3, [r3, #0]
 80254da:	2010      	movs	r0, #16
 80254dc:	4798      	blx	r3
}
 80254de:	bd10      	pop	{r4, pc}
 80254e0:	2000a31c 	.word	0x2000a31c

080254e4 <HAL_SUBGHZ_LrFhssHopCallback>:
{
 80254e4:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_LR_FHSS_HOP );
 80254e6:	2080      	movs	r0, #128	@ 0x80
 80254e8:	4b02      	ldr	r3, [pc, #8]	@ (80254f4 <HAL_SUBGHZ_LrFhssHopCallback+0x10>)
 80254ea:	681b      	ldr	r3, [r3, #0]
 80254ec:	01c0      	lsls	r0, r0, #7
 80254ee:	4798      	blx	r3
}
 80254f0:	bd10      	pop	{r4, pc}
 80254f2:	46c0      	nop			@ (mov r8, r8)
 80254f4:	2000a31c 	.word	0x2000a31c

080254f8 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
    uint8_t i;

    if( bandwidth == 0 )
 80254f8:	2800      	cmp	r0, #0
 80254fa:	d00f      	beq.n	802551c <SUBGRF_GetFskBandwidthRegValue+0x24>
    {
        return( 0x1F );
    }

    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 80254fc:	2300      	movs	r3, #0
 80254fe:	2b15      	cmp	r3, #21
 8025500:	d80b      	bhi.n	802551a <SUBGRF_GetFskBandwidthRegValue+0x22>
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 8025502:	4a07      	ldr	r2, [pc, #28]	@ (8025520 <SUBGRF_GetFskBandwidthRegValue+0x28>)
 8025504:	00d9      	lsls	r1, r3, #3
 8025506:	588a      	ldr	r2, [r1, r2]
 8025508:	4282      	cmp	r2, r0
 802550a:	d802      	bhi.n	8025512 <SUBGRF_GetFskBandwidthRegValue+0x1a>
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 802550c:	3301      	adds	r3, #1
 802550e:	b2db      	uxtb	r3, r3
 8025510:	e7f5      	b.n	80254fe <SUBGRF_GetFskBandwidthRegValue+0x6>
        {
            return FskBandwidths[i].RegValue;
 8025512:	4a03      	ldr	r2, [pc, #12]	@ (8025520 <SUBGRF_GetFskBandwidthRegValue+0x28>)
 8025514:	1852      	adds	r2, r2, r1
 8025516:	7910      	ldrb	r0, [r2, #4]
        }
    }
    // ERROR: Value not found
    while( 1 );
}
 8025518:	4770      	bx	lr
    while( 1 );
 802551a:	e7fe      	b.n	802551a <SUBGRF_GetFskBandwidthRegValue+0x22>
        return( 0x1F );
 802551c:	201f      	movs	r0, #31
 802551e:	e7fb      	b.n	8025518 <SUBGRF_GetFskBandwidthRegValue+0x20>
 8025520:	08026754 	.word	0x08026754

08025524 <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 8025524:	b570      	push	{r4, r5, r6, lr}
 8025526:	b082      	sub	sp, #8
 8025528:	0006      	movs	r6, r0
 802552a:	000c      	movs	r4, r1
  uint8_t BwMant[] = {4, 8, 10, 12};
 802552c:	4b1a      	ldr	r3, [pc, #104]	@ (8025598 <SUBGRF_GetCFO+0x74>)
 802552e:	9301      	str	r3, [sp, #4]
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSELR ));
 8025530:	481a      	ldr	r0, [pc, #104]	@ (802559c <SUBGRF_GetCFO+0x78>)
 8025532:	f7ff fa1b 	bl	802496c <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 8025536:	08c3      	lsrs	r3, r0, #3
 8025538:	2203      	movs	r2, #3
 802553a:	4013      	ands	r3, r2
 802553c:	aa01      	add	r2, sp, #4
 802553e:	5cd1      	ldrb	r1, [r2, r3]
  uint8_t bandwidth_exp = reg & 0x7;
 8025540:	2307      	movs	r3, #7
 8025542:	4003      	ands	r3, r0
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp + 1 )));
 8025544:	3301      	adds	r3, #1
 8025546:	4099      	lsls	r1, r3
 8025548:	4815      	ldr	r0, [pc, #84]	@ (80255a0 <SUBGRF_GetCFO+0x7c>)
 802554a:	f7fa fde5 	bl	8020118 <__udivsi3>
 802554e:	0005      	movs	r5, r0
  uint32_t cf_osr = cf_fs / bitRate;
 8025550:	0031      	movs	r1, r6
 8025552:	f7fa fde1 	bl	8020118 <__udivsi3>
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 8025556:	2807      	cmp	r0, #7
 8025558:	d91b      	bls.n	8025592 <SUBGRF_GetCFO+0x6e>
  uint8_t interp = 1;
 802555a:	2601      	movs	r6, #1
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 802555c:	4370      	muls	r0, r6
 802555e:	2803      	cmp	r0, #3
 8025560:	d800      	bhi.n	8025564 <SUBGRF_GetCFO+0x40>
  {
    interp = 4;
 8025562:	2604      	movs	r6, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
 8025564:	436e      	muls	r6, r5
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_GCFORH ) & 0xF ) << 8;
 8025566:	20d6      	movs	r0, #214	@ 0xd6
 8025568:	00c0      	lsls	r0, r0, #3
 802556a:	f7ff f9ff 	bl	802496c <SUBGRF_ReadRegister>
 802556e:	0205      	lsls	r5, r0, #8
 8025570:	23f0      	movs	r3, #240	@ 0xf0
 8025572:	011b      	lsls	r3, r3, #4
 8025574:	401d      	ands	r5, r3
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_GCFORL );
 8025576:	480b      	ldr	r0, [pc, #44]	@ (80255a4 <SUBGRF_GetCFO+0x80>)
 8025578:	f7ff f9f8 	bl	802496c <SUBGRF_ReadRegister>
 802557c:	4305      	orrs	r5, r0
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 802557e:	052a      	lsls	r2, r5, #20
 8025580:	d501      	bpl.n	8025586 <SUBGRF_GetCFO+0x62>
  {
    cfo_bin |= 0xFFFFF000;
 8025582:	4a09      	ldr	r2, [pc, #36]	@ (80255a8 <SUBGRF_GetCFO+0x84>)
 8025584:	4315      	orrs	r5, r2
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 8025586:	0970      	lsrs	r0, r6, #5
 8025588:	4368      	muls	r0, r5
 802558a:	11c0      	asrs	r0, r0, #7
 802558c:	6020      	str	r0, [r4, #0]
}
 802558e:	b002      	add	sp, #8
 8025590:	bd70      	pop	{r4, r5, r6, pc}
    interp = 2;
 8025592:	2602      	movs	r6, #2
 8025594:	e7e2      	b.n	802555c <SUBGRF_GetCFO+0x38>
 8025596:	46c0      	nop			@ (mov r8, r8)
 8025598:	0c0a0804 	.word	0x0c0a0804
 802559c:	00000807 	.word	0x00000807
 80255a0:	01e84800 	.word	0x01e84800
 80255a4:	000006b1 	.word	0x000006b1
 80255a8:	fffff000 	.word	0xfffff000

080255ac <RFW_TransmitLongPacket>:
        }
    }
#else
    status = -1;
#endif /* RFW_LONGPACKET_ENABLE == 1 */
    return status;
 80255ac:	2001      	movs	r0, #1
}
 80255ae:	4240      	negs	r0, r0
 80255b0:	4770      	bx	lr

080255b2 <RFW_ReceiveLongPacket>:
        }
    }
#else
    status = -1;
#endif /* RFW_LONGPACKET_ENABLE == 1 */
    return status;
 80255b2:	2001      	movs	r0, #1
}
 80255b4:	4240      	negs	r0, r0
 80255b6:	4770      	bx	lr

080255b8 <RFW_Init>:
    RFWPacket.Init.Enable = 1;
    /* Initialize Timer for end of fixed packet, started at sync*/
    TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
    return 0;
#else
    return -1;
 80255b8:	2001      	movs	r0, #1
#endif /* RFW_ENABLE == 1 */
}
 80255ba:	4240      	negs	r0, r0
 80255bc:	4770      	bx	lr

080255be <RFW_DeInit>:
void RFW_DeInit( void )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.Init.Enable = 0; /*Disable the RFWPacket decoding*/
#endif /* RFW_ENABLE == 1 */
}
 80255be:	4770      	bx	lr

080255c0 <RFW_Is_Init>:
#if (RFW_ENABLE == 1 )
    return RFWPacket.Init.Enable;
#else
    return 0;
#endif /* RFW_ENABLE == 1 */
}
 80255c0:	2000      	movs	r0, #0
 80255c2:	4770      	bx	lr

080255c4 <RFW_Is_LongPacketModeEnabled>:
#if (RFW_ENABLE == 1 )
    return RFWPacket.LongPacketModeEnable;
#else
    return 0;
#endif /* RFW_ENABLE == 1 */
}
 80255c4:	2000      	movs	r0, #0
 80255c6:	4770      	bx	lr

080255c8 <RFW_SetAntSwitch>:
void RFW_SetAntSwitch( uint8_t AntSwitch )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.AntSwitchPaSelect = AntSwitch;
#endif /* RFW_ENABLE == 1 */
}
 80255c8:	4770      	bx	lr

080255ca <RFW_TransmitInit>:
        RFWPacket.LongPacketModeEnable = 0;

        status = 0;
    }
#endif /* RFW_ENABLE == 1 */
    return status;
 80255ca:	2001      	movs	r0, #1
}
 80255cc:	4240      	negs	r0, r0
 80255ce:	4770      	bx	lr

080255d0 <RFW_ReceiveInit>:
    RFWPacket.RxPayloadOffset = 0;

    RFWPacket.LongPacketModeEnable = 0;
    return 0;
#else
    return -1;
 80255d0:	2001      	movs	r0, #1
#endif /* RFW_ENABLE == 1 */
}
 80255d2:	4240      	negs	r0, r0
 80255d4:	4770      	bx	lr

080255d6 <RFW_DeInit_TxLongPacket>:
    /*long packet WA*/
    uint8_t reg = SUBGRF_ReadRegister( SUBGHZ_GPKTCTL1AR );
    SUBGRF_WriteRegister( SUBGHZ_GPKTCTL1AR, reg & ~0x02 ); /* clear infinite_sequence bit */
    SUBGRF_WriteRegister( SUBGHZ_GRTXPLDLEN, 0xFF ); /* RxTxPldLen: reset to 0xFF */
#endif /* RFW_LONGPACKET_ENABLE == 1 */
}
 80255d6:	4770      	bx	lr

080255d8 <RFW_ReceivePayload>:
        /*timeout*/
        SUBGRF_SetStandby( STDBY_RC );
        RFWPacket.Init.RadioEvents->RxTimeout( );
    }
#endif /* RFW_ENABLE == 1 */
}
 80255d8:	4770      	bx	lr

080255da <RFW_SetRadioModem>:
void RFW_SetRadioModem( RadioModems_t Modem )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.Init.Modem = Modem;
#endif /* RFW_ENABLE == 1 */
}
 80255da:	4770      	bx	lr

080255dc <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 80255dc:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80255de:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80255e2:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 80255e4:	4b1b      	ldr	r3, [pc, #108]	@ (8025654 <TRACE_AllocateBufer+0x78>)
 80255e6:	8a5d      	ldrh	r5, [r3, #18]
 80255e8:	8a1a      	ldrh	r2, [r3, #16]
 80255ea:	4295      	cmp	r5, r2
 80255ec:	d010      	beq.n	8025610 <TRACE_AllocateBufer+0x34>
#endif
  }
  else
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 80255ee:	d91f      	bls.n	8025630 <TRACE_AllocateBufer+0x54>
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 80255f0:	2380      	movs	r3, #128	@ 0x80
 80255f2:	009b      	lsls	r3, r3, #2
 80255f4:	1b5b      	subs	r3, r3, r5
 80255f6:	b29b      	uxth	r3, r3
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 80255f8:	4283      	cmp	r3, r0
 80255fa:	d81b      	bhi.n	8025634 <TRACE_AllocateBufer+0x58>
 80255fc:	4282      	cmp	r2, r0
 80255fe:	d919      	bls.n	8025634 <TRACE_AllocateBufer+0x58>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8025600:	4b14      	ldr	r3, [pc, #80]	@ (8025654 <TRACE_AllocateBufer+0x78>)
 8025602:	2601      	movs	r6, #1
 8025604:	709e      	strb	r6, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8025606:	801d      	strh	r5, [r3, #0]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 8025608:	2500      	movs	r5, #0
 802560a:	825d      	strh	r5, [r3, #18]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
 802560c:	0013      	movs	r3, r2
 802560e:	e011      	b.n	8025634 <TRACE_AllocateBufer+0x58>
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 8025610:	2380      	movs	r3, #128	@ 0x80
 8025612:	009b      	lsls	r3, r3, #2
 8025614:	1b5b      	subs	r3, r3, r5
 8025616:	b29b      	uxth	r3, r3
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 8025618:	4298      	cmp	r0, r3
 802561a:	d30b      	bcc.n	8025634 <TRACE_AllocateBufer+0x58>
 802561c:	4282      	cmp	r2, r0
 802561e:	d909      	bls.n	8025634 <TRACE_AllocateBufer+0x58>
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8025620:	4b0c      	ldr	r3, [pc, #48]	@ (8025654 <TRACE_AllocateBufer+0x78>)
 8025622:	2601      	movs	r6, #1
 8025624:	709e      	strb	r6, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8025626:	801d      	strh	r5, [r3, #0]
      ADV_TRACE_Ctx.TraceWrPtr = 0;
 8025628:	2500      	movs	r5, #0
 802562a:	825d      	strh	r5, [r3, #18]
      freesize = ADV_TRACE_Ctx.TraceRdPtr;
 802562c:	0013      	movs	r3, r2
 802562e:	e001      	b.n	8025634 <TRACE_AllocateBufer+0x58>
      }
    }
    else
    {
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 8025630:	1b52      	subs	r2, r2, r5
 8025632:	b293      	uxth	r3, r2
      freesize = ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr;
    }
#endif
  }

  if(freesize > Size)
 8025634:	4283      	cmp	r3, r0
 8025636:	d90a      	bls.n	802564e <TRACE_AllocateBufer+0x72>
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 8025638:	4a06      	ldr	r2, [pc, #24]	@ (8025654 <TRACE_AllocateBufer+0x78>)
 802563a:	8a53      	ldrh	r3, [r2, #18]
 802563c:	800b      	strh	r3, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 802563e:	181b      	adds	r3, r3, r0
 8025640:	05db      	lsls	r3, r3, #23
 8025642:	0ddb      	lsrs	r3, r3, #23
 8025644:	8253      	strh	r3, [r2, #18]
    ret = 0;
 8025646:	2000      	movs	r0, #0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025648:	f384 8810 	msr	PRIMASK, r4
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 802564c:	bd70      	pop	{r4, r5, r6, pc}
  int16_t ret = -1;
 802564e:	2001      	movs	r0, #1
 8025650:	4240      	negs	r0, r0
 8025652:	e7f9      	b.n	8025648 <TRACE_AllocateBufer+0x6c>
 8025654:	2000a42c 	.word	0x2000a42c

08025658 <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025658:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802565c:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 802565e:	4a03      	ldr	r2, [pc, #12]	@ (802566c <TRACE_Lock+0x14>)
 8025660:	8ad3      	ldrh	r3, [r2, #22]
 8025662:	3301      	adds	r3, #1
 8025664:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025666:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 802566a:	4770      	bx	lr
 802566c:	2000a42c 	.word	0x2000a42c

08025670 <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025670:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025674:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 8025676:	4a03      	ldr	r2, [pc, #12]	@ (8025684 <TRACE_UnLock+0x14>)
 8025678:	8ad3      	ldrh	r3, [r2, #22]
 802567a:	3b01      	subs	r3, #1
 802567c:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802567e:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 8025682:	4770      	bx	lr
 8025684:	2000a42c 	.word	0x2000a42c

08025688 <TRACE_IsLocked>:
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 8025688:	4b02      	ldr	r3, [pc, #8]	@ (8025694 <TRACE_IsLocked+0xc>)
 802568a:	8ad8      	ldrh	r0, [r3, #22]
 802568c:	1e43      	subs	r3, r0, #1
 802568e:	4198      	sbcs	r0, r3
}
 8025690:	4770      	bx	lr
 8025692:	46c0      	nop			@ (mov r8, r8)
 8025694:	2000a42c 	.word	0x2000a42c

08025698 <UTIL_ADV_TRACE_Init>:
{
 8025698:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 802569a:	4808      	ldr	r0, [pc, #32]	@ (80256bc <UTIL_ADV_TRACE_Init+0x24>)
 802569c:	2218      	movs	r2, #24
 802569e:	2100      	movs	r1, #0
 80256a0:	f000 f993 	bl	80259ca <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 80256a4:	2280      	movs	r2, #128	@ 0x80
 80256a6:	4806      	ldr	r0, [pc, #24]	@ (80256c0 <UTIL_ADV_TRACE_Init+0x28>)
 80256a8:	0092      	lsls	r2, r2, #2
 80256aa:	2100      	movs	r1, #0
 80256ac:	f000 f98d 	bl	80259ca <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 80256b0:	4b04      	ldr	r3, [pc, #16]	@ (80256c4 <UTIL_ADV_TRACE_Init+0x2c>)
 80256b2:	681b      	ldr	r3, [r3, #0]
 80256b4:	4804      	ldr	r0, [pc, #16]	@ (80256c8 <UTIL_ADV_TRACE_Init+0x30>)
 80256b6:	4798      	blx	r3
}
 80256b8:	bd10      	pop	{r4, pc}
 80256ba:	46c0      	nop			@ (mov r8, r8)
 80256bc:	2000a42c 	.word	0x2000a42c
 80256c0:	20009148 	.word	0x20009148
 80256c4:	08026448 	.word	0x08026448
 80256c8:	0802584d 	.word	0x0802584d

080256cc <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 80256cc:	4b01      	ldr	r3, [pc, #4]	@ (80256d4 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 80256ce:	6058      	str	r0, [r3, #4]
}
 80256d0:	4770      	bx	lr
 80256d2:	46c0      	nop			@ (mov r8, r8)
 80256d4:	2000a42c 	.word	0x2000a42c

080256d8 <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 80256d8:	4b01      	ldr	r3, [pc, #4]	@ (80256e0 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 80256da:	7218      	strb	r0, [r3, #8]
}
 80256dc:	4770      	bx	lr
 80256de:	46c0      	nop			@ (mov r8, r8)
 80256e0:	2000a42c 	.word	0x2000a42c

080256e4 <TRACE_Send>:
{
 80256e4:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80256e6:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80256ea:	b672      	cpsid	i
  if(TRACE_IsLocked() == 0u)
 80256ec:	f7ff ffcc 	bl	8025688 <TRACE_IsLocked>
 80256f0:	2800      	cmp	r0, #0
 80256f2:	d003      	beq.n	80256fc <TRACE_Send+0x18>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80256f4:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 80256f8:	2000      	movs	r0, #0
}
 80256fa:	bd70      	pop	{r4, r5, r6, pc}
    TRACE_Lock();
 80256fc:	f7ff ffac 	bl	8025658 <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 8025700:	4b1d      	ldr	r3, [pc, #116]	@ (8025778 <TRACE_Send+0x94>)
 8025702:	8a1a      	ldrh	r2, [r3, #16]
 8025704:	8a5b      	ldrh	r3, [r3, #18]
 8025706:	429a      	cmp	r2, r3
 8025708:	d030      	beq.n	802576c <TRACE_Send+0x88>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 802570a:	491b      	ldr	r1, [pc, #108]	@ (8025778 <TRACE_Send+0x94>)
 802570c:	7889      	ldrb	r1, [r1, #2]
 802570e:	2901      	cmp	r1, #1
 8025710:	d018      	beq.n	8025744 <TRACE_Send+0x60>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8025712:	4a19      	ldr	r2, [pc, #100]	@ (8025778 <TRACE_Send+0x94>)
 8025714:	7892      	ldrb	r2, [r2, #2]
 8025716:	2a00      	cmp	r2, #0
 8025718:	d106      	bne.n	8025728 <TRACE_Send+0x44>
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 802571a:	4a17      	ldr	r2, [pc, #92]	@ (8025778 <TRACE_Send+0x94>)
 802571c:	8a12      	ldrh	r2, [r2, #16]
 802571e:	4293      	cmp	r3, r2
 8025720:	d91e      	bls.n	8025760 <TRACE_Send+0x7c>
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8025722:	1a9b      	subs	r3, r3, r2
 8025724:	4a14      	ldr	r2, [pc, #80]	@ (8025778 <TRACE_Send+0x94>)
 8025726:	8293      	strh	r3, [r2, #20]
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8025728:	4e13      	ldr	r6, [pc, #76]	@ (8025778 <TRACE_Send+0x94>)
 802572a:	8a35      	ldrh	r5, [r6, #16]
 802572c:	4b13      	ldr	r3, [pc, #76]	@ (802577c <TRACE_Send+0x98>)
 802572e:	18ed      	adds	r5, r5, r3
 8025730:	f384 8810 	msr	PRIMASK, r4
      UTIL_ADV_TRACE_PreSendHook();
 8025734:	f7fb f9fb 	bl	8020b2e <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8025738:	4b11      	ldr	r3, [pc, #68]	@ (8025780 <TRACE_Send+0x9c>)
 802573a:	68db      	ldr	r3, [r3, #12]
 802573c:	8ab1      	ldrh	r1, [r6, #20]
 802573e:	0028      	movs	r0, r5
 8025740:	4798      	blx	r3
 8025742:	e7da      	b.n	80256fa <TRACE_Send+0x16>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 8025744:	480c      	ldr	r0, [pc, #48]	@ (8025778 <TRACE_Send+0x94>)
 8025746:	8801      	ldrh	r1, [r0, #0]
 8025748:	1a8a      	subs	r2, r1, r2
 802574a:	b292      	uxth	r2, r2
 802574c:	8282      	strh	r2, [r0, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 802574e:	2102      	movs	r1, #2
 8025750:	7081      	strb	r1, [r0, #2]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 8025752:	2100      	movs	r1, #0
 8025754:	8001      	strh	r1, [r0, #0]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8025756:	2a00      	cmp	r2, #0
 8025758:	d1db      	bne.n	8025712 <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 802575a:	7081      	strb	r1, [r0, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 802575c:	8201      	strh	r1, [r0, #16]
 802575e:	e7d8      	b.n	8025712 <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 8025760:	2380      	movs	r3, #128	@ 0x80
 8025762:	009b      	lsls	r3, r3, #2
 8025764:	1a9b      	subs	r3, r3, r2
 8025766:	4a04      	ldr	r2, [pc, #16]	@ (8025778 <TRACE_Send+0x94>)
 8025768:	8293      	strh	r3, [r2, #20]
 802576a:	e7dd      	b.n	8025728 <TRACE_Send+0x44>
      TRACE_UnLock();
 802576c:	f7ff ff80 	bl	8025670 <TRACE_UnLock>
 8025770:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 8025774:	2000      	movs	r0, #0
}
 8025776:	e7c0      	b.n	80256fa <TRACE_Send+0x16>
 8025778:	2000a42c 	.word	0x2000a42c
 802577c:	20009148 	.word	0x20009148
 8025780:	08026448 	.word	0x08026448

08025784 <UTIL_ADV_TRACE_COND_FSend>:
{
 8025784:	b408      	push	{r3}
 8025786:	b510      	push	{r4, lr}
 8025788:	b087      	sub	sp, #28
  uint16_t timestamp_size = 0u;
 802578a:	466b      	mov	r3, sp
 802578c:	2400      	movs	r4, #0
 802578e:	805c      	strh	r4, [r3, #2]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 8025790:	4b2b      	ldr	r3, [pc, #172]	@ (8025840 <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8025792:	7a1b      	ldrb	r3, [r3, #8]
 8025794:	4283      	cmp	r3, r0
 8025796:	d34c      	bcc.n	8025832 <UTIL_ADV_TRACE_COND_FSend+0xae>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 8025798:	4b29      	ldr	r3, [pc, #164]	@ (8025840 <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 802579a:	68db      	ldr	r3, [r3, #12]
 802579c:	400b      	ands	r3, r1
 802579e:	428b      	cmp	r3, r1
 80257a0:	d14a      	bne.n	8025838 <UTIL_ADV_TRACE_COND_FSend+0xb4>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 80257a2:	4b27      	ldr	r3, [pc, #156]	@ (8025840 <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 80257a4:	685b      	ldr	r3, [r3, #4]
 80257a6:	2b00      	cmp	r3, #0
 80257a8:	d005      	beq.n	80257b6 <UTIL_ADV_TRACE_COND_FSend+0x32>
 80257aa:	2a00      	cmp	r2, #0
 80257ac:	d003      	beq.n	80257b6 <UTIL_ADV_TRACE_COND_FSend+0x32>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 80257ae:	466a      	mov	r2, sp
 80257b0:	1c91      	adds	r1, r2, #2
 80257b2:	a801      	add	r0, sp, #4
 80257b4:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 80257b6:	ab0a      	add	r3, sp, #40	@ 0x28
 80257b8:	9305      	str	r3, [sp, #20]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 80257ba:	2180      	movs	r1, #128	@ 0x80
 80257bc:	4821      	ldr	r0, [pc, #132]	@ (8025844 <UTIL_ADV_TRACE_COND_FSend+0xc0>)
 80257be:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80257c0:	0049      	lsls	r1, r1, #1
 80257c2:	f000 fca3 	bl	802610c <tiny_vsnprintf_like>
 80257c6:	b284      	uxth	r4, r0
  TRACE_Lock();
 80257c8:	f7ff ff46 	bl	8025658 <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 80257cc:	466b      	mov	r3, sp
 80257ce:	8858      	ldrh	r0, [r3, #2]
 80257d0:	1820      	adds	r0, r4, r0
 80257d2:	b280      	uxth	r0, r0
 80257d4:	4669      	mov	r1, sp
 80257d6:	f7ff ff01 	bl	80255dc <TRACE_AllocateBufer>
 80257da:	3001      	adds	r0, #1
 80257dc:	d024      	beq.n	8025828 <UTIL_ADV_TRACE_COND_FSend+0xa4>
    for (idx = 0u; idx < timestamp_size; idx++)
 80257de:	2300      	movs	r3, #0
 80257e0:	e00a      	b.n	80257f8 <UTIL_ADV_TRACE_COND_FSend+0x74>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 80257e2:	466a      	mov	r2, sp
 80257e4:	8812      	ldrh	r2, [r2, #0]
 80257e6:	a901      	add	r1, sp, #4
 80257e8:	5cc8      	ldrb	r0, [r1, r3]
 80257ea:	4917      	ldr	r1, [pc, #92]	@ (8025848 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 80257ec:	5488      	strb	r0, [r1, r2]
      writepos = writepos + 1u;
 80257ee:	3201      	adds	r2, #1
 80257f0:	4669      	mov	r1, sp
 80257f2:	800a      	strh	r2, [r1, #0]
    for (idx = 0u; idx < timestamp_size; idx++)
 80257f4:	3301      	adds	r3, #1
 80257f6:	b29b      	uxth	r3, r3
 80257f8:	466a      	mov	r2, sp
 80257fa:	3202      	adds	r2, #2
 80257fc:	8812      	ldrh	r2, [r2, #0]
 80257fe:	429a      	cmp	r2, r3
 8025800:	d8ef      	bhi.n	80257e2 <UTIL_ADV_TRACE_COND_FSend+0x5e>
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8025802:	466b      	mov	r3, sp
 8025804:	8818      	ldrh	r0, [r3, #0]
 8025806:	4b10      	ldr	r3, [pc, #64]	@ (8025848 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 8025808:	18c0      	adds	r0, r0, r3
 802580a:	9b05      	ldr	r3, [sp, #20]
 802580c:	2180      	movs	r1, #128	@ 0x80
 802580e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8025810:	0049      	lsls	r1, r1, #1
 8025812:	f000 fc7b 	bl	802610c <tiny_vsnprintf_like>
    TRACE_UnLock();
 8025816:	f7ff ff2b 	bl	8025670 <TRACE_UnLock>
    return TRACE_Send();
 802581a:	f7ff ff63 	bl	80256e4 <TRACE_Send>
}
 802581e:	b007      	add	sp, #28
 8025820:	bc10      	pop	{r4}
 8025822:	bc08      	pop	{r3}
 8025824:	b001      	add	sp, #4
 8025826:	4718      	bx	r3
  TRACE_UnLock();
 8025828:	f7ff ff22 	bl	8025670 <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 802582c:	2003      	movs	r0, #3
 802582e:	4240      	negs	r0, r0
 8025830:	e7f5      	b.n	802581e <UTIL_ADV_TRACE_COND_FSend+0x9a>
    return UTIL_ADV_TRACE_GIVEUP;
 8025832:	2005      	movs	r0, #5
 8025834:	4240      	negs	r0, r0
 8025836:	e7f2      	b.n	802581e <UTIL_ADV_TRACE_COND_FSend+0x9a>
    return UTIL_ADV_TRACE_REGIONMASKED;
 8025838:	2006      	movs	r0, #6
 802583a:	4240      	negs	r0, r0
 802583c:	e7ef      	b.n	802581e <UTIL_ADV_TRACE_COND_FSend+0x9a>
 802583e:	46c0      	nop			@ (mov r8, r8)
 8025840:	2000a42c 	.word	0x2000a42c
 8025844:	2000a32c 	.word	0x2000a32c
 8025848:	20009148 	.word	0x20009148

0802584c <TRACE_TxCpltCallback>:
{
 802584c:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802584e:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025852:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 8025854:	4b26      	ldr	r3, [pc, #152]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 8025856:	789b      	ldrb	r3, [r3, #2]
 8025858:	2b02      	cmp	r3, #2
 802585a:	d016      	beq.n	802588a <TRACE_TxCpltCallback+0x3e>
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 802585c:	4a24      	ldr	r2, [pc, #144]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 802585e:	8a13      	ldrh	r3, [r2, #16]
 8025860:	8a90      	ldrh	r0, [r2, #20]
 8025862:	181b      	adds	r3, r3, r0
 8025864:	05db      	lsls	r3, r3, #23
 8025866:	0ddb      	lsrs	r3, r3, #23
 8025868:	8213      	strh	r3, [r2, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 802586a:	4b21      	ldr	r3, [pc, #132]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 802586c:	8a1a      	ldrh	r2, [r3, #16]
 802586e:	8a5b      	ldrh	r3, [r3, #18]
 8025870:	429a      	cmp	r2, r3
 8025872:	d003      	beq.n	802587c <TRACE_TxCpltCallback+0x30>
 8025874:	481e      	ldr	r0, [pc, #120]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 8025876:	8ac0      	ldrh	r0, [r0, #22]
 8025878:	2801      	cmp	r0, #1
 802587a:	d00b      	beq.n	8025894 <TRACE_TxCpltCallback+0x48>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802587c:	f381 8810 	msr	PRIMASK, r1
    UTIL_ADV_TRACE_PostSendHook();
 8025880:	f7fb f95b 	bl	8020b3a <UTIL_ADV_TRACE_PostSendHook>
    TRACE_UnLock();
 8025884:	f7ff fef4 	bl	8025670 <TRACE_UnLock>
}
 8025888:	bd10      	pop	{r4, pc}
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 802588a:	4b19      	ldr	r3, [pc, #100]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 802588c:	2200      	movs	r2, #0
 802588e:	709a      	strb	r2, [r3, #2]
    ADV_TRACE_Ctx.TraceRdPtr = 0;
 8025890:	821a      	strh	r2, [r3, #16]
    UTIL_ADV_TRACE_DEBUG("\nTRACE_TxCpltCallback::unchunk complete\n");
 8025892:	e7ea      	b.n	802586a <TRACE_TxCpltCallback+0x1e>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8025894:	4816      	ldr	r0, [pc, #88]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 8025896:	7880      	ldrb	r0, [r0, #2]
 8025898:	2801      	cmp	r0, #1
 802589a:	d015      	beq.n	80258c8 <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 802589c:	4a14      	ldr	r2, [pc, #80]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 802589e:	7892      	ldrb	r2, [r2, #2]
 80258a0:	2a00      	cmp	r2, #0
 80258a2:	d106      	bne.n	80258b2 <TRACE_TxCpltCallback+0x66>
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 80258a4:	4a12      	ldr	r2, [pc, #72]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 80258a6:	8a12      	ldrh	r2, [r2, #16]
 80258a8:	4293      	cmp	r3, r2
 80258aa:	d91b      	bls.n	80258e4 <TRACE_TxCpltCallback+0x98>
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 80258ac:	1a9b      	subs	r3, r3, r2
 80258ae:	4a10      	ldr	r2, [pc, #64]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 80258b0:	8293      	strh	r3, [r2, #20]
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 80258b2:	4b0f      	ldr	r3, [pc, #60]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 80258b4:	8a18      	ldrh	r0, [r3, #16]
 80258b6:	4a0f      	ldr	r2, [pc, #60]	@ (80258f4 <TRACE_TxCpltCallback+0xa8>)
 80258b8:	1880      	adds	r0, r0, r2
 80258ba:	f381 8810 	msr	PRIMASK, r1
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 80258be:	4a0e      	ldr	r2, [pc, #56]	@ (80258f8 <TRACE_TxCpltCallback+0xac>)
 80258c0:	68d2      	ldr	r2, [r2, #12]
 80258c2:	8a99      	ldrh	r1, [r3, #20]
 80258c4:	4790      	blx	r2
 80258c6:	e7df      	b.n	8025888 <TRACE_TxCpltCallback+0x3c>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 80258c8:	4c09      	ldr	r4, [pc, #36]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 80258ca:	8820      	ldrh	r0, [r4, #0]
 80258cc:	1a82      	subs	r2, r0, r2
 80258ce:	b292      	uxth	r2, r2
 80258d0:	82a2      	strh	r2, [r4, #20]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 80258d2:	2002      	movs	r0, #2
 80258d4:	70a0      	strb	r0, [r4, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 80258d6:	2000      	movs	r0, #0
 80258d8:	8020      	strh	r0, [r4, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 80258da:	2a00      	cmp	r2, #0
 80258dc:	d1de      	bne.n	802589c <TRACE_TxCpltCallback+0x50>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 80258de:	70a0      	strb	r0, [r4, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 80258e0:	8220      	strh	r0, [r4, #16]
 80258e2:	e7db      	b.n	802589c <TRACE_TxCpltCallback+0x50>
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 80258e4:	2380      	movs	r3, #128	@ 0x80
 80258e6:	009b      	lsls	r3, r3, #2
 80258e8:	1a9b      	subs	r3, r3, r2
 80258ea:	4a01      	ldr	r2, [pc, #4]	@ (80258f0 <TRACE_TxCpltCallback+0xa4>)
 80258ec:	8293      	strh	r3, [r2, #20]
 80258ee:	e7e0      	b.n	80258b2 <TRACE_TxCpltCallback+0x66>
 80258f0:	2000a42c 	.word	0x2000a42c
 80258f4:	20009148 	.word	0x20009148
 80258f8:	08026448 	.word	0x08026448

080258fc <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 80258fc:	4b02      	ldr	r3, [pc, #8]	@ (8025908 <UTIL_LPM_Init+0xc>)
 80258fe:	2200      	movs	r2, #0
 8025900:	601a      	str	r2, [r3, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 8025902:	4b02      	ldr	r3, [pc, #8]	@ (802590c <UTIL_LPM_Init+0x10>)
 8025904:	601a      	str	r2, [r3, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 8025906:	4770      	bx	lr
 8025908:	2000a448 	.word	0x2000a448
 802590c:	2000a444 	.word	0x2000a444

08025910 <UTIL_LPM_SetStopMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025910:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025914:	b672      	cpsid	i

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 8025916:	2900      	cmp	r1, #0
 8025918:	d008      	beq.n	802592c <UTIL_LPM_SetStopMode+0x1c>
 802591a:	2901      	cmp	r1, #1
 802591c:	d103      	bne.n	8025926 <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 802591e:	4906      	ldr	r1, [pc, #24]	@ (8025938 <UTIL_LPM_SetStopMode+0x28>)
 8025920:	680a      	ldr	r2, [r1, #0]
 8025922:	4302      	orrs	r2, r0
 8025924:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025926:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 802592a:	4770      	bx	lr
      StopModeDisable &= ( ~lpm_id_bm );
 802592c:	4902      	ldr	r1, [pc, #8]	@ (8025938 <UTIL_LPM_SetStopMode+0x28>)
 802592e:	680a      	ldr	r2, [r1, #0]
 8025930:	4382      	bics	r2, r0
 8025932:	600a      	str	r2, [r1, #0]
      break;
 8025934:	e7f7      	b.n	8025926 <UTIL_LPM_SetStopMode+0x16>
 8025936:	46c0      	nop			@ (mov r8, r8)
 8025938:	2000a448 	.word	0x2000a448

0802593c <UTIL_LPM_SetOffMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802593c:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025940:	b672      	cpsid	i

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 8025942:	2900      	cmp	r1, #0
 8025944:	d008      	beq.n	8025958 <UTIL_LPM_SetOffMode+0x1c>
 8025946:	2901      	cmp	r1, #1
 8025948:	d103      	bne.n	8025952 <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 802594a:	4906      	ldr	r1, [pc, #24]	@ (8025964 <UTIL_LPM_SetOffMode+0x28>)
 802594c:	680a      	ldr	r2, [r1, #0]
 802594e:	4302      	orrs	r2, r0
 8025950:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025952:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8025956:	4770      	bx	lr
      OffModeDisable &= ( ~lpm_id_bm );
 8025958:	4902      	ldr	r1, [pc, #8]	@ (8025964 <UTIL_LPM_SetOffMode+0x28>)
 802595a:	680a      	ldr	r2, [r1, #0]
 802595c:	4382      	bics	r2, r0
 802595e:	600a      	str	r2, [r1, #0]
      break;
 8025960:	e7f7      	b.n	8025952 <UTIL_LPM_SetOffMode+0x16>
 8025962:	46c0      	nop			@ (mov r8, r8)
 8025964:	2000a444 	.word	0x2000a444

08025968 <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 8025968:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802596a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802596e:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 8025970:	4b0d      	ldr	r3, [pc, #52]	@ (80259a8 <UTIL_LPM_EnterLowPower+0x40>)
 8025972:	681b      	ldr	r3, [r3, #0]
 8025974:	2b00      	cmp	r3, #0
 8025976:	d007      	beq.n	8025988 <UTIL_LPM_EnterLowPower+0x20>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 8025978:	4d0c      	ldr	r5, [pc, #48]	@ (80259ac <UTIL_LPM_EnterLowPower+0x44>)
 802597a:	682b      	ldr	r3, [r5, #0]
 802597c:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 802597e:	686b      	ldr	r3, [r5, #4]
 8025980:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025982:	f384 8810 	msr	PRIMASK, r4
      UTIL_PowerDriver.ExitOffMode( );
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 8025986:	bd70      	pop	{r4, r5, r6, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 8025988:	4b09      	ldr	r3, [pc, #36]	@ (80259b0 <UTIL_LPM_EnterLowPower+0x48>)
 802598a:	681b      	ldr	r3, [r3, #0]
 802598c:	2b00      	cmp	r3, #0
 802598e:	d005      	beq.n	802599c <UTIL_LPM_EnterLowPower+0x34>
        UTIL_PowerDriver.EnterStopMode( );
 8025990:	4d06      	ldr	r5, [pc, #24]	@ (80259ac <UTIL_LPM_EnterLowPower+0x44>)
 8025992:	68ab      	ldr	r3, [r5, #8]
 8025994:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 8025996:	68eb      	ldr	r3, [r5, #12]
 8025998:	4798      	blx	r3
 802599a:	e7f2      	b.n	8025982 <UTIL_LPM_EnterLowPower+0x1a>
      UTIL_PowerDriver.EnterOffMode( );
 802599c:	4d03      	ldr	r5, [pc, #12]	@ (80259ac <UTIL_LPM_EnterLowPower+0x44>)
 802599e:	692b      	ldr	r3, [r5, #16]
 80259a0:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 80259a2:	696b      	ldr	r3, [r5, #20]
 80259a4:	4798      	blx	r3
 80259a6:	e7ec      	b.n	8025982 <UTIL_LPM_EnterLowPower+0x1a>
 80259a8:	2000a448 	.word	0x2000a448
 80259ac:	0802632c 	.word	0x0802632c
 80259b0:	2000a444 	.word	0x2000a444

080259b4 <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 80259b4:	e004      	b.n	80259c0 <UTIL_MEM_cpy_8+0xc>
    {
        *dst8++ = *src8++;
 80259b6:	780a      	ldrb	r2, [r1, #0]
 80259b8:	7002      	strb	r2, [r0, #0]
 80259ba:	3101      	adds	r1, #1
 80259bc:	3001      	adds	r0, #1
  while( size-- )
 80259be:	001a      	movs	r2, r3
 80259c0:	1e53      	subs	r3, r2, #1
 80259c2:	b29b      	uxth	r3, r3
 80259c4:	2a00      	cmp	r2, #0
 80259c6:	d1f6      	bne.n	80259b6 <UTIL_MEM_cpy_8+0x2>
    }
}
 80259c8:	4770      	bx	lr

080259ca <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 80259ca:	e002      	b.n	80259d2 <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
 80259cc:	7001      	strb	r1, [r0, #0]
 80259ce:	3001      	adds	r0, #1
  while( size-- )
 80259d0:	001a      	movs	r2, r3
 80259d2:	1e53      	subs	r3, r2, #1
 80259d4:	b29b      	uxth	r3, r3
 80259d6:	2a00      	cmp	r2, #0
 80259d8:	d1f8      	bne.n	80259cc <UTIL_MEM_set_8+0x2>
  }
}
 80259da:	4770      	bx	lr

080259dc <UTIL_SEQ_SetTask>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80259dc:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80259e0:	b672      	cpsid	i

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 80259e2:	4a06      	ldr	r2, [pc, #24]	@ (80259fc <UTIL_SEQ_SetTask+0x20>)
 80259e4:	6813      	ldr	r3, [r2, #0]
 80259e6:	4303      	orrs	r3, r0
 80259e8:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 80259ea:	4b05      	ldr	r3, [pc, #20]	@ (8025a00 <UTIL_SEQ_SetTask+0x24>)
 80259ec:	00c9      	lsls	r1, r1, #3
 80259ee:	58ca      	ldr	r2, [r1, r3]
 80259f0:	4302      	orrs	r2, r0
 80259f2:	50ca      	str	r2, [r1, r3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80259f4:	f38c 8810 	msr	PRIMASK, ip

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 80259f8:	4770      	bx	lr
 80259fa:	46c0      	nop			@ (mov r8, r8)
 80259fc:	2000a470 	.word	0x2000a470
 8025a00:	2000a44c 	.word	0x2000a44c

08025a04 <UTIL_SEQ_SetEvt>:

  return;
}

void UTIL_SEQ_SetEvt( UTIL_SEQ_bm_t EvtId_bm )
{
 8025a04:	0003      	movs	r3, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025a06:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025a0a:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  EvtSet |= EvtId_bm;
 8025a0c:	4a03      	ldr	r2, [pc, #12]	@ (8025a1c <UTIL_SEQ_SetEvt+0x18>)
 8025a0e:	6810      	ldr	r0, [r2, #0]
 8025a10:	4318      	orrs	r0, r3
 8025a12:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025a14:	f381 8810 	msr	PRIMASK, r1

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 8025a18:	4770      	bx	lr
 8025a1a:	46c0      	nop			@ (mov r8, r8)
 8025a1c:	2000a46c 	.word	0x2000a46c

08025a20 <UTIL_SEQ_PreIdle>:
{
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 8025a20:	4770      	bx	lr

08025a22 <UTIL_SEQ_PostIdle>:
{
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 8025a22:	4770      	bx	lr

08025a24 <SEQ_BitPosition>:
uint8_t SEQ_BitPosition(uint32_t Value)
{
uint8_t n = 0U;
uint32_t lvalue = Value;

  if ((lvalue & 0xFFFF0000U) == 0U)  { n  = 16U; lvalue <<= 16U;  }
 8025a24:	2380      	movs	r3, #128	@ 0x80
 8025a26:	025b      	lsls	r3, r3, #9
 8025a28:	4298      	cmp	r0, r3
 8025a2a:	d218      	bcs.n	8025a5e <SEQ_BitPosition+0x3a>
 8025a2c:	0400      	lsls	r0, r0, #16
 8025a2e:	2210      	movs	r2, #16
  if ((lvalue & 0xFF000000U) == 0U)  { n +=  8U; lvalue <<=  8U;  }
 8025a30:	2380      	movs	r3, #128	@ 0x80
 8025a32:	045b      	lsls	r3, r3, #17
 8025a34:	4298      	cmp	r0, r3
 8025a36:	d202      	bcs.n	8025a3e <SEQ_BitPosition+0x1a>
 8025a38:	3208      	adds	r2, #8
 8025a3a:	b2d2      	uxtb	r2, r2
 8025a3c:	0200      	lsls	r0, r0, #8
  if ((lvalue & 0xF0000000U) == 0U)  { n +=  4U; lvalue <<=  4U;  }
 8025a3e:	2380      	movs	r3, #128	@ 0x80
 8025a40:	055b      	lsls	r3, r3, #21
 8025a42:	4298      	cmp	r0, r3
 8025a44:	d202      	bcs.n	8025a4c <SEQ_BitPosition+0x28>
 8025a46:	3204      	adds	r2, #4
 8025a48:	b2d2      	uxtb	r2, r2
 8025a4a:	0100      	lsls	r0, r0, #4

  n += SEQ_clz_table_4bit[lvalue >> (32-4)];
 8025a4c:	0f00      	lsrs	r0, r0, #28
 8025a4e:	4b05      	ldr	r3, [pc, #20]	@ (8025a64 <SEQ_BitPosition+0x40>)
 8025a50:	5c1b      	ldrb	r3, [r3, r0]
 8025a52:	189b      	adds	r3, r3, r2
 8025a54:	b2db      	uxtb	r3, r3

  return (uint8_t)(31U-n);
 8025a56:	201f      	movs	r0, #31
 8025a58:	1ac0      	subs	r0, r0, r3
 8025a5a:	b2c0      	uxtb	r0, r0
}
 8025a5c:	4770      	bx	lr
uint8_t n = 0U;
 8025a5e:	2200      	movs	r2, #0
 8025a60:	e7e6      	b.n	8025a30 <SEQ_BitPosition+0xc>
 8025a62:	46c0      	nop			@ (mov r8, r8)
 8025a64:	08026804 	.word	0x08026804

08025a68 <UTIL_SEQ_Run>:
{
 8025a68:	b570      	push	{r4, r5, r6, lr}
  super_mask_backup = SuperMask;
 8025a6a:	4b41      	ldr	r3, [pc, #260]	@ (8025b70 <UTIL_SEQ_Run+0x108>)
 8025a6c:	681c      	ldr	r4, [r3, #0]
  SuperMask &= Mask_bm;
 8025a6e:	4020      	ands	r0, r4
 8025a70:	6018      	str	r0, [r3, #0]
  local_taskset = TaskSet;
 8025a72:	4b40      	ldr	r3, [pc, #256]	@ (8025b74 <UTIL_SEQ_Run+0x10c>)
 8025a74:	681b      	ldr	r3, [r3, #0]
  local_evtset = EvtSet;
 8025a76:	4a40      	ldr	r2, [pc, #256]	@ (8025b78 <UTIL_SEQ_Run+0x110>)
 8025a78:	6816      	ldr	r6, [r2, #0]
  local_taskmask = TaskMask;
 8025a7a:	4a40      	ldr	r2, [pc, #256]	@ (8025b7c <UTIL_SEQ_Run+0x114>)
 8025a7c:	6811      	ldr	r1, [r2, #0]
  local_evtwaited =  EvtWaited;
 8025a7e:	4a40      	ldr	r2, [pc, #256]	@ (8025b80 <UTIL_SEQ_Run+0x118>)
 8025a80:	6810      	ldr	r0, [r2, #0]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8025a82:	e02d      	b.n	8025ae0 <UTIL_SEQ_Run+0x78>
      counter++;
 8025a84:	3201      	adds	r2, #1
 8025a86:	e034      	b.n	8025af2 <UTIL_SEQ_Run+0x8a>
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 8025a88:	4d3e      	ldr	r5, [pc, #248]	@ (8025b84 <UTIL_SEQ_Run+0x11c>)
 8025a8a:	00d2      	lsls	r2, r2, #3
 8025a8c:	18ad      	adds	r5, r5, r2
 8025a8e:	686b      	ldr	r3, [r5, #4]
 8025a90:	4018      	ands	r0, r3
 8025a92:	f7ff ffc7 	bl	8025a24 <SEQ_BitPosition>
 8025a96:	4e3c      	ldr	r6, [pc, #240]	@ (8025b88 <UTIL_SEQ_Run+0x120>)
 8025a98:	6030      	str	r0, [r6, #0]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 8025a9a:	686a      	ldr	r2, [r5, #4]
 8025a9c:	2301      	movs	r3, #1
 8025a9e:	0019      	movs	r1, r3
 8025aa0:	4081      	lsls	r1, r0
 8025aa2:	438a      	bics	r2, r1
 8025aa4:	606a      	str	r2, [r5, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025aa6:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025aaa:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 8025aac:	6832      	ldr	r2, [r6, #0]
 8025aae:	4093      	lsls	r3, r2
 8025ab0:	43de      	mvns	r6, r3
 8025ab2:	4830      	ldr	r0, [pc, #192]	@ (8025b74 <UTIL_SEQ_Run+0x10c>)
 8025ab4:	6802      	ldr	r2, [r0, #0]
 8025ab6:	439a      	bics	r2, r3
 8025ab8:	6002      	str	r2, [r0, #0]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8025aba:	2301      	movs	r3, #1
 8025abc:	2b00      	cmp	r3, #0
 8025abe:	d12d      	bne.n	8025b1c <UTIL_SEQ_Run+0xb4>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025ac0:	f381 8810 	msr	PRIMASK, r1
    TaskCb[CurrentTaskIdx]( );
 8025ac4:	4b31      	ldr	r3, [pc, #196]	@ (8025b8c <UTIL_SEQ_Run+0x124>)
 8025ac6:	4a30      	ldr	r2, [pc, #192]	@ (8025b88 <UTIL_SEQ_Run+0x120>)
 8025ac8:	6812      	ldr	r2, [r2, #0]
 8025aca:	0092      	lsls	r2, r2, #2
 8025acc:	58d3      	ldr	r3, [r2, r3]
 8025ace:	4798      	blx	r3
    local_taskset = TaskSet;
 8025ad0:	4b28      	ldr	r3, [pc, #160]	@ (8025b74 <UTIL_SEQ_Run+0x10c>)
 8025ad2:	681b      	ldr	r3, [r3, #0]
    local_evtset = EvtSet;
 8025ad4:	4a28      	ldr	r2, [pc, #160]	@ (8025b78 <UTIL_SEQ_Run+0x110>)
 8025ad6:	6816      	ldr	r6, [r2, #0]
    local_taskmask = TaskMask;
 8025ad8:	4a28      	ldr	r2, [pc, #160]	@ (8025b7c <UTIL_SEQ_Run+0x114>)
 8025ada:	6811      	ldr	r1, [r2, #0]
    local_evtwaited = EvtWaited;
 8025adc:	4a28      	ldr	r2, [pc, #160]	@ (8025b80 <UTIL_SEQ_Run+0x118>)
 8025ade:	6810      	ldr	r0, [r2, #0]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8025ae0:	400b      	ands	r3, r1
 8025ae2:	4a23      	ldr	r2, [pc, #140]	@ (8025b70 <UTIL_SEQ_Run+0x108>)
 8025ae4:	6815      	ldr	r5, [r2, #0]
 8025ae6:	421d      	tst	r5, r3
 8025ae8:	d01f      	beq.n	8025b2a <UTIL_SEQ_Run+0xc2>
 8025aea:	0002      	movs	r2, r0
 8025aec:	4032      	ands	r2, r6
 8025aee:	4230      	tst	r0, r6
 8025af0:	d11b      	bne.n	8025b2a <UTIL_SEQ_Run+0xc2>
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 8025af2:	4b24      	ldr	r3, [pc, #144]	@ (8025b84 <UTIL_SEQ_Run+0x11c>)
 8025af4:	00d0      	lsls	r0, r2, #3
 8025af6:	58c3      	ldr	r3, [r0, r3]
 8025af8:	400b      	ands	r3, r1
 8025afa:	421d      	tst	r5, r3
 8025afc:	d0c2      	beq.n	8025a84 <UTIL_SEQ_Run+0x1c>
    current_task_set = TaskPrio[counter].priority & local_taskmask & SuperMask;
 8025afe:	4b21      	ldr	r3, [pc, #132]	@ (8025b84 <UTIL_SEQ_Run+0x11c>)
 8025b00:	0006      	movs	r6, r0
 8025b02:	58c0      	ldr	r0, [r0, r3]
 8025b04:	4008      	ands	r0, r1
 8025b06:	4028      	ands	r0, r5
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 8025b08:	199b      	adds	r3, r3, r6
 8025b0a:	685b      	ldr	r3, [r3, #4]
 8025b0c:	4218      	tst	r0, r3
 8025b0e:	d1bb      	bne.n	8025a88 <UTIL_SEQ_Run+0x20>
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 8025b10:	4b1c      	ldr	r3, [pc, #112]	@ (8025b84 <UTIL_SEQ_Run+0x11c>)
 8025b12:	199b      	adds	r3, r3, r6
 8025b14:	2101      	movs	r1, #1
 8025b16:	4249      	negs	r1, r1
 8025b18:	6059      	str	r1, [r3, #4]
 8025b1a:	e7b5      	b.n	8025a88 <UTIL_SEQ_Run+0x20>
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 8025b1c:	3b01      	subs	r3, #1
 8025b1e:	4a19      	ldr	r2, [pc, #100]	@ (8025b84 <UTIL_SEQ_Run+0x11c>)
 8025b20:	00dd      	lsls	r5, r3, #3
 8025b22:	58a8      	ldr	r0, [r5, r2]
 8025b24:	4030      	ands	r0, r6
 8025b26:	50a8      	str	r0, [r5, r2]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8025b28:	e7c8      	b.n	8025abc <UTIL_SEQ_Run+0x54>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 8025b2a:	4b17      	ldr	r3, [pc, #92]	@ (8025b88 <UTIL_SEQ_Run+0x120>)
 8025b2c:	2201      	movs	r2, #1
 8025b2e:	4252      	negs	r2, r2
 8025b30:	601a      	str	r2, [r3, #0]
  UTIL_SEQ_PreIdle( );
 8025b32:	f7ff ff75 	bl	8025a20 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025b36:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025b3a:	b672      	cpsid	i
  local_taskset = TaskSet;
 8025b3c:	4b0d      	ldr	r3, [pc, #52]	@ (8025b74 <UTIL_SEQ_Run+0x10c>)
 8025b3e:	681a      	ldr	r2, [r3, #0]
  local_evtset = EvtSet;
 8025b40:	4b0d      	ldr	r3, [pc, #52]	@ (8025b78 <UTIL_SEQ_Run+0x110>)
 8025b42:	6819      	ldr	r1, [r3, #0]
  local_taskmask = TaskMask;
 8025b44:	4b0d      	ldr	r3, [pc, #52]	@ (8025b7c <UTIL_SEQ_Run+0x114>)
 8025b46:	681b      	ldr	r3, [r3, #0]
  if ((local_taskset & local_taskmask & SuperMask) == 0U)
 8025b48:	4013      	ands	r3, r2
 8025b4a:	4a09      	ldr	r2, [pc, #36]	@ (8025b70 <UTIL_SEQ_Run+0x108>)
 8025b4c:	6812      	ldr	r2, [r2, #0]
 8025b4e:	421a      	tst	r2, r3
 8025b50:	d103      	bne.n	8025b5a <UTIL_SEQ_Run+0xf2>
    if ((local_evtset & EvtWaited)== 0U)
 8025b52:	4b0b      	ldr	r3, [pc, #44]	@ (8025b80 <UTIL_SEQ_Run+0x118>)
 8025b54:	681b      	ldr	r3, [r3, #0]
 8025b56:	4219      	tst	r1, r3
 8025b58:	d006      	beq.n	8025b68 <UTIL_SEQ_Run+0x100>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025b5a:	f385 8810 	msr	PRIMASK, r5
  UTIL_SEQ_PostIdle( );
 8025b5e:	f7ff ff60 	bl	8025a22 <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 8025b62:	4b03      	ldr	r3, [pc, #12]	@ (8025b70 <UTIL_SEQ_Run+0x108>)
 8025b64:	601c      	str	r4, [r3, #0]
}
 8025b66:	bd70      	pop	{r4, r5, r6, pc}
      UTIL_SEQ_Idle( );
 8025b68:	f7fa ffdd 	bl	8020b26 <UTIL_SEQ_Idle>
 8025b6c:	e7f5      	b.n	8025b5a <UTIL_SEQ_Run+0xf2>
 8025b6e:	46c0      	nop			@ (mov r8, r8)
 8025b70:	2000a010 	.word	0x2000a010
 8025b74:	2000a470 	.word	0x2000a470
 8025b78:	2000a46c 	.word	0x2000a46c
 8025b7c:	2000a014 	.word	0x2000a014
 8025b80:	2000a468 	.word	0x2000a468
 8025b84:	2000a44c 	.word	0x2000a44c
 8025b88:	2000a464 	.word	0x2000a464
 8025b8c:	2000a454 	.word	0x2000a454

08025b90 <UTIL_SEQ_WaitEvt>:
{
 8025b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025b92:	0004      	movs	r4, r0
  current_task_idx = CurrentTaskIdx;
 8025b94:	4b10      	ldr	r3, [pc, #64]	@ (8025bd8 <UTIL_SEQ_WaitEvt+0x48>)
 8025b96:	681e      	ldr	r6, [r3, #0]
  if(UTIL_SEQ_NOTASKRUNNING == CurrentTaskIdx)
 8025b98:	1c73      	adds	r3, r6, #1
 8025b9a:	d005      	beq.n	8025ba8 <UTIL_SEQ_WaitEvt+0x18>
    wait_task_idx = (uint32_t)1u << CurrentTaskIdx;
 8025b9c:	2501      	movs	r5, #1
 8025b9e:	40b5      	lsls	r5, r6
  event_waited_id_backup = EvtWaited;
 8025ba0:	4b0e      	ldr	r3, [pc, #56]	@ (8025bdc <UTIL_SEQ_WaitEvt+0x4c>)
 8025ba2:	681f      	ldr	r7, [r3, #0]
  EvtWaited = EvtId_bm;
 8025ba4:	601c      	str	r4, [r3, #0]
  while ((EvtSet & EvtId_bm) == 0U)
 8025ba6:	e005      	b.n	8025bb4 <UTIL_SEQ_WaitEvt+0x24>
    wait_task_idx = 0u;
 8025ba8:	2500      	movs	r5, #0
 8025baa:	e7f9      	b.n	8025ba0 <UTIL_SEQ_WaitEvt+0x10>
    UTIL_SEQ_EvtIdle(wait_task_idx, EvtId_bm);
 8025bac:	0021      	movs	r1, r4
 8025bae:	0028      	movs	r0, r5
 8025bb0:	f7fa ffb4 	bl	8020b1c <UTIL_SEQ_EvtIdle>
  while ((EvtSet & EvtId_bm) == 0U)
 8025bb4:	4b0a      	ldr	r3, [pc, #40]	@ (8025be0 <UTIL_SEQ_WaitEvt+0x50>)
 8025bb6:	681b      	ldr	r3, [r3, #0]
 8025bb8:	421c      	tst	r4, r3
 8025bba:	d0f7      	beq.n	8025bac <UTIL_SEQ_WaitEvt+0x1c>
  CurrentTaskIdx = current_task_idx;
 8025bbc:	4b06      	ldr	r3, [pc, #24]	@ (8025bd8 <UTIL_SEQ_WaitEvt+0x48>)
 8025bbe:	601e      	str	r6, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025bc0:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025bc4:	b672      	cpsid	i
  EvtSet &= (~EvtId_bm);
 8025bc6:	4a06      	ldr	r2, [pc, #24]	@ (8025be0 <UTIL_SEQ_WaitEvt+0x50>)
 8025bc8:	6813      	ldr	r3, [r2, #0]
 8025bca:	43a3      	bics	r3, r4
 8025bcc:	6013      	str	r3, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025bce:	f381 8810 	msr	PRIMASK, r1
  EvtWaited = event_waited_id_backup;
 8025bd2:	4b02      	ldr	r3, [pc, #8]	@ (8025bdc <UTIL_SEQ_WaitEvt+0x4c>)
 8025bd4:	601f      	str	r7, [r3, #0]
}
 8025bd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025bd8:	2000a464 	.word	0x2000a464
 8025bdc:	2000a468 	.word	0x2000a468
 8025be0:	2000a46c 	.word	0x2000a46c

08025be4 <UTIL_SEQ_RegTask>:
{
 8025be4:	b570      	push	{r4, r5, r6, lr}
 8025be6:	0014      	movs	r4, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025be8:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025bec:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 8025bee:	f7ff ff19 	bl	8025a24 <SEQ_BitPosition>
 8025bf2:	4b03      	ldr	r3, [pc, #12]	@ (8025c00 <UTIL_SEQ_RegTask+0x1c>)
 8025bf4:	0080      	lsls	r0, r0, #2
 8025bf6:	50c4      	str	r4, [r0, r3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025bf8:	f385 8810 	msr	PRIMASK, r5
}
 8025bfc:	bd70      	pop	{r4, r5, r6, pc}
 8025bfe:	46c0      	nop			@ (mov r8, r8)
 8025c00:	2000a454 	.word	0x2000a454

08025c04 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 8025c04:	b082      	sub	sp, #8
 8025c06:	b510      	push	{r4, lr}
 8025c08:	b082      	sub	sp, #8
 8025c0a:	9100      	str	r1, [sp, #0]
 8025c0c:	9201      	str	r2, [sp, #4]
 8025c0e:	9305      	str	r3, [sp, #20]
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };
 8025c10:	2300      	movs	r3, #0
 8025c12:	6003      	str	r3, [r0, #0]
 8025c14:	8083      	strh	r3, [r0, #4]

  c.Seconds = a.Seconds + b.Seconds;
 8025c16:	9b05      	ldr	r3, [sp, #20]
 8025c18:	18ca      	adds	r2, r1, r3
 8025c1a:	6002      	str	r2, [r0, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8025c1c:	466b      	mov	r3, sp
 8025c1e:	889b      	ldrh	r3, [r3, #4]
 8025c20:	a905      	add	r1, sp, #20
 8025c22:	8889      	ldrh	r1, [r1, #4]
 8025c24:	185b      	adds	r3, r3, r1
 8025c26:	b299      	uxth	r1, r3
 8025c28:	b21b      	sxth	r3, r3
 8025c2a:	8083      	strh	r3, [r0, #4]
  if( c.SubSeconds >= 1000 )
 8025c2c:	24fa      	movs	r4, #250	@ 0xfa
 8025c2e:	00a4      	lsls	r4, r4, #2
 8025c30:	42a3      	cmp	r3, r4
 8025c32:	db05      	blt.n	8025c40 <SysTimeAdd+0x3c>
  {
    c.Seconds++;
 8025c34:	3201      	adds	r2, #1
 8025c36:	6002      	str	r2, [r0, #0]
    c.SubSeconds -= 1000;
 8025c38:	4b04      	ldr	r3, [pc, #16]	@ (8025c4c <SysTimeAdd+0x48>)
 8025c3a:	469c      	mov	ip, r3
 8025c3c:	4461      	add	r1, ip
 8025c3e:	8081      	strh	r1, [r0, #4]
  }
  return c;
}
 8025c40:	b002      	add	sp, #8
 8025c42:	bc10      	pop	{r4}
 8025c44:	bc08      	pop	{r3}
 8025c46:	b002      	add	sp, #8
 8025c48:	4718      	bx	r3
 8025c4a:	46c0      	nop			@ (mov r8, r8)
 8025c4c:	fffffc18 	.word	0xfffffc18

08025c50 <SysTimeGet>:
  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
}

SysTime_t SysTimeGet( void )
{
 8025c50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025c52:	b087      	sub	sp, #28
 8025c54:	0004      	movs	r4, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8025c56:	af04      	add	r7, sp, #16
 8025c58:	2300      	movs	r3, #0
 8025c5a:	9304      	str	r3, [sp, #16]
 8025c5c:	80bb      	strh	r3, [r7, #4]
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
 8025c5e:	6003      	str	r3, [r0, #0]
 8025c60:	8083      	strh	r3, [r0, #4]
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8025c62:	4d0b      	ldr	r5, [pc, #44]	@ (8025c90 <SysTimeGet+0x40>)
 8025c64:	692b      	ldr	r3, [r5, #16]
 8025c66:	a805      	add	r0, sp, #20
 8025c68:	4798      	blx	r3
 8025c6a:	9004      	str	r0, [sp, #16]

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8025c6c:	68eb      	ldr	r3, [r5, #12]
 8025c6e:	4798      	blx	r3
 8025c70:	ae02      	add	r6, sp, #8
 8025c72:	80b0      	strh	r0, [r6, #4]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8025c74:	686b      	ldr	r3, [r5, #4]
 8025c76:	4798      	blx	r3
 8025c78:	0001      	movs	r1, r0
 8025c7a:	9002      	str	r0, [sp, #8]

  sysTime = SysTimeAdd( DeltaTime, calendarTime );
 8025c7c:	9b05      	ldr	r3, [sp, #20]
 8025c7e:	9300      	str	r3, [sp, #0]
 8025c80:	9b04      	ldr	r3, [sp, #16]
 8025c82:	9a03      	ldr	r2, [sp, #12]
 8025c84:	0020      	movs	r0, r4
 8025c86:	f7ff ffbd 	bl	8025c04 <SysTimeAdd>

  return sysTime;
}
 8025c8a:	0020      	movs	r0, r4
 8025c8c:	b007      	add	sp, #28
 8025c8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8025c90:	08026378 	.word	0x08026378

08025c94 <UTIL_TIMER_Init>:
  * @addtogroup TIMER_SERVER_exported_function
  *  @{
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
 8025c94:	b510      	push	{r4, lr}
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 8025c96:	4b03      	ldr	r3, [pc, #12]	@ (8025ca4 <UTIL_TIMER_Init+0x10>)
 8025c98:	2200      	movs	r2, #0
 8025c9a:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 8025c9c:	4b02      	ldr	r3, [pc, #8]	@ (8025ca8 <UTIL_TIMER_Init+0x14>)
 8025c9e:	681b      	ldr	r3, [r3, #0]
 8025ca0:	4798      	blx	r3
}
 8025ca2:	bd10      	pop	{r4, pc}
 8025ca4:	2000a474 	.word	0x2000a474
 8025ca8:	0802638c 	.word	0x0802638c

08025cac <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 8025cac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025cae:	0004      	movs	r4, r0
 8025cb0:	0008      	movs	r0, r1
 8025cb2:	0016      	movs	r6, r2
 8025cb4:	001d      	movs	r5, r3
  if((TimerObject != NULL) && (Callback != NULL))
 8025cb6:	2c00      	cmp	r4, #0
 8025cb8:	d011      	beq.n	8025cde <UTIL_TIMER_Create+0x32>
 8025cba:	2b00      	cmp	r3, #0
 8025cbc:	d011      	beq.n	8025ce2 <UTIL_TIMER_Create+0x36>
  {
    TimerObject->Timestamp = 0U;
 8025cbe:	2700      	movs	r7, #0
 8025cc0:	6027      	str	r7, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 8025cc2:	4b09      	ldr	r3, [pc, #36]	@ (8025ce8 <UTIL_TIMER_Create+0x3c>)
 8025cc4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8025cc6:	4798      	blx	r3
 8025cc8:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 8025cca:	7227      	strb	r7, [r4, #8]
    TimerObject->IsRunning = 0U;
 8025ccc:	7267      	strb	r7, [r4, #9]
    TimerObject->IsReloadStopped = 0U;
 8025cce:	72a7      	strb	r7, [r4, #10]
    TimerObject->Callback = Callback;
 8025cd0:	60e5      	str	r5, [r4, #12]
    TimerObject->argument = Argument;
 8025cd2:	9b06      	ldr	r3, [sp, #24]
 8025cd4:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 8025cd6:	72e6      	strb	r6, [r4, #11]
    TimerObject->Next = NULL;
 8025cd8:	6167      	str	r7, [r4, #20]
    return UTIL_TIMER_OK;
 8025cda:	2000      	movs	r0, #0
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 8025cdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 8025cde:	2001      	movs	r0, #1
 8025ce0:	e7fc      	b.n	8025cdc <UTIL_TIMER_Create+0x30>
 8025ce2:	2001      	movs	r0, #1
 8025ce4:	e7fa      	b.n	8025cdc <UTIL_TIMER_Create+0x30>
 8025ce6:	46c0      	nop			@ (mov r8, r8)
 8025ce8:	0802638c 	.word	0x0802638c

08025cec <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 8025cec:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 8025cee:	4c03      	ldr	r4, [pc, #12]	@ (8025cfc <UTIL_TIMER_GetCurrentTime+0x10>)
 8025cf0:	69e3      	ldr	r3, [r4, #28]
 8025cf2:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 8025cf4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8025cf6:	4798      	blx	r3
}
 8025cf8:	bd10      	pop	{r4, pc}
 8025cfa:	46c0      	nop			@ (mov r8, r8)
 8025cfc:	0802638c 	.word	0x0802638c

08025d00 <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 8025d00:	b570      	push	{r4, r5, r6, lr}
 8025d02:	0006      	movs	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 8025d04:	4d05      	ldr	r5, [pc, #20]	@ (8025d1c <UTIL_TIMER_GetElapsedTime+0x1c>)
 8025d06:	69eb      	ldr	r3, [r5, #28]
 8025d08:	4798      	blx	r3
 8025d0a:	0004      	movs	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 8025d0c:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 8025d0e:	0030      	movs	r0, r6
 8025d10:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 8025d12:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8025d14:	1a20      	subs	r0, r4, r0
 8025d16:	4798      	blx	r3
}
 8025d18:	bd70      	pop	{r4, r5, r6, pc}
 8025d1a:	46c0      	nop			@ (mov r8, r8)
 8025d1c:	0802638c 	.word	0x0802638c

08025d20 <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8025d20:	4b05      	ldr	r3, [pc, #20]	@ (8025d38 <TimerExists+0x18>)
 8025d22:	681b      	ldr	r3, [r3, #0]

  while( cur != NULL )
 8025d24:	e000      	b.n	8025d28 <TimerExists+0x8>
  {
    if( cur == TimerObject )
    {
      return true;
    }
    cur = cur->Next;
 8025d26:	695b      	ldr	r3, [r3, #20]
  while( cur != NULL )
 8025d28:	2b00      	cmp	r3, #0
 8025d2a:	d003      	beq.n	8025d34 <TimerExists+0x14>
    if( cur == TimerObject )
 8025d2c:	4283      	cmp	r3, r0
 8025d2e:	d1fa      	bne.n	8025d26 <TimerExists+0x6>
      return true;
 8025d30:	2001      	movs	r0, #1
 8025d32:	e000      	b.n	8025d36 <TimerExists+0x16>
  }
  return false;
 8025d34:	2000      	movs	r0, #0
}
 8025d36:	4770      	bx	lr
 8025d38:	2000a474 	.word	0x2000a474

08025d3c <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 8025d3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025d3e:	0004      	movs	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 8025d40:	4e09      	ldr	r6, [pc, #36]	@ (8025d68 <TimerSetTimeout+0x2c>)
 8025d42:	6a33      	ldr	r3, [r6, #32]
 8025d44:	4798      	blx	r3
 8025d46:	0005      	movs	r5, r0
  TimerObject->IsPending = 1;
 8025d48:	2301      	movs	r3, #1
 8025d4a:	7223      	strb	r3, [r4, #8]

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8025d4c:	6827      	ldr	r7, [r4, #0]
 8025d4e:	69b6      	ldr	r6, [r6, #24]
 8025d50:	47b0      	blx	r6
 8025d52:	1940      	adds	r0, r0, r5
 8025d54:	4287      	cmp	r7, r0
 8025d56:	d202      	bcs.n	8025d5e <TimerSetTimeout+0x22>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 8025d58:	47b0      	blx	r6
 8025d5a:	1940      	adds	r0, r0, r5
 8025d5c:	6020      	str	r0, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 8025d5e:	4b02      	ldr	r3, [pc, #8]	@ (8025d68 <TimerSetTimeout+0x2c>)
 8025d60:	689b      	ldr	r3, [r3, #8]
 8025d62:	6820      	ldr	r0, [r4, #0]
 8025d64:	4798      	blx	r3
}
 8025d66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025d68:	0802638c 	.word	0x0802638c

08025d6c <UTIL_TIMER_Stop>:
{
 8025d6c:	b510      	push	{r4, lr}
  if (NULL != TimerObject)
 8025d6e:	2800      	cmp	r0, #0
 8025d70:	d02f      	beq.n	8025dd2 <UTIL_TIMER_Stop+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025d72:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025d76:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 8025d78:	4b17      	ldr	r3, [pc, #92]	@ (8025dd8 <UTIL_TIMER_Stop+0x6c>)
 8025d7a:	681a      	ldr	r2, [r3, #0]
    TimerObject->IsReloadStopped = 1U;
 8025d7c:	2301      	movs	r3, #1
 8025d7e:	7283      	strb	r3, [r0, #10]
    if(NULL != TimerListHead)
 8025d80:	2a00      	cmp	r2, #0
 8025d82:	d01f      	beq.n	8025dc4 <UTIL_TIMER_Stop+0x58>
      TimerObject->IsRunning = 0U;
 8025d84:	2300      	movs	r3, #0
 8025d86:	7243      	strb	r3, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 8025d88:	4290      	cmp	r0, r2
 8025d8a:	d007      	beq.n	8025d9c <UTIL_TIMER_Stop+0x30>
    UTIL_TIMER_Object_t* cur = TimerListHead;
 8025d8c:	0013      	movs	r3, r2
        while( cur != NULL )
 8025d8e:	2b00      	cmp	r3, #0
 8025d90:	d018      	beq.n	8025dc4 <UTIL_TIMER_Stop+0x58>
          if( cur == TimerObject )
 8025d92:	4283      	cmp	r3, r0
 8025d94:	d012      	beq.n	8025dbc <UTIL_TIMER_Stop+0x50>
            prev = cur;
 8025d96:	001a      	movs	r2, r3
            cur = cur->Next;
 8025d98:	695b      	ldr	r3, [r3, #20]
 8025d9a:	e7f8      	b.n	8025d8e <UTIL_TIMER_Stop+0x22>
          TimerListHead->IsPending = 0;
 8025d9c:	7213      	strb	r3, [r2, #8]
          if( TimerListHead->Next != NULL )
 8025d9e:	6950      	ldr	r0, [r2, #20]
 8025da0:	2800      	cmp	r0, #0
 8025da2:	d004      	beq.n	8025dae <UTIL_TIMER_Stop+0x42>
            TimerListHead = TimerListHead->Next;
 8025da4:	4b0c      	ldr	r3, [pc, #48]	@ (8025dd8 <UTIL_TIMER_Stop+0x6c>)
 8025da6:	6018      	str	r0, [r3, #0]
            TimerSetTimeout( TimerListHead );
 8025da8:	f7ff ffc8 	bl	8025d3c <TimerSetTimeout>
 8025dac:	e00a      	b.n	8025dc4 <UTIL_TIMER_Stop+0x58>
            UTIL_TimerDriver.StopTimerEvt( );
 8025dae:	4b0b      	ldr	r3, [pc, #44]	@ (8025ddc <UTIL_TIMER_Stop+0x70>)
 8025db0:	68db      	ldr	r3, [r3, #12]
 8025db2:	4798      	blx	r3
            TimerListHead = NULL;
 8025db4:	4b08      	ldr	r3, [pc, #32]	@ (8025dd8 <UTIL_TIMER_Stop+0x6c>)
 8025db6:	2200      	movs	r2, #0
 8025db8:	601a      	str	r2, [r3, #0]
 8025dba:	e003      	b.n	8025dc4 <UTIL_TIMER_Stop+0x58>
            if( cur->Next != NULL )
 8025dbc:	695b      	ldr	r3, [r3, #20]
 8025dbe:	2b00      	cmp	r3, #0
 8025dc0:	d004      	beq.n	8025dcc <UTIL_TIMER_Stop+0x60>
              prev->Next = cur;
 8025dc2:	6153      	str	r3, [r2, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025dc4:	f384 8810 	msr	PRIMASK, r4
}
 8025dc8:	2000      	movs	r0, #0
}
 8025dca:	bd10      	pop	{r4, pc}
              prev->Next = cur;
 8025dcc:	2300      	movs	r3, #0
 8025dce:	6153      	str	r3, [r2, #20]
 8025dd0:	e7f8      	b.n	8025dc4 <UTIL_TIMER_Stop+0x58>
    ret = UTIL_TIMER_INVALID_PARAM;
 8025dd2:	2001      	movs	r0, #1
 8025dd4:	e7f9      	b.n	8025dca <UTIL_TIMER_Stop+0x5e>
 8025dd6:	46c0      	nop			@ (mov r8, r8)
 8025dd8:	2000a474 	.word	0x2000a474
 8025ddc:	0802638c 	.word	0x0802638c

08025de0 <TimerInsertTimer>:
 *     next timer to expire.
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
 8025de0:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8025de2:	4b0a      	ldr	r3, [pc, #40]	@ (8025e0c <TimerInsertTimer+0x2c>)
 8025de4:	681a      	ldr	r2, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 8025de6:	6953      	ldr	r3, [r2, #20]

  while (cur->Next != NULL )
 8025de8:	e001      	b.n	8025dee <TimerInsertTimer+0xe>
  {  
    if( TimerObject->Timestamp  > next->Timestamp )
    {
        cur = next;
 8025dea:	001a      	movs	r2, r3
        next = next->Next;
 8025dec:	695b      	ldr	r3, [r3, #20]
  while (cur->Next != NULL )
 8025dee:	6951      	ldr	r1, [r2, #20]
 8025df0:	2900      	cmp	r1, #0
 8025df2:	d006      	beq.n	8025e02 <TimerInsertTimer+0x22>
    if( TimerObject->Timestamp  > next->Timestamp )
 8025df4:	6804      	ldr	r4, [r0, #0]
 8025df6:	6819      	ldr	r1, [r3, #0]
 8025df8:	428c      	cmp	r4, r1
 8025dfa:	d8f6      	bhi.n	8025dea <TimerInsertTimer+0xa>
    }
    else
    {
        cur->Next = TimerObject;
 8025dfc:	6150      	str	r0, [r2, #20]
        TimerObject->Next = next;
 8025dfe:	6143      	str	r3, [r0, #20]
        return;
 8025e00:	e002      	b.n	8025e08 <TimerInsertTimer+0x28>

    }
  }
  cur->Next = TimerObject;
 8025e02:	6150      	str	r0, [r2, #20]
  TimerObject->Next = NULL;
 8025e04:	2300      	movs	r3, #0
 8025e06:	6143      	str	r3, [r0, #20]
}
 8025e08:	bd10      	pop	{r4, pc}
 8025e0a:	46c0      	nop			@ (mov r8, r8)
 8025e0c:	2000a474 	.word	0x2000a474

08025e10 <TimerInsertNewHeadTimer>:
 *
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
 8025e10:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8025e12:	4b06      	ldr	r3, [pc, #24]	@ (8025e2c <TimerInsertNewHeadTimer+0x1c>)
 8025e14:	681b      	ldr	r3, [r3, #0]

  if( cur != NULL )
 8025e16:	2b00      	cmp	r3, #0
 8025e18:	d001      	beq.n	8025e1e <TimerInsertNewHeadTimer+0xe>
  {
    cur->IsPending = 0;
 8025e1a:	2200      	movs	r2, #0
 8025e1c:	721a      	strb	r2, [r3, #8]
  }

  TimerObject->Next = cur;
 8025e1e:	6143      	str	r3, [r0, #20]
  TimerListHead = TimerObject;
 8025e20:	4b02      	ldr	r3, [pc, #8]	@ (8025e2c <TimerInsertNewHeadTimer+0x1c>)
 8025e22:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 8025e24:	f7ff ff8a 	bl	8025d3c <TimerSetTimeout>
}
 8025e28:	bd10      	pop	{r4, pc}
 8025e2a:	46c0      	nop			@ (mov r8, r8)
 8025e2c:	2000a474 	.word	0x2000a474

08025e30 <UTIL_TIMER_Start>:
{
 8025e30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025e32:	1e04      	subs	r4, r0, #0
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 8025e34:	d036      	beq.n	8025ea4 <UTIL_TIMER_Start+0x74>
 8025e36:	f7ff ff73 	bl	8025d20 <TimerExists>
 8025e3a:	2800      	cmp	r0, #0
 8025e3c:	d135      	bne.n	8025eaa <UTIL_TIMER_Start+0x7a>
 8025e3e:	7a65      	ldrb	r5, [r4, #9]
 8025e40:	2d00      	cmp	r5, #0
 8025e42:	d134      	bne.n	8025eae <UTIL_TIMER_Start+0x7e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025e44:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025e48:	b672      	cpsid	i
    ticks = TimerObject->ReloadValue;
 8025e4a:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 8025e4c:	4b19      	ldr	r3, [pc, #100]	@ (8025eb4 <UTIL_TIMER_Start+0x84>)
 8025e4e:	6a1b      	ldr	r3, [r3, #32]
 8025e50:	4798      	blx	r3
    if( ticks < minValue )
 8025e52:	4287      	cmp	r7, r0
 8025e54:	d300      	bcc.n	8025e58 <UTIL_TIMER_Start+0x28>
    ticks = TimerObject->ReloadValue;
 8025e56:	0038      	movs	r0, r7
    TimerObject->Timestamp = ticks;
 8025e58:	6020      	str	r0, [r4, #0]
    TimerObject->IsPending = 0U;
 8025e5a:	2300      	movs	r3, #0
 8025e5c:	7223      	strb	r3, [r4, #8]
    TimerObject->IsRunning = 1U;
 8025e5e:	2201      	movs	r2, #1
 8025e60:	7262      	strb	r2, [r4, #9]
    TimerObject->IsReloadStopped = 0U;
 8025e62:	72a3      	strb	r3, [r4, #10]
    if( TimerListHead == NULL )
 8025e64:	4b14      	ldr	r3, [pc, #80]	@ (8025eb8 <UTIL_TIMER_Start+0x88>)
 8025e66:	681b      	ldr	r3, [r3, #0]
 8025e68:	2b00      	cmp	r3, #0
 8025e6a:	d010      	beq.n	8025e8e <UTIL_TIMER_Start+0x5e>
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 8025e6c:	4b11      	ldr	r3, [pc, #68]	@ (8025eb4 <UTIL_TIMER_Start+0x84>)
 8025e6e:	699b      	ldr	r3, [r3, #24]
 8025e70:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 8025e72:	6823      	ldr	r3, [r4, #0]
 8025e74:	1818      	adds	r0, r3, r0
 8025e76:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 8025e78:	4b0f      	ldr	r3, [pc, #60]	@ (8025eb8 <UTIL_TIMER_Start+0x88>)
 8025e7a:	681b      	ldr	r3, [r3, #0]
 8025e7c:	681b      	ldr	r3, [r3, #0]
 8025e7e:	4298      	cmp	r0, r3
 8025e80:	d20c      	bcs.n	8025e9c <UTIL_TIMER_Start+0x6c>
        TimerInsertNewHeadTimer( TimerObject);
 8025e82:	0020      	movs	r0, r4
 8025e84:	f7ff ffc4 	bl	8025e10 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025e88:	f386 8810 	msr	PRIMASK, r6
}
 8025e8c:	e00b      	b.n	8025ea6 <UTIL_TIMER_Start+0x76>
      UTIL_TimerDriver.SetTimerContext();
 8025e8e:	4b09      	ldr	r3, [pc, #36]	@ (8025eb4 <UTIL_TIMER_Start+0x84>)
 8025e90:	691b      	ldr	r3, [r3, #16]
 8025e92:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 8025e94:	0020      	movs	r0, r4
 8025e96:	f7ff ffbb 	bl	8025e10 <TimerInsertNewHeadTimer>
 8025e9a:	e7f5      	b.n	8025e88 <UTIL_TIMER_Start+0x58>
        TimerInsertTimer( TimerObject);
 8025e9c:	0020      	movs	r0, r4
 8025e9e:	f7ff ff9f 	bl	8025de0 <TimerInsertTimer>
 8025ea2:	e7f1      	b.n	8025e88 <UTIL_TIMER_Start+0x58>
    ret =  UTIL_TIMER_INVALID_PARAM;
 8025ea4:	2501      	movs	r5, #1
}
 8025ea6:	0028      	movs	r0, r5
 8025ea8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret =  UTIL_TIMER_INVALID_PARAM;
 8025eaa:	2501      	movs	r5, #1
 8025eac:	e7fb      	b.n	8025ea6 <UTIL_TIMER_Start+0x76>
 8025eae:	2501      	movs	r5, #1
 8025eb0:	e7f9      	b.n	8025ea6 <UTIL_TIMER_Start+0x76>
 8025eb2:	46c0      	nop			@ (mov r8, r8)
 8025eb4:	0802638c 	.word	0x0802638c
 8025eb8:	2000a474 	.word	0x2000a474

08025ebc <UTIL_TIMER_SetPeriod>:
{
 8025ebc:	b510      	push	{r4, lr}
 8025ebe:	0004      	movs	r4, r0
 8025ec0:	0008      	movs	r0, r1
  if(NULL == TimerObject)
 8025ec2:	2c00      	cmp	r4, #0
 8025ec4:	d011      	beq.n	8025eea <UTIL_TIMER_SetPeriod+0x2e>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 8025ec6:	4b0a      	ldr	r3, [pc, #40]	@ (8025ef0 <UTIL_TIMER_SetPeriod+0x34>)
 8025ec8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8025eca:	4798      	blx	r3
 8025ecc:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 8025ece:	0020      	movs	r0, r4
 8025ed0:	f7ff ff26 	bl	8025d20 <TimerExists>
 8025ed4:	2800      	cmp	r0, #0
 8025ed6:	d101      	bne.n	8025edc <UTIL_TIMER_SetPeriod+0x20>
  UTIL_TIMER_Status_t  ret = UTIL_TIMER_OK;
 8025ed8:	2000      	movs	r0, #0
}
 8025eda:	bd10      	pop	{r4, pc}
      (void)UTIL_TIMER_Stop(TimerObject);
 8025edc:	0020      	movs	r0, r4
 8025ede:	f7ff ff45 	bl	8025d6c <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 8025ee2:	0020      	movs	r0, r4
 8025ee4:	f7ff ffa4 	bl	8025e30 <UTIL_TIMER_Start>
 8025ee8:	e7f7      	b.n	8025eda <UTIL_TIMER_SetPeriod+0x1e>
	  ret = UTIL_TIMER_INVALID_PARAM;
 8025eea:	2001      	movs	r0, #1
 8025eec:	e7f5      	b.n	8025eda <UTIL_TIMER_SetPeriod+0x1e>
 8025eee:	46c0      	nop			@ (mov r8, r8)
 8025ef0:	0802638c 	.word	0x0802638c

08025ef4 <UTIL_TIMER_IRQ_Handler>:
{
 8025ef4:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8025ef6:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8025efa:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 8025efc:	4c21      	ldr	r4, [pc, #132]	@ (8025f84 <UTIL_TIMER_IRQ_Handler+0x90>)
 8025efe:	6963      	ldr	r3, [r4, #20]
 8025f00:	4798      	blx	r3
 8025f02:	0006      	movs	r6, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 8025f04:	6923      	ldr	r3, [r4, #16]
 8025f06:	4798      	blx	r3
  DeltaContext = now  - old; /*intentional wrap around */
 8025f08:	1b84      	subs	r4, r0, r6
  if ( TimerListHead != NULL )
 8025f0a:	4b1f      	ldr	r3, [pc, #124]	@ (8025f88 <UTIL_TIMER_IRQ_Handler+0x94>)
 8025f0c:	681b      	ldr	r3, [r3, #0]
 8025f0e:	2b00      	cmp	r3, #0
 8025f10:	d105      	bne.n	8025f1e <UTIL_TIMER_IRQ_Handler+0x2a>
 8025f12:	e01a      	b.n	8025f4a <UTIL_TIMER_IRQ_Handler+0x56>
        cur->Timestamp = 0;
 8025f14:	2200      	movs	r2, #0
 8025f16:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 8025f18:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 8025f1a:	2b00      	cmp	r3, #0
 8025f1c:	d015      	beq.n	8025f4a <UTIL_TIMER_IRQ_Handler+0x56>
      if (cur->Timestamp > DeltaContext)
 8025f1e:	681a      	ldr	r2, [r3, #0]
 8025f20:	42a2      	cmp	r2, r4
 8025f22:	d9f7      	bls.n	8025f14 <UTIL_TIMER_IRQ_Handler+0x20>
        cur->Timestamp -= DeltaContext;
 8025f24:	1a31      	subs	r1, r6, r0
 8025f26:	188a      	adds	r2, r1, r2
 8025f28:	601a      	str	r2, [r3, #0]
 8025f2a:	e7f5      	b.n	8025f18 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 8025f2c:	4b16      	ldr	r3, [pc, #88]	@ (8025f88 <UTIL_TIMER_IRQ_Handler+0x94>)
 8025f2e:	681c      	ldr	r4, [r3, #0]
      TimerListHead = TimerListHead->Next;
 8025f30:	6962      	ldr	r2, [r4, #20]
 8025f32:	601a      	str	r2, [r3, #0]
      cur->IsPending = 0;
 8025f34:	2300      	movs	r3, #0
 8025f36:	7223      	strb	r3, [r4, #8]
      cur->IsRunning = 0;
 8025f38:	7263      	strb	r3, [r4, #9]
      cur->Callback(cur->argument);
 8025f3a:	68e3      	ldr	r3, [r4, #12]
 8025f3c:	6920      	ldr	r0, [r4, #16]
 8025f3e:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 8025f40:	8962      	ldrh	r2, [r4, #10]
 8025f42:	2380      	movs	r3, #128	@ 0x80
 8025f44:	005b      	lsls	r3, r3, #1
 8025f46:	429a      	cmp	r2, r3
 8025f48:	d015      	beq.n	8025f76 <UTIL_TIMER_IRQ_Handler+0x82>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 8025f4a:	4b0f      	ldr	r3, [pc, #60]	@ (8025f88 <UTIL_TIMER_IRQ_Handler+0x94>)
 8025f4c:	681b      	ldr	r3, [r3, #0]
 8025f4e:	2b00      	cmp	r3, #0
 8025f50:	d007      	beq.n	8025f62 <UTIL_TIMER_IRQ_Handler+0x6e>
 8025f52:	681c      	ldr	r4, [r3, #0]
 8025f54:	2c00      	cmp	r4, #0
 8025f56:	d0e9      	beq.n	8025f2c <UTIL_TIMER_IRQ_Handler+0x38>
 8025f58:	4b0a      	ldr	r3, [pc, #40]	@ (8025f84 <UTIL_TIMER_IRQ_Handler+0x90>)
 8025f5a:	699b      	ldr	r3, [r3, #24]
 8025f5c:	4798      	blx	r3
 8025f5e:	4284      	cmp	r4, r0
 8025f60:	d3e4      	bcc.n	8025f2c <UTIL_TIMER_IRQ_Handler+0x38>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 8025f62:	4b09      	ldr	r3, [pc, #36]	@ (8025f88 <UTIL_TIMER_IRQ_Handler+0x94>)
 8025f64:	6818      	ldr	r0, [r3, #0]
 8025f66:	2800      	cmp	r0, #0
 8025f68:	d002      	beq.n	8025f70 <UTIL_TIMER_IRQ_Handler+0x7c>
 8025f6a:	7a03      	ldrb	r3, [r0, #8]
 8025f6c:	2b00      	cmp	r3, #0
 8025f6e:	d006      	beq.n	8025f7e <UTIL_TIMER_IRQ_Handler+0x8a>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8025f70:	f385 8810 	msr	PRIMASK, r5
}
 8025f74:	bd70      	pop	{r4, r5, r6, pc}
        (void)UTIL_TIMER_Start(cur);
 8025f76:	0020      	movs	r0, r4
 8025f78:	f7ff ff5a 	bl	8025e30 <UTIL_TIMER_Start>
 8025f7c:	e7e5      	b.n	8025f4a <UTIL_TIMER_IRQ_Handler+0x56>
    TimerSetTimeout( TimerListHead );
 8025f7e:	f7ff fedd 	bl	8025d3c <TimerSetTimeout>
 8025f82:	e7f5      	b.n	8025f70 <UTIL_TIMER_IRQ_Handler+0x7c>
 8025f84:	0802638c 	.word	0x0802638c
 8025f88:	2000a474 	.word	0x2000a474

08025f8c <ee_skip_atoi>:
  return sc - s;
}
#endif

static int ee_skip_atoi(const char **s)
{
 8025f8c:	0001      	movs	r1, r0
  int i = 0;
 8025f8e:	2000      	movs	r0, #0
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 8025f90:	e007      	b.n	8025fa2 <ee_skip_atoi+0x16>
 8025f92:	0083      	lsls	r3, r0, #2
 8025f94:	181b      	adds	r3, r3, r0
 8025f96:	005b      	lsls	r3, r3, #1
 8025f98:	1c50      	adds	r0, r2, #1
 8025f9a:	6008      	str	r0, [r1, #0]
 8025f9c:	7810      	ldrb	r0, [r2, #0]
 8025f9e:	1818      	adds	r0, r3, r0
 8025fa0:	3830      	subs	r0, #48	@ 0x30
 8025fa2:	680a      	ldr	r2, [r1, #0]
 8025fa4:	7813      	ldrb	r3, [r2, #0]
 8025fa6:	3b30      	subs	r3, #48	@ 0x30
 8025fa8:	b2db      	uxtb	r3, r3
 8025faa:	2b09      	cmp	r3, #9
 8025fac:	d9f1      	bls.n	8025f92 <ee_skip_atoi+0x6>
  return i;
}
 8025fae:	4770      	bx	lr

08025fb0 <ee_number>:

#define ASSIGN_STR(_c)  do { *str++ = (_c); max_size--; if (max_size == 0) return str; } while (0)

static char *ee_number(char *str, int max_size, long num, int base, int size, int precision, int type)
{
 8025fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025fb2:	46de      	mov	lr, fp
 8025fb4:	4657      	mov	r7, sl
 8025fb6:	464e      	mov	r6, r9
 8025fb8:	4645      	mov	r5, r8
 8025fba:	b5e0      	push	{r5, r6, r7, lr}
 8025fbc:	b095      	sub	sp, #84	@ 0x54
 8025fbe:	0005      	movs	r5, r0
 8025fc0:	000c      	movs	r4, r1
 8025fc2:	0016      	movs	r6, r2
 8025fc4:	4699      	mov	r9, r3
 8025fc6:	9b20      	ldr	r3, [sp, #128]	@ 0x80
  char c;
  char sign, tmp[66];
  char *dig = lower_digits;
  int i;

  if (type & UPPERCASE)  dig = upper_digits;
 8025fc8:	065a      	lsls	r2, r3, #25
 8025fca:	d415      	bmi.n	8025ff8 <ee_number+0x48>
  char *dig = lower_digits;
 8025fcc:	4a4d      	ldr	r2, [pc, #308]	@ (8026104 <ee_number+0x154>)
 8025fce:	4693      	mov	fp, r2
#ifdef TINY_PRINTF
#else
  if (type & LEFT) type &= ~ZEROPAD;
#endif
  if (base < 2 || base > 36) return 0;
 8025fd0:	464a      	mov	r2, r9
 8025fd2:	3a02      	subs	r2, #2
 8025fd4:	2a22      	cmp	r2, #34	@ 0x22
 8025fd6:	d900      	bls.n	8025fda <ee_number+0x2a>
 8025fd8:	e08c      	b.n	80260f4 <ee_number+0x144>

  c = (type & ZEROPAD) ? '0' : ' ';
 8025fda:	2201      	movs	r2, #1
 8025fdc:	0011      	movs	r1, r2
 8025fde:	4019      	ands	r1, r3
 8025fe0:	4688      	mov	r8, r1
 8025fe2:	421a      	tst	r2, r3
 8025fe4:	d00b      	beq.n	8025ffe <ee_number+0x4e>
 8025fe6:	322f      	adds	r2, #47	@ 0x2f
 8025fe8:	4692      	mov	sl, r2
  sign = 0;
  if (type & SIGN)
 8025fea:	079b      	lsls	r3, r3, #30
 8025fec:	d511      	bpl.n	8026012 <ee_number+0x62>
  {
    if (num < 0)
 8025fee:	2e00      	cmp	r6, #0
 8025ff0:	db08      	blt.n	8026004 <ee_number+0x54>
  sign = 0;
 8025ff2:	2300      	movs	r3, #0
 8025ff4:	9301      	str	r3, [sp, #4]
 8025ff6:	e00e      	b.n	8026016 <ee_number+0x66>
  if (type & UPPERCASE)  dig = upper_digits;
 8025ff8:	4a43      	ldr	r2, [pc, #268]	@ (8026108 <ee_number+0x158>)
 8025ffa:	4693      	mov	fp, r2
 8025ffc:	e7e8      	b.n	8025fd0 <ee_number+0x20>
  c = (type & ZEROPAD) ? '0' : ' ';
 8025ffe:	2220      	movs	r2, #32
 8026000:	4692      	mov	sl, r2
 8026002:	e7f2      	b.n	8025fea <ee_number+0x3a>
    {
      sign = '-';
      num = -num;
 8026004:	4276      	negs	r6, r6
      size--;
 8026006:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8026008:	3b01      	subs	r3, #1
 802600a:	931e      	str	r3, [sp, #120]	@ 0x78
      sign = '-';
 802600c:	232d      	movs	r3, #45	@ 0x2d
 802600e:	9301      	str	r3, [sp, #4]
 8026010:	e001      	b.n	8026016 <ee_number+0x66>
  sign = 0;
 8026012:	2300      	movs	r3, #0
 8026014:	9301      	str	r3, [sp, #4]
  }
#endif

  i = 0;

  if (num == 0)
 8026016:	2e00      	cmp	r6, #0
 8026018:	d135      	bne.n	8026086 <ee_number+0xd6>
    tmp[i++] = '0';
 802601a:	ab03      	add	r3, sp, #12
 802601c:	2230      	movs	r2, #48	@ 0x30
 802601e:	701a      	strb	r2, [r3, #0]
 8026020:	2701      	movs	r7, #1
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
      num = ((unsigned long) num) / (unsigned) base;
    }
  }

  if (i > precision) precision = i;
 8026022:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8026024:	429f      	cmp	r7, r3
 8026026:	dd00      	ble.n	802602a <ee_number+0x7a>
 8026028:	971f      	str	r7, [sp, #124]	@ 0x7c
  size -= precision;
 802602a:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 802602c:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 802602e:	1a9b      	subs	r3, r3, r2
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 8026030:	4642      	mov	r2, r8
 8026032:	2a00      	cmp	r2, #0
 8026034:	d029      	beq.n	802608a <ee_number+0xda>
  if (sign) ASSIGN_STR(sign);
 8026036:	9a01      	ldr	r2, [sp, #4]
 8026038:	2a00      	cmp	r2, #0
 802603a:	d005      	beq.n	8026048 <ee_number+0x98>
 802603c:	1c68      	adds	r0, r5, #1
 802603e:	702a      	strb	r2, [r5, #0]
 8026040:	3c01      	subs	r4, #1
 8026042:	2c00      	cmp	r4, #0
 8026044:	d057      	beq.n	80260f6 <ee_number+0x146>
 8026046:	0005      	movs	r5, r0
    }
  }
#endif

#ifdef TINY_PRINTF
  while (size-- > 0) ASSIGN_STR(c);
 8026048:	001a      	movs	r2, r3
 802604a:	3b01      	subs	r3, #1
 802604c:	2a00      	cmp	r2, #0
 802604e:	dd28      	ble.n	80260a2 <ee_number+0xf2>
 8026050:	1c68      	adds	r0, r5, #1
 8026052:	4652      	mov	r2, sl
 8026054:	702a      	strb	r2, [r5, #0]
 8026056:	3c01      	subs	r4, #1
 8026058:	2c00      	cmp	r4, #0
 802605a:	d04c      	beq.n	80260f6 <ee_number+0x146>
 802605c:	0005      	movs	r5, r0
 802605e:	e7f3      	b.n	8026048 <ee_number+0x98>
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 8026060:	4649      	mov	r1, r9
 8026062:	0030      	movs	r0, r6
 8026064:	f7fa f8de 	bl	8020224 <__aeabi_uidivmod>
 8026068:	1c7b      	adds	r3, r7, #1
 802606a:	9300      	str	r3, [sp, #0]
 802606c:	465a      	mov	r2, fp
 802606e:	5c52      	ldrb	r2, [r2, r1]
 8026070:	ab03      	add	r3, sp, #12
 8026072:	55da      	strb	r2, [r3, r7]
      num = ((unsigned long) num) / (unsigned) base;
 8026074:	4649      	mov	r1, r9
 8026076:	0030      	movs	r0, r6
 8026078:	f7fa f84e 	bl	8020118 <__udivsi3>
 802607c:	0006      	movs	r6, r0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 802607e:	9f00      	ldr	r7, [sp, #0]
    while (num != 0)
 8026080:	2e00      	cmp	r6, #0
 8026082:	d1ed      	bne.n	8026060 <ee_number+0xb0>
 8026084:	e7cd      	b.n	8026022 <ee_number+0x72>
  i = 0;
 8026086:	2700      	movs	r7, #0
 8026088:	e7fa      	b.n	8026080 <ee_number+0xd0>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 802608a:	001a      	movs	r2, r3
 802608c:	3b01      	subs	r3, #1
 802608e:	2a00      	cmp	r2, #0
 8026090:	ddd1      	ble.n	8026036 <ee_number+0x86>
 8026092:	1c68      	adds	r0, r5, #1
 8026094:	2220      	movs	r2, #32
 8026096:	702a      	strb	r2, [r5, #0]
 8026098:	3c01      	subs	r4, #1
 802609a:	2c00      	cmp	r4, #0
 802609c:	d02b      	beq.n	80260f6 <ee_number+0x146>
 802609e:	0005      	movs	r5, r0
 80260a0:	e7f3      	b.n	802608a <ee_number+0xda>
#else
  if (!(type & LEFT)) while (size-- > 0) ASSIGN_STR(c);
#endif
  while (i < precision--) ASSIGN_STR('0');
 80260a2:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 80260a4:	0011      	movs	r1, r2
 80260a6:	3901      	subs	r1, #1
 80260a8:	911f      	str	r1, [sp, #124]	@ 0x7c
 80260aa:	42ba      	cmp	r2, r7
 80260ac:	dd07      	ble.n	80260be <ee_number+0x10e>
 80260ae:	1c68      	adds	r0, r5, #1
 80260b0:	2230      	movs	r2, #48	@ 0x30
 80260b2:	702a      	strb	r2, [r5, #0]
 80260b4:	3c01      	subs	r4, #1
 80260b6:	2c00      	cmp	r4, #0
 80260b8:	d01d      	beq.n	80260f6 <ee_number+0x146>
 80260ba:	0005      	movs	r5, r0
 80260bc:	e7f1      	b.n	80260a2 <ee_number+0xf2>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 80260be:	003a      	movs	r2, r7
 80260c0:	3f01      	subs	r7, #1
 80260c2:	2a00      	cmp	r2, #0
 80260c4:	dd08      	ble.n	80260d8 <ee_number+0x128>
 80260c6:	1c68      	adds	r0, r5, #1
 80260c8:	aa03      	add	r2, sp, #12
 80260ca:	5dd2      	ldrb	r2, [r2, r7]
 80260cc:	702a      	strb	r2, [r5, #0]
 80260ce:	3c01      	subs	r4, #1
 80260d0:	2c00      	cmp	r4, #0
 80260d2:	d010      	beq.n	80260f6 <ee_number+0x146>
 80260d4:	0005      	movs	r5, r0
 80260d6:	e7f2      	b.n	80260be <ee_number+0x10e>
  while (size-- > 0) ASSIGN_STR(' ');
 80260d8:	001a      	movs	r2, r3
 80260da:	3b01      	subs	r3, #1
 80260dc:	2a00      	cmp	r2, #0
 80260de:	dd07      	ble.n	80260f0 <ee_number+0x140>
 80260e0:	1c68      	adds	r0, r5, #1
 80260e2:	2220      	movs	r2, #32
 80260e4:	702a      	strb	r2, [r5, #0]
 80260e6:	3c01      	subs	r4, #1
 80260e8:	2c00      	cmp	r4, #0
 80260ea:	d004      	beq.n	80260f6 <ee_number+0x146>
 80260ec:	0005      	movs	r5, r0
 80260ee:	e7f3      	b.n	80260d8 <ee_number+0x128>

  return str;
 80260f0:	0028      	movs	r0, r5
 80260f2:	e000      	b.n	80260f6 <ee_number+0x146>
  if (base < 2 || base > 36) return 0;
 80260f4:	2000      	movs	r0, #0
}
 80260f6:	b015      	add	sp, #84	@ 0x54
 80260f8:	bcf0      	pop	{r4, r5, r6, r7}
 80260fa:	46bb      	mov	fp, r7
 80260fc:	46b2      	mov	sl, r6
 80260fe:	46a9      	mov	r9, r5
 8026100:	46a0      	mov	r8, r4
 8026102:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8026104:	08026814 	.word	0x08026814
 8026108:	0802683c 	.word	0x0802683c

0802610c <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 802610c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802610e:	46ce      	mov	lr, r9
 8026110:	4647      	mov	r7, r8
 8026112:	b580      	push	{r7, lr}
 8026114:	b087      	sub	sp, #28
 8026116:	0006      	movs	r6, r0
 8026118:	1e0f      	subs	r7, r1, #0
 802611a:	9205      	str	r2, [sp, #20]
 802611c:	9304      	str	r3, [sp, #16]

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 802611e:	dc00      	bgt.n	8026122 <tiny_vsnprintf_like+0x16>
 8026120:	e0b2      	b.n	8026288 <tiny_vsnprintf_like+0x17c>
  {
    return 0;
  }

  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8026122:	0004      	movs	r4, r0
 8026124:	e004      	b.n	8026130 <tiny_vsnprintf_like+0x24>
  {
    CHECK_STR_SIZE(buf, str, size);

    if (*fmt != '%')
    {
      *str++ = *fmt;
 8026126:	7022      	strb	r2, [r4, #0]
 8026128:	3401      	adds	r4, #1
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 802612a:	9b05      	ldr	r3, [sp, #20]
 802612c:	3301      	adds	r3, #1
 802612e:	9305      	str	r3, [sp, #20]
 8026130:	9905      	ldr	r1, [sp, #20]
 8026132:	780a      	ldrb	r2, [r1, #0]
 8026134:	2a00      	cmp	r2, #0
 8026136:	d104      	bne.n	8026142 <tiny_vsnprintf_like+0x36>
 8026138:	1ba3      	subs	r3, r4, r6
 802613a:	1e78      	subs	r0, r7, #1
 802613c:	4283      	cmp	r3, r0
 802613e:	da00      	bge.n	8026142 <tiny_vsnprintf_like+0x36>
 8026140:	e09a      	b.n	8026278 <tiny_vsnprintf_like+0x16c>
    CHECK_STR_SIZE(buf, str, size);
 8026142:	1ba3      	subs	r3, r4, r6
 8026144:	1e78      	subs	r0, r7, #1
 8026146:	4680      	mov	r8, r0
 8026148:	4283      	cmp	r3, r0
 802614a:	db00      	blt.n	802614e <tiny_vsnprintf_like+0x42>
 802614c:	e094      	b.n	8026278 <tiny_vsnprintf_like+0x16c>
    if (*fmt != '%')
 802614e:	2a25      	cmp	r2, #37	@ 0x25
 8026150:	d1e9      	bne.n	8026126 <tiny_vsnprintf_like+0x1a>

    // Process flags
    flags = 0;
#ifdef TINY_PRINTF
    /* Support %0, but not %-, %+, %space and %# */
    fmt++;
 8026152:	1c4b      	adds	r3, r1, #1
 8026154:	9305      	str	r3, [sp, #20]
    if (*fmt == '0')
 8026156:	784b      	ldrb	r3, [r1, #1]
 8026158:	2b30      	cmp	r3, #48	@ 0x30
 802615a:	d012      	beq.n	8026182 <tiny_vsnprintf_like+0x76>
    flags = 0;
 802615c:	2200      	movs	r2, #0
 802615e:	4691      	mov	r9, r2
    }
#endif

    // Get field width
    field_width = -1;
    if (is_digit(*fmt))
 8026160:	3b30      	subs	r3, #48	@ 0x30
 8026162:	b2db      	uxtb	r3, r3
 8026164:	2b09      	cmp	r3, #9
 8026166:	d90f      	bls.n	8026188 <tiny_vsnprintf_like+0x7c>
    field_width = -1;
 8026168:	2501      	movs	r5, #1
 802616a:	426d      	negs	r5, r5
#endif

    // Default base
    base = 10;

    switch (*fmt)
 802616c:	9b05      	ldr	r3, [sp, #20]
 802616e:	781a      	ldrb	r2, [r3, #0]
 8026170:	0013      	movs	r3, r2
 8026172:	3b58      	subs	r3, #88	@ 0x58
 8026174:	b2d9      	uxtb	r1, r3
 8026176:	2920      	cmp	r1, #32
 8026178:	d85e      	bhi.n	8026238 <tiny_vsnprintf_like+0x12c>
 802617a:	008b      	lsls	r3, r1, #2
 802617c:	4943      	ldr	r1, [pc, #268]	@ (802628c <tiny_vsnprintf_like+0x180>)
 802617e:	58cb      	ldr	r3, [r1, r3]
 8026180:	469f      	mov	pc, r3
      flags |= ZEROPAD;
 8026182:	2201      	movs	r2, #1
 8026184:	4691      	mov	r9, r2
 8026186:	e7eb      	b.n	8026160 <tiny_vsnprintf_like+0x54>
      field_width = ee_skip_atoi(&fmt);
 8026188:	a805      	add	r0, sp, #20
 802618a:	f7ff feff 	bl	8025f8c <ee_skip_atoi>
 802618e:	0005      	movs	r5, r0
 8026190:	e7ec      	b.n	802616c <tiny_vsnprintf_like+0x60>
    switch (*fmt)
 8026192:	230a      	movs	r3, #10
 8026194:	e035      	b.n	8026202 <tiny_vsnprintf_like+0xf6>
      case 'c':
#ifdef TINY_PRINTF
#else
        if (!(flags & LEFT))
#endif
          while (--field_width > 0) *str++ = ' ';
 8026196:	2220      	movs	r2, #32
 8026198:	701a      	strb	r2, [r3, #0]
 802619a:	3301      	adds	r3, #1
 802619c:	3d01      	subs	r5, #1
 802619e:	2d00      	cmp	r5, #0
 80261a0:	dcf9      	bgt.n	8026196 <tiny_vsnprintf_like+0x8a>
        *str++ = (unsigned char) va_arg(args, int);
 80261a2:	9a04      	ldr	r2, [sp, #16]
 80261a4:	1d11      	adds	r1, r2, #4
 80261a6:	9104      	str	r1, [sp, #16]
 80261a8:	1c5c      	adds	r4, r3, #1
 80261aa:	7812      	ldrb	r2, [r2, #0]
 80261ac:	701a      	strb	r2, [r3, #0]
#ifdef TINY_PRINTF
#else
        while (--field_width > 0) *str++ = ' ';
#endif
        continue;
 80261ae:	e7bc      	b.n	802612a <tiny_vsnprintf_like+0x1e>
    switch (*fmt)
 80261b0:	0023      	movs	r3, r4
 80261b2:	e7f3      	b.n	802619c <tiny_vsnprintf_like+0x90>

      case 's':
        s = va_arg(args, char *);
 80261b4:	9b04      	ldr	r3, [sp, #16]
 80261b6:	1d1a      	adds	r2, r3, #4
 80261b8:	9204      	str	r2, [sp, #16]
 80261ba:	681b      	ldr	r3, [r3, #0]
 80261bc:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 80261be:	2b00      	cmp	r3, #0
 80261c0:	d003      	beq.n	80261ca <tiny_vsnprintf_like+0xbe>
#ifdef TINY_PRINTF
        len = strlen(s);
 80261c2:	4640      	mov	r0, r8
 80261c4:	f7f9 ffa0 	bl	8020108 <strlen>
#else
        len = strnlen(s, precision);
        if (!(flags & LEFT))
#endif
          while (len < field_width--) *str++ = ' ';
 80261c8:	e006      	b.n	80261d8 <tiny_vsnprintf_like+0xcc>
        if (!s) s = "<NULL>";
 80261ca:	4b31      	ldr	r3, [pc, #196]	@ (8026290 <tiny_vsnprintf_like+0x184>)
 80261cc:	4698      	mov	r8, r3
 80261ce:	e7f8      	b.n	80261c2 <tiny_vsnprintf_like+0xb6>
          while (len < field_width--) *str++ = ' ';
 80261d0:	2220      	movs	r2, #32
 80261d2:	7022      	strb	r2, [r4, #0]
 80261d4:	001d      	movs	r5, r3
 80261d6:	3401      	adds	r4, #1
 80261d8:	1e6b      	subs	r3, r5, #1
 80261da:	4285      	cmp	r5, r0
 80261dc:	dcf8      	bgt.n	80261d0 <tiny_vsnprintf_like+0xc4>
        for (i = 0; i < len; ++i) *str++ = *s++;
 80261de:	2300      	movs	r3, #0
 80261e0:	e007      	b.n	80261f2 <tiny_vsnprintf_like+0xe6>
 80261e2:	4642      	mov	r2, r8
 80261e4:	7812      	ldrb	r2, [r2, #0]
 80261e6:	7022      	strb	r2, [r4, #0]
 80261e8:	3301      	adds	r3, #1
 80261ea:	2201      	movs	r2, #1
 80261ec:	4694      	mov	ip, r2
 80261ee:	44e0      	add	r8, ip
 80261f0:	3401      	adds	r4, #1
 80261f2:	4283      	cmp	r3, r0
 80261f4:	dbf5      	blt.n	80261e2 <tiny_vsnprintf_like+0xd6>
 80261f6:	e798      	b.n	802612a <tiny_vsnprintf_like+0x1e>
        base = 8;
        break;
#endif

      case 'X':
        flags |= UPPERCASE;
 80261f8:	2340      	movs	r3, #64	@ 0x40
 80261fa:	464a      	mov	r2, r9
 80261fc:	431a      	orrs	r2, r3
 80261fe:	4691      	mov	r9, r2

      case 'x':
        base = 16;
 8026200:	3b30      	subs	r3, #48	@ 0x30
        continue;
    }

    if (qualifier == 'l')
      num = va_arg(args, unsigned long);
    else if (flags & SIGN)
 8026202:	464a      	mov	r2, r9
 8026204:	0792      	lsls	r2, r2, #30
 8026206:	d532      	bpl.n	802626e <tiny_vsnprintf_like+0x162>
      num = va_arg(args, int);
 8026208:	9a04      	ldr	r2, [sp, #16]
 802620a:	1d11      	adds	r1, r2, #4
 802620c:	9104      	str	r1, [sp, #16]
 802620e:	6812      	ldr	r2, [r2, #0]
    else
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 8026210:	1ba1      	subs	r1, r4, r6
 8026212:	4640      	mov	r0, r8
 8026214:	1a41      	subs	r1, r0, r1
 8026216:	4648      	mov	r0, r9
 8026218:	9002      	str	r0, [sp, #8]
 802621a:	2001      	movs	r0, #1
 802621c:	4240      	negs	r0, r0
 802621e:	9001      	str	r0, [sp, #4]
 8026220:	9500      	str	r5, [sp, #0]
 8026222:	0020      	movs	r0, r4
 8026224:	f7ff fec4 	bl	8025fb0 <ee_number>
 8026228:	0004      	movs	r4, r0
 802622a:	e77e      	b.n	802612a <tiny_vsnprintf_like+0x1e>
        flags |= SIGN;
 802622c:	2302      	movs	r3, #2
 802622e:	464a      	mov	r2, r9
 8026230:	431a      	orrs	r2, r3
 8026232:	4691      	mov	r9, r2
    base = 10;
 8026234:	3308      	adds	r3, #8
 8026236:	e7e4      	b.n	8026202 <tiny_vsnprintf_like+0xf6>
        if (*fmt != '%') *str++ = '%';
 8026238:	2a25      	cmp	r2, #37	@ 0x25
 802623a:	d002      	beq.n	8026242 <tiny_vsnprintf_like+0x136>
 802623c:	2325      	movs	r3, #37	@ 0x25
 802623e:	7023      	strb	r3, [r4, #0]
 8026240:	3401      	adds	r4, #1
        CHECK_STR_SIZE(buf, str, size);
 8026242:	1ba3      	subs	r3, r4, r6
 8026244:	4598      	cmp	r8, r3
 8026246:	dd10      	ble.n	802626a <tiny_vsnprintf_like+0x15e>
        if (*fmt)
 8026248:	9b05      	ldr	r3, [sp, #20]
 802624a:	781a      	ldrb	r2, [r3, #0]
 802624c:	2a00      	cmp	r2, #0
 802624e:	d007      	beq.n	8026260 <tiny_vsnprintf_like+0x154>
          *str++ = *fmt;
 8026250:	7022      	strb	r2, [r4, #0]
 8026252:	3401      	adds	r4, #1
        CHECK_STR_SIZE(buf, str, size);
 8026254:	1ba3      	subs	r3, r4, r6
 8026256:	4598      	cmp	r8, r3
 8026258:	dd00      	ble.n	802625c <tiny_vsnprintf_like+0x150>
 802625a:	e766      	b.n	802612a <tiny_vsnprintf_like+0x1e>
    base = 10;
 802625c:	230a      	movs	r3, #10
 802625e:	e7d0      	b.n	8026202 <tiny_vsnprintf_like+0xf6>
          --fmt;
 8026260:	3b01      	subs	r3, #1
 8026262:	9305      	str	r3, [sp, #20]
 8026264:	e7f6      	b.n	8026254 <tiny_vsnprintf_like+0x148>
        base = 16;
 8026266:	2310      	movs	r3, #16
 8026268:	e7cb      	b.n	8026202 <tiny_vsnprintf_like+0xf6>
    base = 10;
 802626a:	230a      	movs	r3, #10
 802626c:	e7c9      	b.n	8026202 <tiny_vsnprintf_like+0xf6>
      num = va_arg(args, unsigned int);
 802626e:	9a04      	ldr	r2, [sp, #16]
 8026270:	1d11      	adds	r1, r2, #4
 8026272:	9104      	str	r1, [sp, #16]
 8026274:	6812      	ldr	r2, [r2, #0]
 8026276:	e7cb      	b.n	8026210 <tiny_vsnprintf_like+0x104>
  }

  *str = '\0';
 8026278:	2300      	movs	r3, #0
 802627a:	7023      	strb	r3, [r4, #0]
  return str - buf;
 802627c:	1ba0      	subs	r0, r4, r6
}
 802627e:	b007      	add	sp, #28
 8026280:	bcc0      	pop	{r6, r7}
 8026282:	46b9      	mov	r9, r7
 8026284:	46b0      	mov	r8, r6
 8026286:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return 0;
 8026288:	2000      	movs	r0, #0
 802628a:	e7f8      	b.n	802627e <tiny_vsnprintf_like+0x172>
 802628c:	0802686c 	.word	0x0802686c
 8026290:	08026864 	.word	0x08026864

08026294 <memset>:
 8026294:	0003      	movs	r3, r0
 8026296:	1882      	adds	r2, r0, r2
 8026298:	4293      	cmp	r3, r2
 802629a:	d100      	bne.n	802629e <memset+0xa>
 802629c:	4770      	bx	lr
 802629e:	7019      	strb	r1, [r3, #0]
 80262a0:	3301      	adds	r3, #1
 80262a2:	e7f9      	b.n	8026298 <memset+0x4>

080262a4 <__libc_init_array>:
 80262a4:	b570      	push	{r4, r5, r6, lr}
 80262a6:	2600      	movs	r6, #0
 80262a8:	4c0c      	ldr	r4, [pc, #48]	@ (80262dc <__libc_init_array+0x38>)
 80262aa:	4d0d      	ldr	r5, [pc, #52]	@ (80262e0 <__libc_init_array+0x3c>)
 80262ac:	1b64      	subs	r4, r4, r5
 80262ae:	10a4      	asrs	r4, r4, #2
 80262b0:	42a6      	cmp	r6, r4
 80262b2:	d109      	bne.n	80262c8 <__libc_init_array+0x24>
 80262b4:	2600      	movs	r6, #0
 80262b6:	f000 f819 	bl	80262ec <_init>
 80262ba:	4c0a      	ldr	r4, [pc, #40]	@ (80262e4 <__libc_init_array+0x40>)
 80262bc:	4d0a      	ldr	r5, [pc, #40]	@ (80262e8 <__libc_init_array+0x44>)
 80262be:	1b64      	subs	r4, r4, r5
 80262c0:	10a4      	asrs	r4, r4, #2
 80262c2:	42a6      	cmp	r6, r4
 80262c4:	d105      	bne.n	80262d2 <__libc_init_array+0x2e>
 80262c6:	bd70      	pop	{r4, r5, r6, pc}
 80262c8:	00b3      	lsls	r3, r6, #2
 80262ca:	58eb      	ldr	r3, [r5, r3]
 80262cc:	4798      	blx	r3
 80262ce:	3601      	adds	r6, #1
 80262d0:	e7ee      	b.n	80262b0 <__libc_init_array+0xc>
 80262d2:	00b3      	lsls	r3, r6, #2
 80262d4:	58eb      	ldr	r3, [r5, r3]
 80262d6:	4798      	blx	r3
 80262d8:	3601      	adds	r6, #1
 80262da:	e7f2      	b.n	80262c2 <__libc_init_array+0x1e>
 80262dc:	080268f8 	.word	0x080268f8
 80262e0:	080268f8 	.word	0x080268f8
 80262e4:	080268fc 	.word	0x080268fc
 80262e8:	080268f8 	.word	0x080268f8

080262ec <_init>:
 80262ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80262ee:	46c0      	nop			@ (mov r8, r8)
 80262f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80262f2:	bc08      	pop	{r3}
 80262f4:	469e      	mov	lr, r3
 80262f6:	4770      	bx	lr

080262f8 <_fini>:
 80262f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80262fa:	46c0      	nop			@ (mov r8, r8)
 80262fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80262fe:	bc08      	pop	{r3}
 8026300:	469e      	mov	lr, r3
 8026302:	4770      	bx	lr
 8026304:	0000      	movs	r0, r0
	...
